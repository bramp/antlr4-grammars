// Code generated from PlSqlParser.g4 by ANTLR 4.7.1. DO NOT EDIT.

package plsql // PlSqlParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 575, 5772,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 4, 257, 9, 257, 4, 258, 9, 258, 4, 259, 9, 259,
	4, 260, 9, 260, 4, 261, 9, 261, 4, 262, 9, 262, 4, 263, 9, 263, 4, 264,
	9, 264, 4, 265, 9, 265, 4, 266, 9, 266, 4, 267, 9, 267, 4, 268, 9, 268,
	4, 269, 9, 269, 4, 270, 9, 270, 4, 271, 9, 271, 4, 272, 9, 272, 4, 273,
	9, 273, 4, 274, 9, 274, 4, 275, 9, 275, 4, 276, 9, 276, 4, 277, 9, 277,
	4, 278, 9, 278, 4, 279, 9, 279, 4, 280, 9, 280, 4, 281, 9, 281, 4, 282,
	9, 282, 4, 283, 9, 283, 4, 284, 9, 284, 4, 285, 9, 285, 4, 286, 9, 286,
	4, 287, 9, 287, 4, 288, 9, 288, 4, 289, 9, 289, 4, 290, 9, 290, 4, 291,
	9, 291, 4, 292, 9, 292, 4, 293, 9, 293, 4, 294, 9, 294, 4, 295, 9, 295,
	4, 296, 9, 296, 4, 297, 9, 297, 4, 298, 9, 298, 4, 299, 9, 299, 4, 300,
	9, 300, 4, 301, 9, 301, 4, 302, 9, 302, 4, 303, 9, 303, 4, 304, 9, 304,
	4, 305, 9, 305, 4, 306, 9, 306, 4, 307, 9, 307, 4, 308, 9, 308, 4, 309,
	9, 309, 4, 310, 9, 310, 4, 311, 9, 311, 4, 312, 9, 312, 4, 313, 9, 313,
	4, 314, 9, 314, 4, 315, 9, 315, 4, 316, 9, 316, 4, 317, 9, 317, 4, 318,
	9, 318, 4, 319, 9, 319, 4, 320, 9, 320, 4, 321, 9, 321, 4, 322, 9, 322,
	4, 323, 9, 323, 4, 324, 9, 324, 4, 325, 9, 325, 4, 326, 9, 326, 4, 327,
	9, 327, 4, 328, 9, 328, 4, 329, 9, 329, 4, 330, 9, 330, 4, 331, 9, 331,
	4, 332, 9, 332, 4, 333, 9, 333, 4, 334, 9, 334, 4, 335, 9, 335, 4, 336,
	9, 336, 4, 337, 9, 337, 4, 338, 9, 338, 4, 339, 9, 339, 4, 340, 9, 340,
	4, 341, 9, 341, 4, 342, 9, 342, 4, 343, 9, 343, 4, 344, 9, 344, 4, 345,
	9, 345, 4, 346, 9, 346, 4, 347, 9, 347, 4, 348, 9, 348, 4, 349, 9, 349,
	4, 350, 9, 350, 4, 351, 9, 351, 4, 352, 9, 352, 4, 353, 9, 353, 4, 354,
	9, 354, 4, 355, 9, 355, 4, 356, 9, 356, 4, 357, 9, 357, 4, 358, 9, 358,
	4, 359, 9, 359, 4, 360, 9, 360, 4, 361, 9, 361, 4, 362, 9, 362, 4, 363,
	9, 363, 4, 364, 9, 364, 4, 365, 9, 365, 4, 366, 9, 366, 4, 367, 9, 367,
	4, 368, 9, 368, 4, 369, 9, 369, 4, 370, 9, 370, 4, 371, 9, 371, 4, 372,
	9, 372, 4, 373, 9, 373, 4, 374, 9, 374, 4, 375, 9, 375, 4, 376, 9, 376,
	4, 377, 9, 377, 4, 378, 9, 378, 4, 379, 9, 379, 4, 380, 9, 380, 4, 381,
	9, 381, 4, 382, 9, 382, 4, 383, 9, 383, 4, 384, 9, 384, 4, 385, 9, 385,
	4, 386, 9, 386, 3, 2, 3, 2, 5, 2, 775, 10, 2, 3, 2, 5, 2, 778, 10, 2, 7,
	2, 780, 10, 2, 12, 2, 14, 2, 783, 11, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 5, 3, 817, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 829, 10, 5, 3, 5, 7, 5, 832, 10, 5, 12, 5,
	14, 5, 835, 11, 5, 3, 5, 3, 5, 5, 5, 839, 10, 5, 3, 5, 3, 5, 3, 6, 3, 6,
	3, 6, 5, 6, 846, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 854,
	10, 6, 12, 6, 14, 6, 857, 11, 6, 3, 6, 3, 6, 5, 6, 861, 10, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 869, 10, 6, 12, 6, 14, 6, 872, 11, 6,
	3, 6, 5, 6, 875, 10, 6, 3, 6, 3, 6, 5, 6, 879, 10, 6, 3, 6, 7, 6, 882,
	10, 6, 12, 6, 14, 6, 885, 11, 6, 3, 6, 3, 6, 5, 6, 889, 10, 6, 3, 6, 3,
	6, 3, 6, 5, 6, 894, 10, 6, 3, 6, 3, 6, 3, 7, 3, 7, 5, 7, 900, 10, 7, 3,
	8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 7, 8, 912, 10,
	8, 12, 8, 14, 8, 915, 11, 8, 3, 8, 3, 8, 5, 8, 919, 10, 8, 3, 8, 5, 8,
	922, 10, 8, 3, 8, 3, 8, 3, 9, 3, 9, 5, 9, 928, 10, 9, 3, 10, 3, 10, 3,
	10, 3, 10, 3, 10, 7, 10, 935, 10, 10, 12, 10, 14, 10, 938, 11, 10, 3, 10,
	3, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 7, 11, 949, 10,
	11, 12, 11, 14, 11, 952, 11, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 5,
	12, 959, 10, 12, 3, 12, 3, 12, 3, 12, 5, 12, 964, 10, 12, 3, 12, 3, 12,
	3, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 974, 10, 13, 3, 13, 5,
	13, 977, 10, 13, 3, 13, 7, 13, 980, 10, 13, 12, 13, 14, 13, 983, 11, 13,
	3, 13, 3, 13, 5, 13, 987, 10, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14, 5,
	14, 994, 10, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 1000, 10, 14, 3, 14,
	3, 14, 5, 14, 1004, 10, 14, 3, 14, 3, 14, 7, 14, 1008, 10, 14, 12, 14,
	14, 14, 1011, 11, 14, 3, 14, 3, 14, 5, 14, 1015, 10, 14, 3, 14, 3, 14,
	3, 15, 3, 15, 3, 15, 5, 15, 1022, 10, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3,
	15, 5, 15, 1029, 10, 15, 3, 15, 3, 15, 3, 15, 7, 15, 1034, 10, 15, 12,
	15, 14, 15, 1037, 11, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 1043, 10,
	15, 5, 15, 1045, 10, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 5, 16, 1057, 10, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3,
	17, 3, 17, 7, 17, 1065, 10, 17, 12, 17, 14, 17, 1068, 11, 17, 3, 17, 3,
	17, 5, 17, 1072, 10, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 7, 18, 1082, 10, 18, 12, 18, 14, 18, 1085, 11, 18, 3, 18, 3, 18,
	5, 18, 1089, 10, 18, 3, 18, 3, 18, 3, 18, 5, 18, 1094, 10, 18, 3, 18, 5,
	18, 1097, 10, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 5, 19, 1110, 10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 1122, 10, 21, 3, 21, 7, 21,
	1125, 10, 21, 12, 21, 14, 21, 1128, 11, 21, 3, 21, 3, 21, 5, 21, 1132,
	10, 21, 3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22,
	1142, 10, 22, 12, 22, 14, 22, 1145, 11, 22, 3, 22, 3, 22, 5, 22, 1149,
	10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 1157, 10, 22,
	12, 22, 14, 22, 1160, 11, 22, 3, 22, 5, 22, 1163, 10, 22, 3, 22, 3, 22,
	5, 22, 1167, 10, 22, 3, 22, 7, 22, 1170, 10, 22, 12, 22, 14, 22, 1173,
	11, 22, 3, 22, 3, 22, 5, 22, 1177, 10, 22, 3, 22, 3, 22, 3, 22, 5, 22,
	1182, 10, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 7,
	23, 1192, 10, 23, 12, 23, 14, 23, 1195, 11, 23, 3, 23, 3, 23, 5, 23, 1199,
	10, 23, 3, 23, 3, 23, 5, 23, 1203, 10, 23, 3, 23, 7, 23, 1206, 10, 23,
	12, 23, 14, 23, 1209, 11, 23, 3, 23, 3, 23, 3, 23, 5, 23, 1214, 10, 23,
	3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 5, 24, 1221, 10, 24, 3, 24, 3, 24, 3,
	24, 3, 24, 3, 24, 3, 24, 7, 24, 1229, 10, 24, 12, 24, 14, 24, 1232, 11,
	24, 3, 24, 3, 24, 5, 24, 1236, 10, 24, 3, 24, 5, 24, 1239, 10, 24, 3, 24,
	3, 24, 5, 24, 1243, 10, 24, 3, 24, 7, 24, 1246, 10, 24, 12, 24, 14, 24,
	1249, 11, 24, 3, 24, 3, 24, 3, 24, 5, 24, 1254, 10, 24, 3, 24, 3, 24, 3,
	25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26,
	3, 26, 3, 26, 3, 26, 5, 26, 1272, 10, 26, 3, 26, 7, 26, 1275, 10, 26, 12,
	26, 14, 26, 1278, 11, 26, 3, 26, 3, 26, 5, 26, 1282, 10, 26, 5, 26, 1284,
	10, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 5, 27, 1291, 10, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 1298, 10, 27, 3, 27, 5, 27, 1301, 10,
	27, 3, 27, 5, 27, 1304, 10, 27, 3, 27, 5, 27, 1307, 10, 27, 3, 27, 3, 27,
	3, 27, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 1316, 10, 28, 12, 28, 14, 28,
	1319, 11, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 3,
	30, 5, 30, 1330, 10, 30, 3, 30, 3, 30, 5, 30, 1334, 10, 30, 3, 30, 5, 30,
	1337, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 32, 3, 32, 3, 32, 5, 32, 1346,
	10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 1352, 10, 33, 12, 33, 14, 33,
	1355, 11, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 1362, 10, 33, 3,
	33, 5, 33, 1365, 10, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 1372,
	10, 34, 3, 35, 3, 35, 5, 35, 1376, 10, 35, 3, 36, 3, 36, 3, 36, 7, 36,
	1381, 10, 36, 12, 36, 14, 36, 1384, 11, 36, 3, 36, 6, 36, 1387, 10, 36,
	13, 36, 14, 36, 1388, 3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	37, 5, 37, 1430, 10, 37, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38,
	3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3,
	38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38, 1458,
	10, 38, 3, 39, 3, 39, 3, 39, 7, 39, 1463, 10, 39, 12, 39, 14, 39, 1466,
	11, 39, 3, 39, 3, 39, 5, 39, 1470, 10, 39, 3, 39, 3, 39, 3, 40, 3, 40,
	3, 40, 3, 40, 3, 40, 7, 40, 1479, 10, 40, 12, 40, 14, 40, 1482, 11, 40,
	5, 40, 1484, 10, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 6,
	42, 1493, 10, 42, 13, 42, 14, 42, 1494, 3, 43, 3, 43, 3, 43, 3, 44, 3,
	44, 3, 44, 5, 44, 1503, 10, 44, 3, 44, 3, 44, 5, 44, 1507, 10, 44, 3, 44,
	3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 1519,
	10, 45, 3, 45, 5, 45, 1522, 10, 45, 3, 45, 3, 45, 3, 46, 3, 46, 5, 46,
	1528, 10, 46, 3, 46, 5, 46, 1531, 10, 46, 3, 46, 7, 46, 1534, 10, 46, 12,
	46, 14, 46, 1537, 11, 46, 3, 46, 3, 46, 5, 46, 1541, 10, 46, 3, 47, 3,
	47, 5, 47, 1545, 10, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 7, 47,
	1553, 10, 47, 12, 47, 14, 47, 1556, 11, 47, 3, 47, 3, 47, 3, 48, 3, 48,
	3, 48, 7, 48, 1563, 10, 48, 12, 48, 14, 48, 1566, 11, 48, 3, 49, 3, 49,
	3, 49, 5, 49, 1571, 10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 7, 50, 1580, 10, 50, 12, 50, 14, 50, 1583, 11, 50, 3, 50, 3, 50, 5,
	50, 1587, 10, 50, 3, 51, 3, 51, 5, 51, 1591, 10, 51, 3, 52, 3, 52, 3, 52,
	3, 52, 3, 52, 3, 52, 5, 52, 1599, 10, 52, 3, 53, 3, 53, 3, 53, 3, 53, 3,
	53, 3, 53, 5, 53, 1607, 10, 53, 3, 53, 3, 53, 3, 53, 5, 53, 1612, 10, 53,
	3, 53, 5, 53, 1615, 10, 53, 5, 53, 1617, 10, 53, 3, 54, 5, 54, 1620, 10,
	54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 5, 55, 1629, 10, 55,
	3, 55, 3, 55, 3, 55, 5, 55, 1634, 10, 55, 3, 55, 3, 55, 3, 56, 3, 56, 3,
	56, 5, 56, 1641, 10, 56, 3, 56, 5, 56, 1644, 10, 56, 3, 57, 5, 57, 1647,
	10, 57, 3, 57, 3, 57, 5, 57, 1651, 10, 57, 3, 57, 5, 57, 1654, 10, 57,
	3, 57, 3, 57, 3, 57, 3, 57, 7, 57, 1660, 10, 57, 12, 57, 14, 57, 1663,
	11, 57, 3, 57, 3, 57, 5, 57, 1667, 10, 57, 3, 57, 7, 57, 1670, 10, 57,
	12, 57, 14, 57, 1673, 11, 57, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1679,
	10, 58, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 5, 60,
	1689, 10, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	62, 3, 62, 3, 62, 3, 62, 6, 62, 1703, 10, 62, 13, 62, 14, 62, 1704, 3,
	62, 3, 62, 3, 63, 3, 63, 5, 63, 1711, 10, 63, 3, 64, 3, 64, 3, 64, 3, 64,
	3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 1721, 10, 65, 3, 66, 3, 66, 3, 66, 3,
	66, 3, 66, 3, 66, 7, 66, 1729, 10, 66, 12, 66, 14, 66, 1732, 11, 66, 3,
	66, 3, 66, 3, 66, 3, 66, 5, 66, 1738, 10, 66, 3, 66, 7, 66, 1741, 10, 66,
	12, 66, 14, 66, 1744, 11, 66, 3, 66, 3, 66, 3, 66, 5, 66, 1749, 10, 66,
	3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 1757, 10, 67, 12, 67,
	14, 67, 1760, 11, 67, 3, 67, 3, 67, 5, 67, 1764, 10, 67, 3, 67, 3, 67,
	3, 67, 3, 67, 3, 67, 5, 67, 1771, 10, 67, 3, 67, 7, 67, 1774, 10, 67, 12,
	67, 14, 67, 1777, 11, 67, 3, 67, 3, 67, 3, 67, 5, 67, 1782, 10, 67, 3,
	68, 5, 68, 1785, 10, 68, 3, 68, 5, 68, 1788, 10, 68, 3, 68, 3, 68, 3, 68,
	3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 7,
	68, 1803, 10, 68, 12, 68, 14, 68, 1806, 11, 68, 3, 68, 3, 68, 5, 68, 1810,
	10, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 1819, 10,
	68, 3, 68, 7, 68, 1822, 10, 68, 12, 68, 14, 68, 1825, 11, 68, 3, 68, 3,
	68, 3, 68, 5, 68, 1830, 10, 68, 3, 69, 5, 69, 1833, 10, 69, 3, 69, 3, 69,
	3, 70, 3, 70, 3, 70, 5, 70, 1840, 10, 70, 3, 70, 5, 70, 1843, 10, 70, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 72, 5, 72, 1850, 10, 72, 3, 72, 6, 72, 1853,
	10, 72, 13, 72, 14, 72, 1854, 3, 72, 3, 72, 5, 72, 1859, 10, 72, 3, 73,
	3, 73, 3, 73, 5, 73, 1864, 10, 73, 3, 74, 3, 74, 3, 74, 5, 74, 1869, 10,
	74, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 7, 75, 1877, 10, 75, 12,
	75, 14, 75, 1880, 11, 75, 3, 75, 3, 75, 3, 75, 5, 75, 1885, 10, 75, 3,
	76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 7, 76, 1893, 10, 76, 12, 76, 14,
	76, 1896, 11, 76, 3, 76, 3, 76, 5, 76, 1900, 10, 76, 3, 76, 3, 76, 3, 76,
	3, 76, 3, 76, 5, 76, 1907, 10, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 1913,
	10, 76, 3, 76, 3, 76, 5, 76, 1917, 10, 76, 3, 77, 5, 77, 1920, 10, 77,
	3, 77, 5, 77, 1923, 10, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3,
	77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 7, 77, 1938, 10, 77, 12,
	77, 14, 77, 1941, 11, 77, 3, 77, 3, 77, 5, 77, 1945, 10, 77, 3, 77, 3,
	77, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 1953, 10, 77, 3, 78, 3, 78, 3, 78,
	3, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 7, 79, 1965, 10, 79, 12,
	79, 14, 79, 1968, 11, 79, 3, 79, 3, 79, 3, 80, 3, 80, 5, 80, 1974, 10,
	80, 3, 81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83,
	3, 83, 3, 83, 6, 83, 1988, 10, 83, 13, 83, 14, 83, 1989, 3, 83, 3, 83,
	3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 7, 84, 1999, 10, 84, 12, 84, 14, 84,
	2002, 11, 84, 3, 84, 3, 84, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85,
	2022, 10, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 87, 3, 87, 5, 87, 2030, 10,
	87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 7, 87, 2040,
	10, 87, 12, 87, 14, 87, 2043, 11, 87, 3, 87, 3, 87, 3, 87, 5, 87, 2048,
	10, 87, 3, 87, 3, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88,
	3, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 5, 90, 2068,
	10, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90,
	7, 90, 2079, 10, 90, 12, 90, 14, 90, 2082, 11, 90, 3, 90, 3, 90, 3, 90,
	3, 90, 3, 90, 5, 90, 2089, 10, 90, 3, 90, 3, 90, 3, 90, 5, 90, 2094, 10,
	90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 7, 90, 2102, 10, 90, 12,
	90, 14, 90, 2105, 11, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3,
	90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90,
	3, 90, 5, 90, 2125, 10, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 6, 90, 2132,
	10, 90, 13, 90, 14, 90, 2133, 3, 90, 5, 90, 2137, 10, 90, 3, 90, 3, 90,
	5, 90, 2141, 10, 90, 3, 90, 5, 90, 2144, 10, 90, 3, 90, 3, 90, 3, 90, 3,
	90, 3, 90, 3, 90, 5, 90, 2152, 10, 90, 5, 90, 2154, 10, 90, 5, 90, 2156,
	10, 90, 3, 90, 5, 90, 2159, 10, 90, 3, 90, 3, 90, 3, 91, 3, 91, 3, 91,
	3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3,
	93, 3, 93, 3, 93, 3, 93, 3, 94, 3, 94, 3, 94, 5, 94, 2183, 10, 94, 3, 94,
	3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 5, 94, 2192, 10, 94, 3, 94, 3,
	94, 3, 94, 5, 94, 2197, 10, 94, 3, 94, 3, 94, 3, 94, 5, 94, 2202, 10, 94,
	3, 94, 3, 94, 3, 94, 3, 94, 5, 94, 2208, 10, 94, 3, 94, 3, 94, 3, 94, 3,
	94, 3, 94, 5, 94, 2215, 10, 94, 3, 94, 3, 94, 3, 94, 5, 94, 2220, 10, 94,
	5, 94, 2222, 10, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3,
	96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 5, 96, 2238, 10, 96, 3, 97,
	3, 97, 3, 97, 5, 97, 2243, 10, 97, 3, 97, 3, 97, 3, 97, 3, 97, 5, 97, 2249,
	10, 97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 5, 98, 2256, 10, 98, 3, 99,
	3, 99, 3, 99, 3, 99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 101, 3, 101, 3,
	101, 3, 101, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 7, 102, 2276,
	10, 102, 12, 102, 14, 102, 2279, 11, 102, 3, 102, 3, 102, 3, 102, 5, 102,
	2284, 10, 102, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 7, 103,
	2292, 10, 103, 12, 103, 14, 103, 2295, 11, 103, 3, 103, 3, 103, 3, 104,
	3, 104, 3, 104, 3, 104, 3, 104, 5, 104, 2304, 10, 104, 3, 105, 3, 105,
	3, 105, 3, 105, 3, 105, 7, 105, 2311, 10, 105, 12, 105, 14, 105, 2314,
	11, 105, 3, 105, 3, 105, 3, 106, 3, 106, 3, 106, 3, 106, 3, 106, 3, 106,
	7, 106, 2324, 10, 106, 12, 106, 14, 106, 2327, 11, 106, 3, 106, 3, 106,
	3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 108, 3, 108, 3, 108, 3, 109,
	3, 109, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 5, 110, 2346, 10, 110,
	3, 111, 3, 111, 3, 111, 3, 111, 3, 112, 3, 112, 3, 112, 5, 112, 2355, 10,
	112, 3, 112, 3, 112, 3, 112, 5, 112, 2360, 10, 112, 3, 112, 3, 112, 5,
	112, 2364, 10, 112, 3, 112, 5, 112, 2367, 10, 112, 3, 113, 3, 113, 3, 113,
	3, 113, 3, 113, 3, 113, 3, 114, 3, 114, 3, 114, 3, 114, 3, 114, 3, 114,
	5, 114, 2381, 10, 114, 3, 114, 3, 114, 3, 115, 3, 115, 7, 115, 2387, 10,
	115, 12, 115, 14, 115, 2390, 11, 115, 3, 115, 5, 115, 2393, 10, 115, 3,
	115, 5, 115, 2396, 10, 115, 3, 116, 3, 116, 3, 116, 3, 117, 3, 117, 3,
	117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 5, 117, 2411,
	10, 117, 3, 118, 3, 118, 5, 118, 2415, 10, 118, 3, 118, 3, 118, 3, 118,
	5, 118, 2420, 10, 118, 3, 118, 5, 118, 2423, 10, 118, 3, 118, 3, 118, 3,
	119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 5,
	119, 2436, 10, 119, 3, 119, 3, 119, 5, 119, 2440, 10, 119, 3, 119, 3, 119,
	3, 120, 3, 120, 3, 120, 3, 120, 3, 120, 3, 120, 7, 120, 2450, 10, 120,
	12, 120, 14, 120, 2453, 11, 120, 3, 120, 3, 120, 5, 120, 2457, 10, 120,
	3, 120, 3, 120, 5, 120, 2461, 10, 120, 3, 120, 3, 120, 5, 120, 2465, 10,
	120, 3, 120, 3, 120, 3, 121, 3, 121, 5, 121, 2471, 10, 121, 3, 121, 5,
	121, 2474, 10, 121, 3, 121, 5, 121, 2477, 10, 121, 3, 122, 3, 122, 3, 122,
	3, 122, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123,
	3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123,
	3, 123, 3, 123, 3, 123, 3, 123, 5, 123, 2504, 10, 123, 3, 123, 3, 123,
	6, 123, 2508, 10, 123, 13, 123, 14, 123, 2509, 3, 123, 3, 123, 5, 123,
	2514, 10, 123, 3, 123, 3, 123, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124,
	7, 124, 2523, 10, 124, 12, 124, 14, 124, 2526, 11, 124, 3, 124, 3, 124,
	3, 125, 3, 125, 5, 125, 2532, 10, 125, 3, 125, 3, 125, 5, 125, 2536, 10,
	125, 3, 125, 5, 125, 2539, 10, 125, 3, 126, 3, 126, 3, 126, 3, 126, 5,
	126, 2545, 10, 126, 3, 127, 3, 127, 3, 127, 3, 127, 3, 127, 3, 127, 3,
	127, 5, 127, 2554, 10, 127, 3, 127, 3, 127, 3, 128, 3, 128, 3, 128, 3,
	128, 5, 128, 2562, 10, 128, 3, 128, 3, 128, 5, 128, 2566, 10, 128, 3, 129,
	3, 129, 5, 129, 2570, 10, 129, 3, 129, 3, 129, 3, 129, 3, 130, 3, 130,
	3, 130, 5, 130, 2578, 10, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130,
	3, 130, 3, 130, 5, 130, 2587, 10, 130, 3, 131, 3, 131, 3, 131, 3, 131,
	6, 131, 2593, 10, 131, 13, 131, 14, 131, 2594, 3, 132, 3, 132, 3, 132,
	3, 132, 3, 132, 3, 132, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133,
	5, 133, 2609, 10, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133,
	3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133,
	3, 133, 3, 133, 3, 133, 3, 133, 5, 133, 2630, 10, 133, 3, 134, 6, 134,
	2633, 10, 134, 13, 134, 14, 134, 2634, 3, 135, 3, 135, 5, 135, 2639, 10,
	135, 3, 135, 3, 135, 3, 135, 3, 136, 3, 136, 5, 136, 2646, 10, 136, 3,
	136, 3, 136, 5, 136, 2650, 10, 136, 3, 137, 3, 137, 5, 137, 2654, 10, 137,
	3, 137, 3, 137, 5, 137, 2658, 10, 137, 3, 138, 3, 138, 3, 138, 3, 139,
	3, 139, 3, 139, 3, 139, 3, 139, 7, 139, 2668, 10, 139, 12, 139, 14, 139,
	2671, 11, 139, 3, 139, 5, 139, 2674, 10, 139, 3, 139, 3, 139, 3, 139, 3,
	140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 141, 3, 141, 3, 141, 3, 142, 5,
	142, 2688, 10, 142, 3, 142, 3, 142, 3, 142, 3, 142, 5, 142, 2694, 10, 142,
	3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 5, 142, 2701, 10, 142, 3, 143,
	3, 143, 3, 143, 5, 143, 2706, 10, 143, 3, 143, 3, 143, 3, 143, 3, 143,
	3, 143, 3, 143, 3, 143, 3, 143, 3, 143, 5, 143, 2717, 10, 143, 3, 143,
	5, 143, 2720, 10, 143, 3, 143, 3, 143, 3, 143, 3, 143, 5, 143, 2726, 10,
	143, 5, 143, 2728, 10, 143, 3, 144, 3, 144, 3, 144, 3, 144, 3, 144, 3,
	144, 3, 144, 5, 144, 2737, 10, 144, 3, 145, 3, 145, 3, 145, 3, 145, 3,
	145, 3, 145, 3, 145, 3, 145, 5, 145, 2747, 10, 145, 3, 145, 3, 145, 3,
	145, 5, 145, 2752, 10, 145, 3, 146, 3, 146, 3, 146, 3, 146, 3, 146, 3,
	147, 3, 147, 3, 148, 3, 148, 3, 149, 3, 149, 3, 150, 3, 150, 5, 150, 2767,
	10, 150, 3, 151, 3, 151, 5, 151, 2771, 10, 151, 3, 152, 5, 152, 2774, 10,
	152, 3, 152, 3, 152, 5, 152, 2778, 10, 152, 3, 153, 3, 153, 3, 153, 3,
	153, 3, 153, 3, 153, 3, 154, 3, 154, 3, 154, 3, 154, 6, 154, 2790, 10,
	154, 13, 154, 14, 154, 2791, 5, 154, 2794, 10, 154, 3, 154, 3, 154, 5,
	154, 2798, 10, 154, 3, 155, 3, 155, 3, 155, 3, 155, 7, 155, 2804, 10, 155,
	12, 155, 14, 155, 2807, 11, 155, 3, 155, 3, 155, 3, 155, 3, 156, 5, 156,
	2813, 10, 156, 3, 156, 6, 156, 2816, 10, 156, 13, 156, 14, 156, 2817, 5,
	156, 2820, 10, 156, 3, 156, 3, 156, 3, 157, 5, 157, 2825, 10, 157, 3, 157,
	6, 157, 2828, 10, 157, 13, 157, 14, 157, 2829, 3, 157, 3, 157, 3, 158,
	3, 158, 3, 158, 3, 158, 5, 158, 2838, 10, 158, 3, 159, 3, 159, 3, 159,
	3, 159, 3, 159, 5, 159, 2845, 10, 159, 3, 159, 3, 159, 5, 159, 2849, 10,
	159, 3, 159, 5, 159, 2852, 10, 159, 3, 160, 3, 160, 3, 160, 3, 161, 3,
	161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 5, 161, 2864, 10, 161, 3,
	162, 3, 162, 3, 162, 3, 162, 5, 162, 2870, 10, 162, 3, 163, 3, 163, 3,
	163, 3, 164, 3, 164, 3, 164, 3, 164, 5, 164, 2879, 10, 164, 3, 164, 5,
	164, 2882, 10, 164, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 7,
	165, 2890, 10, 165, 12, 165, 14, 165, 2893, 11, 165, 3, 165, 3, 165, 3,
	165, 3, 165, 3, 165, 3, 165, 7, 165, 2901, 10, 165, 12, 165, 14, 165, 2904,
	11, 165, 5, 165, 2906, 10, 165, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166,
	5, 166, 2913, 10, 166, 3, 166, 5, 166, 2916, 10, 166, 3, 167, 3, 167, 3,
	167, 3, 167, 3, 167, 5, 167, 2923, 10, 167, 3, 168, 3, 168, 3, 168, 3,
	168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 5, 168, 2934, 10, 168, 3,
	168, 3, 168, 3, 168, 3, 168, 5, 168, 2940, 10, 168, 3, 168, 3, 168, 5,
	168, 2944, 10, 168, 3, 169, 3, 169, 3, 169, 3, 169, 3, 169, 3, 169, 7,
	169, 2952, 10, 169, 12, 169, 14, 169, 2955, 11, 169, 5, 169, 2957, 10,
	169, 3, 169, 3, 169, 3, 170, 3, 170, 5, 170, 2963, 10, 170, 3, 170, 3,
	170, 3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 5, 170, 2974,
	10, 170, 5, 170, 2976, 10, 170, 5, 170, 2978, 10, 170, 3, 170, 5, 170,
	2981, 10, 170, 3, 171, 3, 171, 5, 171, 2985, 10, 171, 3, 171, 5, 171, 2988,
	10, 171, 3, 172, 3, 172, 5, 172, 2992, 10, 172, 3, 172, 3, 172, 5, 172,
	2996, 10, 172, 3, 172, 3, 172, 3, 172, 5, 172, 3001, 10, 172, 3, 173, 3,
	173, 3, 173, 3, 174, 3, 174, 3, 174, 3, 174, 3, 174, 3, 174, 5, 174, 3012,
	10, 174, 3, 174, 3, 174, 5, 174, 3016, 10, 174, 3, 174, 3, 174, 3, 174,
	3, 174, 3, 174, 3, 174, 5, 174, 3024, 10, 174, 3, 175, 5, 175, 3027, 10,
	175, 3, 175, 3, 175, 3, 175, 7, 175, 3032, 10, 175, 12, 175, 14, 175, 3035,
	11, 175, 3, 176, 3, 176, 3, 176, 3, 176, 7, 176, 3041, 10, 176, 12, 176,
	14, 176, 3044, 11, 176, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 7, 177,
	3051, 10, 177, 12, 177, 14, 177, 3054, 11, 177, 3, 177, 3, 177, 5, 177,
	3058, 10, 177, 3, 177, 3, 177, 3, 177, 3, 177, 5, 177, 3064, 10, 177, 3,
	177, 3, 177, 5, 177, 3068, 10, 177, 3, 177, 5, 177, 3071, 10, 177, 3, 178,
	3, 178, 3, 178, 3, 178, 3, 178, 3, 178, 5, 178, 3079, 10, 178, 3, 178,
	5, 178, 3082, 10, 178, 3, 178, 3, 178, 5, 178, 3086, 10, 178, 3, 178, 3,
	178, 5, 178, 3090, 10, 178, 3, 178, 3, 178, 3, 178, 5, 178, 3095, 10, 178,
	3, 178, 5, 178, 3098, 10, 178, 3, 178, 3, 178, 5, 178, 3102, 10, 178, 3,
	178, 3, 178, 5, 178, 3106, 10, 178, 7, 178, 3108, 10, 178, 12, 178, 14,
	178, 3111, 11, 178, 3, 178, 3, 178, 3, 178, 3, 179, 3, 179, 3, 179, 3,
	179, 7, 179, 3120, 10, 179, 12, 179, 14, 179, 3123, 11, 179, 3, 179, 3,
	179, 3, 179, 3, 179, 3, 179, 3, 179, 3, 179, 3, 180, 3, 180, 7, 180, 3134,
	10, 180, 12, 180, 14, 180, 3137, 11, 180, 3, 181, 3, 181, 3, 181, 3, 181,
	3, 181, 5, 181, 3144, 10, 181, 3, 182, 3, 182, 5, 182, 3148, 10, 182, 3,
	182, 3, 182, 5, 182, 3152, 10, 182, 3, 182, 3, 182, 3, 183, 3, 183, 5,
	183, 3158, 10, 183, 3, 183, 3, 183, 3, 183, 3, 183, 7, 183, 3164, 10, 183,
	12, 183, 14, 183, 3167, 11, 183, 5, 183, 3169, 10, 183, 3, 183, 5, 183,
	3172, 10, 183, 3, 183, 3, 183, 5, 183, 3176, 10, 183, 3, 183, 5, 183, 3179,
	10, 183, 3, 183, 5, 183, 3182, 10, 183, 3, 183, 5, 183, 3185, 10, 183,
	3, 184, 3, 184, 5, 184, 3189, 10, 184, 3, 185, 3, 185, 3, 185, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 5, 186, 3201, 10, 186,
	3, 186, 5, 186, 3204, 10, 186, 3, 187, 3, 187, 3, 187, 7, 187, 3209, 10,
	187, 12, 187, 14, 187, 3212, 11, 187, 3, 188, 3, 188, 7, 188, 3216, 10,
	188, 12, 188, 14, 188, 3219, 11, 188, 3, 188, 3, 188, 5, 188, 3223, 10,
	188, 3, 189, 3, 189, 7, 189, 3227, 10, 189, 12, 189, 14, 189, 3230, 11,
	189, 3, 189, 5, 189, 3233, 10, 189, 3, 190, 3, 190, 3, 190, 5, 190, 3238,
	10, 190, 3, 190, 3, 190, 3, 190, 7, 190, 3243, 10, 190, 12, 190, 14, 190,
	3246, 11, 190, 3, 190, 3, 190, 3, 190, 5, 190, 3251, 10, 190, 3, 190, 3,
	190, 3, 190, 3, 190, 3, 190, 5, 190, 3258, 10, 190, 3, 191, 5, 191, 3261,
	10, 191, 3, 191, 5, 191, 3264, 10, 191, 3, 191, 3, 191, 5, 191, 3268, 10,
	191, 3, 191, 3, 191, 3, 191, 5, 191, 3273, 10, 191, 3, 191, 3, 191, 7,
	191, 3277, 10, 191, 12, 191, 14, 191, 3280, 11, 191, 3, 192, 3, 192, 3,
	192, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 7, 193, 3290, 10, 193, 12,
	193, 14, 193, 3293, 11, 193, 3, 193, 3, 193, 3, 194, 3, 194, 5, 194, 3299,
	10, 194, 3, 195, 3, 195, 3, 195, 3, 195, 3, 195, 5, 195, 3306, 10, 195,
	3, 195, 3, 195, 5, 195, 3310, 10, 195, 3, 196, 3, 196, 3, 196, 3, 196,
	3, 196, 3, 196, 3, 196, 3, 196, 5, 196, 3320, 10, 196, 3, 197, 3, 197,
	5, 197, 3324, 10, 197, 3, 197, 3, 197, 3, 197, 3, 197, 7, 197, 3330, 10,
	197, 12, 197, 14, 197, 3333, 11, 197, 3, 197, 3, 197, 3, 197, 3, 197, 3,
	198, 3, 198, 3, 198, 3, 198, 3, 198, 5, 198, 3344, 10, 198, 3, 199, 3,
	199, 3, 199, 3, 199, 3, 199, 3, 199, 7, 199, 3352, 10, 199, 12, 199, 14,
	199, 3355, 11, 199, 3, 199, 3, 199, 5, 199, 3359, 10, 199, 3, 200, 3, 200,
	3, 200, 3, 200, 3, 200, 3, 200, 7, 200, 3367, 10, 200, 12, 200, 14, 200,
	3370, 11, 200, 3, 200, 3, 200, 3, 200, 7, 200, 3375, 10, 200, 12, 200,
	14, 200, 3378, 11, 200, 5, 200, 3380, 10, 200, 3, 200, 3, 200, 3, 201,
	3, 201, 5, 201, 3386, 10, 201, 3, 202, 3, 202, 3, 202, 5, 202, 3391, 10,
	202, 3, 202, 5, 202, 3394, 10, 202, 3, 203, 3, 203, 3, 203, 5, 203, 3399,
	10, 203, 3, 203, 3, 203, 3, 203, 3, 203, 3, 203, 3, 203, 7, 203, 3407,
	10, 203, 12, 203, 14, 203, 3410, 11, 203, 3, 203, 3, 203, 5, 203, 3414,
	10, 203, 3, 203, 3, 203, 3, 203, 3, 203, 3, 204, 3, 204, 3, 204, 3, 204,
	3, 204, 7, 204, 3425, 10, 204, 12, 204, 14, 204, 3428, 11, 204, 3, 204,
	3, 204, 3, 205, 3, 205, 3, 205, 3, 205, 3, 205, 7, 205, 3437, 10, 205,
	12, 205, 14, 205, 3440, 11, 205, 3, 205, 3, 205, 5, 205, 3444, 10, 205,
	3, 205, 3, 205, 3, 205, 3, 205, 3, 205, 3, 205, 7, 205, 3452, 10, 205,
	12, 205, 14, 205, 3455, 11, 205, 3, 205, 3, 205, 5, 205, 3459, 10, 205,
	5, 205, 3461, 10, 205, 3, 206, 3, 206, 3, 206, 5, 206, 3466, 10, 206, 3,
	206, 3, 206, 5, 206, 3470, 10, 206, 3, 206, 3, 206, 3, 206, 3, 206, 5,
	206, 3476, 10, 206, 3, 206, 3, 206, 5, 206, 3480, 10, 206, 3, 207, 3, 207,
	3, 207, 3, 207, 3, 208, 3, 208, 3, 208, 3, 208, 3, 208, 7, 208, 3491, 10,
	208, 12, 208, 14, 208, 3494, 11, 208, 3, 208, 5, 208, 3497, 10, 208, 3,
	208, 3, 208, 3, 208, 3, 208, 3, 208, 3, 208, 7, 208, 3505, 10, 208, 12,
	208, 14, 208, 3508, 11, 208, 5, 208, 3510, 10, 208, 5, 208, 3512, 10, 208,
	3, 209, 3, 209, 3, 209, 5, 209, 3517, 10, 209, 3, 210, 3, 210, 3, 210,
	3, 210, 3, 210, 7, 210, 3524, 10, 210, 12, 210, 14, 210, 3527, 11, 210,
	3, 210, 3, 210, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211, 7, 211,
	3537, 10, 211, 12, 211, 14, 211, 3540, 11, 211, 3, 211, 3, 211, 3, 212,
	3, 212, 3, 212, 5, 212, 3547, 10, 212, 3, 212, 3, 212, 5, 212, 3551, 10,
	212, 3, 213, 3, 213, 3, 213, 3, 214, 3, 214, 7, 214, 3558, 10, 214, 12,
	214, 14, 214, 3561, 11, 214, 3, 214, 5, 214, 3564, 10, 214, 3, 214, 7,
	214, 3567, 10, 214, 12, 214, 14, 214, 3570, 11, 214, 3, 214, 3, 214, 3,
	215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 5, 215, 3580, 10, 215, 5,
	215, 3582, 10, 215, 3, 216, 3, 216, 3, 216, 3, 216, 3, 217, 3, 217, 3,
	217, 3, 217, 3, 217, 3, 217, 3, 217, 3, 217, 7, 217, 3596, 10, 217, 12,
	217, 14, 217, 3599, 11, 217, 3, 218, 3, 218, 5, 218, 3603, 10, 218, 3,
	218, 3, 218, 7, 218, 3607, 10, 218, 12, 218, 14, 218, 3610, 11, 218, 3,
	218, 3, 218, 3, 219, 5, 219, 3615, 10, 219, 3, 219, 3, 219, 3, 219, 3,
	219, 3, 219, 3, 219, 3, 220, 3, 220, 3, 220, 3, 220, 3, 221, 3, 221, 3,
	221, 3, 221, 7, 221, 3631, 10, 221, 12, 221, 14, 221, 3634, 11, 221, 3,
	221, 3, 221, 3, 222, 3, 222, 5, 222, 3640, 10, 222, 3, 222, 5, 222, 3643,
	10, 222, 3, 223, 5, 223, 3646, 10, 223, 3, 223, 3, 223, 3, 223, 3, 223,
	7, 223, 3652, 10, 223, 12, 223, 14, 223, 3655, 11, 223, 5, 223, 3657, 10,
	223, 3, 223, 3, 223, 3, 224, 3, 224, 3, 224, 3, 224, 5, 224, 3665, 10,
	224, 5, 224, 3667, 10, 224, 3, 224, 3, 224, 5, 224, 3671, 10, 224, 3, 224,
	5, 224, 3674, 10, 224, 3, 225, 3, 225, 3, 225, 5, 225, 3679, 10, 225, 5,
	225, 3681, 10, 225, 3, 225, 3, 225, 5, 225, 3685, 10, 225, 3, 225, 3, 225,
	3, 225, 3, 226, 3, 226, 3, 227, 3, 227, 3, 227, 3, 227, 3, 227, 5, 227,
	3697, 10, 227, 3, 228, 3, 228, 3, 228, 3, 228, 3, 228, 3, 229, 3, 229,
	5, 229, 3706, 10, 229, 3, 229, 3, 229, 3, 229, 3, 229, 7, 229, 3712, 10,
	229, 12, 229, 14, 229, 3715, 11, 229, 3, 230, 3, 230, 5, 230, 3719, 10,
	230, 3, 230, 3, 230, 5, 230, 3723, 10, 230, 3, 231, 3, 231, 3, 231, 5,
	231, 3728, 10, 231, 3, 231, 5, 231, 3731, 10, 231, 3, 232, 3, 232, 3, 232,
	3, 232, 7, 232, 3737, 10, 232, 12, 232, 14, 232, 3740, 11, 232, 3, 233,
	3, 233, 3, 233, 3, 233, 3, 233, 5, 233, 3747, 10, 233, 3, 234, 3, 234,
	3, 234, 3, 234, 5, 234, 3753, 10, 234, 3, 234, 5, 234, 3756, 10, 234, 3,
	234, 5, 234, 3759, 10, 234, 3, 235, 3, 235, 3, 235, 3, 235, 7, 235, 3765,
	10, 235, 12, 235, 14, 235, 3768, 11, 235, 3, 235, 3, 235, 3, 235, 3, 235,
	3, 235, 3, 235, 3, 235, 5, 235, 3777, 10, 235, 3, 236, 3, 236, 3, 236,
	3, 236, 3, 236, 3, 236, 3, 236, 3, 236, 7, 236, 3787, 10, 236, 12, 236,
	14, 236, 3790, 11, 236, 3, 236, 3, 236, 3, 236, 3, 236, 5, 236, 3796, 10,
	236, 3, 237, 3, 237, 5, 237, 3800, 10, 237, 3, 237, 3, 237, 5, 237, 3804,
	10, 237, 3, 237, 5, 237, 3807, 10, 237, 3, 237, 5, 237, 3810, 10, 237,
	3, 238, 3, 238, 3, 238, 5, 238, 3815, 10, 238, 3, 239, 3, 239, 3, 239,
	5, 239, 3820, 10, 239, 3, 239, 5, 239, 3823, 10, 239, 3, 239, 5, 239, 3826,
	10, 239, 3, 240, 3, 240, 6, 240, 3830, 10, 240, 13, 240, 14, 240, 3831,
	3, 240, 5, 240, 3835, 10, 240, 3, 240, 3, 240, 3, 241, 3, 241, 5, 241,
	3841, 10, 241, 3, 241, 5, 241, 3844, 10, 241, 3, 242, 5, 242, 3847, 10,
	242, 3, 242, 6, 242, 3850, 10, 242, 13, 242, 14, 242, 3851, 3, 242, 5,
	242, 3855, 10, 242, 3, 243, 3, 243, 3, 243, 3, 243, 6, 243, 3861, 10, 243,
	13, 243, 14, 243, 3862, 3, 244, 3, 244, 6, 244, 3867, 10, 244, 13, 244,
	14, 244, 3868, 3, 245, 3, 245, 3, 245, 3, 245, 3, 245, 3, 245, 7, 245,
	3877, 10, 245, 12, 245, 14, 245, 3880, 11, 245, 3, 245, 3, 245, 5, 245,
	3884, 10, 245, 3, 246, 3, 246, 3, 246, 5, 246, 3889, 10, 246, 3, 246, 3,
	246, 3, 247, 3, 247, 3, 247, 3, 247, 5, 247, 3897, 10, 247, 3, 247, 3,
	247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 5, 247, 3907, 10,
	247, 3, 247, 3, 247, 5, 247, 3911, 10, 247, 5, 247, 3913, 10, 247, 3, 247,
	5, 247, 3916, 10, 247, 3, 248, 3, 248, 3, 248, 3, 248, 3, 248, 3, 248,
	3, 248, 3, 248, 7, 248, 3926, 10, 248, 12, 248, 14, 248, 3929, 11, 248,
	3, 248, 5, 248, 3932, 10, 248, 3, 248, 5, 248, 3935, 10, 248, 3, 249, 3,
	249, 3, 249, 3, 249, 3, 250, 3, 250, 3, 250, 3, 251, 3, 251, 3, 251, 3,
	251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 7, 251, 3953, 10, 251, 12,
	251, 14, 251, 3956, 11, 251, 3, 251, 3, 251, 5, 251, 3960, 10, 251, 3,
	251, 3, 251, 3, 251, 5, 251, 3965, 10, 251, 3, 251, 3, 251, 5, 251, 3969,
	10, 251, 3, 252, 3, 252, 3, 252, 3, 252, 3, 252, 5, 252, 3976, 10, 252,
	3, 252, 5, 252, 3979, 10, 252, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253,
	7, 253, 3986, 10, 253, 12, 253, 14, 253, 3989, 11, 253, 3, 253, 3, 253,
	3, 253, 3, 253, 5, 253, 3995, 10, 253, 3, 254, 3, 254, 3, 254, 5, 254,
	4000, 10, 254, 3, 255, 3, 255, 5, 255, 4004, 10, 255, 3, 256, 3, 256, 3,
	256, 3, 256, 3, 256, 3, 256, 5, 256, 4012, 10, 256, 3, 256, 3, 256, 3,
	256, 3, 256, 5, 256, 4018, 10, 256, 3, 257, 3, 257, 3, 257, 3, 257, 3,
	257, 3, 257, 5, 257, 4026, 10, 257, 3, 257, 5, 257, 4029, 10, 257, 3, 258,
	3, 258, 3, 258, 3, 258, 3, 259, 3, 259, 3, 259, 5, 259, 4038, 10, 259,
	3, 259, 5, 259, 4041, 10, 259, 3, 259, 5, 259, 4044, 10, 259, 3, 260, 3,
	260, 3, 260, 3, 261, 3, 261, 3, 261, 3, 261, 5, 261, 4053, 10, 261, 3,
	262, 3, 262, 3, 262, 3, 262, 5, 262, 4059, 10, 262, 3, 262, 3, 262, 3,
	262, 3, 262, 5, 262, 4065, 10, 262, 5, 262, 4067, 10, 262, 3, 263, 3, 263,
	3, 263, 3, 263, 3, 263, 3, 263, 3, 263, 3, 263, 3, 263, 3, 263, 3, 263,
	5, 263, 4080, 10, 263, 5, 263, 4082, 10, 263, 3, 264, 3, 264, 3, 264, 3,
	264, 3, 264, 3, 264, 3, 264, 5, 264, 4091, 10, 264, 5, 264, 4093, 10, 264,
	3, 265, 3, 265, 5, 265, 4097, 10, 265, 3, 265, 3, 265, 3, 265, 3, 265,
	5, 265, 4103, 10, 265, 3, 265, 3, 265, 5, 265, 4107, 10, 265, 3, 266, 3,
	266, 3, 266, 3, 266, 3, 266, 3, 267, 3, 267, 3, 268, 3, 268, 3, 268, 7,
	268, 4119, 10, 268, 12, 268, 14, 268, 4122, 11, 268, 3, 269, 3, 269, 5,
	269, 4126, 10, 269, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 271, 3,
	271, 3, 271, 3, 271, 5, 271, 4137, 10, 271, 3, 271, 3, 271, 3, 271, 3,
	271, 3, 271, 3, 271, 3, 271, 3, 271, 3, 271, 5, 271, 4148, 10, 271, 3,
	271, 3, 271, 5, 271, 4152, 10, 271, 3, 271, 3, 271, 3, 271, 7, 271, 4157,
	10, 271, 12, 271, 14, 271, 4160, 11, 271, 3, 271, 3, 271, 5, 271, 4164,
	10, 271, 7, 271, 4166, 10, 271, 12, 271, 14, 271, 4169, 11, 271, 3, 271,
	3, 271, 5, 271, 4173, 10, 271, 3, 271, 3, 271, 3, 271, 3, 271, 3, 271,
	3, 271, 7, 271, 4181, 10, 271, 12, 271, 14, 271, 4184, 11, 271, 3, 272,
	3, 272, 3, 272, 5, 272, 4189, 10, 272, 3, 272, 5, 272, 4192, 10, 272, 3,
	273, 3, 273, 3, 273, 3, 273, 3, 273, 3, 273, 3, 273, 7, 273, 4201, 10,
	273, 12, 273, 14, 273, 4204, 11, 273, 3, 274, 3, 274, 5, 274, 4208, 10,
	274, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 5,
	274, 4218, 10, 274, 5, 274, 4220, 10, 274, 5, 274, 4222, 10, 274, 3, 275,
	3, 275, 3, 275, 3, 275, 3, 275, 3, 275, 3, 275, 3, 275, 5, 275, 4232, 10,
	275, 3, 275, 3, 275, 5, 275, 4236, 10, 275, 5, 275, 4238, 10, 275, 3, 276,
	3, 276, 3, 276, 3, 276, 3, 276, 3, 276, 3, 276, 3, 276, 7, 276, 4248, 10,
	276, 12, 276, 14, 276, 4251, 11, 276, 3, 276, 3, 276, 3, 276, 3, 276, 3,
	276, 5, 276, 4258, 10, 276, 3, 277, 3, 277, 3, 277, 3, 277, 3, 278, 3,
	278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 5, 278, 4271, 10, 278, 3,
	278, 5, 278, 4274, 10, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3,
	278, 3, 278, 3, 278, 3, 278, 3, 278, 7, 278, 4286, 10, 278, 12, 278, 14,
	278, 4289, 11, 278, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 5, 279, 4296,
	10, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 5, 279, 4304,
	10, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 5, 279, 4311, 10, 279,
	3, 279, 3, 279, 5, 279, 4315, 10, 279, 3, 280, 3, 280, 3, 280, 3, 280,
	3, 280, 5, 280, 4322, 10, 280, 3, 281, 3, 281, 5, 281, 4326, 10, 281, 3,
	281, 3, 281, 3, 281, 5, 281, 4331, 10, 281, 7, 281, 4333, 10, 281, 12,
	281, 14, 281, 4336, 11, 281, 3, 281, 3, 281, 3, 281, 7, 281, 4341, 10,
	281, 12, 281, 14, 281, 4344, 11, 281, 3, 281, 5, 281, 4347, 10, 281, 3,
	282, 3, 282, 3, 282, 3, 282, 3, 282, 5, 282, 4354, 10, 282, 3, 282, 3,
	282, 3, 282, 5, 282, 4359, 10, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3,
	282, 3, 282, 3, 282, 5, 282, 4368, 10, 282, 3, 283, 3, 283, 3, 283, 3,
	283, 3, 283, 7, 283, 4375, 10, 283, 12, 283, 14, 283, 4378, 11, 283, 3,
	283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 5, 283, 4386, 10, 283, 3,
	283, 5, 283, 4389, 10, 283, 3, 283, 3, 283, 3, 284, 3, 284, 3, 284, 3,
	284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 3,
	284, 3, 284, 3, 284, 3, 284, 5, 284, 4409, 10, 284, 3, 285, 3, 285, 5,
	285, 4413, 10, 285, 3, 286, 5, 286, 4416, 10, 286, 3, 286, 3, 286, 3, 286,
	6, 286, 4421, 10, 286, 13, 286, 14, 286, 4422, 3, 286, 5, 286, 4426, 10,
	286, 3, 286, 3, 286, 5, 286, 4430, 10, 286, 3, 286, 5, 286, 4433, 10, 286,
	3, 287, 3, 287, 3, 287, 3, 287, 3, 287, 5, 287, 4440, 10, 287, 3, 288,
	5, 288, 4443, 10, 288, 3, 288, 3, 288, 6, 288, 4447, 10, 288, 13, 288,
	14, 288, 4448, 3, 288, 5, 288, 4452, 10, 288, 3, 288, 3, 288, 5, 288, 4456,
	10, 288, 3, 288, 5, 288, 4459, 10, 288, 3, 289, 3, 289, 3, 289, 3, 289,
	3, 289, 5, 289, 4466, 10, 289, 3, 290, 3, 290, 3, 290, 5, 290, 4471, 10,
	290, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3,
	291, 3, 291, 7, 291, 4483, 10, 291, 12, 291, 14, 291, 4486, 11, 291, 3,
	291, 3, 291, 3, 291, 3, 291, 5, 291, 4492, 10, 291, 3, 292, 3, 292, 3,
	292, 3, 292, 3, 292, 3, 292, 3, 292, 3, 292, 3, 292, 5, 292, 4503, 10,
	292, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 5, 293, 4512,
	10, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 5, 293,
	4521, 10, 293, 3, 293, 3, 293, 5, 293, 4525, 10, 293, 3, 293, 3, 293, 5,
	293, 4529, 10, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3,
	293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3,
	293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 5,
	293, 4555, 10, 293, 3, 293, 5, 293, 4558, 10, 293, 3, 293, 5, 293, 4561,
	10, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293,
	5, 293, 4571, 10, 293, 3, 293, 3, 293, 5, 293, 4575, 10, 293, 3, 294, 3,
	294, 3, 294, 5, 294, 4580, 10, 294, 3, 295, 3, 295, 3, 295, 5, 295, 4585,
	10, 295, 3, 296, 3, 296, 3, 296, 5, 296, 4590, 10, 296, 3, 296, 3, 296,
	3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 5, 296, 4599, 10, 296, 3, 296,
	5, 296, 4602, 10, 296, 5, 296, 4604, 10, 296, 3, 296, 3, 296, 5, 296, 4608,
	10, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 5, 296, 4615, 10, 296,
	3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 5, 296, 4622, 10, 296, 3, 296,
	3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 5, 296, 4630, 10, 296, 3, 296,
	3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296,
	3, 296, 3, 296, 3, 296, 5, 296, 4645, 10, 296, 3, 297, 3, 297, 3, 297,
	5, 297, 4650, 10, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4655, 10, 297, 3,
	297, 3, 297, 3, 297, 3, 297, 5, 297, 4661, 10, 297, 3, 297, 5, 297, 4664,
	10, 297, 3, 297, 3, 297, 5, 297, 4668, 10, 297, 3, 297, 3, 297, 3, 297,
	3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4678, 10, 297, 3, 297,
	3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297,
	5, 297, 4690, 10, 297, 5, 297, 4692, 10, 297, 3, 297, 3, 297, 3, 297, 3,
	297, 3, 297, 5, 297, 4699, 10, 297, 3, 297, 3, 297, 5, 297, 4703, 10, 297,
	3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 6, 297, 4710, 10, 297, 13, 297,
	14, 297, 4711, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297,
	5, 297, 4721, 10, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297,
	3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4735, 10, 297,
	3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4743, 10, 297,
	3, 297, 5, 297, 4746, 10, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297,
	3, 297, 3, 297, 5, 297, 4755, 10, 297, 3, 297, 3, 297, 7, 297, 4759, 10,
	297, 12, 297, 14, 297, 4762, 11, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3,
	297, 3, 297, 3, 297, 5, 297, 4771, 10, 297, 3, 297, 3, 297, 3, 297, 3,
	297, 3, 297, 3, 297, 5, 297, 4779, 10, 297, 3, 297, 5, 297, 4782, 10, 297,
	3, 297, 5, 297, 4785, 10, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297,
	3, 297, 3, 297, 5, 297, 4794, 10, 297, 3, 297, 3, 297, 3, 297, 5, 297,
	4799, 10, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 7, 297, 4806, 10,
	297, 12, 297, 14, 297, 4809, 11, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4814,
	10, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4819, 10, 297, 3, 297, 5, 297,
	4822, 10, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4827, 10, 297, 3, 297, 3,
	297, 3, 297, 5, 297, 4832, 10, 297, 7, 297, 4834, 10, 297, 12, 297, 14,
	297, 4837, 11, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4842, 10, 297, 3, 297,
	3, 297, 3, 297, 3, 297, 5, 297, 4848, 10, 297, 3, 297, 3, 297, 3, 297,
	3, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4857, 10, 297, 3, 297, 3, 297,
	3, 297, 5, 297, 4862, 10, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297,
	3, 297, 5, 297, 4870, 10, 297, 3, 297, 3, 297, 5, 297, 4874, 10, 297, 3,
	297, 3, 297, 3, 297, 5, 297, 4879, 10, 297, 3, 297, 3, 297, 3, 297, 3,
	297, 5, 297, 4885, 10, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 5,
	297, 4892, 10, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4897, 10, 297, 3, 297,
	3, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4904, 10, 297, 3, 297, 3, 297,
	5, 297, 4908, 10, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4913, 10, 297, 3,
	297, 3, 297, 3, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4921, 10, 297, 3,
	297, 5, 297, 4924, 10, 297, 3, 297, 5, 297, 4927, 10, 297, 3, 297, 5, 297,
	4930, 10, 297, 3, 297, 3, 297, 5, 297, 4934, 10, 297, 3, 297, 3, 297, 3,
	297, 5, 297, 4939, 10, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4944, 10, 297,
	3, 297, 3, 297, 5, 297, 4948, 10, 297, 3, 297, 3, 297, 3, 297, 3, 297,
	3, 297, 5, 297, 4955, 10, 297, 3, 297, 3, 297, 3, 297, 5, 297, 4960, 10,
	297, 5, 297, 4962, 10, 297, 3, 298, 3, 298, 3, 299, 3, 299, 3, 300, 3,
	300, 3, 301, 3, 301, 3, 301, 5, 301, 4973, 10, 301, 3, 301, 3, 301, 5,
	301, 4977, 10, 301, 5, 301, 4979, 10, 301, 3, 301, 3, 301, 3, 302, 3, 302,
	3, 302, 3, 302, 3, 302, 3, 302, 3, 302, 5, 302, 4990, 10, 302, 3, 303,
	3, 303, 3, 304, 3, 304, 3, 304, 3, 304, 3, 304, 3, 304, 3, 304, 5, 304,
	5001, 10, 304, 3, 305, 3, 305, 3, 305, 3, 305, 3, 305, 7, 305, 5008, 10,
	305, 12, 305, 14, 305, 5011, 11, 305, 5, 305, 5013, 10, 305, 3, 306, 3,
	306, 5, 306, 5017, 10, 306, 3, 306, 5, 306, 5020, 10, 306, 3, 306, 3, 306,
	5, 306, 5024, 10, 306, 3, 307, 3, 307, 3, 307, 3, 307, 3, 308, 3, 308,
	3, 308, 3, 308, 3, 308, 3, 308, 3, 308, 5, 308, 5037, 10, 308, 3, 309,
	3, 309, 3, 309, 5, 309, 5042, 10, 309, 3, 309, 3, 309, 3, 309, 3, 309,
	7, 309, 5048, 10, 309, 12, 309, 14, 309, 5051, 11, 309, 3, 309, 3, 309,
	3, 309, 3, 309, 5, 309, 5057, 10, 309, 3, 309, 3, 309, 5, 309, 5061, 10,
	309, 3, 310, 3, 310, 3, 310, 5, 310, 5066, 10, 310, 3, 310, 3, 310, 5,
	310, 5070, 10, 310, 3, 310, 3, 310, 3, 310, 5, 310, 5075, 10, 310, 3, 311,
	3, 311, 3, 311, 5, 311, 5080, 10, 311, 3, 311, 5, 311, 5083, 10, 311, 3,
	311, 3, 311, 3, 311, 7, 311, 5088, 10, 311, 12, 311, 14, 311, 5091, 11,
	311, 3, 311, 3, 311, 3, 312, 3, 312, 3, 312, 3, 312, 3, 312, 5, 312, 5100,
	10, 312, 3, 312, 3, 312, 3, 312, 3, 312, 7, 312, 5106, 10, 312, 12, 312,
	14, 312, 5109, 11, 312, 3, 312, 5, 312, 5112, 10, 312, 3, 312, 3, 312,
	3, 313, 3, 313, 3, 313, 3, 313, 3, 313, 3, 313, 5, 313, 5122, 10, 313,
	3, 313, 5, 313, 5125, 10, 313, 5, 313, 5127, 10, 313, 3, 314, 3, 314, 3,
	314, 3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 5, 315, 5137, 10, 315, 5,
	315, 5139, 10, 315, 3, 316, 3, 316, 3, 316, 3, 316, 5, 316, 5145, 10, 316,
	3, 317, 3, 317, 3, 317, 3, 317, 5, 317, 5151, 10, 317, 5, 317, 5153, 10,
	317, 3, 318, 3, 318, 3, 318, 3, 319, 3, 319, 3, 319, 3, 320, 3, 320, 3,
	320, 3, 320, 3, 320, 3, 320, 5, 320, 5167, 10, 320, 5, 320, 5169, 10, 320,
	3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 5, 321,
	5179, 10, 321, 3, 322, 3, 322, 3, 322, 3, 322, 3, 322, 3, 322, 3, 322,
	5, 322, 5188, 10, 322, 3, 323, 3, 323, 3, 323, 3, 323, 3, 323, 3, 323,
	3, 323, 5, 323, 5197, 10, 323, 3, 324, 3, 324, 5, 324, 5201, 10, 324, 3,
	324, 3, 324, 5, 324, 5205, 10, 324, 3, 324, 3, 324, 3, 325, 5, 325, 5210,
	10, 325, 3, 325, 3, 325, 5, 325, 5214, 10, 325, 3, 325, 5, 325, 5217, 10,
	325, 3, 326, 3, 326, 5, 326, 5221, 10, 326, 3, 327, 3, 327, 3, 327, 3,
	327, 3, 327, 5, 327, 5228, 10, 327, 3, 328, 3, 328, 5, 328, 5232, 10, 328,
	3, 328, 3, 328, 3, 328, 3, 328, 7, 328, 5238, 10, 328, 12, 328, 14, 328,
	5241, 11, 328, 3, 329, 3, 329, 5, 329, 5245, 10, 329, 3, 330, 3, 330, 3,
	331, 3, 331, 3, 332, 3, 332, 3, 333, 3, 333, 3, 334, 3, 334, 3, 335, 3,
	335, 3, 336, 3, 336, 3, 336, 7, 336, 5262, 10, 336, 12, 336, 14, 336, 5265,
	11, 336, 3, 336, 3, 336, 5, 336, 5269, 10, 336, 3, 337, 3, 337, 3, 338,
	3, 338, 3, 338, 5, 338, 5276, 10, 338, 3, 339, 3, 339, 3, 340, 3, 340,
	3, 341, 3, 341, 3, 342, 3, 342, 3, 342, 7, 342, 5287, 10, 342, 12, 342,
	14, 342, 5290, 11, 342, 3, 343, 3, 343, 3, 344, 3, 344, 3, 344, 7, 344,
	5297, 10, 344, 12, 344, 14, 344, 5300, 11, 344, 3, 344, 3, 344, 5, 344,
	5304, 10, 344, 3, 345, 3, 345, 3, 346, 3, 346, 3, 346, 7, 346, 5311, 10,
	346, 12, 346, 14, 346, 5314, 11, 346, 3, 347, 3, 347, 3, 347, 7, 347, 5319,
	10, 347, 12, 347, 14, 347, 5322, 11, 347, 3, 348, 3, 348, 3, 348, 7, 348,
	5327, 10, 348, 12, 348, 14, 348, 5330, 11, 348, 3, 349, 3, 349, 3, 349,
	5, 349, 5335, 10, 349, 3, 350, 3, 350, 3, 350, 5, 350, 5340, 10, 350, 3,
	351, 3, 351, 3, 351, 5, 351, 5345, 10, 351, 3, 352, 3, 352, 5, 352, 5349,
	10, 352, 3, 352, 3, 352, 3, 352, 5, 352, 5354, 10, 352, 3, 352, 5, 352,
	5357, 10, 352, 3, 353, 3, 353, 3, 354, 3, 354, 5, 354, 5363, 10, 354, 3,
	355, 3, 355, 5, 355, 5367, 10, 355, 3, 356, 3, 356, 3, 356, 5, 356, 5372,
	10, 356, 3, 357, 3, 357, 3, 358, 3, 358, 3, 358, 7, 358, 5379, 10, 358,
	12, 358, 14, 358, 5382, 11, 358, 3, 359, 3, 359, 3, 359, 5, 359, 5387,
	10, 359, 3, 359, 3, 359, 3, 359, 5, 359, 5392, 10, 359, 3, 360, 3, 360,
	3, 360, 7, 360, 5397, 10, 360, 12, 360, 14, 360, 5400, 11, 360, 3, 361,
	3, 361, 3, 362, 3, 362, 3, 363, 3, 363, 3, 363, 3, 363, 3, 363, 3, 363,
	3, 363, 5, 363, 5413, 10, 363, 3, 364, 3, 364, 5, 364, 5417, 10, 364, 3,
	364, 3, 364, 7, 364, 5421, 10, 364, 12, 364, 14, 364, 5424, 11, 364, 3,
	364, 3, 364, 5, 364, 5428, 10, 364, 3, 365, 3, 365, 3, 365, 5, 365, 5433,
	10, 365, 5, 365, 5435, 10, 365, 3, 365, 3, 365, 3, 365, 5, 365, 5440, 10,
	365, 7, 365, 5442, 10, 365, 12, 365, 14, 365, 5445, 11, 365, 3, 365, 3,
	365, 5, 365, 5449, 10, 365, 3, 366, 3, 366, 3, 366, 3, 366, 3, 366, 5,
	366, 5456, 10, 366, 3, 366, 3, 366, 3, 366, 5, 366, 5461, 10, 366, 5, 366,
	5463, 10, 366, 5, 366, 5465, 10, 366, 3, 366, 3, 366, 3, 366, 3, 366, 3,
	366, 3, 366, 3, 366, 3, 366, 5, 366, 5475, 10, 366, 3, 366, 3, 366, 3,
	366, 5, 366, 5480, 10, 366, 7, 366, 5482, 10, 366, 12, 366, 14, 366, 5485,
	11, 366, 5, 366, 5487, 10, 366, 3, 366, 3, 366, 5, 366, 5491, 10, 366,
	3, 367, 3, 367, 3, 367, 3, 368, 3, 368, 3, 368, 3, 368, 5, 368, 5500, 10,
	368, 3, 368, 3, 368, 3, 369, 3, 369, 5, 369, 5506, 10, 369, 3, 369, 3,
	369, 5, 369, 5510, 10, 369, 5, 369, 5512, 10, 369, 3, 370, 3, 370, 5, 370,
	5516, 10, 370, 3, 370, 3, 370, 5, 370, 5520, 10, 370, 3, 370, 3, 370, 3,
	370, 3, 370, 3, 370, 5, 370, 5527, 10, 370, 3, 370, 3, 370, 3, 370, 3,
	370, 3, 370, 3, 370, 5, 370, 5535, 10, 370, 3, 370, 3, 370, 3, 370, 3,
	370, 3, 370, 3, 370, 5, 370, 5543, 10, 370, 5, 370, 5545, 10, 370, 3, 371,
	3, 371, 3, 371, 3, 371, 5, 371, 5551, 10, 371, 3, 371, 5, 371, 5554, 10,
	371, 3, 371, 3, 371, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3,
	372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3,
	372, 3, 372, 3, 372, 3, 372, 3, 372, 5, 372, 5578, 10, 372, 3, 372, 3,
	372, 3, 372, 3, 372, 3, 372, 5, 372, 5585, 10, 372, 3, 372, 3, 372, 3,
	372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3,
	372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3,
	372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3,
	372, 3, 372, 5, 372, 5618, 10, 372, 3, 373, 3, 373, 3, 373, 5, 373, 5623,
	10, 373, 3, 373, 5, 373, 5626, 10, 373, 3, 373, 3, 373, 3, 373, 5, 373,
	5631, 10, 373, 5, 373, 5633, 10, 373, 3, 373, 3, 373, 7, 373, 5637, 10,
	373, 12, 373, 14, 373, 5640, 11, 373, 3, 374, 3, 374, 3, 374, 7, 374, 5645,
	10, 374, 12, 374, 14, 374, 5648, 11, 374, 3, 375, 3, 375, 5, 375, 5652,
	10, 375, 3, 375, 3, 375, 3, 375, 7, 375, 5657, 10, 375, 12, 375, 14, 375,
	5660, 11, 375, 3, 375, 3, 375, 5, 375, 5664, 10, 375, 3, 375, 5, 375, 5667,
	10, 375, 3, 376, 3, 376, 5, 376, 5671, 10, 376, 3, 376, 3, 376, 3, 376,
	7, 376, 5676, 10, 376, 12, 376, 14, 376, 5679, 11, 376, 3, 377, 3, 377,
	3, 377, 5, 377, 5684, 10, 377, 3, 377, 3, 377, 3, 377, 3, 377, 5, 377,
	5690, 10, 377, 3, 377, 3, 377, 3, 377, 3, 377, 5, 377, 5696, 10, 377, 3,
	377, 3, 377, 3, 377, 3, 377, 5, 377, 5702, 10, 377, 3, 377, 3, 377, 3,
	377, 5, 377, 5707, 10, 377, 5, 377, 5709, 10, 377, 3, 377, 5, 377, 5712,
	10, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377,
	5, 377, 5722, 10, 377, 3, 377, 5, 377, 5725, 10, 377, 5, 377, 5727, 10,
	377, 5, 377, 5729, 10, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3,
	377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 5, 377, 5743, 10,
	377, 3, 378, 3, 378, 3, 379, 3, 379, 3, 379, 3, 380, 3, 380, 3, 381, 3,
	381, 5, 381, 5754, 10, 381, 3, 381, 3, 381, 3, 382, 3, 382, 5, 382, 5760,
	10, 382, 3, 383, 3, 383, 3, 383, 3, 383, 3, 384, 3, 384, 3, 385, 3, 385,
	3, 386, 3, 386, 3, 386, 2, 5, 540, 544, 554, 387, 2, 4, 6, 8, 10, 12, 14,
	16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
	52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86,
	88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118,
	120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148,
	150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178,
	180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208,
	210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238,
	240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268,
	270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298,
	300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328,
	330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358,
	360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388,
	390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418,
	420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448,
	450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478,
	480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508,
	510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538,
	540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568,
	570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598,
	600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628,
	630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656, 658,
	660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684, 686, 688,
	690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714, 716, 718,
	720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744, 746, 748,
	750, 752, 754, 756, 758, 760, 762, 764, 766, 768, 770, 2, 95, 4, 2, 15,
	15, 206, 206, 4, 2, 6, 6, 320, 320, 5, 2, 174, 174, 225, 225, 338, 338,
	4, 2, 58, 58, 296, 296, 5, 2, 36, 36, 304, 304, 401, 401, 4, 2, 116, 116,
	128, 128, 4, 2, 4, 4, 27, 27, 5, 2, 111, 111, 197, 197, 451, 451, 5, 2,
	262, 262, 288, 288, 307, 307, 4, 2, 160, 160, 456, 456, 4, 2, 36, 36, 401,
	401, 4, 2, 3, 3, 121, 121, 5, 2, 3, 3, 121, 121, 250, 250, 5, 2, 92, 92,
	295, 295, 402, 402, 4, 2, 237, 237, 296, 296, 4, 2, 241, 241, 409, 409,
	5, 2, 152, 152, 198, 198, 303, 303, 4, 2, 111, 111, 331, 331, 4, 2, 109,
	109, 181, 181, 4, 2, 447, 447, 539, 539, 5, 2, 107, 107, 211, 211, 343,
	343, 5, 2, 107, 107, 211, 211, 273, 273, 5, 2, 151, 151, 229, 229, 270,
	270, 4, 2, 13, 13, 336, 336, 4, 2, 177, 177, 235, 235, 4, 2, 90, 90, 110,
	110, 6, 2, 191, 191, 196, 196, 267, 267, 301, 301, 4, 2, 107, 107, 554,
	554, 3, 3, 563, 563, 3, 2, 563, 563, 3, 2, 356, 357, 4, 2, 290, 290, 476,
	476, 3, 2, 74, 75, 4, 2, 278, 278, 466, 466, 4, 2, 26, 26, 181, 181, 4,
	2, 39, 39, 112, 112, 5, 2, 8, 8, 118, 118, 446, 446, 4, 2, 87, 87, 255,
	255, 5, 2, 166, 166, 217, 217, 361, 361, 4, 2, 373, 373, 426, 426, 5, 2,
	373, 373, 399, 399, 426, 426, 4, 2, 140, 140, 182, 182, 4, 2, 88, 88, 363,
	363, 4, 2, 180, 180, 211, 211, 4, 2, 8, 8, 450, 450, 4, 2, 23, 23, 381,
	381, 4, 2, 16, 16, 113, 113, 4, 2, 153, 153, 214, 214, 4, 2, 8, 8, 153,
	153, 4, 2, 421, 421, 424, 424, 4, 2, 241, 241, 413, 413, 3, 2, 220, 223,
	3, 2, 560, 561, 4, 2, 548, 548, 552, 552, 3, 2, 549, 550, 4, 2, 106, 106,
	184, 184, 6, 2, 8, 8, 12, 12, 143, 143, 400, 400, 5, 2, 38, 38, 216, 216,
	435, 435, 4, 2, 8, 8, 118, 118, 4, 2, 49, 49, 479, 479, 4, 2, 118, 118,
	446, 446, 3, 2, 314, 317, 4, 2, 46, 46, 66, 66, 4, 2, 154, 154, 215, 215,
	4, 2, 52, 52, 258, 258, 4, 2, 480, 480, 483, 483, 4, 2, 132, 132, 269,
	269, 4, 2, 136, 136, 253, 253, 4, 2, 77, 77, 119, 119, 4, 2, 176, 176,
	390, 390, 7, 2, 509, 511, 513, 518, 520, 521, 523, 523, 527, 530, 3, 2,
	502, 508, 3, 2, 496, 501, 4, 2, 338, 338, 366, 366, 4, 2, 157, 157, 328,
	328, 4, 2, 276, 276, 371, 371, 3, 2, 133, 134, 4, 2, 299, 299, 403, 403,
	5, 2, 148, 148, 417, 417, 467, 467, 4, 2, 64, 64, 362, 362, 5, 2, 64, 64,
	273, 273, 362, 362, 4, 2, 308, 308, 414, 414, 4, 2, 180, 180, 352, 352,
	3, 2, 318, 319, 4, 2, 97, 97, 492, 492, 4, 2, 251, 251, 375, 375, 4, 2,
	43, 43, 51, 51, 8, 2, 97, 97, 178, 178, 245, 245, 251, 251, 375, 375, 492,
	492, 3, 2, 539, 540, 4, 2, 534, 534, 541, 541, 88, 2, 3, 7, 10, 10, 14,
	14, 17, 24, 26, 27, 30, 38, 41, 41, 43, 43, 45, 47, 49, 52, 54, 58, 60,
	60, 62, 68, 73, 84, 87, 88, 90, 95, 97, 103, 105, 106, 108, 111, 114, 117,
	119, 120, 122, 124, 127, 129, 132, 140, 142, 142, 144, 148, 152, 154, 156,
	160, 166, 167, 172, 172, 174, 174, 176, 176, 178, 178, 180, 186, 188, 190,
	194, 196, 198, 200, 202, 203, 205, 205, 207, 222, 224, 224, 226, 227, 230,
	234, 236, 242, 245, 248, 250, 262, 264, 264, 267, 269, 273, 274, 276, 276,
	280, 285, 287, 288, 290, 290, 292, 292, 295, 295, 297, 297, 299, 310, 320,
	320, 323, 330, 337, 342, 344, 344, 346, 359, 361, 373, 375, 377, 379, 379,
	381, 388, 390, 395, 397, 404, 406, 410, 412, 418, 422, 422, 425, 433, 435,
	439, 441, 444, 447, 447, 449, 450, 452, 454, 456, 456, 458, 469, 472, 473,
	475, 511, 513, 518, 520, 521, 523, 524, 526, 530, 574, 574, 5, 2, 54, 54,
	512, 512, 524, 526, 7, 2, 84, 84, 509, 509, 519, 519, 522, 522, 527, 527,
	2, 6472, 2, 781, 3, 2, 2, 2, 4, 816, 3, 2, 2, 2, 6, 818, 3, 2, 2, 2, 8,
	823, 3, 2, 2, 2, 10, 842, 3, 2, 2, 2, 12, 897, 3, 2, 2, 2, 14, 901, 3,
	2, 2, 2, 16, 925, 3, 2, 2, 2, 18, 929, 3, 2, 2, 2, 20, 941, 3, 2, 2, 2,
	22, 955, 3, 2, 2, 2, 24, 968, 3, 2, 2, 2, 26, 990, 3, 2, 2, 2, 28, 1018,
	3, 2, 2, 2, 30, 1056, 3, 2, 2, 2, 32, 1058, 3, 2, 2, 2, 34, 1075, 3, 2,
	2, 2, 36, 1109, 3, 2, 2, 2, 38, 1111, 3, 2, 2, 2, 40, 1116, 3, 2, 2, 2,
	42, 1135, 3, 2, 2, 2, 44, 1185, 3, 2, 2, 2, 46, 1217, 3, 2, 2, 2, 48, 1257,
	3, 2, 2, 2, 50, 1262, 3, 2, 2, 2, 52, 1287, 3, 2, 2, 2, 54, 1311, 3, 2,
	2, 2, 56, 1320, 3, 2, 2, 2, 58, 1329, 3, 2, 2, 2, 60, 1338, 3, 2, 2, 2,
	62, 1342, 3, 2, 2, 2, 64, 1347, 3, 2, 2, 2, 66, 1371, 3, 2, 2, 2, 68, 1373,
	3, 2, 2, 2, 70, 1377, 3, 2, 2, 2, 72, 1429, 3, 2, 2, 2, 74, 1457, 3, 2,
	2, 2, 76, 1459, 3, 2, 2, 2, 78, 1473, 3, 2, 2, 2, 80, 1485, 3, 2, 2, 2,
	82, 1490, 3, 2, 2, 2, 84, 1496, 3, 2, 2, 2, 86, 1499, 3, 2, 2, 2, 88, 1510,
	3, 2, 2, 2, 90, 1525, 3, 2, 2, 2, 92, 1542, 3, 2, 2, 2, 94, 1559, 3, 2,
	2, 2, 96, 1567, 3, 2, 2, 2, 98, 1572, 3, 2, 2, 2, 100, 1588, 3, 2, 2, 2,
	102, 1592, 3, 2, 2, 2, 104, 1616, 3, 2, 2, 2, 106, 1619, 3, 2, 2, 2, 108,
	1625, 3, 2, 2, 2, 110, 1637, 3, 2, 2, 2, 112, 1646, 3, 2, 2, 2, 114, 1674,
	3, 2, 2, 2, 116, 1680, 3, 2, 2, 2, 118, 1683, 3, 2, 2, 2, 120, 1690, 3,
	2, 2, 2, 122, 1698, 3, 2, 2, 2, 124, 1710, 3, 2, 2, 2, 126, 1712, 3, 2,
	2, 2, 128, 1716, 3, 2, 2, 2, 130, 1722, 3, 2, 2, 2, 132, 1750, 3, 2, 2,
	2, 134, 1784, 3, 2, 2, 2, 136, 1832, 3, 2, 2, 2, 138, 1842, 3, 2, 2, 2,
	140, 1844, 3, 2, 2, 2, 142, 1849, 3, 2, 2, 2, 144, 1863, 3, 2, 2, 2, 146,
	1865, 3, 2, 2, 2, 148, 1870, 3, 2, 2, 2, 150, 1886, 3, 2, 2, 2, 152, 1919,
	3, 2, 2, 2, 154, 1954, 3, 2, 2, 2, 156, 1958, 3, 2, 2, 2, 158, 1973, 3,
	2, 2, 2, 160, 1975, 3, 2, 2, 2, 162, 1978, 3, 2, 2, 2, 164, 1983, 3, 2,
	2, 2, 166, 1993, 3, 2, 2, 2, 168, 2021, 3, 2, 2, 2, 170, 2023, 3, 2, 2,
	2, 172, 2027, 3, 2, 2, 2, 174, 2051, 3, 2, 2, 2, 176, 2059, 3, 2, 2, 2,
	178, 2064, 3, 2, 2, 2, 180, 2162, 3, 2, 2, 2, 182, 2165, 3, 2, 2, 2, 184,
	2170, 3, 2, 2, 2, 186, 2221, 3, 2, 2, 2, 188, 2223, 3, 2, 2, 2, 190, 2230,
	3, 2, 2, 2, 192, 2239, 3, 2, 2, 2, 194, 2250, 3, 2, 2, 2, 196, 2257, 3,
	2, 2, 2, 198, 2261, 3, 2, 2, 2, 200, 2265, 3, 2, 2, 2, 202, 2269, 3, 2,
	2, 2, 204, 2285, 3, 2, 2, 2, 206, 2298, 3, 2, 2, 2, 208, 2305, 3, 2, 2,
	2, 210, 2317, 3, 2, 2, 2, 212, 2330, 3, 2, 2, 2, 214, 2335, 3, 2, 2, 2,
	216, 2338, 3, 2, 2, 2, 218, 2342, 3, 2, 2, 2, 220, 2347, 3, 2, 2, 2, 222,
	2351, 3, 2, 2, 2, 224, 2368, 3, 2, 2, 2, 226, 2374, 3, 2, 2, 2, 228, 2384,
	3, 2, 2, 2, 230, 2397, 3, 2, 2, 2, 232, 2410, 3, 2, 2, 2, 234, 2412, 3,
	2, 2, 2, 236, 2426, 3, 2, 2, 2, 238, 2443, 3, 2, 2, 2, 240, 2468, 3, 2,
	2, 2, 242, 2478, 3, 2, 2, 2, 244, 2482, 3, 2, 2, 2, 246, 2517, 3, 2, 2,
	2, 248, 2529, 3, 2, 2, 2, 250, 2540, 3, 2, 2, 2, 252, 2546, 3, 2, 2, 2,
	254, 2557, 3, 2, 2, 2, 256, 2569, 3, 2, 2, 2, 258, 2577, 3, 2, 2, 2, 260,
	2592, 3, 2, 2, 2, 262, 2596, 3, 2, 2, 2, 264, 2629, 3, 2, 2, 2, 266, 2632,
	3, 2, 2, 2, 268, 2638, 3, 2, 2, 2, 270, 2643, 3, 2, 2, 2, 272, 2651, 3,
	2, 2, 2, 274, 2659, 3, 2, 2, 2, 276, 2662, 3, 2, 2, 2, 278, 2678, 3, 2,
	2, 2, 280, 2683, 3, 2, 2, 2, 282, 2687, 3, 2, 2, 2, 284, 2727, 3, 2, 2,
	2, 286, 2729, 3, 2, 2, 2, 288, 2751, 3, 2, 2, 2, 290, 2753, 3, 2, 2, 2,
	292, 2758, 3, 2, 2, 2, 294, 2760, 3, 2, 2, 2, 296, 2762, 3, 2, 2, 2, 298,
	2764, 3, 2, 2, 2, 300, 2768, 3, 2, 2, 2, 302, 2773, 3, 2, 2, 2, 304, 2779,
	3, 2, 2, 2, 306, 2785, 3, 2, 2, 2, 308, 2799, 3, 2, 2, 2, 310, 2819, 3,
	2, 2, 2, 312, 2824, 3, 2, 2, 2, 314, 2837, 3, 2, 2, 2, 316, 2839, 3, 2,
	2, 2, 318, 2853, 3, 2, 2, 2, 320, 2863, 3, 2, 2, 2, 322, 2869, 3, 2, 2,
	2, 324, 2871, 3, 2, 2, 2, 326, 2874, 3, 2, 2, 2, 328, 2883, 3, 2, 2, 2,
	330, 2907, 3, 2, 2, 2, 332, 2922, 3, 2, 2, 2, 334, 2924, 3, 2, 2, 2, 336,
	2945, 3, 2, 2, 2, 338, 2960, 3, 2, 2, 2, 340, 2982, 3, 2, 2, 2, 342, 2989,
	3, 2, 2, 2, 344, 3002, 3, 2, 2, 2, 346, 3005, 3, 2, 2, 2, 348, 3026, 3,
	2, 2, 2, 350, 3036, 3, 2, 2, 2, 352, 3045, 3, 2, 2, 2, 354, 3072, 3, 2,
	2, 2, 356, 3115, 3, 2, 2, 2, 358, 3131, 3, 2, 2, 2, 360, 3143, 3, 2, 2,
	2, 362, 3151, 3, 2, 2, 2, 364, 3155, 3, 2, 2, 2, 366, 3186, 3, 2, 2, 2,
	368, 3190, 3, 2, 2, 2, 370, 3203, 3, 2, 2, 2, 372, 3205, 3, 2, 2, 2, 374,
	3213, 3, 2, 2, 2, 376, 3224, 3, 2, 2, 2, 378, 3257, 3, 2, 2, 2, 380, 3260,
	3, 2, 2, 2, 382, 3281, 3, 2, 2, 2, 384, 3284, 3, 2, 2, 2, 386, 3296, 3,
	2, 2, 2, 388, 3300, 3, 2, 2, 2, 390, 3319, 3, 2, 2, 2, 392, 3321, 3, 2,
	2, 2, 394, 3338, 3, 2, 2, 2, 396, 3345, 3, 2, 2, 2, 398, 3360, 3, 2, 2,
	2, 400, 3383, 3, 2, 2, 2, 402, 3393, 3, 2, 2, 2, 404, 3395, 3, 2, 2, 2,
	406, 3419, 3, 2, 2, 2, 408, 3443, 3, 2, 2, 2, 410, 3479, 3, 2, 2, 2, 412,
	3481, 3, 2, 2, 2, 414, 3511, 3, 2, 2, 2, 416, 3516, 3, 2, 2, 2, 418, 3518,
	3, 2, 2, 2, 420, 3530, 3, 2, 2, 2, 422, 3550, 3, 2, 2, 2, 424, 3552, 3,
	2, 2, 2, 426, 3555, 3, 2, 2, 2, 428, 3581, 3, 2, 2, 2, 430, 3583, 3, 2,
	2, 2, 432, 3587, 3, 2, 2, 2, 434, 3602, 3, 2, 2, 2, 436, 3614, 3, 2, 2,
	2, 438, 3622, 3, 2, 2, 2, 440, 3626, 3, 2, 2, 2, 442, 3639, 3, 2, 2, 2,
	444, 3645, 3, 2, 2, 2, 446, 3660, 3, 2, 2, 2, 448, 3680, 3, 2, 2, 2, 450,
	3689, 3, 2, 2, 2, 452, 3691, 3, 2, 2, 2, 454, 3698, 3, 2, 2, 2, 456, 3703,
	3, 2, 2, 2, 458, 3716, 3, 2, 2, 2, 460, 3724, 3, 2, 2, 2, 462, 3732, 3,
	2, 2, 2, 464, 3746, 3, 2, 2, 2, 466, 3748, 3, 2, 2, 2, 468, 3760, 3, 2,
	2, 2, 470, 3795, 3, 2, 2, 2, 472, 3797, 3, 2, 2, 2, 474, 3811, 3, 2, 2,
	2, 476, 3816, 3, 2, 2, 2, 478, 3834, 3, 2, 2, 2, 480, 3838, 3, 2, 2, 2,
	482, 3846, 3, 2, 2, 2, 484, 3856, 3, 2, 2, 2, 486, 3864, 3, 2, 2, 2, 488,
	3870, 3, 2, 2, 2, 490, 3885, 3, 2, 2, 2, 492, 3892, 3, 2, 2, 2, 494, 3917,
	3, 2, 2, 2, 496, 3936, 3, 2, 2, 2, 498, 3940, 3, 2, 2, 2, 500, 3943, 3,
	2, 2, 2, 502, 3975, 3, 2, 2, 2, 504, 3980, 3, 2, 2, 2, 506, 3999, 3, 2,
	2, 2, 508, 4001, 3, 2, 2, 2, 510, 4017, 3, 2, 2, 2, 512, 4025, 3, 2, 2,
	2, 514, 4030, 3, 2, 2, 2, 516, 4034, 3, 2, 2, 2, 518, 4045, 3, 2, 2, 2,
	520, 4048, 3, 2, 2, 2, 522, 4066, 3, 2, 2, 2, 524, 4068, 3, 2, 2, 2, 526,
	4083, 3, 2, 2, 2, 528, 4094, 3, 2, 2, 2, 530, 4108, 3, 2, 2, 2, 532, 4113,
	3, 2, 2, 2, 534, 4115, 3, 2, 2, 2, 536, 4125, 3, 2, 2, 2, 538, 4127, 3,
	2, 2, 2, 540, 4172, 3, 2, 2, 2, 542, 4185, 3, 2, 2, 2, 544, 4193, 3, 2,
	2, 2, 546, 4205, 3, 2, 2, 2, 548, 4237, 3, 2, 2, 2, 550, 4257, 3, 2, 2,
	2, 552, 4259, 3, 2, 2, 2, 554, 4263, 3, 2, 2, 2, 556, 4314, 3, 2, 2, 2,
	558, 4316, 3, 2, 2, 2, 560, 4346, 3, 2, 2, 2, 562, 4348, 3, 2, 2, 2, 564,
	4369, 3, 2, 2, 2, 566, 4408, 3, 2, 2, 2, 568, 4412, 3, 2, 2, 2, 570, 4415,
	3, 2, 2, 2, 572, 4434, 3, 2, 2, 2, 574, 4442, 3, 2, 2, 2, 576, 4460, 3,
	2, 2, 2, 578, 4467, 3, 2, 2, 2, 580, 4491, 3, 2, 2, 2, 582, 4493, 3, 2,
	2, 2, 584, 4574, 3, 2, 2, 2, 586, 4579, 3, 2, 2, 2, 588, 4581, 3, 2, 2,
	2, 590, 4644, 3, 2, 2, 2, 592, 4961, 3, 2, 2, 2, 594, 4963, 3, 2, 2, 2,
	596, 4965, 3, 2, 2, 2, 598, 4967, 3, 2, 2, 2, 600, 4969, 3, 2, 2, 2, 602,
	4982, 3, 2, 2, 2, 604, 4991, 3, 2, 2, 2, 606, 5000, 3, 2, 2, 2, 608, 5002,
	3, 2, 2, 2, 610, 5019, 3, 2, 2, 2, 612, 5025, 3, 2, 2, 2, 614, 5036, 3,
	2, 2, 2, 616, 5038, 3, 2, 2, 2, 618, 5062, 3, 2, 2, 2, 620, 5076, 3, 2,
	2, 2, 622, 5094, 3, 2, 2, 2, 624, 5115, 3, 2, 2, 2, 626, 5128, 3, 2, 2,
	2, 628, 5131, 3, 2, 2, 2, 630, 5140, 3, 2, 2, 2, 632, 5146, 3, 2, 2, 2,
	634, 5154, 3, 2, 2, 2, 636, 5157, 3, 2, 2, 2, 638, 5168, 3, 2, 2, 2, 640,
	5178, 3, 2, 2, 2, 642, 5180, 3, 2, 2, 2, 644, 5189, 3, 2, 2, 2, 646, 5198,
	3, 2, 2, 2, 648, 5216, 3, 2, 2, 2, 650, 5220, 3, 2, 2, 2, 652, 5222, 3,
	2, 2, 2, 654, 5231, 3, 2, 2, 2, 656, 5244, 3, 2, 2, 2, 658, 5246, 3, 2,
	2, 2, 660, 5248, 3, 2, 2, 2, 662, 5250, 3, 2, 2, 2, 664, 5252, 3, 2, 2,
	2, 666, 5254, 3, 2, 2, 2, 668, 5256, 3, 2, 2, 2, 670, 5258, 3, 2, 2, 2,
	672, 5270, 3, 2, 2, 2, 674, 5272, 3, 2, 2, 2, 676, 5277, 3, 2, 2, 2, 678,
	5279, 3, 2, 2, 2, 680, 5281, 3, 2, 2, 2, 682, 5283, 3, 2, 2, 2, 684, 5291,
	3, 2, 2, 2, 686, 5293, 3, 2, 2, 2, 688, 5305, 3, 2, 2, 2, 690, 5307, 3,
	2, 2, 2, 692, 5315, 3, 2, 2, 2, 694, 5323, 3, 2, 2, 2, 696, 5331, 3, 2,
	2, 2, 698, 5336, 3, 2, 2, 2, 700, 5341, 3, 2, 2, 2, 702, 5356, 3, 2, 2,
	2, 704, 5358, 3, 2, 2, 2, 706, 5362, 3, 2, 2, 2, 708, 5366, 3, 2, 2, 2,
	710, 5368, 3, 2, 2, 2, 712, 5373, 3, 2, 2, 2, 714, 5375, 3, 2, 2, 2, 716,
	5383, 3, 2, 2, 2, 718, 5393, 3, 2, 2, 2, 720, 5401, 3, 2, 2, 2, 722, 5403,
	3, 2, 2, 2, 724, 5405, 3, 2, 2, 2, 726, 5414, 3, 2, 2, 2, 728, 5429, 3,
	2, 2, 2, 730, 5450, 3, 2, 2, 2, 732, 5492, 3, 2, 2, 2, 734, 5499, 3, 2,
	2, 2, 736, 5511, 3, 2, 2, 2, 738, 5544, 3, 2, 2, 2, 740, 5546, 3, 2, 2,
	2, 742, 5617, 3, 2, 2, 2, 744, 5622, 3, 2, 2, 2, 746, 5641, 3, 2, 2, 2,
	748, 5651, 3, 2, 2, 2, 750, 5670, 3, 2, 2, 2, 752, 5742, 3, 2, 2, 2, 754,
	5744, 3, 2, 2, 2, 756, 5746, 3, 2, 2, 2, 758, 5749, 3, 2, 2, 2, 760, 5753,
	3, 2, 2, 2, 762, 5759, 3, 2, 2, 2, 764, 5761, 3, 2, 2, 2, 766, 5765, 3,
	2, 2, 2, 768, 5767, 3, 2, 2, 2, 770, 5769, 3, 2, 2, 2, 772, 775, 5, 4,
	3, 2, 773, 775, 5, 640, 321, 2, 774, 772, 3, 2, 2, 2, 774, 773, 3, 2, 2,
	2, 775, 777, 3, 2, 2, 2, 776, 778, 7, 563, 2, 2, 777, 776, 3, 2, 2, 2,
	777, 778, 3, 2, 2, 2, 778, 780, 3, 2, 2, 2, 779, 774, 3, 2, 2, 2, 780,
	783, 3, 2, 2, 2, 781, 779, 3, 2, 2, 2, 781, 782, 3, 2, 2, 2, 782, 784,
	3, 2, 2, 2, 783, 781, 3, 2, 2, 2, 784, 785, 7, 2, 2, 3, 785, 3, 3, 2, 2,
	2, 786, 817, 5, 8, 5, 2, 787, 817, 5, 24, 13, 2, 788, 817, 5, 40, 21, 2,
	789, 817, 5, 164, 83, 2, 790, 817, 5, 50, 26, 2, 791, 817, 5, 88, 45, 2,
	792, 817, 5, 190, 96, 2, 793, 817, 5, 174, 88, 2, 794, 817, 5, 10, 6, 2,
	795, 817, 5, 46, 24, 2, 796, 817, 5, 26, 14, 2, 797, 817, 5, 28, 15, 2,
	798, 817, 5, 172, 87, 2, 799, 817, 5, 178, 90, 2, 800, 817, 5, 166, 84,
	2, 801, 817, 5, 52, 27, 2, 802, 817, 5, 108, 55, 2, 803, 817, 5, 186, 94,
	2, 804, 817, 5, 6, 4, 2, 805, 817, 5, 22, 12, 2, 806, 817, 5, 38, 20, 2,
	807, 817, 5, 162, 82, 2, 808, 817, 5, 48, 25, 2, 809, 817, 5, 86, 44, 2,
	810, 817, 5, 320, 161, 2, 811, 817, 5, 182, 92, 2, 812, 817, 5, 176, 89,
	2, 813, 817, 5, 184, 93, 2, 814, 817, 5, 188, 95, 2, 815, 817, 5, 212,
	107, 2, 816, 786, 3, 2, 2, 2, 816, 787, 3, 2, 2, 2, 816, 788, 3, 2, 2,
	2, 816, 789, 3, 2, 2, 2, 816, 790, 3, 2, 2, 2, 816, 791, 3, 2, 2, 2, 816,
	792, 3, 2, 2, 2, 816, 793, 3, 2, 2, 2, 816, 794, 3, 2, 2, 2, 816, 795,
	3, 2, 2, 2, 816, 796, 3, 2, 2, 2, 816, 797, 3, 2, 2, 2, 816, 798, 3, 2,
	2, 2, 816, 799, 3, 2, 2, 2, 816, 800, 3, 2, 2, 2, 816, 801, 3, 2, 2, 2,
	816, 802, 3, 2, 2, 2, 816, 803, 3, 2, 2, 2, 816, 804, 3, 2, 2, 2, 816,
	805, 3, 2, 2, 2, 816, 806, 3, 2, 2, 2, 816, 807, 3, 2, 2, 2, 816, 808,
	3, 2, 2, 2, 816, 809, 3, 2, 2, 2, 816, 810, 3, 2, 2, 2, 816, 811, 3, 2,
	2, 2, 816, 812, 3, 2, 2, 2, 816, 813, 3, 2, 2, 2, 816, 814, 3, 2, 2, 2,
	816, 815, 3, 2, 2, 2, 817, 5, 3, 2, 2, 2, 818, 819, 7, 121, 2, 2, 819,
	820, 7, 167, 2, 2, 820, 821, 5, 696, 349, 2, 821, 822, 7, 563, 2, 2, 822,
	7, 3, 2, 2, 2, 823, 824, 7, 9, 2, 2, 824, 825, 7, 167, 2, 2, 825, 826,
	5, 696, 349, 2, 826, 828, 7, 67, 2, 2, 827, 829, 7, 101, 2, 2, 828, 827,
	3, 2, 2, 2, 828, 829, 3, 2, 2, 2, 829, 833, 3, 2, 2, 2, 830, 832, 5, 216,
	109, 2, 831, 830, 3, 2, 2, 2, 832, 835, 3, 2, 2, 2, 833, 831, 3, 2, 2,
	2, 833, 834, 3, 2, 2, 2, 834, 838, 3, 2, 2, 2, 835, 833, 3, 2, 2, 2, 836,
	837, 7, 358, 2, 2, 837, 839, 7, 388, 2, 2, 838, 836, 3, 2, 2, 2, 838, 839,
	3, 2, 2, 2, 839, 840, 3, 2, 2, 2, 840, 841, 7, 563, 2, 2, 841, 9, 3, 2,
	2, 2, 842, 845, 7, 85, 2, 2, 843, 844, 7, 298, 2, 2, 844, 846, 7, 351,
	2, 2, 845, 843, 3, 2, 2, 2, 845, 846, 3, 2, 2, 2, 846, 847, 3, 2, 2, 2,
	847, 848, 7, 167, 2, 2, 848, 860, 5, 696, 349, 2, 849, 850, 7, 545, 2,
	2, 850, 855, 5, 228, 115, 2, 851, 852, 7, 551, 2, 2, 852, 854, 5, 228,
	115, 2, 853, 851, 3, 2, 2, 2, 854, 857, 3, 2, 2, 2, 855, 853, 3, 2, 2,
	2, 855, 856, 3, 2, 2, 2, 856, 858, 3, 2, 2, 2, 857, 855, 3, 2, 2, 2, 858,
	859, 7, 546, 2, 2, 859, 861, 3, 2, 2, 2, 860, 849, 3, 2, 2, 2, 860, 861,
	3, 2, 2, 2, 861, 862, 3, 2, 2, 2, 862, 863, 7, 357, 2, 2, 863, 870, 5,
	736, 369, 2, 864, 869, 5, 214, 108, 2, 865, 869, 5, 12, 7, 2, 866, 869,
	5, 16, 9, 2, 867, 869, 7, 114, 2, 2, 868, 864, 3, 2, 2, 2, 868, 865, 3,
	2, 2, 2, 868, 866, 3, 2, 2, 2, 868, 867, 3, 2, 2, 2, 869, 872, 3, 2, 2,
	2, 870, 868, 3, 2, 2, 2, 870, 871, 3, 2, 2, 2, 871, 893, 3, 2, 2, 2, 872,
	870, 3, 2, 2, 2, 873, 875, 7, 320, 2, 2, 874, 873, 3, 2, 2, 2, 874, 875,
	3, 2, 2, 2, 875, 876, 3, 2, 2, 2, 876, 888, 9, 2, 2, 2, 877, 879, 7, 104,
	2, 2, 878, 877, 3, 2, 2, 2, 878, 879, 3, 2, 2, 2, 879, 883, 3, 2, 2, 2,
	880, 882, 5, 232, 117, 2, 881, 880, 3, 2, 2, 2, 882, 885, 3, 2, 2, 2, 883,
	881, 3, 2, 2, 2, 883, 884, 3, 2, 2, 2, 884, 886, 3, 2, 2, 2, 885, 883,
	3, 2, 2, 2, 886, 889, 5, 306, 154, 2, 887, 889, 5, 218, 110, 2, 888, 878,
	3, 2, 2, 2, 888, 887, 3, 2, 2, 2, 889, 894, 3, 2, 2, 2, 890, 891, 9, 3,
	2, 2, 891, 892, 7, 455, 2, 2, 892, 894, 5, 674, 338, 2, 893, 874, 3, 2,
	2, 2, 893, 890, 3, 2, 2, 2, 894, 895, 3, 2, 2, 2, 895, 896, 7, 563, 2,
	2, 896, 11, 3, 2, 2, 2, 897, 899, 7, 305, 2, 2, 898, 900, 5, 14, 8, 2,
	899, 898, 3, 2, 2, 2, 899, 900, 3, 2, 2, 2, 900, 13, 3, 2, 2, 2, 901, 902,
	7, 545, 2, 2, 902, 903, 7, 308, 2, 2, 903, 904, 5, 536, 269, 2, 904, 918,
	7, 42, 2, 2, 905, 919, 7, 12, 2, 2, 906, 907, 9, 4, 2, 2, 907, 908, 7,
	545, 2, 2, 908, 913, 5, 714, 358, 2, 909, 910, 7, 551, 2, 2, 910, 912,
	5, 714, 358, 2, 911, 909, 3, 2, 2, 2, 912, 915, 3, 2, 2, 2, 913, 911, 3,
	2, 2, 2, 913, 914, 3, 2, 2, 2, 914, 916, 3, 2, 2, 2, 915, 913, 3, 2, 2,
	2, 916, 917, 7, 546, 2, 2, 917, 919, 3, 2, 2, 2, 918, 905, 3, 2, 2, 2,
	918, 906, 3, 2, 2, 2, 919, 921, 3, 2, 2, 2, 920, 922, 5, 20, 11, 2, 921,
	920, 3, 2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 923, 3, 2, 2, 2, 923, 924,
	7, 546, 2, 2, 924, 15, 3, 2, 2, 2, 925, 927, 7, 354, 2, 2, 926, 928, 5,
	18, 10, 2, 927, 926, 3, 2, 2, 2, 927, 928, 3, 2, 2, 2, 928, 17, 3, 2, 2,
	2, 929, 930, 7, 349, 2, 2, 930, 931, 7, 545, 2, 2, 931, 936, 5, 716, 359,
	2, 932, 933, 7, 551, 2, 2, 933, 935, 5, 716, 359, 2, 934, 932, 3, 2, 2,
	2, 935, 938, 3, 2, 2, 2, 936, 934, 3, 2, 2, 2, 936, 937, 3, 2, 2, 2, 937,
	939, 3, 2, 2, 2, 938, 936, 3, 2, 2, 2, 939, 940, 7, 546, 2, 2, 940, 19,
	3, 2, 2, 2, 941, 942, 9, 5, 2, 2, 942, 943, 5, 536, 269, 2, 943, 944, 7,
	42, 2, 2, 944, 945, 7, 545, 2, 2, 945, 950, 5, 714, 358, 2, 946, 947, 7,
	551, 2, 2, 947, 949, 5, 714, 358, 2, 948, 946, 3, 2, 2, 2, 949, 952, 3,
	2, 2, 2, 950, 948, 3, 2, 2, 2, 950, 951, 3, 2, 2, 2, 951, 953, 3, 2, 2,
	2, 952, 950, 3, 2, 2, 2, 953, 954, 7, 546, 2, 2, 954, 21, 3, 2, 2, 2, 955,
	956, 7, 121, 2, 2, 956, 958, 7, 304, 2, 2, 957, 959, 7, 36, 2, 2, 958,
	957, 3, 2, 2, 2, 958, 959, 3, 2, 2, 2, 959, 963, 3, 2, 2, 2, 960, 961,
	5, 722, 362, 2, 961, 962, 7, 538, 2, 2, 962, 964, 3, 2, 2, 2, 963, 960,
	3, 2, 2, 2, 963, 964, 3, 2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 966, 5, 672,
	337, 2, 966, 967, 7, 563, 2, 2, 967, 23, 3, 2, 2, 2, 968, 969, 7, 9, 2,
	2, 969, 970, 7, 304, 2, 2, 970, 971, 5, 672, 337, 2, 971, 973, 7, 67, 2,
	2, 972, 974, 7, 101, 2, 2, 973, 972, 3, 2, 2, 2, 973, 974, 3, 2, 2, 2,
	974, 976, 3, 2, 2, 2, 975, 977, 9, 6, 2, 2, 976, 975, 3, 2, 2, 2, 976,
	977, 3, 2, 2, 2, 977, 981, 3, 2, 2, 2, 978, 980, 5, 216, 109, 2, 979, 978,
	3, 2, 2, 2, 980, 983, 3, 2, 2, 2, 981, 979, 3, 2, 2, 2, 981, 982, 3, 2,
	2, 2, 982, 986, 3, 2, 2, 2, 983, 981, 3, 2, 2, 2, 984, 985, 7, 358, 2,
	2, 985, 987, 7, 388, 2, 2, 986, 984, 3, 2, 2, 2, 986, 987, 3, 2, 2, 2,
	987, 988, 3, 2, 2, 2, 988, 989, 7, 563, 2, 2, 989, 25, 3, 2, 2, 2, 990,
	993, 7, 85, 2, 2, 991, 992, 7, 298, 2, 2, 992, 994, 7, 351, 2, 2, 993,
	991, 3, 2, 2, 2, 993, 994, 3, 2, 2, 2, 994, 995, 3, 2, 2, 2, 995, 999,
	7, 304, 2, 2, 996, 997, 5, 722, 362, 2, 997, 998, 7, 538, 2, 2, 998, 1000,
	3, 2, 2, 2, 999, 996, 3, 2, 2, 2, 999, 1000, 3, 2, 2, 2, 1000, 1001, 3,
	2, 2, 2, 1001, 1003, 5, 672, 337, 2, 1002, 1004, 5, 214, 108, 2, 1003,
	1002, 3, 2, 2, 2, 1003, 1004, 3, 2, 2, 2, 1004, 1005, 3, 2, 2, 2, 1005,
	1009, 9, 2, 2, 2, 1006, 1008, 5, 30, 16, 2, 1007, 1006, 3, 2, 2, 2, 1008,
	1011, 3, 2, 2, 2, 1009, 1007, 3, 2, 2, 2, 1009, 1010, 3, 2, 2, 2, 1010,
	1012, 3, 2, 2, 2, 1011, 1009, 3, 2, 2, 2, 1012, 1014, 7, 131, 2, 2, 1013,
	1015, 5, 672, 337, 2, 1014, 1013, 3, 2, 2, 2, 1014, 1015, 3, 2, 2, 2, 1015,
	1016, 3, 2, 2, 2, 1016, 1017, 7, 563, 2, 2, 1017, 27, 3, 2, 2, 2, 1018,
	1021, 7, 85, 2, 2, 1019, 1020, 7, 298, 2, 2, 1020, 1022, 7, 351, 2, 2,
	1021, 1019, 3, 2, 2, 2, 1021, 1022, 3, 2, 2, 2, 1022, 1023, 3, 2, 2, 2,
	1023, 1024, 7, 304, 2, 2, 1024, 1028, 7, 36, 2, 2, 1025, 1026, 5, 722,
	362, 2, 1026, 1027, 7, 538, 2, 2, 1027, 1029, 3, 2, 2, 2, 1028, 1025, 3,
	2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029, 1030, 3, 2, 2, 2, 1030, 1031, 5,
	672, 337, 2, 1031, 1035, 9, 2, 2, 2, 1032, 1034, 5, 36, 19, 2, 1033, 1032,
	3, 2, 2, 2, 1034, 1037, 3, 2, 2, 2, 1035, 1033, 3, 2, 2, 2, 1035, 1036,
	3, 2, 2, 2, 1036, 1044, 3, 2, 2, 2, 1037, 1035, 3, 2, 2, 2, 1038, 1039,
	7, 28, 2, 2, 1039, 1045, 5, 260, 131, 2, 1040, 1042, 7, 131, 2, 2, 1041,
	1043, 5, 672, 337, 2, 1042, 1041, 3, 2, 2, 2, 1042, 1043, 3, 2, 2, 2, 1043,
	1045, 3, 2, 2, 2, 1044, 1038, 3, 2, 2, 2, 1044, 1040, 3, 2, 2, 2, 1045,
	1046, 3, 2, 2, 2, 1046, 1047, 7, 563, 2, 2, 1047, 29, 3, 2, 2, 2, 1048,
	1057, 5, 234, 118, 2, 1049, 1057, 5, 236, 119, 2, 1050, 1057, 5, 238, 120,
	2, 1051, 1057, 5, 242, 122, 2, 1052, 1057, 5, 244, 123, 2, 1053, 1057,
	5, 252, 127, 2, 1054, 1057, 5, 32, 17, 2, 1055, 1057, 5, 34, 18, 2, 1056,
	1048, 3, 2, 2, 2, 1056, 1049, 3, 2, 2, 2, 1056, 1050, 3, 2, 2, 2, 1056,
	1051, 3, 2, 2, 2, 1056, 1052, 3, 2, 2, 2, 1056, 1053, 3, 2, 2, 2, 1056,
	1054, 3, 2, 2, 2, 1056, 1055, 3, 2, 2, 2, 1057, 31, 3, 2, 2, 2, 1058, 1059,
	7, 334, 2, 2, 1059, 1071, 5, 760, 381, 2, 1060, 1061, 7, 545, 2, 2, 1061,
	1066, 5, 228, 115, 2, 1062, 1063, 7, 551, 2, 2, 1063, 1065, 5, 228, 115,
	2, 1064, 1062, 3, 2, 2, 2, 1065, 1068, 3, 2, 2, 2, 1066, 1064, 3, 2, 2,
	2, 1066, 1067, 3, 2, 2, 2, 1067, 1069, 3, 2, 2, 2, 1068, 1066, 3, 2, 2,
	2, 1069, 1070, 7, 546, 2, 2, 1070, 1072, 3, 2, 2, 2, 1071, 1060, 3, 2,
	2, 2, 1071, 1072, 3, 2, 2, 2, 1072, 1073, 3, 2, 2, 2, 1073, 1074, 7, 563,
	2, 2, 1074, 33, 3, 2, 2, 2, 1075, 1076, 7, 167, 2, 2, 1076, 1088, 5, 760,
	381, 2, 1077, 1078, 7, 545, 2, 2, 1078, 1083, 5, 228, 115, 2, 1079, 1080,
	7, 551, 2, 2, 1080, 1082, 5, 228, 115, 2, 1081, 1079, 3, 2, 2, 2, 1082,
	1085, 3, 2, 2, 2, 1083, 1081, 3, 2, 2, 2, 1083, 1084, 3, 2, 2, 2, 1084,
	1086, 3, 2, 2, 2, 1085, 1083, 3, 2, 2, 2, 1086, 1087, 7, 546, 2, 2, 1087,
	1089, 3, 2, 2, 2, 1088, 1077, 3, 2, 2, 2, 1088, 1089, 3, 2, 2, 2, 1089,
	1090, 3, 2, 2, 2, 1090, 1091, 7, 357, 2, 2, 1091, 1093, 5, 736, 369, 2,
	1092, 1094, 7, 114, 2, 2, 1093, 1092, 3, 2, 2, 2, 1093, 1094, 3, 2, 2,
	2, 1094, 1096, 3, 2, 2, 2, 1095, 1097, 7, 354, 2, 2, 1096, 1095, 3, 2,
	2, 2, 1096, 1097, 3, 2, 2, 2, 1097, 1098, 3, 2, 2, 2, 1098, 1099, 7, 563,
	2, 2, 1099, 35, 3, 2, 2, 2, 1100, 1110, 5, 234, 118, 2, 1101, 1110, 5,
	236, 119, 2, 1102, 1110, 5, 238, 120, 2, 1103, 1110, 5, 242, 122, 2, 1104,
	1110, 5, 252, 127, 2, 1105, 1110, 5, 44, 23, 2, 1106, 1110, 5, 42, 22,
	2, 1107, 1110, 5, 32, 17, 2, 1108, 1110, 5, 34, 18, 2, 1109, 1100, 3, 2,
	2, 2, 1109, 1101, 3, 2, 2, 2, 1109, 1102, 3, 2, 2, 2, 1109, 1103, 3, 2,
	2, 2, 1109, 1104, 3, 2, 2, 2, 1109, 1105, 3, 2, 2, 2, 1109, 1106, 3, 2,
	2, 2, 1109, 1107, 3, 2, 2, 2, 1109, 1108, 3, 2, 2, 2, 1110, 37, 3, 2, 2,
	2, 1111, 1112, 7, 121, 2, 2, 1112, 1113, 7, 334, 2, 2, 1113, 1114, 5, 698,
	350, 2, 1114, 1115, 7, 563, 2, 2, 1115, 39, 3, 2, 2, 2, 1116, 1117, 7,
	9, 2, 2, 1117, 1118, 7, 334, 2, 2, 1118, 1119, 5, 698, 350, 2, 1119, 1121,
	7, 67, 2, 2, 1120, 1122, 7, 101, 2, 2, 1121, 1120, 3, 2, 2, 2, 1121, 1122,
	3, 2, 2, 2, 1122, 1126, 3, 2, 2, 2, 1123, 1125, 5, 216, 109, 2, 1124, 1123,
	3, 2, 2, 2, 1125, 1128, 3, 2, 2, 2, 1126, 1124, 3, 2, 2, 2, 1126, 1127,
	3, 2, 2, 2, 1127, 1131, 3, 2, 2, 2, 1128, 1126, 3, 2, 2, 2, 1129, 1130,
	7, 358, 2, 2, 1130, 1132, 7, 388, 2, 2, 1131, 1129, 3, 2, 2, 2, 1131, 1132,
	3, 2, 2, 2, 1132, 1133, 3, 2, 2, 2, 1133, 1134, 7, 563, 2, 2, 1134, 41,
	3, 2, 2, 2, 1135, 1136, 7, 167, 2, 2, 1136, 1148, 5, 760, 381, 2, 1137,
	1138, 7, 545, 2, 2, 1138, 1143, 5, 228, 115, 2, 1139, 1140, 7, 551, 2,
	2, 1140, 1142, 5, 228, 115, 2, 1141, 1139, 3, 2, 2, 2, 1142, 1145, 3, 2,
	2, 2, 1143, 1141, 3, 2, 2, 2, 1143, 1144, 3, 2, 2, 2, 1144, 1146, 3, 2,
	2, 2, 1145, 1143, 3, 2, 2, 2, 1146, 1147, 7, 546, 2, 2, 1147, 1149, 3,
	2, 2, 2, 1148, 1137, 3, 2, 2, 2, 1148, 1149, 3, 2, 2, 2, 1149, 1150, 3,
	2, 2, 2, 1150, 1151, 7, 357, 2, 2, 1151, 1158, 5, 736, 369, 2, 1152, 1157,
	5, 214, 108, 2, 1153, 1157, 5, 12, 7, 2, 1154, 1157, 5, 16, 9, 2, 1155,
	1157, 7, 114, 2, 2, 1156, 1152, 3, 2, 2, 2, 1156, 1153, 3, 2, 2, 2, 1156,
	1154, 3, 2, 2, 2, 1156, 1155, 3, 2, 2, 2, 1157, 1160, 3, 2, 2, 2, 1158,
	1156, 3, 2, 2, 2, 1158, 1159, 3, 2, 2, 2, 1159, 1181, 3, 2, 2, 2, 1160,
	1158, 3, 2, 2, 2, 1161, 1163, 7, 320, 2, 2, 1162, 1161, 3, 2, 2, 2, 1162,
	1163, 3, 2, 2, 2, 1163, 1164, 3, 2, 2, 2, 1164, 1176, 9, 2, 2, 2, 1165,
	1167, 7, 104, 2, 2, 1166, 1165, 3, 2, 2, 2, 1166, 1167, 3, 2, 2, 2, 1167,
	1171, 3, 2, 2, 2, 1168, 1170, 5, 232, 117, 2, 1169, 1168, 3, 2, 2, 2, 1170,
	1173, 3, 2, 2, 2, 1171, 1169, 3, 2, 2, 2, 1171, 1172, 3, 2, 2, 2, 1172,
	1174, 3, 2, 2, 2, 1173, 1171, 3, 2, 2, 2, 1174, 1177, 5, 306, 154, 2, 1175,
	1177, 5, 218, 110, 2, 1176, 1166, 3, 2, 2, 2, 1176, 1175, 3, 2, 2, 2, 1177,
	1182, 3, 2, 2, 2, 1178, 1179, 9, 3, 2, 2, 1179, 1180, 7, 455, 2, 2, 1180,
	1182, 5, 674, 338, 2, 1181, 1162, 3, 2, 2, 2, 1181, 1178, 3, 2, 2, 2, 1182,
	1183, 3, 2, 2, 2, 1183, 1184, 7, 563, 2, 2, 1184, 43, 3, 2, 2, 2, 1185,
	1186, 7, 334, 2, 2, 1186, 1198, 5, 760, 381, 2, 1187, 1188, 7, 545, 2,
	2, 1188, 1193, 5, 228, 115, 2, 1189, 1190, 7, 551, 2, 2, 1190, 1192, 5,
	228, 115, 2, 1191, 1189, 3, 2, 2, 2, 1192, 1195, 3, 2, 2, 2, 1193, 1191,
	3, 2, 2, 2, 1193, 1194, 3, 2, 2, 2, 1194, 1196, 3, 2, 2, 2, 1195, 1193,
	3, 2, 2, 2, 1196, 1197, 7, 546, 2, 2, 1197, 1199, 3, 2, 2, 2, 1198, 1187,
	3, 2, 2, 2, 1198, 1199, 3, 2, 2, 2, 1199, 1200, 3, 2, 2, 2, 1200, 1213,
	9, 2, 2, 2, 1201, 1203, 7, 104, 2, 2, 1202, 1201, 3, 2, 2, 2, 1202, 1203,
	3, 2, 2, 2, 1203, 1207, 3, 2, 2, 2, 1204, 1206, 5, 232, 117, 2, 1205, 1204,
	3, 2, 2, 2, 1206, 1209, 3, 2, 2, 2, 1207, 1205, 3, 2, 2, 2, 1207, 1208,
	3, 2, 2, 2, 1208, 1210, 3, 2, 2, 2, 1209, 1207, 3, 2, 2, 2, 1210, 1214,
	5, 306, 154, 2, 1211, 1214, 5, 218, 110, 2, 1212, 1214, 7, 146, 2, 2, 1213,
	1202, 3, 2, 2, 2, 1213, 1211, 3, 2, 2, 2, 1213, 1212, 3, 2, 2, 2, 1214,
	1215, 3, 2, 2, 2, 1215, 1216, 7, 563, 2, 2, 1216, 45, 3, 2, 2, 2, 1217,
	1220, 7, 85, 2, 2, 1218, 1219, 7, 298, 2, 2, 1219, 1221, 7, 351, 2, 2,
	1220, 1218, 3, 2, 2, 2, 1220, 1221, 3, 2, 2, 2, 1221, 1222, 3, 2, 2, 2,
	1222, 1223, 7, 334, 2, 2, 1223, 1235, 5, 698, 350, 2, 1224, 1225, 7, 545,
	2, 2, 1225, 1230, 5, 228, 115, 2, 1226, 1227, 7, 551, 2, 2, 1227, 1229,
	5, 228, 115, 2, 1228, 1226, 3, 2, 2, 2, 1229, 1232, 3, 2, 2, 2, 1230, 1228,
	3, 2, 2, 2, 1230, 1231, 3, 2, 2, 2, 1231, 1233, 3, 2, 2, 2, 1232, 1230,
	3, 2, 2, 2, 1233, 1234, 7, 546, 2, 2, 1234, 1236, 3, 2, 2, 2, 1235, 1224,
	3, 2, 2, 2, 1235, 1236, 3, 2, 2, 2, 1236, 1238, 3, 2, 2, 2, 1237, 1239,
	5, 214, 108, 2, 1238, 1237, 3, 2, 2, 2, 1238, 1239, 3, 2, 2, 2, 1239, 1240,
	3, 2, 2, 2, 1240, 1253, 9, 2, 2, 2, 1241, 1243, 7, 104, 2, 2, 1242, 1241,
	3, 2, 2, 2, 1242, 1243, 3, 2, 2, 2, 1243, 1247, 3, 2, 2, 2, 1244, 1246,
	5, 232, 117, 2, 1245, 1244, 3, 2, 2, 2, 1246, 1249, 3, 2, 2, 2, 1247, 1245,
	3, 2, 2, 2, 1247, 1248, 3, 2, 2, 2, 1248, 1250, 3, 2, 2, 2, 1249, 1247,
	3, 2, 2, 2, 1250, 1254, 5, 306, 154, 2, 1251, 1254, 5, 218, 110, 2, 1252,
	1254, 7, 146, 2, 2, 1253, 1242, 3, 2, 2, 2, 1253, 1251, 3, 2, 2, 2, 1253,
	1252, 3, 2, 2, 2, 1254, 1255, 3, 2, 2, 2, 1255, 1256, 7, 563, 2, 2, 1256,
	47, 3, 2, 2, 2, 1257, 1258, 7, 121, 2, 2, 1258, 1259, 7, 439, 2, 2, 1259,
	1260, 5, 700, 351, 2, 1260, 1261, 7, 563, 2, 2, 1261, 49, 3, 2, 2, 2, 1262,
	1263, 7, 9, 2, 2, 1263, 1264, 7, 439, 2, 2, 1264, 1283, 5, 700, 351, 2,
	1265, 1284, 9, 7, 2, 2, 1266, 1267, 7, 350, 2, 2, 1267, 1268, 7, 434, 2,
	2, 1268, 1284, 5, 700, 351, 2, 1269, 1271, 7, 67, 2, 2, 1270, 1272, 7,
	101, 2, 2, 1271, 1270, 3, 2, 2, 2, 1271, 1272, 3, 2, 2, 2, 1272, 1276,
	3, 2, 2, 2, 1273, 1275, 5, 216, 109, 2, 1274, 1273, 3, 2, 2, 2, 1275, 1278,
	3, 2, 2, 2, 1276, 1274, 3, 2, 2, 2, 1276, 1277, 3, 2, 2, 2, 1277, 1281,
	3, 2, 2, 2, 1278, 1276, 3, 2, 2, 2, 1279, 1280, 7, 358, 2, 2, 1280, 1282,
	7, 388, 2, 2, 1281, 1279, 3, 2, 2, 2, 1281, 1282, 3, 2, 2, 2, 1282, 1284,
	3, 2, 2, 2, 1283, 1265, 3, 2, 2, 2, 1283, 1266, 3, 2, 2, 2, 1283, 1269,
	3, 2, 2, 2, 1284, 1285, 3, 2, 2, 2, 1285, 1286, 7, 563, 2, 2, 1286, 51,
	3, 2, 2, 2, 1287, 1290, 7, 85, 2, 2, 1288, 1289, 7, 298, 2, 2, 1289, 1291,
	7, 351, 2, 2, 1290, 1288, 3, 2, 2, 2, 1290, 1291, 3, 2, 2, 2, 1291, 1292,
	3, 2, 2, 2, 1292, 1293, 7, 439, 2, 2, 1293, 1297, 5, 700, 351, 2, 1294,
	1298, 5, 58, 30, 2, 1295, 1298, 5, 62, 32, 2, 1296, 1298, 5, 64, 33, 2,
	1297, 1294, 3, 2, 2, 2, 1297, 1295, 3, 2, 2, 2, 1297, 1296, 3, 2, 2, 2,
	1298, 1300, 3, 2, 2, 2, 1299, 1301, 5, 54, 28, 2, 1300, 1299, 3, 2, 2,
	2, 1300, 1301, 3, 2, 2, 2, 1301, 1303, 3, 2, 2, 2, 1302, 1304, 9, 7, 2,
	2, 1303, 1302, 3, 2, 2, 2, 1303, 1304, 3, 2, 2, 2, 1304, 1306, 3, 2, 2,
	2, 1305, 1307, 5, 56, 29, 2, 1306, 1305, 3, 2, 2, 2, 1306, 1307, 3, 2,
	2, 2, 1307, 1308, 3, 2, 2, 2, 1308, 1309, 5, 66, 34, 2, 1309, 1310, 7,
	563, 2, 2, 1310, 53, 3, 2, 2, 2, 1311, 1312, 7, 158, 2, 2, 1312, 1317,
	5, 700, 351, 2, 1313, 1314, 7, 551, 2, 2, 1314, 1316, 5, 700, 351, 2, 1315,
	1313, 3, 2, 2, 2, 1316, 1319, 3, 2, 2, 2, 1317, 1315, 3, 2, 2, 2, 1317,
	1318, 3, 2, 2, 2, 1318, 55, 3, 2, 2, 2, 1319, 1317, 3, 2, 2, 2, 1320, 1321,
	7, 470, 2, 2, 1321, 1322, 7, 545, 2, 2, 1322, 1323, 5, 532, 267, 2, 1323,
	1324, 7, 546, 2, 2, 1324, 57, 3, 2, 2, 2, 1325, 1330, 7, 27, 2, 2, 1326,
	1330, 7, 4, 2, 2, 1327, 1328, 7, 199, 2, 2, 1328, 1330, 7, 286, 2, 2, 1329,
	1325, 3, 2, 2, 2, 1329, 1326, 3, 2, 2, 2, 1329, 1327, 3, 2, 2, 2, 1330,
	1331, 3, 2, 2, 2, 1331, 1333, 5, 76, 39, 2, 1332, 1334, 5, 82, 42, 2, 1333,
	1332, 3, 2, 2, 2, 1333, 1334, 3, 2, 2, 2, 1334, 1336, 3, 2, 2, 2, 1335,
	1337, 5, 60, 31, 2, 1336, 1335, 3, 2, 2, 2, 1336, 1337, 3, 2, 2, 2, 1337,
	59, 3, 2, 2, 2, 1338, 1339, 7, 162, 2, 2, 1339, 1340, 7, 123, 2, 2, 1340,
	1341, 7, 365, 2, 2, 1341, 61, 3, 2, 2, 2, 1342, 1343, 7, 162, 2, 2, 1343,
	1345, 5, 76, 39, 2, 1344, 1346, 5, 82, 42, 2, 1345, 1344, 3, 2, 2, 2, 1345,
	1346, 3, 2, 2, 2, 1346, 63, 3, 2, 2, 2, 1347, 1348, 9, 8, 2, 2, 1348, 1353,
	5, 74, 38, 2, 1349, 1350, 7, 298, 2, 2, 1350, 1352, 5, 74, 38, 2, 1351,
	1349, 3, 2, 2, 2, 1352, 1355, 3, 2, 2, 2, 1353, 1351, 3, 2, 2, 2, 1353,
	1354, 3, 2, 2, 2, 1354, 1356, 3, 2, 2, 2, 1355, 1353, 3, 2, 2, 2, 1356,
	1364, 7, 291, 2, 2, 1357, 1365, 7, 94, 2, 2, 1358, 1359, 5, 668, 335, 2,
	1359, 1360, 7, 538, 2, 2, 1360, 1362, 3, 2, 2, 2, 1361, 1358, 3, 2, 2,
	2, 1361, 1362, 3, 2, 2, 2, 1362, 1363, 3, 2, 2, 2, 1363, 1365, 7, 372,
	2, 2, 1364, 1357, 3, 2, 2, 2, 1364, 1361, 3, 2, 2, 2, 1365, 65, 3, 2, 2,
	2, 1366, 1367, 7, 68, 2, 2, 1367, 1372, 7, 439, 2, 2, 1368, 1369, 7, 45,
	2, 2, 1369, 1372, 5, 760, 381, 2, 1370, 1372, 5, 310, 156, 2, 1371, 1366,
	3, 2, 2, 2, 1371, 1368, 3, 2, 2, 2, 1371, 1370, 3, 2, 2, 2, 1372, 67, 3,
	2, 2, 2, 1373, 1375, 5, 670, 336, 2, 1374, 1376, 5, 726, 364, 2, 1375,
	1374, 3, 2, 2, 2, 1375, 1376, 3, 2, 2, 2, 1376, 69, 3, 2, 2, 2, 1377, 1378,
	7, 68, 2, 2, 1378, 1382, 7, 439, 2, 2, 1379, 1381, 5, 232, 117, 2, 1380,
	1379, 3, 2, 2, 2, 1381, 1384, 3, 2, 2, 2, 1382, 1380, 3, 2, 2, 2, 1382,
	1383, 3, 2, 2, 2, 1383, 1386, 3, 2, 2, 2, 1384, 1382, 3, 2, 2, 2, 1385,
	1387, 5, 72, 37, 2, 1386, 1385, 3, 2, 2, 2, 1387, 1388, 3, 2, 2, 2, 1388,
	1386, 3, 2, 2, 2, 1388, 1389, 3, 2, 2, 2, 1389, 1390, 3, 2, 2, 2, 1390,
	1391, 7, 131, 2, 2, 1391, 1392, 5, 700, 351, 2, 1392, 71, 3, 2, 2, 2, 1393,
	1394, 7, 27, 2, 2, 1394, 1395, 7, 408, 2, 2, 1395, 1396, 7, 206, 2, 2,
	1396, 1397, 5, 310, 156, 2, 1397, 1398, 7, 27, 2, 2, 1398, 1399, 7, 408,
	2, 2, 1399, 1400, 7, 563, 2, 2, 1400, 1430, 3, 2, 2, 2, 1401, 1402, 7,
	27, 2, 2, 1402, 1403, 7, 123, 2, 2, 1403, 1404, 7, 365, 2, 2, 1404, 1405,
	7, 206, 2, 2, 1405, 1406, 5, 310, 156, 2, 1406, 1407, 7, 27, 2, 2, 1407,
	1408, 7, 123, 2, 2, 1408, 1409, 7, 365, 2, 2, 1409, 1410, 7, 563, 2, 2,
	1410, 1430, 3, 2, 2, 2, 1411, 1412, 7, 4, 2, 2, 1412, 1413, 7, 408, 2,
	2, 1413, 1414, 7, 206, 2, 2, 1414, 1415, 5, 310, 156, 2, 1415, 1416, 7,
	4, 2, 2, 1416, 1417, 7, 408, 2, 2, 1417, 1418, 7, 563, 2, 2, 1418, 1430,
	3, 2, 2, 2, 1419, 1420, 7, 4, 2, 2, 1420, 1421, 7, 123, 2, 2, 1421, 1422,
	7, 365, 2, 2, 1422, 1423, 7, 206, 2, 2, 1423, 1424, 5, 310, 156, 2, 1424,
	1425, 7, 4, 2, 2, 1425, 1426, 7, 123, 2, 2, 1426, 1427, 7, 365, 2, 2, 1427,
	1428, 7, 563, 2, 2, 1428, 1430, 3, 2, 2, 2, 1429, 1393, 3, 2, 2, 2, 1429,
	1401, 3, 2, 2, 2, 1429, 1411, 3, 2, 2, 2, 1429, 1419, 3, 2, 2, 2, 1430,
	73, 3, 2, 2, 2, 1431, 1458, 7, 9, 2, 2, 1432, 1458, 7, 10, 2, 2, 1433,
	1434, 7, 17, 2, 2, 1434, 1458, 7, 410, 2, 2, 1435, 1458, 7, 20, 2, 2, 1436,
	1458, 7, 63, 2, 2, 1437, 1458, 7, 85, 2, 2, 1438, 1439, 7, 117, 2, 2, 1439,
	1458, 7, 410, 2, 2, 1440, 1458, 7, 121, 2, 2, 1441, 1458, 7, 170, 2, 2,
	1442, 1458, 7, 264, 2, 2, 1443, 1458, 7, 350, 2, 2, 1444, 1458, 7, 360,
	2, 2, 1445, 1458, 7, 441, 2, 2, 1446, 1458, 7, 100, 2, 2, 1447, 1458, 7,
	406, 2, 2, 1448, 1458, 7, 391, 2, 2, 1449, 1458, 7, 98, 2, 2, 1450, 1458,
	7, 232, 2, 2, 1451, 1458, 7, 231, 2, 2, 1452, 1458, 7, 384, 2, 2, 1453,
	1458, 7, 418, 2, 2, 1454, 1458, 7, 94, 2, 2, 1455, 1458, 7, 372, 2, 2,
	1456, 1458, 7, 158, 2, 2, 1457, 1431, 3, 2, 2, 2, 1457, 1432, 3, 2, 2,
	2, 1457, 1433, 3, 2, 2, 2, 1457, 1435, 3, 2, 2, 2, 1457, 1436, 3, 2, 2,
	2, 1457, 1437, 3, 2, 2, 2, 1457, 1438, 3, 2, 2, 2, 1457, 1440, 3, 2, 2,
	2, 1457, 1441, 3, 2, 2, 2, 1457, 1442, 3, 2, 2, 2, 1457, 1443, 3, 2, 2,
	2, 1457, 1444, 3, 2, 2, 2, 1457, 1445, 3, 2, 2, 2, 1457, 1446, 3, 2, 2,
	2, 1457, 1447, 3, 2, 2, 2, 1457, 1448, 3, 2, 2, 2, 1457, 1449, 3, 2, 2,
	2, 1457, 1450, 3, 2, 2, 2, 1457, 1451, 3, 2, 2, 2, 1457, 1452, 3, 2, 2,
	2, 1457, 1453, 3, 2, 2, 2, 1457, 1454, 3, 2, 2, 2, 1457, 1455, 3, 2, 2,
	2, 1457, 1456, 3, 2, 2, 2, 1458, 75, 3, 2, 2, 2, 1459, 1464, 5, 78, 40,
	2, 1460, 1461, 7, 298, 2, 2, 1461, 1463, 5, 78, 40, 2, 1462, 1460, 3, 2,
	2, 2, 1463, 1466, 3, 2, 2, 2, 1464, 1462, 3, 2, 2, 2, 1464, 1465, 3, 2,
	2, 2, 1465, 1467, 3, 2, 2, 2, 1466, 1464, 3, 2, 2, 2, 1467, 1469, 7, 291,
	2, 2, 1468, 1470, 5, 80, 41, 2, 1469, 1468, 3, 2, 2, 2, 1469, 1470, 3,
	2, 2, 2, 1470, 1471, 3, 2, 2, 2, 1471, 1472, 5, 716, 359, 2, 1472, 77,
	3, 2, 2, 2, 1473, 1483, 9, 9, 2, 2, 1474, 1475, 7, 286, 2, 2, 1475, 1480,
	5, 714, 358, 2, 1476, 1477, 7, 551, 2, 2, 1477, 1479, 5, 714, 358, 2, 1478,
	1476, 3, 2, 2, 2, 1479, 1482, 3, 2, 2, 2, 1480, 1478, 3, 2, 2, 2, 1480,
	1481, 3, 2, 2, 2, 1481, 1484, 3, 2, 2, 2, 1482, 1480, 3, 2, 2, 2, 1483,
	1474, 3, 2, 2, 2, 1483, 1484, 3, 2, 2, 2, 1484, 79, 3, 2, 2, 2, 1485, 1486,
	7, 261, 2, 2, 1486, 1487, 7, 421, 2, 2, 1487, 1488, 5, 716, 359, 2, 1488,
	1489, 7, 286, 2, 2, 1489, 81, 3, 2, 2, 2, 1490, 1492, 7, 346, 2, 2, 1491,
	1493, 5, 84, 43, 2, 1492, 1491, 3, 2, 2, 2, 1493, 1494, 3, 2, 2, 2, 1494,
	1492, 3, 2, 2, 2, 1494, 1495, 3, 2, 2, 2, 1495, 83, 3, 2, 2, 2, 1496, 1497,
	9, 10, 2, 2, 1497, 1498, 5, 648, 325, 2, 1498, 85, 3, 2, 2, 2, 1499, 1500,
	7, 121, 2, 2, 1500, 1502, 7, 442, 2, 2, 1501, 1503, 7, 36, 2, 2, 1502,
	1501, 3, 2, 2, 2, 1502, 1503, 3, 2, 2, 2, 1503, 1504, 3, 2, 2, 2, 1504,
	1506, 5, 690, 346, 2, 1505, 1507, 9, 11, 2, 2, 1506, 1505, 3, 2, 2, 2,
	1506, 1507, 3, 2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 1509, 7, 563, 2,
	2, 1509, 87, 3, 2, 2, 2, 1510, 1511, 7, 9, 2, 2, 1511, 1512, 7, 442, 2,
	2, 1512, 1518, 5, 690, 346, 2, 1513, 1519, 5, 90, 46, 2, 1514, 1519, 5,
	92, 47, 2, 1515, 1519, 5, 94, 48, 2, 1516, 1519, 5, 102, 52, 2, 1517, 1519,
	5, 136, 69, 2, 1518, 1513, 3, 2, 2, 2, 1518, 1514, 3, 2, 2, 2, 1518, 1515,
	3, 2, 2, 2, 1518, 1516, 3, 2, 2, 2, 1518, 1517, 3, 2, 2, 2, 1519, 1521,
	3, 2, 2, 2, 1520, 1522, 5, 104, 53, 2, 1521, 1520, 3, 2, 2, 2, 1521, 1522,
	3, 2, 2, 2, 1522, 1523, 3, 2, 2, 2, 1523, 1524, 7, 563, 2, 2, 1524, 89,
	3, 2, 2, 2, 1525, 1527, 7, 67, 2, 2, 1526, 1528, 7, 101, 2, 2, 1527, 1526,
	3, 2, 2, 2, 1527, 1528, 3, 2, 2, 2, 1528, 1530, 3, 2, 2, 2, 1529, 1531,
	9, 12, 2, 2, 1530, 1529, 3, 2, 2, 2, 1530, 1531, 3, 2, 2, 2, 1531, 1535,
	3, 2, 2, 2, 1532, 1534, 5, 216, 109, 2, 1533, 1532, 3, 2, 2, 2, 1534, 1537,
	3, 2, 2, 2, 1535, 1533, 3, 2, 2, 2, 1535, 1536, 3, 2, 2, 2, 1536, 1540,
	3, 2, 2, 2, 1537, 1535, 3, 2, 2, 2, 1538, 1539, 7, 358, 2, 2, 1539, 1541,
	7, 388, 2, 2, 1540, 1538, 3, 2, 2, 2, 1540, 1541, 3, 2, 2, 2, 1541, 91,
	3, 2, 2, 2, 1542, 1544, 7, 351, 2, 2, 1543, 1545, 5, 214, 108, 2, 1544,
	1543, 3, 2, 2, 2, 1544, 1545, 3, 2, 2, 2, 1545, 1546, 3, 2, 2, 2, 1546,
	1547, 7, 15, 2, 2, 1547, 1548, 7, 284, 2, 2, 1548, 1549, 7, 545, 2, 2,
	1549, 1554, 5, 138, 70, 2, 1550, 1551, 7, 551, 2, 2, 1551, 1553, 5, 138,
	70, 2, 1552, 1550, 3, 2, 2, 2, 1553, 1556, 3, 2, 2, 2, 1554, 1552, 3, 2,
	2, 2, 1554, 1555, 3, 2, 2, 2, 1555, 1557, 3, 2, 2, 2, 1556, 1554, 3, 2,
	2, 2, 1557, 1558, 7, 546, 2, 2, 1558, 93, 3, 2, 2, 2, 1559, 1564, 5, 96,
	49, 2, 1560, 1561, 7, 551, 2, 2, 1561, 1563, 5, 96, 49, 2, 1562, 1560,
	3, 2, 2, 2, 1563, 1566, 3, 2, 2, 2, 1564, 1562, 3, 2, 2, 2, 1564, 1565,
	3, 2, 2, 2, 1565, 95, 3, 2, 2, 2, 1566, 1564, 3, 2, 2, 2, 1567, 1570, 9,
	13, 2, 2, 1568, 1571, 5, 154, 78, 2, 1569, 1571, 5, 146, 74, 2, 1570, 1568,
	3, 2, 2, 2, 1570, 1569, 3, 2, 2, 2, 1571, 97, 3, 2, 2, 2, 1572, 1573, 9,
	14, 2, 2, 1573, 1586, 7, 19, 2, 2, 1574, 1587, 5, 100, 51, 2, 1575, 1576,
	7, 545, 2, 2, 1576, 1581, 5, 100, 51, 2, 1577, 1578, 7, 551, 2, 2, 1578,
	1580, 5, 100, 51, 2, 1579, 1577, 3, 2, 2, 2, 1580, 1583, 3, 2, 2, 2, 1581,
	1579, 3, 2, 2, 2, 1581, 1582, 3, 2, 2, 2, 1582, 1584, 3, 2, 2, 2, 1583,
	1581, 3, 2, 2, 2, 1584, 1585, 7, 546, 2, 2, 1585, 1587, 3, 2, 2, 2, 1586,
	1574, 3, 2, 2, 2, 1586, 1575, 3, 2, 2, 2, 1587, 99, 3, 2, 2, 2, 1588, 1590,
	5, 660, 331, 2, 1589, 1591, 5, 736, 369, 2, 1590, 1589, 3, 2, 2, 2, 1590,
	1591, 3, 2, 2, 2, 1591, 101, 3, 2, 2, 2, 1592, 1598, 7, 250, 2, 2, 1593,
	1594, 7, 224, 2, 2, 1594, 1599, 5, 536, 269, 2, 1595, 1596, 7, 124, 2,
	2, 1596, 1597, 7, 442, 2, 2, 1597, 1599, 5, 736, 369, 2, 1598, 1593, 3,
	2, 2, 2, 1598, 1595, 3, 2, 2, 2, 1599, 103, 3, 2, 2, 2, 1600, 1617, 7,
	205, 2, 2, 1601, 1611, 7, 47, 2, 2, 1602, 1603, 7, 80, 2, 2, 1603, 1604,
	7, 434, 2, 2, 1604, 1612, 7, 415, 2, 2, 1605, 1607, 7, 277, 2, 2, 1606,
	1605, 3, 2, 2, 2, 1606, 1607, 3, 2, 2, 2, 1607, 1608, 3, 2, 2, 2, 1608,
	1609, 7, 183, 2, 2, 1609, 1610, 7, 421, 2, 2, 1610, 1612, 7, 95, 2, 2,
	1611, 1602, 3, 2, 2, 2, 1611, 1606, 3, 2, 2, 2, 1611, 1612, 3, 2, 2, 2,
	1612, 1614, 3, 2, 2, 2, 1613, 1615, 5, 106, 54, 2, 1614, 1613, 3, 2, 2,
	2, 1614, 1615, 3, 2, 2, 2, 1615, 1617, 3, 2, 2, 2, 1616, 1600, 3, 2, 2,
	2, 1616, 1601, 3, 2, 2, 2, 1617, 105, 3, 2, 2, 2, 1618, 1620, 7, 160, 2,
	2, 1619, 1618, 3, 2, 2, 2, 1619, 1620, 3, 2, 2, 2, 1620, 1621, 3, 2, 2,
	2, 1621, 1622, 7, 139, 2, 2, 1622, 1623, 7, 204, 2, 2, 1623, 1624, 5, 716,
	359, 2, 1624, 107, 3, 2, 2, 2, 1625, 1628, 7, 85, 2, 2, 1626, 1627, 7,
	298, 2, 2, 1627, 1629, 7, 351, 2, 2, 1628, 1626, 3, 2, 2, 2, 1628, 1629,
	3, 2, 2, 2, 1629, 1630, 3, 2, 2, 2, 1630, 1633, 7, 442, 2, 2, 1631, 1634,
	5, 110, 56, 2, 1632, 1634, 5, 122, 62, 2, 1633, 1631, 3, 2, 2, 2, 1633,
	1632, 3, 2, 2, 2, 1634, 1635, 3, 2, 2, 2, 1635, 1636, 7, 563, 2, 2, 1636,
	109, 3, 2, 2, 2, 1637, 1640, 5, 690, 346, 2, 1638, 1639, 7, 287, 2, 2,
	1639, 1641, 7, 541, 2, 2, 1640, 1638, 3, 2, 2, 2, 1640, 1641, 3, 2, 2,
	2, 1641, 1643, 3, 2, 2, 2, 1642, 1644, 5, 112, 57, 2, 1643, 1642, 3, 2,
	2, 2, 1643, 1644, 3, 2, 2, 2, 1644, 111, 3, 2, 2, 2, 1645, 1647, 5, 214,
	108, 2, 1646, 1645, 3, 2, 2, 2, 1646, 1647, 3, 2, 2, 2, 1647, 1650, 3,
	2, 2, 2, 1648, 1651, 5, 114, 58, 2, 1649, 1651, 5, 116, 59, 2, 1650, 1648,
	3, 2, 2, 2, 1650, 1649, 3, 2, 2, 2, 1651, 1653, 3, 2, 2, 2, 1652, 1654,
	5, 120, 61, 2, 1653, 1652, 3, 2, 2, 2, 1653, 1654, 3, 2, 2, 2, 1654, 1666,
	3, 2, 2, 2, 1655, 1656, 7, 545, 2, 2, 1656, 1661, 5, 138, 70, 2, 1657,
	1658, 7, 551, 2, 2, 1658, 1660, 5, 138, 70, 2, 1659, 1657, 3, 2, 2, 2,
	1660, 1663, 3, 2, 2, 2, 1661, 1659, 3, 2, 2, 2, 1661, 1662, 3, 2, 2, 2,
	1662, 1664, 3, 2, 2, 2, 1663, 1661, 3, 2, 2, 2, 1664, 1665, 7, 546, 2,
	2, 1665, 1667, 3, 2, 2, 2, 1666, 1655, 3, 2, 2, 2, 1666, 1667, 3, 2, 2,
	2, 1667, 1671, 3, 2, 2, 2, 1668, 1670, 5, 136, 69, 2, 1669, 1668, 3, 2,
	2, 2, 1670, 1673, 3, 2, 2, 2, 1671, 1669, 3, 2, 2, 2, 1671, 1672, 3, 2,
	2, 2, 1672, 113, 3, 2, 2, 2, 1673, 1671, 3, 2, 2, 2, 1674, 1678, 9, 2,
	2, 2, 1675, 1679, 7, 284, 2, 2, 1676, 1679, 5, 258, 130, 2, 1677, 1679,
	5, 118, 60, 2, 1678, 1675, 3, 2, 2, 2, 1678, 1676, 3, 2, 2, 2, 1678, 1677,
	3, 2, 2, 2, 1679, 115, 3, 2, 2, 2, 1680, 1681, 7, 444, 2, 2, 1681, 1682,
	5, 736, 369, 2, 1682, 117, 3, 2, 2, 2, 1683, 1684, 7, 421, 2, 2, 1684,
	1685, 7, 286, 2, 2, 1685, 1688, 5, 736, 369, 2, 1686, 1687, 7, 277, 2,
	2, 1687, 1689, 7, 279, 2, 2, 1688, 1686, 3, 2, 2, 2, 1688, 1689, 3, 2,
	2, 2, 1689, 119, 3, 2, 2, 2, 1690, 1691, 7, 146, 2, 2, 1691, 1692, 7, 253,
	2, 2, 1692, 1693, 5, 536, 269, 2, 1693, 1694, 7, 213, 2, 2, 1694, 1695,
	7, 209, 2, 2, 1695, 1696, 7, 455, 2, 2, 1696, 1697, 9, 15, 2, 2, 1697,
	121, 3, 2, 2, 2, 1698, 1699, 7, 36, 2, 2, 1699, 1700, 5, 690, 346, 2, 1700,
	1702, 9, 2, 2, 2, 1701, 1703, 5, 124, 63, 2, 1702, 1701, 3, 2, 2, 2, 1703,
	1704, 3, 2, 2, 2, 1704, 1702, 3, 2, 2, 2, 1704, 1705, 3, 2, 2, 2, 1705,
	1706, 3, 2, 2, 2, 1706, 1707, 7, 131, 2, 2, 1707, 123, 3, 2, 2, 2, 1708,
	1711, 5, 126, 64, 2, 1709, 1711, 5, 128, 65, 2, 1710, 1708, 3, 2, 2, 2,
	1710, 1709, 3, 2, 2, 2, 1711, 125, 3, 2, 2, 2, 1712, 1713, 9, 16, 2, 2,
	1713, 1714, 7, 241, 2, 2, 1714, 1715, 5, 132, 67, 2, 1715, 127, 3, 2, 2,
	2, 1716, 1720, 9, 17, 2, 2, 1717, 1721, 5, 130, 66, 2, 1718, 1721, 5, 132,
	67, 2, 1719, 1721, 5, 134, 68, 2, 1720, 1717, 3, 2, 2, 2, 1720, 1718, 3,
	2, 2, 2, 1720, 1719, 3, 2, 2, 2, 1721, 129, 3, 2, 2, 2, 1722, 1723, 7,
	334, 2, 2, 1723, 1724, 5, 698, 350, 2, 1724, 1725, 7, 545, 2, 2, 1725,
	1730, 5, 160, 81, 2, 1726, 1727, 7, 551, 2, 2, 1727, 1729, 5, 160, 81,
	2, 1728, 1726, 3, 2, 2, 2, 1729, 1732, 3, 2, 2, 2, 1730, 1728, 3, 2, 2,
	2, 1730, 1731, 3, 2, 2, 2, 1731, 1733, 3, 2, 2, 2, 1732, 1730, 3, 2, 2,
	2, 1733, 1734, 7, 546, 2, 2, 1734, 1748, 9, 2, 2, 2, 1735, 1749, 5, 218,
	110, 2, 1736, 1738, 7, 104, 2, 2, 1737, 1736, 3, 2, 2, 2, 1737, 1738, 3,
	2, 2, 2, 1738, 1742, 3, 2, 2, 2, 1739, 1741, 5, 232, 117, 2, 1740, 1739,
	3, 2, 2, 2, 1741, 1744, 3, 2, 2, 2, 1742, 1740, 3, 2, 2, 2, 1742, 1743,
	3, 2, 2, 2, 1743, 1745, 3, 2, 2, 2, 1744, 1742, 3, 2, 2, 2, 1745, 1746,
	5, 306, 154, 2, 1746, 1747, 7, 563, 2, 2, 1747, 1749, 3, 2, 2, 2, 1748,
	1735, 3, 2, 2, 2, 1748, 1737, 3, 2, 2, 2, 1749, 131, 3, 2, 2, 2, 1750,
	1751, 7, 167, 2, 2, 1751, 1763, 5, 696, 349, 2, 1752, 1753, 7, 545, 2,
	2, 1753, 1758, 5, 160, 81, 2, 1754, 1755, 7, 551, 2, 2, 1755, 1757, 5,
	160, 81, 2, 1756, 1754, 3, 2, 2, 2, 1757, 1760, 3, 2, 2, 2, 1758, 1756,
	3, 2, 2, 2, 1758, 1759, 3, 2, 2, 2, 1759, 1761, 3, 2, 2, 2, 1760, 1758,
	3, 2, 2, 2, 1761, 1762, 7, 546, 2, 2, 1762, 1764, 3, 2, 2, 2, 1763, 1752,
	3, 2, 2, 2, 1763, 1764, 3, 2, 2, 2, 1764, 1765, 3, 2, 2, 2, 1765, 1766,
	7, 357, 2, 2, 1766, 1767, 5, 736, 369, 2, 1767, 1781, 9, 2, 2, 2, 1768,
	1782, 5, 218, 110, 2, 1769, 1771, 7, 104, 2, 2, 1770, 1769, 3, 2, 2, 2,
	1770, 1771, 3, 2, 2, 2, 1771, 1775, 3, 2, 2, 2, 1772, 1774, 5, 232, 117,
	2, 1773, 1772, 3, 2, 2, 2, 1774, 1777, 3, 2, 2, 2, 1775, 1773, 3, 2, 2,
	2, 1775, 1776, 3, 2, 2, 2, 1776, 1778, 3, 2, 2, 2, 1777, 1775, 3, 2, 2,
	2, 1778, 1779, 5, 306, 154, 2, 1779, 1780, 7, 563, 2, 2, 1780, 1782, 3,
	2, 2, 2, 1781, 1768, 3, 2, 2, 2, 1781, 1770, 3, 2, 2, 2, 1782, 133, 3,
	2, 2, 2, 1783, 1785, 7, 152, 2, 2, 1784, 1783, 3, 2, 2, 2, 1784, 1785,
	3, 2, 2, 2, 1785, 1787, 3, 2, 2, 2, 1786, 1788, 7, 198, 2, 2, 1787, 1786,
	3, 2, 2, 2, 1787, 1788, 3, 2, 2, 2, 1788, 1789, 3, 2, 2, 2, 1789, 1790,
	7, 76, 2, 2, 1790, 1791, 7, 167, 2, 2, 1791, 1809, 5, 736, 369, 2, 1792,
	1793, 7, 545, 2, 2, 1793, 1794, 7, 379, 2, 2, 1794, 1795, 7, 191, 2, 2,
	1795, 1796, 7, 301, 2, 2, 1796, 1797, 5, 736, 369, 2, 1797, 1798, 7, 551,
	2, 2, 1798, 1799, 3, 2, 2, 2, 1799, 1804, 5, 160, 81, 2, 1800, 1801, 7,
	551, 2, 2, 1801, 1803, 5, 160, 81, 2, 1802, 1800, 3, 2, 2, 2, 1803, 1806,
	3, 2, 2, 2, 1804, 1802, 3, 2, 2, 2, 1804, 1805, 3, 2, 2, 2, 1805, 1807,
	3, 2, 2, 2, 1806, 1804, 3, 2, 2, 2, 1807, 1808, 7, 546, 2, 2, 1808, 1810,
	3, 2, 2, 2, 1809, 1792, 3, 2, 2, 2, 1809, 1810, 3, 2, 2, 2, 1810, 1811,
	3, 2, 2, 2, 1811, 1812, 7, 357, 2, 2, 1812, 1813, 7, 379, 2, 2, 1813, 1814,
	7, 15, 2, 2, 1814, 1815, 7, 355, 2, 2, 1815, 1829, 9, 2, 2, 2, 1816, 1830,
	5, 218, 110, 2, 1817, 1819, 7, 104, 2, 2, 1818, 1817, 3, 2, 2, 2, 1818,
	1819, 3, 2, 2, 2, 1819, 1823, 3, 2, 2, 2, 1820, 1822, 5, 232, 117, 2, 1821,
	1820, 3, 2, 2, 2, 1822, 1825, 3, 2, 2, 2, 1823, 1821, 3, 2, 2, 2, 1823,
	1824, 3, 2, 2, 2, 1824, 1826, 3, 2, 2, 2, 1825, 1823, 3, 2, 2, 2, 1826,
	1827, 5, 306, 154, 2, 1827, 1828, 7, 563, 2, 2, 1828, 1830, 3, 2, 2, 2,
	1829, 1816, 3, 2, 2, 2, 1829, 1818, 3, 2, 2, 2, 1830, 135, 3, 2, 2, 2,
	1831, 1833, 7, 277, 2, 2, 1832, 1831, 3, 2, 2, 2, 1832, 1833, 3, 2, 2,
	2, 1833, 1834, 3, 2, 2, 2, 1834, 1835, 9, 18, 2, 2, 1835, 137, 3, 2, 2,
	2, 1836, 1837, 5, 760, 381, 2, 1837, 1839, 5, 736, 369, 2, 1838, 1840,
	5, 140, 71, 2, 1839, 1838, 3, 2, 2, 2, 1839, 1840, 3, 2, 2, 2, 1840, 1843,
	3, 2, 2, 2, 1841, 1843, 5, 142, 72, 2, 1842, 1836, 3, 2, 2, 2, 1842, 1841,
	3, 2, 2, 2, 1843, 139, 3, 2, 2, 2, 1844, 1845, 7, 146, 2, 2, 1845, 1846,
	7, 253, 2, 2, 1846, 1847, 5, 536, 269, 2, 1847, 141, 3, 2, 2, 2, 1848,
	1850, 5, 136, 69, 2, 1849, 1848, 3, 2, 2, 2, 1849, 1850, 3, 2, 2, 2, 1850,
	1852, 3, 2, 2, 2, 1851, 1853, 5, 144, 73, 2, 1852, 1851, 3, 2, 2, 2, 1853,
	1854, 3, 2, 2, 2, 1854, 1852, 3, 2, 2, 2, 1854, 1855, 3, 2, 2, 2, 1855,
	1858, 3, 2, 2, 2, 1856, 1857, 7, 551, 2, 2, 1857, 1859, 5, 156, 79, 2,
	1858, 1856, 3, 2, 2, 2, 1858, 1859, 3, 2, 2, 2, 1859, 143, 3, 2, 2, 2,
	1860, 1864, 5, 146, 74, 2, 1861, 1864, 5, 152, 77, 2, 1862, 1864, 5, 154,
	78, 2, 1863, 1860, 3, 2, 2, 2, 1863, 1861, 3, 2, 2, 2, 1863, 1862, 3, 2,
	2, 2, 1864, 145, 3, 2, 2, 2, 1865, 1868, 9, 17, 2, 2, 1866, 1869, 5, 148,
	75, 2, 1867, 1869, 5, 150, 76, 2, 1868, 1866, 3, 2, 2, 2, 1868, 1867, 3,
	2, 2, 2, 1869, 147, 3, 2, 2, 2, 1870, 1871, 7, 334, 2, 2, 1871, 1872, 5,
	698, 350, 2, 1872, 1873, 7, 545, 2, 2, 1873, 1878, 5, 160, 81, 2, 1874,
	1875, 7, 551, 2, 2, 1875, 1877, 5, 160, 81, 2, 1876, 1874, 3, 2, 2, 2,
	1877, 1880, 3, 2, 2, 2, 1878, 1876, 3, 2, 2, 2, 1878, 1879, 3, 2, 2, 2,
	1879, 1881, 3, 2, 2, 2, 1880, 1878, 3, 2, 2, 2, 1881, 1884, 7, 546, 2,
	2, 1882, 1883, 9, 2, 2, 2, 1883, 1885, 5, 218, 110, 2, 1884, 1882, 3, 2,
	2, 2, 1884, 1885, 3, 2, 2, 2, 1885, 149, 3, 2, 2, 2, 1886, 1887, 7, 167,
	2, 2, 1887, 1899, 5, 696, 349, 2, 1888, 1889, 7, 545, 2, 2, 1889, 1894,
	5, 160, 81, 2, 1890, 1891, 7, 551, 2, 2, 1891, 1893, 5, 160, 81, 2, 1892,
	1890, 3, 2, 2, 2, 1893, 1896, 3, 2, 2, 2, 1894, 1892, 3, 2, 2, 2, 1894,
	1895, 3, 2, 2, 2, 1895, 1897, 3, 2, 2, 2, 1896, 1894, 3, 2, 2, 2, 1897,
	1898, 7, 546, 2, 2, 1898, 1900, 3, 2, 2, 2, 1899, 1888, 3, 2, 2, 2, 1899,
	1900, 3, 2, 2, 2, 1900, 1901, 3, 2, 2, 2, 1901, 1906, 7, 357, 2, 2, 1902,
	1907, 5, 736, 369, 2, 1903, 1904, 7, 379, 2, 2, 1904, 1905, 7, 15, 2, 2,
	1905, 1907, 7, 355, 2, 2, 1906, 1902, 3, 2, 2, 2, 1906, 1903, 3, 2, 2,
	2, 1907, 1916, 3, 2, 2, 2, 1908, 1909, 9, 2, 2, 2, 1909, 1917, 5, 218,
	110, 2, 1910, 1912, 7, 146, 2, 2, 1911, 1913, 7, 461, 2, 2, 1912, 1911,
	3, 2, 2, 2, 1912, 1913, 3, 2, 2, 2, 1913, 1914, 3, 2, 2, 2, 1914, 1915,
	7, 253, 2, 2, 1915, 1917, 5, 536, 269, 2, 1916, 1908, 3, 2, 2, 2, 1916,
	1910, 3, 2, 2, 2, 1916, 1917, 3, 2, 2, 2, 1917, 151, 3, 2, 2, 2, 1918,
	1920, 7, 152, 2, 2, 1919, 1918, 3, 2, 2, 2, 1919, 1920, 3, 2, 2, 2, 1920,
	1922, 3, 2, 2, 2, 1921, 1923, 7, 198, 2, 2, 1922, 1921, 3, 2, 2, 2, 1922,
	1923, 3, 2, 2, 2, 1923, 1924, 3, 2, 2, 2, 1924, 1925, 7, 76, 2, 2, 1925,
	1926, 7, 167, 2, 2, 1926, 1944, 5, 736, 369, 2, 1927, 1928, 7, 545, 2,
	2, 1928, 1929, 7, 379, 2, 2, 1929, 1930, 7, 191, 2, 2, 1930, 1931, 7, 301,
	2, 2, 1931, 1932, 5, 736, 369, 2, 1932, 1933, 7, 551, 2, 2, 1933, 1934,
	3, 2, 2, 2, 1934, 1939, 5, 160, 81, 2, 1935, 1936, 7, 551, 2, 2, 1936,
	1938, 5, 160, 81, 2, 1937, 1935, 3, 2, 2, 2, 1938, 1941, 3, 2, 2, 2, 1939,
	1937, 3, 2, 2, 2, 1939, 1940, 3, 2, 2, 2, 1940, 1942, 3, 2, 2, 2, 1941,
	1939, 3, 2, 2, 2, 1942, 1943, 7, 546, 2, 2, 1943, 1945, 3, 2, 2, 2, 1944,
	1927, 3, 2, 2, 2, 1944, 1945, 3, 2, 2, 2, 1945, 1946, 3, 2, 2, 2, 1946,
	1947, 7, 357, 2, 2, 1947, 1948, 7, 379, 2, 2, 1948, 1949, 7, 15, 2, 2,
	1949, 1952, 7, 355, 2, 2, 1950, 1951, 9, 2, 2, 2, 1951, 1953, 5, 218, 110,
	2, 1952, 1950, 3, 2, 2, 2, 1952, 1953, 3, 2, 2, 2, 1953, 153, 3, 2, 2,
	2, 1954, 1955, 9, 16, 2, 2, 1955, 1956, 7, 241, 2, 2, 1956, 1957, 5, 150,
	76, 2, 1957, 155, 3, 2, 2, 2, 1958, 1959, 7, 327, 2, 2, 1959, 1960, 7,
	353, 2, 2, 1960, 1961, 7, 545, 2, 2, 1961, 1966, 5, 158, 80, 2, 1962, 1963,
	7, 551, 2, 2, 1963, 1965, 5, 158, 80, 2, 1964, 1962, 3, 2, 2, 2, 1965,
	1968, 3, 2, 2, 2, 1966, 1964, 3, 2, 2, 2, 1966, 1967, 3, 2, 2, 2, 1967,
	1969, 3, 2, 2, 2, 1968, 1966, 3, 2, 2, 2, 1969, 1970, 7, 546, 2, 2, 1970,
	157, 3, 2, 2, 2, 1971, 1974, 5, 760, 381, 2, 1972, 1974, 7, 107, 2, 2,
	1973, 1971, 3, 2, 2, 2, 1973, 1972, 3, 2, 2, 2, 1974, 159, 3, 2, 2, 2,
	1975, 1976, 5, 676, 339, 2, 1976, 1977, 5, 736, 369, 2, 1977, 161, 3, 2,
	2, 2, 1978, 1979, 7, 121, 2, 2, 1979, 1980, 7, 380, 2, 2, 1980, 1981, 5,
	692, 347, 2, 1981, 1982, 7, 563, 2, 2, 1982, 163, 3, 2, 2, 2, 1983, 1984,
	7, 9, 2, 2, 1984, 1985, 7, 380, 2, 2, 1985, 1987, 5, 692, 347, 2, 1986,
	1988, 5, 168, 85, 2, 1987, 1986, 3, 2, 2, 2, 1988, 1989, 3, 2, 2, 2, 1989,
	1987, 3, 2, 2, 2, 1989, 1990, 3, 2, 2, 2, 1990, 1991, 3, 2, 2, 2, 1991,
	1992, 7, 563, 2, 2, 1992, 165, 3, 2, 2, 2, 1993, 1994, 7, 85, 2, 2, 1994,
	1995, 7, 380, 2, 2, 1995, 2000, 5, 692, 347, 2, 1996, 1999, 5, 170, 86,
	2, 1997, 1999, 5, 168, 85, 2, 1998, 1996, 3, 2, 2, 2, 1998, 1997, 3, 2,
	2, 2, 1999, 2002, 3, 2, 2, 2, 2000, 1998, 3, 2, 2, 2, 2000, 2001, 3, 2,
	2, 2, 2001, 2003, 3, 2, 2, 2, 2002, 2000, 3, 2, 2, 2, 2003, 2004, 7, 563,
	2, 2, 2004, 167, 3, 2, 2, 2, 2005, 2006, 7, 184, 2, 2, 2006, 2007, 7, 42,
	2, 2, 2007, 2022, 7, 539, 2, 2, 2008, 2009, 7, 239, 2, 2, 2009, 2022, 7,
	539, 2, 2, 2010, 2022, 7, 271, 2, 2, 2011, 2012, 7, 246, 2, 2, 2012, 2022,
	7, 539, 2, 2, 2013, 2022, 7, 272, 2, 2, 2014, 2022, 7, 93, 2, 2, 2015,
	2022, 7, 268, 2, 2, 2016, 2017, 7, 44, 2, 2, 2017, 2022, 7, 539, 2, 2,
	2018, 2022, 7, 265, 2, 2, 2019, 2022, 7, 296, 2, 2, 2020, 2022, 7, 275,
	2, 2, 2021, 2005, 3, 2, 2, 2, 2021, 2008, 3, 2, 2, 2, 2021, 2010, 3, 2,
	2, 2, 2021, 2011, 3, 2, 2, 2, 2021, 2013, 3, 2, 2, 2, 2021, 2014, 3, 2,
	2, 2, 2021, 2015, 3, 2, 2, 2, 2021, 2016, 3, 2, 2, 2, 2021, 2018, 3, 2,
	2, 2, 2021, 2019, 3, 2, 2, 2, 2021, 2020, 3, 2, 2, 2, 2022, 169, 3, 2,
	2, 2, 2023, 2024, 7, 405, 2, 2, 2024, 2025, 7, 474, 2, 2, 2025, 2026, 7,
	539, 2, 2, 2026, 171, 3, 2, 2, 2, 2027, 2029, 7, 85, 2, 2, 2028, 2030,
	7, 446, 2, 2, 2029, 2028, 3, 2, 2, 2, 2029, 2030, 3, 2, 2, 2, 2030, 2031,
	3, 2, 2, 2, 2031, 2032, 7, 187, 2, 2, 2032, 2033, 5, 704, 353, 2, 2033,
	2034, 7, 291, 2, 2, 2034, 2035, 5, 716, 359, 2, 2035, 2036, 7, 545, 2,
	2, 2036, 2041, 5, 714, 358, 2, 2037, 2038, 7, 551, 2, 2, 2038, 2040, 5,
	714, 358, 2, 2039, 2037, 3, 2, 2, 2, 2040, 2043, 3, 2, 2, 2, 2041, 2039,
	3, 2, 2, 2, 2041, 2042, 3, 2, 2, 2, 2042, 2044, 3, 2, 2, 2, 2043, 2041,
	3, 2, 2, 2, 2044, 2047, 7, 546, 2, 2, 2045, 2046, 7, 70, 2, 2, 2046, 2048,
	7, 410, 2, 2, 2047, 2045, 3, 2, 2, 2, 2047, 2048, 3, 2, 2, 2, 2048, 2049,
	3, 2, 2, 2, 2049, 2050, 7, 563, 2, 2, 2050, 173, 3, 2, 2, 2, 2051, 2052,
	7, 9, 2, 2, 2052, 2053, 7, 187, 2, 2, 2053, 2054, 5, 704, 353, 2, 2054,
	2055, 7, 350, 2, 2, 2055, 2056, 7, 434, 2, 2, 2056, 2057, 5, 704, 353,
	2, 2057, 2058, 7, 563, 2, 2, 2058, 175, 3, 2, 2, 2, 2059, 2060, 7, 121,
	2, 2, 2060, 2061, 7, 187, 2, 2, 2061, 2062, 5, 704, 353, 2, 2062, 2063,
	7, 563, 2, 2, 2063, 177, 3, 2, 2, 2, 2064, 2067, 7, 85, 2, 2, 2065, 2066,
	7, 168, 2, 2, 2066, 2068, 7, 422, 2, 2, 2067, 2065, 3, 2, 2, 2, 2067, 2068,
	3, 2, 2, 2, 2068, 2069, 3, 2, 2, 2, 2069, 2070, 7, 421, 2, 2, 2070, 2071,
	5, 716, 359, 2, 2071, 2072, 7, 545, 2, 2, 2072, 2073, 5, 714, 358, 2, 2073,
	2080, 5, 738, 370, 2, 2074, 2075, 7, 551, 2, 2, 2075, 2076, 5, 714, 358,
	2, 2076, 2077, 5, 738, 370, 2, 2077, 2079, 3, 2, 2, 2, 2078, 2074, 3, 2,
	2, 2, 2079, 2082, 3, 2, 2, 2, 2080, 2078, 3, 2, 2, 2, 2080, 2081, 3, 2,
	2, 2, 2081, 2083, 3, 2, 2, 2, 2082, 2080, 3, 2, 2, 2, 2083, 2088, 7, 546,
	2, 2, 2084, 2085, 7, 291, 2, 2, 2085, 2086, 7, 64, 2, 2, 2086, 2087, 9,
	19, 2, 2, 2087, 2089, 7, 366, 2, 2, 2088, 2084, 3, 2, 2, 2, 2088, 2089,
	3, 2, 2, 2, 2089, 2093, 3, 2, 2, 2, 2090, 2091, 7, 377, 2, 2, 2091, 2092,
	7, 86, 2, 2, 2092, 2094, 9, 20, 2, 2, 2093, 2090, 3, 2, 2, 2, 2093, 2094,
	3, 2, 2, 2, 2094, 2103, 3, 2, 2, 2, 2095, 2096, 7, 311, 2, 2, 2096, 2102,
	7, 539, 2, 2, 2097, 2098, 7, 313, 2, 2, 2098, 2102, 7, 539, 2, 2, 2099,
	2100, 7, 193, 2, 2, 2100, 2102, 7, 539, 2, 2, 2101, 2095, 3, 2, 2, 2, 2101,
	2097, 3, 2, 2, 2, 2101, 2099, 3, 2, 2, 2, 2102, 2105, 3, 2, 2, 2, 2103,
	2101, 3, 2, 2, 2, 2103, 2104, 3, 2, 2, 2, 2104, 2136, 3, 2, 2, 2, 2105,
	2103, 3, 2, 2, 2, 2106, 2107, 7, 411, 2, 2, 2107, 2131, 7, 545, 2, 2, 2108,
	2109, 7, 192, 2, 2, 2109, 2132, 5, 180, 91, 2, 2110, 2111, 7, 263, 2, 2,
	2111, 2132, 5, 180, 91, 2, 2112, 2113, 7, 243, 2, 2, 2113, 2132, 9, 21,
	2, 2, 2114, 2115, 7, 312, 2, 2, 2115, 2132, 7, 539, 2, 2, 2116, 2117, 7,
	164, 2, 2, 2117, 2132, 7, 539, 2, 2, 2118, 2119, 7, 163, 2, 2, 2119, 2120,
	7, 173, 2, 2, 2120, 2132, 7, 539, 2, 2, 2121, 2124, 7, 293, 2, 2, 2122,
	2125, 5, 180, 91, 2, 2123, 2125, 7, 279, 2, 2, 2124, 2122, 3, 2, 2, 2,
	2124, 2123, 3, 2, 2, 2, 2125, 2132, 3, 2, 2, 2, 2126, 2127, 7, 40, 2, 2,
	2127, 2132, 9, 22, 2, 2, 2128, 2129, 7, 155, 2, 2, 2129, 2132, 9, 23, 2,
	2, 2130, 2132, 7, 130, 2, 2, 2131, 2108, 3, 2, 2, 2, 2131, 2110, 3, 2,
	2, 2, 2131, 2112, 3, 2, 2, 2, 2131, 2114, 3, 2, 2, 2, 2131, 2116, 3, 2,
	2, 2, 2131, 2118, 3, 2, 2, 2, 2131, 2121, 3, 2, 2, 2, 2131, 2126, 3, 2,
	2, 2, 2131, 2128, 3, 2, 2, 2, 2131, 2130, 3, 2, 2, 2, 2132, 2133, 3, 2,
	2, 2, 2133, 2131, 3, 2, 2, 2, 2133, 2134, 3, 2, 2, 2, 2134, 2135, 3, 2,
	2, 2, 2135, 2137, 7, 546, 2, 2, 2136, 2106, 3, 2, 2, 2, 2136, 2137, 3,
	2, 2, 2, 2137, 2140, 3, 2, 2, 2, 2138, 2139, 7, 420, 2, 2, 2139, 2141,
	7, 574, 2, 2, 2140, 2138, 3, 2, 2, 2, 2140, 2141, 3, 2, 2, 2, 2141, 2143,
	3, 2, 2, 2, 2142, 2144, 9, 24, 2, 2, 2143, 2142, 3, 2, 2, 2, 2143, 2144,
	3, 2, 2, 2, 2144, 2158, 3, 2, 2, 2, 2145, 2155, 7, 69, 2, 2, 2146, 2156,
	7, 25, 2, 2, 2147, 2153, 7, 162, 2, 2, 2148, 2154, 7, 289, 2, 2, 2149,
	2151, 9, 25, 2, 2, 2150, 2152, 9, 26, 2, 2, 2151, 2150, 3, 2, 2, 2, 2151,
	2152, 3, 2, 2, 2, 2152, 2154, 3, 2, 2, 2, 2153, 2148, 3, 2, 2, 2, 2153,
	2149, 3, 2, 2, 2, 2154, 2156, 3, 2, 2, 2, 2155, 2146, 3, 2, 2, 2, 2155,
	2147, 3, 2, 2, 2, 2155, 2156, 3, 2, 2, 2, 2156, 2159, 3, 2, 2, 2, 2157,
	2159, 7, 266, 2, 2, 2158, 2145, 3, 2, 2, 2, 2158, 2157, 3, 2, 2, 2, 2158,
	2159, 3, 2, 2, 2, 2159, 2160, 3, 2, 2, 2, 2160, 2161, 7, 563, 2, 2, 2161,
	179, 3, 2, 2, 2, 2162, 2163, 7, 539, 2, 2, 2163, 2164, 7, 574, 2, 2, 2164,
	181, 3, 2, 2, 2, 2165, 2166, 7, 121, 2, 2, 2166, 2167, 7, 421, 2, 2, 2167,
	2168, 5, 716, 359, 2, 2168, 2169, 7, 563, 2, 2, 2169, 183, 3, 2, 2, 2,
	2170, 2171, 7, 63, 2, 2, 2171, 2172, 7, 291, 2, 2, 2172, 2173, 7, 61, 2,
	2, 2173, 2174, 5, 716, 359, 2, 2174, 2175, 7, 538, 2, 2, 2175, 2176, 5,
	714, 358, 2, 2176, 2177, 7, 206, 2, 2, 2177, 2178, 5, 758, 380, 2, 2178,
	185, 3, 2, 2, 2, 2179, 2182, 7, 85, 2, 2, 2180, 2181, 7, 298, 2, 2, 2181,
	2183, 7, 351, 2, 2, 2182, 2180, 3, 2, 2, 2, 2182, 2183, 3, 2, 2, 2, 2183,
	2184, 3, 2, 2, 2, 2184, 2185, 7, 335, 2, 2, 2185, 2186, 7, 419, 2, 2, 2186,
	2187, 5, 720, 361, 2, 2187, 2191, 7, 162, 2, 2, 2188, 2189, 5, 668, 335,
	2, 2189, 2190, 7, 538, 2, 2, 2190, 2192, 3, 2, 2, 2, 2191, 2188, 3, 2,
	2, 2, 2191, 2192, 3, 2, 2, 2, 2192, 2193, 3, 2, 2, 2, 2193, 2196, 5, 722,
	362, 2, 2194, 2195, 7, 553, 2, 2, 2195, 2197, 5, 712, 357, 2, 2196, 2194,
	3, 2, 2, 2, 2196, 2197, 3, 2, 2, 2, 2197, 2222, 3, 2, 2, 2, 2198, 2201,
	7, 85, 2, 2, 2199, 2200, 7, 298, 2, 2, 2200, 2202, 7, 351, 2, 2, 2201,
	2199, 3, 2, 2, 2, 2201, 2202, 3, 2, 2, 2, 2202, 2203, 3, 2, 2, 2, 2203,
	2207, 7, 419, 2, 2, 2204, 2205, 5, 668, 335, 2, 2205, 2206, 7, 538, 2,
	2, 2206, 2208, 3, 2, 2, 2, 2207, 2204, 3, 2, 2, 2, 2207, 2208, 3, 2, 2,
	2, 2208, 2209, 3, 2, 2, 2, 2209, 2210, 5, 720, 361, 2, 2210, 2214, 7, 162,
	2, 2, 2211, 2212, 5, 668, 335, 2, 2212, 2213, 7, 538, 2, 2, 2213, 2215,
	3, 2, 2, 2, 2214, 2211, 3, 2, 2, 2, 2214, 2215, 3, 2, 2, 2, 2215, 2216,
	3, 2, 2, 2, 2216, 2219, 5, 722, 362, 2, 2217, 2218, 7, 553, 2, 2, 2218,
	2220, 5, 712, 357, 2, 2219, 2217, 3, 2, 2, 2, 2219, 2220, 3, 2, 2, 2, 2220,
	2222, 3, 2, 2, 2, 2221, 2179, 3, 2, 2, 2, 2221, 2198, 3, 2, 2, 2, 2222,
	187, 3, 2, 2, 2, 2223, 2224, 7, 63, 2, 2, 2224, 2225, 7, 291, 2, 2, 2225,
	2226, 7, 421, 2, 2, 2226, 2227, 5, 716, 359, 2, 2227, 2228, 7, 206, 2,
	2, 2228, 2229, 5, 758, 380, 2, 2229, 189, 3, 2, 2, 2, 2230, 2231, 7, 9,
	2, 2, 2231, 2232, 7, 421, 2, 2, 2232, 2237, 5, 716, 359, 2, 2233, 2238,
	5, 192, 97, 2, 2234, 2238, 5, 196, 99, 2, 2235, 2238, 5, 198, 100, 2, 2236,
	2238, 5, 200, 101, 2, 2237, 2233, 3, 2, 2, 2, 2237, 2234, 3, 2, 2, 2, 2237,
	2235, 3, 2, 2, 2, 2237, 2236, 3, 2, 2, 2, 2238, 191, 3, 2, 2, 2, 2239,
	2242, 7, 3, 2, 2, 2240, 2241, 7, 74, 2, 2, 2241, 2243, 5, 686, 344, 2,
	2242, 2240, 3, 2, 2, 2, 2242, 2243, 3, 2, 2, 2, 2243, 2248, 3, 2, 2, 2,
	2244, 2249, 5, 210, 106, 2, 2245, 2249, 5, 202, 102, 2, 2246, 2249, 5,
	208, 105, 2, 2247, 2249, 5, 194, 98, 2, 2248, 2244, 3, 2, 2, 2, 2248, 2245,
	3, 2, 2, 2, 2248, 2246, 3, 2, 2, 2, 2248, 2247, 3, 2, 2, 2, 2249, 193,
	3, 2, 2, 2, 2250, 2251, 7, 53, 2, 2, 2251, 2252, 7, 545, 2, 2, 2252, 2253,
	5, 532, 267, 2, 2253, 2255, 7, 546, 2, 2, 2254, 2256, 7, 116, 2, 2, 2255,
	2254, 3, 2, 2, 2, 2255, 2256, 3, 2, 2, 2, 2256, 195, 3, 2, 2, 2, 2257,
	2258, 7, 121, 2, 2, 2258, 2259, 7, 74, 2, 2, 2259, 2260, 5, 686, 344, 2,
	2260, 197, 3, 2, 2, 2, 2261, 2262, 7, 128, 2, 2, 2262, 2263, 7, 74, 2,
	2, 2263, 2264, 5, 686, 344, 2, 2264, 199, 3, 2, 2, 2, 2265, 2266, 7, 116,
	2, 2, 2266, 2267, 7, 74, 2, 2, 2267, 2268, 5, 686, 344, 2, 2268, 201, 3,
	2, 2, 2, 2269, 2270, 7, 161, 2, 2, 2270, 2271, 7, 212, 2, 2, 2271, 2272,
	7, 545, 2, 2, 2272, 2277, 5, 714, 358, 2, 2273, 2274, 7, 551, 2, 2, 2274,
	2276, 5, 714, 358, 2, 2275, 2273, 3, 2, 2, 2, 2276, 2279, 3, 2, 2, 2, 2277,
	2275, 3, 2, 2, 2, 2277, 2278, 3, 2, 2, 2, 2278, 2280, 3, 2, 2, 2, 2279,
	2277, 3, 2, 2, 2, 2280, 2281, 7, 546, 2, 2, 2281, 2283, 5, 204, 103, 2,
	2282, 2284, 5, 206, 104, 2, 2283, 2282, 3, 2, 2, 2, 2283, 2284, 3, 2, 2,
	2, 2284, 203, 3, 2, 2, 2, 2285, 2286, 7, 345, 2, 2, 2286, 2287, 5, 716,
	359, 2, 2287, 2288, 7, 545, 2, 2, 2288, 2293, 5, 714, 358, 2, 2289, 2290,
	7, 551, 2, 2, 2290, 2292, 5, 714, 358, 2, 2291, 2289, 3, 2, 2, 2, 2292,
	2295, 3, 2, 2, 2, 2293, 2291, 3, 2, 2, 2, 2293, 2294, 3, 2, 2, 2, 2294,
	2296, 3, 2, 2, 2, 2295, 2293, 3, 2, 2, 2, 2296, 2297, 7, 546, 2, 2, 2297,
	205, 3, 2, 2, 2, 2298, 2299, 7, 291, 2, 2, 2299, 2303, 7, 111, 2, 2, 2300,
	2304, 7, 47, 2, 2, 2301, 2302, 7, 386, 2, 2, 2302, 2304, 7, 279, 2, 2,
	2303, 2300, 3, 2, 2, 2, 2303, 2301, 3, 2, 2, 2, 2304, 207, 3, 2, 2, 2,
	2305, 2306, 7, 446, 2, 2, 2306, 2307, 7, 545, 2, 2, 2307, 2312, 5, 714,
	358, 2, 2308, 2309, 7, 551, 2, 2, 2309, 2311, 5, 714, 358, 2, 2310, 2308,
	3, 2, 2, 2, 2311, 2314, 3, 2, 2, 2, 2312, 2310, 3, 2, 2, 2, 2312, 2313,
	3, 2, 2, 2, 2313, 2315, 3, 2, 2, 2, 2314, 2312, 3, 2, 2, 2, 2315, 2316,
	7, 546, 2, 2, 2316, 209, 3, 2, 2, 2, 2317, 2318, 7, 332, 2, 2, 2318, 2319,
	7, 212, 2, 2, 2319, 2320, 7, 545, 2, 2, 2320, 2325, 5, 714, 358, 2, 2321,
	2322, 7, 551, 2, 2, 2322, 2324, 5, 714, 358, 2, 2323, 2321, 3, 2, 2, 2,
	2324, 2327, 3, 2, 2, 2, 2325, 2323, 3, 2, 2, 2, 2325, 2326, 3, 2, 2, 2,
	2326, 2328, 3, 2, 2, 2, 2327, 2325, 3, 2, 2, 2, 2328, 2329, 7, 546, 2,
	2, 2329, 211, 3, 2, 2, 2, 2330, 2331, 7, 28, 2, 2, 2331, 2332, 5, 260,
	131, 2, 2332, 2333, 7, 131, 2, 2, 2333, 2334, 7, 563, 2, 2, 2334, 213,
	3, 2, 2, 2, 2335, 2336, 7, 21, 2, 2, 2336, 2337, 9, 27, 2, 2, 2337, 215,
	3, 2, 2, 2, 2338, 2339, 5, 760, 381, 2, 2339, 2340, 7, 565, 2, 2, 2340,
	2341, 5, 536, 269, 2, 2341, 217, 3, 2, 2, 2, 2342, 2345, 7, 213, 2, 2,
	2343, 2346, 5, 220, 111, 2, 2344, 2346, 5, 222, 112, 2, 2345, 2343, 3,
	2, 2, 2, 2345, 2344, 3, 2, 2, 2, 2346, 219, 3, 2, 2, 2, 2347, 2348, 7,
	209, 2, 2, 2348, 2349, 7, 253, 2, 2, 2349, 2350, 7, 541, 2, 2, 2350, 221,
	3, 2, 2, 2, 2351, 2354, 7, 55, 2, 2, 2352, 2353, 7, 253, 2, 2, 2353, 2355,
	7, 541, 2, 2, 2354, 2352, 3, 2, 2, 2, 2354, 2355, 3, 2, 2, 2, 2355, 2356,
	3, 2, 2, 2, 2356, 2357, 7, 219, 2, 2, 2357, 2359, 5, 760, 381, 2, 2358,
	2360, 5, 224, 113, 2, 2359, 2358, 3, 2, 2, 2, 2359, 2360, 3, 2, 2, 2, 2360,
	2363, 3, 2, 2, 2, 2361, 2362, 7, 474, 2, 2, 2362, 2364, 7, 78, 2, 2, 2363,
	2361, 3, 2, 2, 2, 2363, 2364, 3, 2, 2, 2, 2364, 2366, 3, 2, 2, 2, 2365,
	2367, 5, 226, 114, 2, 2366, 2365, 3, 2, 2, 2, 2366, 2367, 3, 2, 2, 2, 2367,
	223, 3, 2, 2, 2, 2368, 2369, 7, 5, 2, 2, 2369, 2370, 7, 191, 2, 2, 2370,
	2371, 7, 545, 2, 2, 2371, 2372, 5, 534, 268, 2, 2372, 2373, 7, 546, 2,
	2, 2373, 225, 3, 2, 2, 2, 2374, 2375, 7, 306, 2, 2, 2375, 2380, 7, 545,
	2, 2, 2376, 2381, 5, 534, 268, 2, 2377, 2378, 7, 538, 2, 2, 2378, 2379,
	7, 538, 2, 2, 2379, 2381, 7, 538, 2, 2, 2380, 2376, 3, 2, 2, 2, 2380, 2377,
	3, 2, 2, 2, 2381, 2382, 3, 2, 2, 2, 2382, 2383, 7, 546, 2, 2, 2383, 227,
	3, 2, 2, 2, 2384, 2388, 5, 676, 339, 2, 2385, 2387, 9, 28, 2, 2, 2386,
	2385, 3, 2, 2, 2, 2387, 2390, 3, 2, 2, 2, 2388, 2386, 3, 2, 2, 2, 2388,
	2389, 3, 2, 2, 2, 2389, 2392, 3, 2, 2, 2, 2390, 2388, 3, 2, 2, 2, 2391,
	2393, 5, 736, 369, 2, 2392, 2391, 3, 2, 2, 2, 2392, 2393, 3, 2, 2, 2, 2393,
	2395, 3, 2, 2, 2, 2394, 2396, 5, 230, 116, 2, 2395, 2394, 3, 2, 2, 2, 2395,
	2396, 3, 2, 2, 2, 2396, 229, 3, 2, 2, 2, 2397, 2398, 9, 29, 2, 2, 2398,
	2399, 5, 536, 269, 2, 2399, 231, 3, 2, 2, 2, 2400, 2411, 5, 234, 118, 2,
	2401, 2411, 5, 236, 119, 2, 2402, 2411, 5, 238, 120, 2, 2403, 2411, 5,
	242, 122, 2, 2404, 2411, 5, 244, 123, 2, 2405, 2411, 5, 252, 127, 2, 2406,
	2411, 5, 32, 17, 2, 2407, 2411, 5, 34, 18, 2, 2408, 2411, 5, 44, 23, 2,
	2409, 2411, 5, 42, 22, 2, 2410, 2400, 3, 2, 2, 2, 2410, 2401, 3, 2, 2,
	2, 2410, 2402, 3, 2, 2, 2, 2410, 2403, 3, 2, 2, 2, 2410, 2404, 3, 2, 2,
	2, 2410, 2405, 3, 2, 2, 2, 2410, 2406, 3, 2, 2, 2, 2410, 2407, 3, 2, 2,
	2, 2410, 2408, 3, 2, 2, 2, 2410, 2409, 3, 2, 2, 2, 2411, 233, 3, 2, 2,
	2, 2412, 2414, 5, 760, 381, 2, 2413, 2415, 7, 73, 2, 2, 2414, 2413, 3,
	2, 2, 2, 2414, 2415, 3, 2, 2, 2, 2415, 2416, 3, 2, 2, 2, 2416, 2419, 5,
	736, 369, 2, 2417, 2418, 7, 277, 2, 2, 2418, 2420, 7, 279, 2, 2, 2419,
	2417, 3, 2, 2, 2, 2419, 2420, 3, 2, 2, 2, 2420, 2422, 3, 2, 2, 2, 2421,
	2423, 5, 230, 116, 2, 2422, 2421, 3, 2, 2, 2, 2422, 2423, 3, 2, 2, 2, 2423,
	2424, 3, 2, 2, 2, 2424, 2425, 7, 563, 2, 2, 2425, 235, 3, 2, 2, 2, 2426,
	2427, 7, 416, 2, 2, 2427, 2428, 5, 760, 381, 2, 2428, 2429, 7, 206, 2,
	2, 2429, 2435, 5, 736, 369, 2, 2430, 2431, 7, 338, 2, 2, 2431, 2432, 5,
	536, 269, 2, 2432, 2433, 7, 537, 2, 2, 2433, 2434, 5, 536, 269, 2, 2434,
	2436, 3, 2, 2, 2, 2435, 2430, 3, 2, 2, 2, 2435, 2436, 3, 2, 2, 2, 2436,
	2439, 3, 2, 2, 2, 2437, 2438, 7, 277, 2, 2, 2438, 2440, 7, 279, 2, 2, 2439,
	2437, 3, 2, 2, 2, 2439, 2440, 3, 2, 2, 2, 2440, 2441, 3, 2, 2, 2, 2441,
	2442, 7, 563, 2, 2, 2442, 237, 3, 2, 2, 2, 2443, 2444, 7, 91, 2, 2, 2444,
	2456, 5, 760, 381, 2, 2445, 2446, 7, 545, 2, 2, 2446, 2451, 5, 240, 121,
	2, 2447, 2448, 7, 551, 2, 2, 2448, 2450, 5, 240, 121, 2, 2449, 2447, 3,
	2, 2, 2, 2450, 2453, 3, 2, 2, 2, 2451, 2449, 3, 2, 2, 2, 2451, 2452, 3,
	2, 2, 2, 2452, 2454, 3, 2, 2, 2, 2453, 2451, 3, 2, 2, 2, 2454, 2455, 7,
	546, 2, 2, 2455, 2457, 3, 2, 2, 2, 2456, 2445, 3, 2, 2, 2, 2456, 2457,
	3, 2, 2, 2, 2457, 2460, 3, 2, 2, 2, 2458, 2459, 7, 357, 2, 2, 2459, 2461,
	5, 736, 369, 2, 2460, 2458, 3, 2, 2, 2, 2460, 2461, 3, 2, 2, 2, 2461, 2464,
	3, 2, 2, 2, 2462, 2463, 7, 206, 2, 2, 2463, 2465, 5, 348, 175, 2, 2464,
	2462, 3, 2, 2, 2, 2464, 2465, 3, 2, 2, 2, 2465, 2466, 3, 2, 2, 2, 2466,
	2467, 7, 563, 2, 2, 2467, 239, 3, 2, 2, 2, 2468, 2473, 5, 676, 339, 2,
	2469, 2471, 7, 191, 2, 2, 2470, 2469, 3, 2, 2, 2, 2470, 2471, 3, 2, 2,
	2, 2471, 2472, 3, 2, 2, 2, 2472, 2474, 5, 736, 369, 2, 2473, 2470, 3, 2,
	2, 2, 2473, 2474, 3, 2, 2, 2, 2474, 2476, 3, 2, 2, 2, 2475, 2477, 5, 230,
	116, 2, 2476, 2475, 3, 2, 2, 2, 2476, 2477, 3, 2, 2, 2, 2477, 241, 3, 2,
	2, 2, 2478, 2479, 5, 760, 381, 2, 2479, 2480, 7, 137, 2, 2, 2480, 2481,
	7, 563, 2, 2, 2481, 243, 3, 2, 2, 2, 2482, 2513, 7, 327, 2, 2, 2483, 2514,
	7, 383, 2, 2, 2484, 2514, 7, 24, 2, 2, 2485, 2486, 7, 138, 2, 2, 2486,
	2487, 7, 545, 2, 2, 2487, 2488, 5, 694, 348, 2, 2488, 2489, 7, 551, 2,
	2, 2489, 2490, 5, 756, 379, 2, 2490, 2491, 7, 546, 2, 2, 2491, 2514, 3,
	2, 2, 2, 2492, 2493, 7, 194, 2, 2, 2493, 2494, 7, 545, 2, 2, 2494, 2495,
	5, 760, 381, 2, 2495, 2496, 7, 551, 2, 2, 2496, 2497, 5, 536, 269, 2, 2497,
	2498, 7, 546, 2, 2, 2498, 2514, 3, 2, 2, 2, 2499, 2500, 7, 353, 2, 2, 2500,
	2503, 7, 545, 2, 2, 2501, 2504, 5, 760, 381, 2, 2502, 2504, 7, 107, 2,
	2, 2503, 2501, 3, 2, 2, 2, 2503, 2502, 3, 2, 2, 2, 2504, 2507, 3, 2, 2,
	2, 2505, 2506, 7, 551, 2, 2, 2506, 2508, 5, 760, 381, 2, 2507, 2505, 3,
	2, 2, 2, 2508, 2509, 3, 2, 2, 2, 2509, 2507, 3, 2, 2, 2, 2509, 2510, 3,
	2, 2, 2, 2510, 2511, 3, 2, 2, 2, 2511, 2512, 7, 546, 2, 2, 2512, 2514,
	3, 2, 2, 2, 2513, 2483, 3, 2, 2, 2, 2513, 2484, 3, 2, 2, 2, 2513, 2485,
	3, 2, 2, 2, 2513, 2492, 3, 2, 2, 2, 2513, 2499, 3, 2, 2, 2, 2514, 2515,
	3, 2, 2, 2, 2515, 2516, 7, 563, 2, 2, 2516, 245, 3, 2, 2, 2, 2517, 2518,
	7, 342, 2, 2, 2518, 2519, 7, 545, 2, 2, 2519, 2524, 5, 248, 125, 2, 2520,
	2521, 7, 551, 2, 2, 2521, 2523, 5, 248, 125, 2, 2522, 2520, 3, 2, 2, 2,
	2523, 2526, 3, 2, 2, 2, 2524, 2522, 3, 2, 2, 2, 2524, 2525, 3, 2, 2, 2,
	2525, 2527, 3, 2, 2, 2, 2526, 2524, 3, 2, 2, 2, 2527, 2528, 7, 546, 2,
	2, 2528, 247, 3, 2, 2, 2, 2529, 2531, 5, 714, 358, 2, 2530, 2532, 5, 736,
	369, 2, 2531, 2530, 3, 2, 2, 2, 2531, 2532, 3, 2, 2, 2, 2532, 2535, 3,
	2, 2, 2, 2533, 2534, 7, 277, 2, 2, 2534, 2536, 7, 279, 2, 2, 2535, 2533,
	3, 2, 2, 2, 2535, 2536, 3, 2, 2, 2, 2536, 2538, 3, 2, 2, 2, 2537, 2539,
	5, 230, 116, 2, 2538, 2537, 3, 2, 2, 2, 2538, 2539, 3, 2, 2, 2, 2539, 249,
	3, 2, 2, 2, 2540, 2541, 7, 347, 2, 2, 2541, 2544, 7, 91, 2, 2, 2542, 2543,
	7, 357, 2, 2, 2543, 2545, 5, 736, 369, 2, 2544, 2542, 3, 2, 2, 2, 2544,
	2545, 3, 2, 2, 2, 2545, 251, 3, 2, 2, 2, 2546, 2547, 7, 442, 2, 2, 2547,
	2548, 5, 760, 381, 2, 2548, 2553, 7, 206, 2, 2, 2549, 2554, 5, 254, 128,
	2, 2550, 2554, 5, 258, 130, 2, 2551, 2554, 5, 246, 124, 2, 2552, 2554,
	5, 250, 126, 2, 2553, 2549, 3, 2, 2, 2, 2553, 2550, 3, 2, 2, 2, 2553, 2551,
	3, 2, 2, 2, 2553, 2552, 3, 2, 2, 2, 2554, 2555, 3, 2, 2, 2, 2555, 2556,
	7, 563, 2, 2, 2556, 253, 3, 2, 2, 2, 2557, 2558, 7, 421, 2, 2, 2558, 2559,
	7, 286, 2, 2, 2559, 2561, 5, 736, 369, 2, 2560, 2562, 5, 256, 129, 2, 2561,
	2560, 3, 2, 2, 2, 2561, 2562, 3, 2, 2, 2, 2562, 2565, 3, 2, 2, 2, 2563,
	2564, 7, 277, 2, 2, 2564, 2566, 7, 279, 2, 2, 2565, 2563, 3, 2, 2, 2, 2565,
	2566, 3, 2, 2, 2, 2566, 255, 3, 2, 2, 2, 2567, 2570, 7, 186, 2, 2, 2568,
	2570, 7, 187, 2, 2, 2569, 2567, 3, 2, 2, 2, 2569, 2568, 3, 2, 2, 2, 2570,
	2571, 3, 2, 2, 2, 2571, 2572, 7, 42, 2, 2, 2572, 2573, 5, 736, 369, 2,
	2573, 257, 3, 2, 2, 2, 2574, 2578, 7, 462, 2, 2, 2575, 2576, 7, 463, 2,
	2, 2576, 2578, 7, 14, 2, 2, 2577, 2574, 3, 2, 2, 2, 2577, 2575, 3, 2, 2,
	2, 2578, 2579, 3, 2, 2, 2, 2579, 2580, 7, 545, 2, 2, 2580, 2581, 5, 536,
	269, 2, 2581, 2582, 7, 546, 2, 2, 2582, 2583, 7, 286, 2, 2, 2583, 2586,
	5, 736, 369, 2, 2584, 2585, 7, 277, 2, 2, 2585, 2587, 7, 279, 2, 2, 2586,
	2584, 3, 2, 2, 2, 2586, 2587, 3, 2, 2, 2, 2587, 259, 3, 2, 2, 2, 2588,
	2589, 5, 264, 133, 2, 2589, 2590, 9, 30, 2, 2, 2590, 2593, 3, 2, 2, 2,
	2591, 2593, 5, 262, 132, 2, 2592, 2588, 3, 2, 2, 2, 2592, 2591, 3, 2, 2,
	2, 2593, 2594, 3, 2, 2, 2, 2594, 2592, 3, 2, 2, 2, 2594, 2595, 3, 2, 2,
	2, 2595, 261, 3, 2, 2, 2, 2596, 2597, 7, 561, 2, 2, 2597, 2598, 7, 561,
	2, 2, 2598, 2599, 5, 688, 345, 2, 2599, 2600, 7, 560, 2, 2, 2600, 2601,
	7, 560, 2, 2, 2601, 263, 3, 2, 2, 2, 2602, 2603, 7, 85, 2, 2, 2603, 2630,
	5, 266, 134, 2, 2604, 2605, 7, 9, 2, 2, 2605, 2630, 5, 266, 134, 2, 2606,
	2608, 7, 170, 2, 2, 2607, 2609, 7, 8, 2, 2, 2608, 2607, 3, 2, 2, 2, 2608,
	2609, 3, 2, 2, 2, 2609, 2610, 3, 2, 2, 2, 2610, 2630, 5, 266, 134, 2, 2611,
	2612, 7, 441, 2, 2, 2612, 2630, 5, 266, 134, 2, 2613, 2630, 5, 306, 154,
	2, 2614, 2630, 5, 312, 157, 2, 2615, 2630, 5, 268, 135, 2, 2616, 2630,
	5, 270, 136, 2, 2617, 2630, 5, 272, 137, 2, 2618, 2630, 5, 274, 138, 2,
	2619, 2630, 5, 276, 139, 2, 2620, 2630, 5, 282, 142, 2, 2621, 2630, 5,
	286, 144, 2, 2622, 2630, 5, 296, 149, 2, 2623, 2630, 5, 298, 150, 2, 2624,
	2630, 5, 300, 151, 2, 2625, 2630, 5, 568, 285, 2, 2626, 2630, 5, 314, 158,
	2, 2627, 2630, 5, 302, 152, 2, 2628, 2630, 5, 304, 153, 2, 2629, 2602,
	3, 2, 2, 2, 2629, 2604, 3, 2, 2, 2, 2629, 2606, 3, 2, 2, 2, 2629, 2611,
	3, 2, 2, 2, 2629, 2613, 3, 2, 2, 2, 2629, 2614, 3, 2, 2, 2, 2629, 2615,
	3, 2, 2, 2, 2629, 2616, 3, 2, 2, 2, 2629, 2617, 3, 2, 2, 2, 2629, 2618,
	3, 2, 2, 2, 2629, 2619, 3, 2, 2, 2, 2629, 2620, 3, 2, 2, 2, 2629, 2621,
	3, 2, 2, 2, 2629, 2622, 3, 2, 2, 2, 2629, 2623, 3, 2, 2, 2, 2629, 2624,
	3, 2, 2, 2, 2629, 2625, 3, 2, 2, 2, 2629, 2626, 3, 2, 2, 2, 2629, 2627,
	3, 2, 2, 2, 2629, 2628, 3, 2, 2, 2, 2630, 265, 3, 2, 2, 2, 2631, 2633,
	10, 31, 2, 2, 2632, 2631, 3, 2, 2, 2, 2633, 2634, 3, 2, 2, 2, 2634, 2632,
	3, 2, 2, 2, 2634, 2635, 3, 2, 2, 2, 2635, 267, 3, 2, 2, 2, 2636, 2639,
	5, 746, 374, 2, 2637, 2639, 5, 744, 373, 2, 2638, 2636, 3, 2, 2, 2, 2638,
	2637, 3, 2, 2, 2, 2639, 2640, 3, 2, 2, 2, 2640, 2641, 7, 554, 2, 2, 2641,
	2642, 5, 536, 269, 2, 2642, 269, 3, 2, 2, 2, 2643, 2645, 7, 79, 2, 2, 2644,
	2646, 5, 688, 345, 2, 2645, 2644, 3, 2, 2, 2, 2645, 2646, 3, 2, 2, 2, 2646,
	2649, 3, 2, 2, 2, 2647, 2648, 7, 470, 2, 2, 2648, 2650, 5, 532, 267, 2,
	2649, 2647, 3, 2, 2, 2, 2649, 2650, 3, 2, 2, 2, 2650, 271, 3, 2, 2, 2,
	2651, 2653, 7, 144, 2, 2, 2652, 2654, 5, 688, 345, 2, 2653, 2652, 3, 2,
	2, 2, 2653, 2654, 3, 2, 2, 2, 2654, 2657, 3, 2, 2, 2, 2655, 2656, 7, 470,
	2, 2, 2656, 2658, 5, 532, 267, 2, 2657, 2655, 3, 2, 2, 2, 2657, 2658, 3,
	2, 2, 2, 2658, 273, 3, 2, 2, 2, 2659, 2660, 7, 169, 2, 2, 2660, 2661, 5,
	688, 345, 2, 2661, 275, 3, 2, 2, 2, 2662, 2663, 7, 179, 2, 2, 2663, 2664,
	5, 532, 267, 2, 2664, 2665, 7, 423, 2, 2, 2665, 2669, 5, 260, 131, 2, 2666,
	2668, 5, 278, 140, 2, 2667, 2666, 3, 2, 2, 2, 2668, 2671, 3, 2, 2, 2, 2669,
	2667, 3, 2, 2, 2, 2669, 2670, 3, 2, 2, 2, 2670, 2673, 3, 2, 2, 2, 2671,
	2669, 3, 2, 2, 2, 2672, 2674, 5, 280, 141, 2, 2673, 2672, 3, 2, 2, 2, 2673,
	2674, 3, 2, 2, 2, 2674, 2675, 3, 2, 2, 2, 2675, 2676, 7, 131, 2, 2, 2676,
	2677, 7, 179, 2, 2, 2677, 277, 3, 2, 2, 2, 2678, 2679, 7, 126, 2, 2, 2679,
	2680, 5, 532, 267, 2, 2680, 2681, 7, 423, 2, 2, 2681, 2682, 5, 260, 131,
	2, 2682, 279, 3, 2, 2, 2, 2683, 2684, 7, 125, 2, 2, 2684, 2685, 5, 260,
	131, 2, 2685, 281, 3, 2, 2, 2, 2686, 2688, 5, 688, 345, 2, 2687, 2686,
	3, 2, 2, 2, 2687, 2688, 3, 2, 2, 2, 2688, 2693, 3, 2, 2, 2, 2689, 2690,
	7, 472, 2, 2, 2690, 2694, 5, 532, 267, 2, 2691, 2692, 7, 162, 2, 2, 2692,
	2694, 5, 284, 143, 2, 2693, 2689, 3, 2, 2, 2, 2693, 2691, 3, 2, 2, 2, 2693,
	2694, 3, 2, 2, 2, 2694, 2695, 3, 2, 2, 2, 2695, 2696, 7, 234, 2, 2, 2696,
	2697, 5, 260, 131, 2, 2697, 2698, 7, 131, 2, 2, 2698, 2700, 7, 234, 2,
	2, 2699, 2701, 5, 688, 345, 2, 2700, 2699, 3, 2, 2, 2, 2700, 2701, 3, 2,
	2, 2, 2701, 283, 3, 2, 2, 2, 2702, 2703, 5, 704, 353, 2, 2703, 2705, 7,
	191, 2, 2, 2704, 2706, 7, 359, 2, 2, 2705, 2704, 3, 2, 2, 2, 2705, 2706,
	3, 2, 2, 2, 2706, 2707, 3, 2, 2, 2, 2707, 2708, 5, 292, 147, 2, 2708, 2709,
	7, 537, 2, 2, 2709, 2710, 5, 294, 148, 2, 2710, 2728, 3, 2, 2, 2, 2711,
	2712, 5, 708, 355, 2, 2712, 2725, 7, 191, 2, 2, 2713, 2719, 5, 706, 354,
	2, 2714, 2716, 7, 545, 2, 2, 2715, 2717, 5, 534, 268, 2, 2716, 2715, 3,
	2, 2, 2, 2716, 2717, 3, 2, 2, 2, 2717, 2718, 3, 2, 2, 2, 2718, 2720, 7,
	546, 2, 2, 2719, 2714, 3, 2, 2, 2, 2719, 2720, 3, 2, 2, 2, 2720, 2726,
	3, 2, 2, 2, 2721, 2722, 7, 545, 2, 2, 2722, 2723, 5, 348, 175, 2, 2723,
	2724, 7, 546, 2, 2, 2724, 2726, 3, 2, 2, 2, 2725, 2713, 3, 2, 2, 2, 2725,
	2721, 3, 2, 2, 2, 2726, 2728, 3, 2, 2, 2, 2727, 2702, 3, 2, 2, 2, 2727,
	2711, 3, 2, 2, 2, 2728, 285, 3, 2, 2, 2, 2729, 2730, 7, 159, 2, 2, 2730,
	2731, 5, 704, 353, 2, 2731, 2732, 7, 191, 2, 2, 2732, 2733, 5, 288, 145,
	2, 2733, 2736, 5, 314, 158, 2, 2734, 2735, 7, 370, 2, 2, 2735, 2737, 7,
	139, 2, 2, 2736, 2734, 3, 2, 2, 2, 2736, 2737, 3, 2, 2, 2, 2737, 287, 3,
	2, 2, 2, 2738, 2739, 5, 292, 147, 2, 2739, 2740, 7, 537, 2, 2, 2740, 2741,
	5, 294, 148, 2, 2741, 2752, 3, 2, 2, 2, 2742, 2743, 7, 189, 2, 2, 2743,
	2744, 7, 286, 2, 2, 2744, 2746, 5, 710, 356, 2, 2745, 2747, 5, 290, 146,
	2, 2746, 2745, 3, 2, 2, 2, 2746, 2747, 3, 2, 2, 2, 2747, 2752, 3, 2, 2,
	2, 2748, 2749, 7, 457, 2, 2, 2749, 2750, 7, 286, 2, 2, 2750, 2752, 5, 704,
	353, 2, 2751, 2738, 3, 2, 2, 2, 2751, 2742, 3, 2, 2, 2, 2751, 2748, 3,
	2, 2, 2, 2752, 289, 3, 2, 2, 2, 2753, 2754, 7, 29, 2, 2, 2754, 2755, 5,
	292, 147, 2, 2755, 2756, 7, 11, 2, 2, 2756, 2757, 5, 294, 148, 2, 2757,
	291, 3, 2, 2, 2, 2758, 2759, 5, 554, 278, 2, 2759, 293, 3, 2, 2, 2, 2760,
	2761, 5, 554, 278, 2, 2761, 295, 3, 2, 2, 2, 2762, 2763, 7, 279, 2, 2,
	2763, 297, 3, 2, 2, 2, 2764, 2766, 7, 337, 2, 2, 2765, 2767, 5, 694, 348,
	2, 2766, 2765, 3, 2, 2, 2, 2766, 2767, 3, 2, 2, 2, 2767, 299, 3, 2, 2,
	2, 2768, 2770, 7, 357, 2, 2, 2769, 2771, 5, 536, 269, 2, 2770, 2769, 3,
	2, 2, 2, 2770, 2771, 3, 2, 2, 2, 2771, 301, 3, 2, 2, 2, 2772, 2774, 7,
	45, 2, 2, 2773, 2772, 3, 2, 2, 2, 2773, 2774, 3, 2, 2, 2, 2774, 2775, 3,
	2, 2, 2, 2775, 2777, 5, 670, 336, 2, 2776, 2778, 5, 726, 364, 2, 2777,
	2776, 3, 2, 2, 2, 2777, 2778, 3, 2, 2, 2, 2778, 303, 3, 2, 2, 2, 2779,
	2780, 7, 321, 2, 2, 2780, 2781, 7, 365, 2, 2, 2781, 2782, 7, 545, 2, 2,
	2782, 2783, 5, 536, 269, 2, 2783, 2784, 7, 546, 2, 2, 2784, 305, 3, 2,
	2, 2, 2785, 2786, 7, 28, 2, 2, 2786, 2793, 5, 260, 131, 2, 2787, 2789,
	7, 137, 2, 2, 2788, 2790, 5, 308, 155, 2, 2789, 2788, 3, 2, 2, 2, 2790,
	2791, 3, 2, 2, 2, 2791, 2789, 3, 2, 2, 2, 2791, 2792, 3, 2, 2, 2, 2792,
	2794, 3, 2, 2, 2, 2793, 2787, 3, 2, 2, 2, 2793, 2794, 3, 2, 2, 2, 2794,
	2795, 3, 2, 2, 2, 2795, 2797, 7, 131, 2, 2, 2796, 2798, 5, 688, 345, 2,
	2797, 2796, 3, 2, 2, 2, 2797, 2798, 3, 2, 2, 2, 2798, 307, 3, 2, 2, 2,
	2799, 2800, 7, 470, 2, 2, 2800, 2805, 5, 694, 348, 2, 2801, 2802, 7, 298,
	2, 2, 2802, 2804, 5, 694, 348, 2, 2803, 2801, 3, 2, 2, 2, 2804, 2807, 3,
	2, 2, 2, 2805, 2803, 3, 2, 2, 2, 2805, 2806, 3, 2, 2, 2, 2806, 2808, 3,
	2, 2, 2, 2807, 2805, 3, 2, 2, 2, 2808, 2809, 7, 423, 2, 2, 2809, 2810,
	5, 260, 131, 2, 2810, 309, 3, 2, 2, 2, 2811, 2813, 7, 104, 2, 2, 2812,
	2811, 3, 2, 2, 2, 2812, 2813, 3, 2, 2, 2, 2813, 2815, 3, 2, 2, 2, 2814,
	2816, 5, 232, 117, 2, 2815, 2814, 3, 2, 2, 2, 2816, 2817, 3, 2, 2, 2, 2817,
	2815, 3, 2, 2, 2, 2817, 2818, 3, 2, 2, 2, 2818, 2820, 3, 2, 2, 2, 2819,
	2812, 3, 2, 2, 2, 2819, 2820, 3, 2, 2, 2, 2820, 2821, 3, 2, 2, 2, 2821,
	2822, 5, 306, 154, 2, 2822, 311, 3, 2, 2, 2, 2823, 2825, 7, 104, 2, 2,
	2824, 2823, 3, 2, 2, 2, 2824, 2825, 3, 2, 2, 2, 2825, 2827, 3, 2, 2, 2,
	2826, 2828, 5, 232, 117, 2, 2827, 2826, 3, 2, 2, 2, 2828, 2829, 3, 2, 2,
	2, 2829, 2827, 3, 2, 2, 2, 2829, 2830, 3, 2, 2, 2, 2830, 2831, 3, 2, 2,
	2, 2831, 2832, 5, 306, 154, 2, 2832, 313, 3, 2, 2, 2, 2833, 2838, 5, 316,
	159, 2, 2834, 2838, 5, 320, 161, 2, 2835, 2838, 5, 322, 162, 2, 2836, 2838,
	5, 332, 167, 2, 2837, 2833, 3, 2, 2, 2, 2837, 2834, 3, 2, 2, 2, 2837, 2835,
	3, 2, 2, 2, 2837, 2836, 3, 2, 2, 2, 2838, 315, 3, 2, 2, 2, 2839, 2840,
	7, 142, 2, 2, 2840, 2841, 7, 181, 2, 2, 2841, 2851, 5, 536, 269, 2, 2842,
	2844, 5, 654, 328, 2, 2843, 2845, 5, 608, 305, 2, 2844, 2843, 3, 2, 2,
	2, 2844, 2845, 3, 2, 2, 2, 2845, 2852, 3, 2, 2, 2, 2846, 2848, 5, 608,
	305, 2, 2847, 2849, 5, 318, 160, 2, 2848, 2847, 3, 2, 2, 2, 2848, 2849,
	3, 2, 2, 2, 2849, 2852, 3, 2, 2, 2, 2850, 2852, 5, 318, 160, 2, 2851, 2842,
	3, 2, 2, 2, 2851, 2846, 3, 2, 2, 2, 2851, 2850, 3, 2, 2, 2, 2851, 2852,
	3, 2, 2, 2, 2852, 317, 3, 2, 2, 2, 2853, 2854, 9, 32, 2, 2, 2854, 2855,
	5, 654, 328, 2, 2855, 319, 3, 2, 2, 2, 2856, 2864, 5, 492, 247, 2, 2857,
	2864, 5, 504, 253, 2, 2858, 2864, 5, 348, 175, 2, 2859, 2864, 5, 466, 234,
	2, 2860, 2864, 5, 472, 237, 2, 2861, 2864, 5, 474, 238, 2, 2862, 2864,
	5, 346, 174, 2, 2863, 2856, 3, 2, 2, 2, 2863, 2857, 3, 2, 2, 2, 2863, 2858,
	3, 2, 2, 2, 2863, 2859, 3, 2, 2, 2, 2863, 2860, 3, 2, 2, 2, 2863, 2861,
	3, 2, 2, 2, 2863, 2862, 3, 2, 2, 2, 2864, 321, 3, 2, 2, 2, 2865, 2870,
	5, 324, 163, 2, 2866, 2870, 5, 326, 164, 2, 2867, 2870, 5, 328, 165, 2,
	2868, 2870, 5, 330, 166, 2, 2869, 2865, 3, 2, 2, 2, 2869, 2866, 3, 2, 2,
	2, 2869, 2867, 3, 2, 2, 2, 2869, 2868, 3, 2, 2, 2, 2870, 323, 3, 2, 2,
	2, 2871, 2872, 7, 57, 2, 2, 2872, 2873, 5, 706, 354, 2, 2873, 325, 3, 2,
	2, 2, 2874, 2875, 7, 292, 2, 2, 2875, 2881, 5, 706, 354, 2, 2876, 2878,
	7, 545, 2, 2, 2877, 2879, 5, 534, 268, 2, 2878, 2877, 3, 2, 2, 2, 2878,
	2879, 3, 2, 2, 2, 2879, 2880, 3, 2, 2, 2, 2880, 2882, 7, 546, 2, 2, 2881,
	2876, 3, 2, 2, 2, 2881, 2882, 3, 2, 2, 2, 2882, 327, 3, 2, 2, 2, 2883,
	2884, 7, 150, 2, 2, 2884, 2905, 5, 706, 354, 2, 2885, 2886, 7, 204, 2,
	2, 2886, 2891, 5, 702, 352, 2, 2887, 2888, 7, 551, 2, 2, 2888, 2890, 5,
	702, 352, 2, 2889, 2887, 3, 2, 2, 2, 2890, 2893, 3, 2, 2, 2, 2891, 2889,
	3, 2, 2, 2, 2891, 2892, 3, 2, 2, 2, 2892, 2906, 3, 2, 2, 2, 2893, 2891,
	3, 2, 2, 2, 2894, 2895, 7, 41, 2, 2, 2895, 2896, 7, 60, 2, 2, 2896, 2897,
	7, 204, 2, 2, 2897, 2902, 5, 702, 352, 2, 2898, 2899, 7, 551, 2, 2, 2899,
	2901, 5, 702, 352, 2, 2900, 2898, 3, 2, 2, 2, 2901, 2904, 3, 2, 2, 2, 2902,
	2900, 3, 2, 2, 2, 2902, 2903, 3, 2, 2, 2, 2903, 2906, 3, 2, 2, 2, 2904,
	2902, 3, 2, 2, 2, 2905, 2885, 3, 2, 2, 2, 2905, 2894, 3, 2, 2, 2, 2906,
	329, 3, 2, 2, 2, 2907, 2908, 7, 292, 2, 2, 2908, 2909, 5, 702, 352, 2,
	2909, 2912, 7, 162, 2, 2, 2910, 2913, 5, 348, 175, 2, 2911, 2913, 5, 536,
	269, 2, 2912, 2910, 3, 2, 2, 2, 2912, 2911, 3, 2, 2, 2, 2913, 2915, 3,
	2, 2, 2, 2914, 2916, 5, 608, 305, 2, 2915, 2914, 3, 2, 2, 2, 2915, 2916,
	3, 2, 2, 2, 2916, 331, 3, 2, 2, 2, 2917, 2923, 5, 334, 168, 2, 2918, 2923,
	5, 336, 169, 2, 2919, 2923, 5, 338, 170, 2, 2920, 2923, 5, 342, 172, 2,
	2921, 2923, 5, 344, 173, 2, 2922, 2917, 3, 2, 2, 2, 2922, 2918, 3, 2, 2,
	2, 2922, 2919, 3, 2, 2, 2, 2922, 2920, 3, 2, 2, 2, 2922, 2921, 3, 2, 2,
	2, 2923, 333, 3, 2, 2, 2, 2924, 2925, 7, 386, 2, 2, 2925, 2939, 7, 436,
	2, 2, 2926, 2927, 7, 340, 2, 2, 2927, 2940, 9, 33, 2, 2, 2928, 2929, 7,
	207, 2, 2, 2929, 2933, 7, 218, 2, 2, 2930, 2934, 7, 382, 2, 2, 2931, 2932,
	7, 340, 2, 2, 2932, 2934, 7, 65, 2, 2, 2933, 2930, 3, 2, 2, 2, 2933, 2931,
	3, 2, 2, 2, 2934, 2940, 3, 2, 2, 2, 2935, 2936, 7, 454, 2, 2, 2936, 2937,
	7, 362, 2, 2, 2937, 2938, 7, 377, 2, 2, 2938, 2940, 5, 664, 333, 2, 2939,
	2926, 3, 2, 2, 2, 2939, 2928, 3, 2, 2, 2, 2939, 2935, 3, 2, 2, 2, 2939,
	2940, 3, 2, 2, 2, 2940, 2943, 3, 2, 2, 2, 2941, 2942, 7, 253, 2, 2, 2942,
	2944, 5, 758, 380, 2, 2943, 2941, 3, 2, 2, 2, 2943, 2944, 3, 2, 2, 2, 2944,
	335, 3, 2, 2, 2, 2945, 2946, 7, 386, 2, 2, 2946, 2956, 9, 34, 2, 2, 2947,
	2957, 7, 8, 2, 2, 2948, 2953, 5, 686, 344, 2, 2949, 2950, 7, 551, 2, 2,
	2950, 2952, 5, 686, 344, 2, 2951, 2949, 3, 2, 2, 2, 2952, 2955, 3, 2, 2,
	2, 2953, 2951, 3, 2, 2, 2, 2953, 2954, 3, 2, 2, 2, 2954, 2957, 3, 2, 2,
	2, 2955, 2953, 3, 2, 2, 2, 2956, 2947, 3, 2, 2, 2, 2956, 2948, 3, 2, 2,
	2, 2957, 2958, 3, 2, 2, 2, 2958, 2959, 9, 20, 2, 2, 2959, 337, 3, 2, 2,
	2, 2960, 2962, 7, 64, 2, 2, 2961, 2963, 7, 475, 2, 2, 2962, 2961, 3, 2,
	2, 2, 2962, 2963, 3, 2, 2, 2, 2963, 2977, 3, 2, 2, 2, 2964, 2965, 7, 63,
	2, 2, 2965, 2978, 5, 536, 269, 2, 2966, 2975, 7, 160, 2, 2, 2967, 2968,
	7, 82, 2, 2, 2968, 2976, 5, 536, 269, 2, 2969, 2976, 7, 81, 2, 2, 2970,
	2973, 5, 536, 269, 2, 2971, 2972, 7, 551, 2, 2, 2972, 2974, 5, 536, 269,
	2, 2973, 2971, 3, 2, 2, 2, 2973, 2974, 3, 2, 2, 2, 2974, 2976, 3, 2, 2,
	2, 2975, 2967, 3, 2, 2, 2, 2975, 2969, 3, 2, 2, 2, 2975, 2970, 3, 2, 2,
	2, 2976, 2978, 3, 2, 2, 2, 2977, 2964, 3, 2, 2, 2, 2977, 2966, 3, 2, 2,
	2, 2977, 2978, 3, 2, 2, 2, 2978, 2980, 3, 2, 2, 2, 2979, 2981, 5, 340,
	171, 2, 2980, 2979, 3, 2, 2, 2, 2980, 2981, 3, 2, 2, 2, 2981, 339, 3, 2,
	2, 2, 2982, 2984, 7, 476, 2, 2, 2983, 2985, 9, 35, 2, 2, 2984, 2983, 3,
	2, 2, 2, 2984, 2985, 3, 2, 2, 2, 2985, 2987, 3, 2, 2, 2, 2986, 2988, 9,
	36, 2, 2, 2987, 2986, 3, 2, 2, 2, 2987, 2988, 3, 2, 2, 2, 2988, 341, 3,
	2, 2, 2, 2989, 2991, 7, 362, 2, 2, 2990, 2992, 7, 475, 2, 2, 2991, 2990,
	3, 2, 2, 2, 2991, 2992, 3, 2, 2, 2, 2992, 3000, 3, 2, 2, 2, 2993, 2995,
	7, 434, 2, 2, 2994, 2996, 7, 369, 2, 2, 2995, 2994, 3, 2, 2, 2, 2995, 2996,
	3, 2, 2, 2, 2996, 2997, 3, 2, 2, 2, 2997, 3001, 5, 662, 332, 2, 2998, 2999,
	7, 160, 2, 2, 2999, 3001, 5, 758, 380, 2, 3000, 2993, 3, 2, 2, 2, 3000,
	2998, 3, 2, 2, 2, 3000, 3001, 3, 2, 2, 2, 3001, 343, 3, 2, 2, 2, 3002,
	3003, 7, 369, 2, 2, 3003, 3004, 5, 662, 332, 2, 3004, 345, 3, 2, 2, 2,
	3005, 3006, 7, 145, 2, 2, 3006, 3011, 7, 323, 2, 2, 3007, 3008, 7, 386,
	2, 2, 3008, 3009, 7, 407, 2, 2, 3009, 3010, 7, 565, 2, 2, 3010, 3012, 5,
	758, 380, 2, 3011, 3007, 3, 2, 2, 2, 3011, 3012, 3, 2, 2, 2, 3012, 3015,
	3, 2, 2, 2, 3013, 3014, 7, 204, 2, 2, 3014, 3016, 5, 716, 359, 2, 3015,
	3013, 3, 2, 2, 2, 3015, 3016, 3, 2, 2, 2, 3016, 3017, 3, 2, 2, 2, 3017,
	3023, 7, 162, 2, 2, 3018, 3024, 5, 348, 175, 2, 3019, 3024, 5, 466, 234,
	2, 3020, 3024, 5, 472, 237, 2, 3021, 3024, 5, 474, 238, 2, 3022, 3024,
	5, 492, 247, 2, 3023, 3018, 3, 2, 2, 2, 3023, 3019, 3, 2, 2, 2, 3023, 3020,
	3, 2, 2, 2, 3023, 3021, 3, 2, 2, 2, 3023, 3022, 3, 2, 2, 2, 3024, 347,
	3, 2, 2, 2, 3025, 3027, 5, 350, 176, 2, 3026, 3025, 3, 2, 2, 2, 3026, 3027,
	3, 2, 2, 2, 3027, 3028, 3, 2, 2, 2, 3028, 3033, 5, 358, 180, 2, 3029, 3032,
	5, 460, 231, 2, 3030, 3032, 5, 456, 229, 2, 3031, 3029, 3, 2, 2, 2, 3031,
	3030, 3, 2, 2, 2, 3032, 3035, 3, 2, 2, 2, 3033, 3031, 3, 2, 2, 2, 3033,
	3034, 3, 2, 2, 2, 3034, 349, 3, 2, 2, 2, 3035, 3033, 3, 2, 2, 2, 3036,
	3037, 7, 474, 2, 2, 3037, 3042, 5, 352, 177, 2, 3038, 3039, 7, 551, 2,
	2, 3039, 3041, 5, 352, 177, 2, 3040, 3038, 3, 2, 2, 2, 3041, 3044, 3, 2,
	2, 2, 3042, 3040, 3, 2, 2, 2, 3042, 3043, 3, 2, 2, 2, 3043, 351, 3, 2,
	2, 2, 3044, 3042, 3, 2, 2, 2, 3045, 3057, 5, 684, 343, 2, 3046, 3047, 7,
	545, 2, 2, 3047, 3052, 5, 714, 358, 2, 3048, 3049, 7, 551, 2, 2, 3049,
	3051, 5, 714, 358, 2, 3050, 3048, 3, 2, 2, 2, 3051, 3054, 3, 2, 2, 2, 3052,
	3050, 3, 2, 2, 2, 3052, 3053, 3, 2, 2, 2, 3053, 3055, 3, 2, 2, 2, 3054,
	3052, 3, 2, 2, 2, 3055, 3056, 7, 546, 2, 2, 3056, 3058, 3, 2, 2, 2, 3057,
	3046, 3, 2, 2, 2, 3057, 3058, 3, 2, 2, 2, 3058, 3059, 3, 2, 2, 2, 3059,
	3060, 7, 15, 2, 2, 3060, 3061, 7, 545, 2, 2, 3061, 3063, 5, 358, 180, 2,
	3062, 3064, 5, 456, 229, 2, 3063, 3062, 3, 2, 2, 2, 3063, 3064, 3, 2, 2,
	2, 3064, 3065, 3, 2, 2, 2, 3065, 3067, 7, 546, 2, 2, 3066, 3068, 5, 354,
	178, 2, 3067, 3066, 3, 2, 2, 2, 3067, 3068, 3, 2, 2, 2, 3068, 3070, 3,
	2, 2, 2, 3069, 3071, 5, 356, 179, 2, 3070, 3069, 3, 2, 2, 2, 3070, 3071,
	3, 2, 2, 2, 3071, 353, 3, 2, 2, 2, 3072, 3073, 7, 374, 2, 2, 3073, 3074,
	9, 37, 2, 2, 3074, 3075, 7, 153, 2, 2, 3075, 3076, 7, 42, 2, 2, 3076, 3078,
	5, 714, 358, 2, 3077, 3079, 7, 16, 2, 2, 3078, 3077, 3, 2, 2, 2, 3078,
	3079, 3, 2, 2, 2, 3079, 3081, 3, 2, 2, 2, 3080, 3082, 7, 113, 2, 2, 3081,
	3080, 3, 2, 2, 2, 3081, 3082, 3, 2, 2, 2, 3082, 3085, 3, 2, 2, 2, 3083,
	3084, 7, 280, 2, 2, 3084, 3086, 7, 153, 2, 2, 3085, 3083, 3, 2, 2, 2, 3085,
	3086, 3, 2, 2, 2, 3086, 3089, 3, 2, 2, 2, 3087, 3088, 7, 280, 2, 2, 3088,
	3090, 7, 214, 2, 2, 3089, 3087, 3, 2, 2, 2, 3089, 3090, 3, 2, 2, 2, 3090,
	3109, 3, 2, 2, 2, 3091, 3092, 7, 551, 2, 2, 3092, 3094, 5, 714, 358, 2,
	3093, 3095, 7, 16, 2, 2, 3094, 3093, 3, 2, 2, 2, 3094, 3095, 3, 2, 2, 2,
	3095, 3097, 3, 2, 2, 2, 3096, 3098, 7, 113, 2, 2, 3097, 3096, 3, 2, 2,
	2, 3097, 3098, 3, 2, 2, 2, 3098, 3101, 3, 2, 2, 2, 3099, 3100, 7, 280,
	2, 2, 3100, 3102, 7, 153, 2, 2, 3101, 3099, 3, 2, 2, 2, 3101, 3102, 3,
	2, 2, 2, 3102, 3105, 3, 2, 2, 2, 3103, 3104, 7, 280, 2, 2, 3104, 3106,
	7, 214, 2, 2, 3105, 3103, 3, 2, 2, 2, 3105, 3106, 3, 2, 2, 2, 3106, 3108,
	3, 2, 2, 2, 3107, 3091, 3, 2, 2, 2, 3108, 3111, 3, 2, 2, 2, 3109, 3107,
	3, 2, 2, 2, 3109, 3110, 3, 2, 2, 2, 3110, 3112, 3, 2, 2, 2, 3111, 3109,
	3, 2, 2, 2, 3112, 3113, 7, 386, 2, 2, 3113, 3114, 5, 714, 358, 2, 3114,
	355, 3, 2, 2, 2, 3115, 3116, 7, 93, 2, 2, 3116, 3121, 5, 714, 358, 2, 3117,
	3118, 7, 551, 2, 2, 3118, 3120, 5, 714, 358, 2, 3119, 3117, 3, 2, 2, 2,
	3120, 3123, 3, 2, 2, 2, 3121, 3119, 3, 2, 2, 2, 3121, 3122, 3, 2, 2, 2,
	3122, 3124, 3, 2, 2, 2, 3123, 3121, 3, 2, 2, 2, 3124, 3125, 7, 386, 2,
	2, 3125, 3126, 5, 714, 358, 2, 3126, 3127, 7, 434, 2, 2, 3127, 3128, 5,
	536, 269, 2, 3128, 3129, 7, 107, 2, 2, 3129, 3130, 5, 536, 269, 2, 3130,
	357, 3, 2, 2, 2, 3131, 3135, 5, 360, 181, 2, 3132, 3134, 5, 362, 182, 2,
	3133, 3132, 3, 2, 2, 2, 3134, 3137, 3, 2, 2, 2, 3135, 3133, 3, 2, 2, 2,
	3135, 3136, 3, 2, 2, 2, 3136, 359, 3, 2, 2, 2, 3137, 3135, 3, 2, 2, 2,
	3138, 3144, 5, 364, 183, 2, 3139, 3140, 7, 545, 2, 2, 3140, 3141, 5, 358,
	180, 2, 3141, 3142, 7, 546, 2, 2, 3142, 3144, 3, 2, 2, 2, 3143, 3138, 3,
	2, 2, 2, 3143, 3139, 3, 2, 2, 2, 3144, 361, 3, 2, 2, 2, 3145, 3147, 7,
	445, 2, 2, 3146, 3148, 7, 8, 2, 2, 3147, 3146, 3, 2, 2, 2, 3147, 3148,
	3, 2, 2, 2, 3148, 3152, 3, 2, 2, 2, 3149, 3152, 7, 201, 2, 2, 3150, 3152,
	7, 244, 2, 2, 3151, 3145, 3, 2, 2, 2, 3151, 3149, 3, 2, 2, 2, 3151, 3150,
	3, 2, 2, 2, 3152, 3153, 3, 2, 2, 2, 3153, 3154, 5, 360, 181, 2, 3154, 363,
	3, 2, 2, 2, 3155, 3157, 7, 378, 2, 2, 3156, 3158, 9, 38, 2, 2, 3157, 3156,
	3, 2, 2, 2, 3157, 3158, 3, 2, 2, 2, 3158, 3168, 3, 2, 2, 2, 3159, 3169,
	7, 548, 2, 2, 3160, 3165, 5, 366, 184, 2, 3161, 3162, 7, 551, 2, 2, 3162,
	3164, 5, 366, 184, 2, 3163, 3161, 3, 2, 2, 2, 3164, 3167, 3, 2, 2, 2, 3165,
	3163, 3, 2, 2, 2, 3165, 3166, 3, 2, 2, 2, 3166, 3169, 3, 2, 2, 2, 3167,
	3165, 3, 2, 2, 2, 3168, 3159, 3, 2, 2, 2, 3168, 3160, 3, 2, 2, 2, 3169,
	3171, 3, 2, 2, 2, 3170, 3172, 5, 654, 328, 2, 3171, 3170, 3, 2, 2, 2, 3171,
	3172, 3, 2, 2, 2, 3172, 3173, 3, 2, 2, 2, 3173, 3175, 5, 368, 185, 2, 3174,
	3176, 5, 652, 327, 2, 3175, 3174, 3, 2, 2, 2, 3175, 3176, 3, 2, 2, 2, 3176,
	3178, 3, 2, 2, 2, 3177, 3179, 5, 410, 206, 2, 3178, 3177, 3, 2, 2, 2, 3178,
	3179, 3, 2, 2, 2, 3179, 3181, 3, 2, 2, 2, 3180, 3182, 5, 414, 208, 2, 3181,
	3180, 3, 2, 2, 2, 3181, 3182, 3, 2, 2, 2, 3182, 3184, 3, 2, 2, 2, 3183,
	3185, 5, 426, 214, 2, 3184, 3183, 3, 2, 2, 2, 3184, 3185, 3, 2, 2, 2, 3185,
	365, 3, 2, 2, 2, 3186, 3188, 5, 370, 186, 2, 3187, 3189, 5, 648, 325, 2,
	3188, 3187, 3, 2, 2, 2, 3188, 3189, 3, 2, 2, 2, 3189, 367, 3, 2, 2, 2,
	3190, 3191, 7, 165, 2, 2, 3191, 3192, 5, 372, 187, 2, 3192, 369, 3, 2,
	2, 2, 3193, 3194, 5, 716, 359, 2, 3194, 3195, 7, 538, 2, 2, 3195, 3196,
	7, 548, 2, 2, 3196, 3204, 3, 2, 2, 2, 3197, 3198, 5, 766, 384, 2, 3198,
	3199, 7, 538, 2, 2, 3199, 3201, 3, 2, 2, 2, 3200, 3197, 3, 2, 2, 2, 3200,
	3201, 3, 2, 2, 2, 3201, 3202, 3, 2, 2, 2, 3202, 3204, 5, 536, 269, 2, 3203,
	3193, 3, 2, 2, 2, 3203, 3200, 3, 2, 2, 2, 3204, 371, 3, 2, 2, 2, 3205,
	3210, 5, 374, 188, 2, 3206, 3207, 7, 551, 2, 2, 3207, 3209, 5, 374, 188,
	2, 3208, 3206, 3, 2, 2, 2, 3209, 3212, 3, 2, 2, 2, 3210, 3208, 3, 2, 2,
	2, 3210, 3211, 3, 2, 2, 2, 3211, 373, 3, 2, 2, 2, 3212, 3210, 3, 2, 2,
	2, 3213, 3217, 5, 376, 189, 2, 3214, 3216, 5, 380, 191, 2, 3215, 3214,
	3, 2, 2, 2, 3216, 3219, 3, 2, 2, 2, 3217, 3215, 3, 2, 2, 2, 3217, 3218,
	3, 2, 2, 2, 3218, 3222, 3, 2, 2, 2, 3219, 3217, 3, 2, 2, 2, 3220, 3223,
	5, 392, 197, 2, 3221, 3223, 5, 404, 203, 2, 3222, 3220, 3, 2, 2, 2, 3222,
	3221, 3, 2, 2, 2, 3222, 3223, 3, 2, 2, 2, 3223, 375, 3, 2, 2, 2, 3224,
	3228, 5, 378, 190, 2, 3225, 3227, 5, 390, 196, 2, 3226, 3225, 3, 2, 2,
	2, 3227, 3230, 3, 2, 2, 2, 3228, 3226, 3, 2, 2, 2, 3228, 3229, 3, 2, 2,
	2, 3229, 3232, 3, 2, 2, 2, 3230, 3228, 3, 2, 2, 2, 3231, 3233, 5, 650,
	326, 2, 3232, 3231, 3, 2, 2, 2, 3232, 3233, 3, 2, 2, 2, 3233, 377, 3, 2,
	2, 2, 3234, 3237, 5, 522, 262, 2, 3235, 3238, 5, 392, 197, 2, 3236, 3238,
	5, 404, 203, 2, 3237, 3235, 3, 2, 2, 2, 3237, 3236, 3, 2, 2, 2, 3237, 3238,
	3, 2, 2, 2, 3238, 3258, 3, 2, 2, 2, 3239, 3240, 7, 545, 2, 2, 3240, 3244,
	5, 374, 188, 2, 3241, 3243, 5, 362, 182, 2, 3242, 3241, 3, 2, 2, 2, 3243,
	3246, 3, 2, 2, 2, 3244, 3242, 3, 2, 2, 2, 3244, 3245, 3, 2, 2, 2, 3245,
	3247, 3, 2, 2, 2, 3246, 3244, 3, 2, 2, 2, 3247, 3250, 7, 546, 2, 2, 3248,
	3251, 5, 392, 197, 2, 3249, 3251, 5, 404, 203, 2, 3250, 3248, 3, 2, 2,
	2, 3250, 3249, 3, 2, 2, 2, 3250, 3251, 3, 2, 2, 2, 3251, 3258, 3, 2, 2,
	2, 3252, 3253, 7, 290, 2, 2, 3253, 3254, 7, 545, 2, 2, 3254, 3255, 5, 522,
	262, 2, 3255, 3256, 7, 546, 2, 2, 3256, 3258, 3, 2, 2, 2, 3257, 3234, 3,
	2, 2, 2, 3257, 3239, 3, 2, 2, 2, 3257, 3252, 3, 2, 2, 2, 3258, 379, 3,
	2, 2, 2, 3259, 3261, 5, 388, 195, 2, 3260, 3259, 3, 2, 2, 2, 3260, 3261,
	3, 2, 2, 2, 3261, 3263, 3, 2, 2, 2, 3262, 3264, 9, 39, 2, 2, 3263, 3262,
	3, 2, 2, 2, 3263, 3264, 3, 2, 2, 2, 3264, 3267, 3, 2, 2, 2, 3265, 3268,
	7, 195, 2, 2, 3266, 3268, 5, 386, 194, 2, 3267, 3265, 3, 2, 2, 2, 3267,
	3266, 3, 2, 2, 2, 3267, 3268, 3, 2, 2, 2, 3268, 3269, 3, 2, 2, 2, 3269,
	3270, 7, 210, 2, 2, 3270, 3272, 5, 376, 189, 2, 3271, 3273, 5, 388, 195,
	2, 3272, 3271, 3, 2, 2, 2, 3272, 3273, 3, 2, 2, 2, 3273, 3278, 3, 2, 2,
	2, 3274, 3277, 5, 382, 192, 2, 3275, 3277, 5, 384, 193, 2, 3276, 3274,
	3, 2, 2, 2, 3276, 3275, 3, 2, 2, 2, 3277, 3280, 3, 2, 2, 2, 3278, 3276,
	3, 2, 2, 2, 3278, 3279, 3, 2, 2, 2, 3279, 381, 3, 2, 2, 2, 3280, 3278,
	3, 2, 2, 2, 3281, 3282, 7, 291, 2, 2, 3282, 3283, 5, 532, 267, 2, 3283,
	383, 3, 2, 2, 2, 3284, 3285, 7, 455, 2, 2, 3285, 3286, 7, 545, 2, 2, 3286,
	3291, 5, 714, 358, 2, 3287, 3288, 7, 551, 2, 2, 3288, 3290, 5, 714, 358,
	2, 3289, 3287, 3, 2, 2, 2, 3290, 3293, 3, 2, 2, 2, 3291, 3289, 3, 2, 2,
	2, 3291, 3292, 3, 2, 2, 2, 3292, 3294, 3, 2, 2, 2, 3293, 3291, 3, 2, 2,
	2, 3294, 3295, 7, 546, 2, 2, 3295, 385, 3, 2, 2, 2, 3296, 3298, 9, 40,
	2, 2, 3297, 3299, 7, 300, 2, 2, 3298, 3297, 3, 2, 2, 2, 3298, 3299, 3,
	2, 2, 2, 3299, 387, 3, 2, 2, 2, 3300, 3301, 7, 308, 2, 2, 3301, 3309, 7,
	42, 2, 2, 3302, 3305, 7, 545, 2, 2, 3303, 3306, 5, 358, 180, 2, 3304, 3306,
	5, 534, 268, 2, 3305, 3303, 3, 2, 2, 2, 3305, 3304, 3, 2, 2, 2, 3305, 3306,
	3, 2, 2, 2, 3306, 3307, 3, 2, 2, 2, 3307, 3310, 7, 546, 2, 2, 3308, 3310,
	5, 534, 268, 2, 3309, 3302, 3, 2, 2, 2, 3309, 3308, 3, 2, 2, 2, 3310, 389,
	3, 2, 2, 2, 3311, 3312, 7, 464, 2, 2, 3312, 3313, 7, 29, 2, 2, 3313, 3314,
	9, 41, 2, 2, 3314, 3320, 5, 536, 269, 2, 3315, 3316, 7, 15, 2, 2, 3316,
	3317, 7, 286, 2, 2, 3317, 3318, 9, 42, 2, 2, 3318, 3320, 5, 536, 269, 2,
	3319, 3311, 3, 2, 2, 2, 3319, 3315, 3, 2, 2, 2, 3320, 391, 3, 2, 2, 2,
	3321, 3323, 7, 322, 2, 2, 3322, 3324, 7, 491, 2, 2, 3323, 3322, 3, 2, 2,
	2, 3323, 3324, 3, 2, 2, 2, 3324, 3325, 3, 2, 2, 2, 3325, 3326, 7, 545,
	2, 2, 3326, 3331, 5, 394, 198, 2, 3327, 3328, 7, 551, 2, 2, 3328, 3330,
	5, 394, 198, 2, 3329, 3327, 3, 2, 2, 2, 3330, 3333, 3, 2, 2, 2, 3331, 3329,
	3, 2, 2, 2, 3331, 3332, 3, 2, 2, 2, 3332, 3334, 3, 2, 2, 2, 3333, 3331,
	3, 2, 2, 2, 3334, 3335, 5, 396, 199, 2, 3335, 3336, 5, 398, 200, 2, 3336,
	3337, 7, 546, 2, 2, 3337, 393, 3, 2, 2, 2, 3338, 3339, 5, 682, 342, 2,
	3339, 3340, 7, 545, 2, 2, 3340, 3341, 5, 536, 269, 2, 3341, 3343, 7, 546,
	2, 2, 3342, 3344, 5, 648, 325, 2, 3343, 3342, 3, 2, 2, 2, 3343, 3344, 3,
	2, 2, 2, 3344, 395, 3, 2, 2, 2, 3345, 3358, 7, 162, 2, 2, 3346, 3359, 5,
	714, 358, 2, 3347, 3348, 7, 545, 2, 2, 3348, 3353, 5, 714, 358, 2, 3349,
	3350, 7, 551, 2, 2, 3350, 3352, 5, 714, 358, 2, 3351, 3349, 3, 2, 2, 2,
	3352, 3355, 3, 2, 2, 2, 3353, 3351, 3, 2, 2, 2, 3353, 3354, 3, 2, 2, 2,
	3354, 3356, 3, 2, 2, 2, 3355, 3353, 3, 2, 2, 2, 3356, 3357, 7, 546, 2,
	2, 3357, 3359, 3, 2, 2, 2, 3358, 3346, 3, 2, 2, 2, 3358, 3347, 3, 2, 2,
	2, 3359, 397, 3, 2, 2, 2, 3360, 3361, 7, 191, 2, 2, 3361, 3379, 7, 545,
	2, 2, 3362, 3380, 5, 358, 180, 2, 3363, 3368, 7, 12, 2, 2, 3364, 3365,
	7, 551, 2, 2, 3365, 3367, 7, 12, 2, 2, 3366, 3364, 3, 2, 2, 2, 3367, 3370,
	3, 2, 2, 2, 3368, 3366, 3, 2, 2, 2, 3368, 3369, 3, 2, 2, 2, 3369, 3380,
	3, 2, 2, 2, 3370, 3368, 3, 2, 2, 2, 3371, 3376, 5, 400, 201, 2, 3372, 3373,
	7, 551, 2, 2, 3373, 3375, 5, 400, 201, 2, 3374, 3372, 3, 2, 2, 2, 3375,
	3378, 3, 2, 2, 2, 3376, 3374, 3, 2, 2, 2, 3376, 3377, 3, 2, 2, 2, 3377,
	3380, 3, 2, 2, 2, 3378, 3376, 3, 2, 2, 2, 3379, 3362, 3, 2, 2, 2, 3379,
	3363, 3, 2, 2, 2, 3379, 3371, 3, 2, 2, 2, 3380, 3381, 3, 2, 2, 2, 3381,
	3382, 7, 546, 2, 2, 3382, 399, 3, 2, 2, 2, 3383, 3385, 5, 402, 202, 2,
	3384, 3386, 5, 648, 325, 2, 3385, 3384, 3, 2, 2, 2, 3385, 3386, 3, 2, 2,
	2, 3386, 401, 3, 2, 2, 2, 3387, 3394, 5, 536, 269, 2, 3388, 3390, 7, 545,
	2, 2, 3389, 3391, 5, 534, 268, 2, 3390, 3389, 3, 2, 2, 2, 3390, 3391, 3,
	2, 2, 2, 3391, 3392, 3, 2, 2, 2, 3392, 3394, 7, 546, 2, 2, 3393, 3387,
	3, 2, 2, 2, 3393, 3388, 3, 2, 2, 2, 3394, 403, 3, 2, 2, 2, 3395, 3398,
	7, 448, 2, 2, 3396, 3397, 9, 43, 2, 2, 3397, 3399, 7, 280, 2, 2, 3398,
	3396, 3, 2, 2, 2, 3398, 3399, 3, 2, 2, 2, 3399, 3400, 3, 2, 2, 2, 3400,
	3413, 7, 545, 2, 2, 3401, 3414, 5, 714, 358, 2, 3402, 3403, 7, 545, 2,
	2, 3403, 3408, 5, 714, 358, 2, 3404, 3405, 7, 551, 2, 2, 3405, 3407, 5,
	714, 358, 2, 3406, 3404, 3, 2, 2, 2, 3407, 3410, 3, 2, 2, 2, 3408, 3406,
	3, 2, 2, 2, 3408, 3409, 3, 2, 2, 2, 3409, 3411, 3, 2, 2, 2, 3410, 3408,
	3, 2, 2, 2, 3411, 3412, 7, 546, 2, 2, 3412, 3414, 3, 2, 2, 2, 3413, 3401,
	3, 2, 2, 2, 3413, 3402, 3, 2, 2, 2, 3414, 3415, 3, 2, 2, 2, 3415, 3416,
	5, 396, 199, 2, 3416, 3417, 5, 406, 204, 2, 3417, 3418, 7, 546, 2, 2, 3418,
	405, 3, 2, 2, 2, 3419, 3420, 7, 191, 2, 2, 3420, 3421, 7, 545, 2, 2, 3421,
	3426, 5, 408, 205, 2, 3422, 3423, 7, 551, 2, 2, 3423, 3425, 5, 408, 205,
	2, 3424, 3422, 3, 2, 2, 2, 3425, 3428, 3, 2, 2, 2, 3426, 3424, 3, 2, 2,
	2, 3426, 3427, 3, 2, 2, 2, 3427, 3429, 3, 2, 2, 2, 3428, 3426, 3, 2, 2,
	2, 3429, 3430, 7, 546, 2, 2, 3430, 407, 3, 2, 2, 2, 3431, 3444, 5, 714,
	358, 2, 3432, 3433, 7, 545, 2, 2, 3433, 3438, 5, 714, 358, 2, 3434, 3435,
	7, 551, 2, 2, 3435, 3437, 5, 714, 358, 2, 3436, 3434, 3, 2, 2, 2, 3437,
	3440, 3, 2, 2, 2, 3438, 3436, 3, 2, 2, 2, 3438, 3439, 3, 2, 2, 2, 3439,
	3441, 3, 2, 2, 2, 3440, 3438, 3, 2, 2, 2, 3441, 3442, 7, 546, 2, 2, 3442,
	3444, 3, 2, 2, 2, 3443, 3431, 3, 2, 2, 2, 3443, 3432, 3, 2, 2, 2, 3444,
	3460, 3, 2, 2, 2, 3445, 3458, 7, 15, 2, 2, 3446, 3459, 5, 752, 377, 2,
	3447, 3448, 7, 545, 2, 2, 3448, 3453, 5, 752, 377, 2, 3449, 3450, 7, 551,
	2, 2, 3450, 3452, 5, 752, 377, 2, 3451, 3449, 3, 2, 2, 2, 3452, 3455, 3,
	2, 2, 2, 3453, 3451, 3, 2, 2, 2, 3453, 3454, 3, 2, 2, 2, 3454, 3456, 3,
	2, 2, 2, 3455, 3453, 3, 2, 2, 2, 3456, 3457, 7, 546, 2, 2, 3457, 3459,
	3, 2, 2, 2, 3458, 3446, 3, 2, 2, 2, 3458, 3447, 3, 2, 2, 2, 3459, 3461,
	3, 2, 2, 2, 3460, 3445, 3, 2, 2, 2, 3460, 3461, 3, 2, 2, 2, 3461, 409,
	3, 2, 2, 2, 3462, 3463, 7, 72, 2, 2, 3463, 3465, 7, 42, 2, 2, 3464, 3466,
	7, 268, 2, 2, 3465, 3464, 3, 2, 2, 2, 3465, 3466, 3, 2, 2, 2, 3466, 3467,
	3, 2, 2, 2, 3467, 3469, 5, 532, 267, 2, 3468, 3470, 5, 412, 207, 2, 3469,
	3468, 3, 2, 2, 2, 3469, 3470, 3, 2, 2, 2, 3470, 3480, 3, 2, 2, 2, 3471,
	3472, 5, 412, 207, 2, 3472, 3473, 7, 72, 2, 2, 3473, 3475, 7, 42, 2, 2,
	3474, 3476, 7, 268, 2, 2, 3475, 3474, 3, 2, 2, 2, 3475, 3476, 3, 2, 2,
	2, 3476, 3477, 3, 2, 2, 2, 3477, 3478, 5, 532, 267, 2, 3478, 3480, 3, 2,
	2, 2, 3479, 3462, 3, 2, 2, 2, 3479, 3471, 3, 2, 2, 2, 3480, 411, 3, 2,
	2, 2, 3481, 3482, 7, 405, 2, 2, 3482, 3483, 7, 474, 2, 2, 3483, 3484, 5,
	532, 267, 2, 3484, 413, 3, 2, 2, 2, 3485, 3486, 7, 171, 2, 2, 3486, 3487,
	7, 42, 2, 2, 3487, 3492, 5, 416, 209, 2, 3488, 3489, 7, 551, 2, 2, 3489,
	3491, 5, 416, 209, 2, 3490, 3488, 3, 2, 2, 2, 3491, 3494, 3, 2, 2, 2, 3492,
	3490, 3, 2, 2, 2, 3492, 3493, 3, 2, 2, 2, 3493, 3496, 3, 2, 2, 2, 3494,
	3492, 3, 2, 2, 2, 3495, 3497, 5, 424, 213, 2, 3496, 3495, 3, 2, 2, 2, 3496,
	3497, 3, 2, 2, 2, 3497, 3512, 3, 2, 2, 2, 3498, 3509, 5, 424, 213, 2, 3499,
	3500, 7, 171, 2, 2, 3500, 3501, 7, 42, 2, 2, 3501, 3506, 5, 416, 209, 2,
	3502, 3503, 7, 551, 2, 2, 3503, 3505, 5, 416, 209, 2, 3504, 3502, 3, 2,
	2, 2, 3505, 3508, 3, 2, 2, 2, 3506, 3504, 3, 2, 2, 2, 3506, 3507, 3, 2,
	2, 2, 3507, 3510, 3, 2, 2, 2, 3508, 3506, 3, 2, 2, 2, 3509, 3499, 3, 2,
	2, 2, 3509, 3510, 3, 2, 2, 2, 3510, 3512, 3, 2, 2, 2, 3511, 3485, 3, 2,
	2, 2, 3511, 3498, 3, 2, 2, 2, 3512, 415, 3, 2, 2, 2, 3513, 3517, 5, 420,
	211, 2, 3514, 3517, 5, 418, 210, 2, 3515, 3517, 5, 536, 269, 2, 3516, 3513,
	3, 2, 2, 2, 3516, 3514, 3, 2, 2, 2, 3516, 3515, 3, 2, 2, 2, 3517, 417,
	3, 2, 2, 2, 3518, 3519, 9, 44, 2, 2, 3519, 3520, 7, 545, 2, 2, 3520, 3525,
	5, 422, 212, 2, 3521, 3522, 7, 551, 2, 2, 3522, 3524, 5, 422, 212, 2, 3523,
	3521, 3, 2, 2, 2, 3524, 3527, 3, 2, 2, 2, 3525, 3523, 3, 2, 2, 2, 3525,
	3526, 3, 2, 2, 2, 3526, 3528, 3, 2, 2, 2, 3527, 3525, 3, 2, 2, 2, 3528,
	3529, 7, 546, 2, 2, 3529, 419, 3, 2, 2, 2, 3530, 3531, 7, 172, 2, 2, 3531,
	3532, 7, 387, 2, 2, 3532, 3533, 7, 545, 2, 2, 3533, 3538, 5, 422, 212,
	2, 3534, 3535, 7, 551, 2, 2, 3535, 3537, 5, 422, 212, 2, 3536, 3534, 3,
	2, 2, 2, 3537, 3540, 3, 2, 2, 2, 3538, 3536, 3, 2, 2, 2, 3538, 3539, 3,
	2, 2, 2, 3539, 3541, 3, 2, 2, 2, 3540, 3538, 3, 2, 2, 2, 3541, 3542, 7,
	546, 2, 2, 3542, 421, 3, 2, 2, 2, 3543, 3551, 5, 418, 210, 2, 3544, 3546,
	7, 545, 2, 2, 3545, 3547, 5, 534, 268, 2, 3546, 3545, 3, 2, 2, 2, 3546,
	3547, 3, 2, 2, 2, 3547, 3548, 3, 2, 2, 2, 3548, 3551, 7, 546, 2, 2, 3549,
	3551, 5, 536, 269, 2, 3550, 3543, 3, 2, 2, 2, 3550, 3544, 3, 2, 2, 2, 3550,
	3549, 3, 2, 2, 2, 3551, 423, 3, 2, 2, 2, 3552, 3553, 7, 175, 2, 2, 3553,
	3554, 5, 532, 267, 2, 3554, 425, 3, 2, 2, 2, 3555, 3559, 7, 248, 2, 2,
	3556, 3558, 5, 428, 215, 2, 3557, 3556, 3, 2, 2, 2, 3558, 3561, 3, 2, 2,
	2, 3559, 3557, 3, 2, 2, 2, 3559, 3560, 3, 2, 2, 2, 3560, 3563, 3, 2, 2,
	2, 3561, 3559, 3, 2, 2, 2, 3562, 3564, 5, 430, 216, 2, 3563, 3562, 3, 2,
	2, 2, 3563, 3564, 3, 2, 2, 2, 3564, 3568, 3, 2, 2, 2, 3565, 3567, 5, 432,
	217, 2, 3566, 3565, 3, 2, 2, 2, 3567, 3570, 3, 2, 2, 2, 3568, 3566, 3,
	2, 2, 2, 3568, 3569, 3, 2, 2, 2, 3569, 3571, 3, 2, 2, 2, 3570, 3568, 3,
	2, 2, 2, 3571, 3572, 5, 434, 218, 2, 3572, 427, 3, 2, 2, 2, 3573, 3574,
	9, 45, 2, 2, 3574, 3582, 7, 257, 2, 2, 3575, 3579, 7, 446, 2, 2, 3576,
	3580, 7, 115, 2, 2, 3577, 3578, 7, 395, 2, 2, 3578, 3580, 7, 344, 2, 2,
	3579, 3576, 3, 2, 2, 2, 3579, 3577, 3, 2, 2, 2, 3580, 3582, 3, 2, 2, 2,
	3581, 3573, 3, 2, 2, 2, 3581, 3575, 3, 2, 2, 2, 3582, 429, 3, 2, 2, 2,
	3583, 3584, 7, 357, 2, 2, 3584, 3585, 9, 46, 2, 2, 3585, 3586, 7, 366,
	2, 2, 3586, 431, 3, 2, 2, 2, 3587, 3588, 7, 344, 2, 2, 3588, 3589, 5, 678,
	340, 2, 3589, 3590, 7, 291, 2, 2, 3590, 3591, 7, 545, 2, 2, 3591, 3592,
	5, 358, 180, 2, 3592, 3593, 7, 546, 2, 2, 3593, 3597, 5, 436, 219, 2, 3594,
	3596, 5, 428, 215, 2, 3595, 3594, 3, 2, 2, 2, 3596, 3599, 3, 2, 2, 2, 3597,
	3595, 3, 2, 2, 2, 3597, 3598, 3, 2, 2, 2, 3598, 433, 3, 2, 2, 2, 3599,
	3597, 3, 2, 2, 2, 3600, 3601, 7, 236, 2, 2, 3601, 3603, 5, 680, 341, 2,
	3602, 3600, 3, 2, 2, 2, 3602, 3603, 3, 2, 2, 2, 3603, 3604, 3, 2, 2, 2,
	3604, 3608, 5, 436, 219, 2, 3605, 3607, 5, 428, 215, 2, 3606, 3605, 3,
	2, 2, 2, 3607, 3610, 3, 2, 2, 2, 3608, 3606, 3, 2, 2, 2, 3608, 3609, 3,
	2, 2, 2, 3609, 3611, 3, 2, 2, 2, 3610, 3608, 3, 2, 2, 2, 3611, 3612, 5,
	444, 223, 2, 3612, 435, 3, 2, 2, 2, 3613, 3615, 5, 438, 220, 2, 3614, 3613,
	3, 2, 2, 2, 3614, 3615, 3, 2, 2, 2, 3615, 3616, 3, 2, 2, 2, 3616, 3617,
	7, 115, 2, 2, 3617, 3618, 7, 42, 2, 2, 3618, 3619, 5, 440, 221, 2, 3619,
	3620, 7, 240, 2, 2, 3620, 3621, 5, 440, 221, 2, 3621, 437, 3, 2, 2, 2,
	3622, 3623, 7, 308, 2, 2, 3623, 3624, 7, 42, 2, 2, 3624, 3625, 5, 440,
	221, 2, 3625, 439, 3, 2, 2, 2, 3626, 3627, 7, 545, 2, 2, 3627, 3632, 5,
	442, 222, 2, 3628, 3629, 7, 551, 2, 2, 3629, 3631, 5, 442, 222, 2, 3630,
	3628, 3, 2, 2, 2, 3631, 3634, 3, 2, 2, 2, 3632, 3630, 3, 2, 2, 2, 3632,
	3633, 3, 2, 2, 2, 3633, 3635, 3, 2, 2, 2, 3634, 3632, 3, 2, 2, 2, 3635,
	3636, 7, 546, 2, 2, 3636, 441, 3, 2, 2, 2, 3637, 3640, 5, 536, 269, 2,
	3638, 3640, 5, 364, 183, 2, 3639, 3637, 3, 2, 2, 2, 3639, 3638, 3, 2, 2,
	2, 3640, 3642, 3, 2, 2, 2, 3641, 3643, 5, 648, 325, 2, 3642, 3641, 3, 2,
	2, 2, 3642, 3643, 3, 2, 2, 2, 3643, 443, 3, 2, 2, 2, 3644, 3646, 5, 446,
	224, 2, 3645, 3644, 3, 2, 2, 2, 3645, 3646, 3, 2, 2, 2, 3646, 3647, 3,
	2, 2, 2, 3647, 3656, 7, 545, 2, 2, 3648, 3653, 5, 448, 225, 2, 3649, 3650,
	7, 551, 2, 2, 3650, 3652, 5, 448, 225, 2, 3651, 3649, 3, 2, 2, 2, 3652,
	3655, 3, 2, 2, 2, 3653, 3651, 3, 2, 2, 2, 3653, 3654, 3, 2, 2, 2, 3654,
	3657, 3, 2, 2, 2, 3655, 3653, 3, 2, 2, 2, 3656, 3648, 3, 2, 2, 2, 3656,
	3657, 3, 2, 2, 2, 3657, 3658, 3, 2, 2, 2, 3658, 3659, 7, 546, 2, 2, 3659,
	445, 3, 2, 2, 2, 3660, 3666, 7, 367, 2, 2, 3661, 3667, 7, 451, 2, 2, 3662,
	3664, 7, 452, 2, 2, 3663, 3665, 7, 8, 2, 2, 3664, 3663, 3, 2, 2, 2, 3664,
	3665, 3, 2, 2, 2, 3665, 3667, 3, 2, 2, 2, 3666, 3661, 3, 2, 2, 2, 3666,
	3662, 3, 2, 2, 2, 3666, 3667, 3, 2, 2, 2, 3667, 3670, 3, 2, 2, 2, 3668,
	3669, 9, 47, 2, 2, 3669, 3671, 7, 296, 2, 2, 3670, 3668, 3, 2, 2, 2, 3670,
	3671, 3, 2, 2, 2, 3671, 3673, 3, 2, 2, 2, 3672, 3674, 5, 452, 227, 2, 3673,
	3672, 3, 2, 2, 2, 3673, 3674, 3, 2, 2, 2, 3674, 447, 3, 2, 2, 2, 3675,
	3681, 7, 451, 2, 2, 3676, 3678, 7, 452, 2, 2, 3677, 3679, 7, 8, 2, 2, 3678,
	3677, 3, 2, 2, 2, 3678, 3679, 3, 2, 2, 2, 3679, 3681, 3, 2, 2, 2, 3680,
	3675, 3, 2, 2, 2, 3680, 3676, 3, 2, 2, 2, 3680, 3681, 3, 2, 2, 2, 3681,
	3682, 3, 2, 2, 2, 3682, 3684, 5, 450, 226, 2, 3683, 3685, 5, 456, 229,
	2, 3684, 3683, 3, 2, 2, 2, 3684, 3685, 3, 2, 2, 2, 3685, 3686, 3, 2, 2,
	2, 3686, 3687, 7, 565, 2, 2, 3687, 3688, 5, 536, 269, 2, 3688, 449, 3,
	2, 2, 2, 3689, 3690, 5, 558, 280, 2, 3690, 451, 3, 2, 2, 2, 3691, 3692,
	7, 208, 2, 2, 3692, 3693, 7, 545, 2, 2, 3693, 3694, 5, 536, 269, 2, 3694,
	3696, 7, 546, 2, 2, 3695, 3697, 5, 454, 228, 2, 3696, 3695, 3, 2, 2, 2,
	3696, 3697, 3, 2, 2, 2, 3697, 453, 3, 2, 2, 2, 3698, 3699, 7, 449, 2, 2,
	3699, 3700, 7, 545, 2, 2, 3700, 3701, 5, 532, 267, 2, 3701, 3702, 7, 546,
	2, 2, 3702, 455, 3, 2, 2, 2, 3703, 3705, 7, 296, 2, 2, 3704, 3706, 7, 392,
	2, 2, 3705, 3704, 3, 2, 2, 2, 3705, 3706, 3, 2, 2, 2, 3706, 3707, 3, 2,
	2, 2, 3707, 3708, 7, 42, 2, 2, 3708, 3713, 5, 458, 230, 2, 3709, 3710,
	7, 551, 2, 2, 3710, 3712, 5, 458, 230, 2, 3711, 3709, 3, 2, 2, 2, 3712,
	3715, 3, 2, 2, 2, 3713, 3711, 3, 2, 2, 2, 3713, 3714, 3, 2, 2, 2, 3714,
	457, 3, 2, 2, 2, 3715, 3713, 3, 2, 2, 2, 3716, 3718, 5, 536, 269, 2, 3717,
	3719, 9, 48, 2, 2, 3718, 3717, 3, 2, 2, 2, 3718, 3719, 3, 2, 2, 2, 3719,
	3722, 3, 2, 2, 2, 3720, 3721, 7, 280, 2, 2, 3721, 3723, 9, 49, 2, 2, 3722,
	3720, 3, 2, 2, 2, 3722, 3723, 3, 2, 2, 2, 3723, 459, 3, 2, 2, 2, 3724,
	3725, 7, 162, 2, 2, 3725, 3727, 7, 451, 2, 2, 3726, 3728, 5, 462, 232,
	2, 3727, 3726, 3, 2, 2, 2, 3727, 3728, 3, 2, 2, 2, 3728, 3730, 3, 2, 2,
	2, 3729, 3731, 5, 464, 233, 2, 3730, 3729, 3, 2, 2, 2, 3730, 3731, 3, 2,
	2, 2, 3731, 461, 3, 2, 2, 2, 3732, 3733, 7, 286, 2, 2, 3733, 3738, 5, 714,
	358, 2, 3734, 3735, 7, 551, 2, 2, 3735, 3737, 5, 714, 358, 2, 3736, 3734,
	3, 2, 2, 2, 3737, 3740, 3, 2, 2, 2, 3738, 3736, 3, 2, 2, 2, 3738, 3739,
	3, 2, 2, 2, 3739, 463, 3, 2, 2, 2, 3740, 3738, 3, 2, 2, 2, 3741, 3742,
	7, 397, 2, 2, 3742, 3747, 7, 227, 2, 2, 3743, 3747, 7, 278, 2, 2, 3744,
	3745, 7, 466, 2, 2, 3745, 3747, 5, 536, 269, 2, 3746, 3741, 3, 2, 2, 2,
	3746, 3743, 3, 2, 2, 2, 3746, 3744, 3, 2, 2, 2, 3747, 465, 3, 2, 2, 2,
	3748, 3749, 7, 451, 2, 2, 3749, 3750, 5, 512, 257, 2, 3750, 3752, 5, 468,
	235, 2, 3751, 3753, 5, 652, 327, 2, 3752, 3751, 3, 2, 2, 2, 3752, 3753,
	3, 2, 2, 2, 3753, 3755, 3, 2, 2, 2, 3754, 3756, 5, 514, 258, 2, 3755, 3754,
	3, 2, 2, 2, 3755, 3756, 3, 2, 2, 2, 3756, 3758, 3, 2, 2, 2, 3757, 3759,
	5, 516, 259, 2, 3758, 3757, 3, 2, 2, 2, 3758, 3759, 3, 2, 2, 2, 3759, 467,
	3, 2, 2, 2, 3760, 3776, 7, 386, 2, 2, 3761, 3766, 5, 470, 236, 2, 3762,
	3763, 7, 551, 2, 2, 3763, 3765, 5, 470, 236, 2, 3764, 3762, 3, 2, 2, 2,
	3765, 3768, 3, 2, 2, 2, 3766, 3764, 3, 2, 2, 2, 3766, 3767, 3, 2, 2, 2,
	3767, 3777, 3, 2, 2, 2, 3768, 3766, 3, 2, 2, 2, 3769, 3770, 7, 458, 2,
	2, 3770, 3771, 7, 545, 2, 2, 3771, 3772, 5, 760, 381, 2, 3772, 3773, 7,
	546, 2, 2, 3773, 3774, 7, 565, 2, 2, 3774, 3775, 5, 536, 269, 2, 3775,
	3777, 3, 2, 2, 2, 3776, 3761, 3, 2, 2, 2, 3776, 3769, 3, 2, 2, 2, 3777,
	469, 3, 2, 2, 2, 3778, 3779, 5, 714, 358, 2, 3779, 3780, 7, 565, 2, 2,
	3780, 3781, 5, 536, 269, 2, 3781, 3796, 3, 2, 2, 2, 3782, 3783, 7, 545,
	2, 2, 3783, 3788, 5, 714, 358, 2, 3784, 3785, 7, 551, 2, 2, 3785, 3787,
	5, 714, 358, 2, 3786, 3784, 3, 2, 2, 2, 3787, 3790, 3, 2, 2, 2, 3788, 3786,
	3, 2, 2, 2, 3788, 3789, 3, 2, 2, 2, 3789, 3791, 3, 2, 2, 2, 3790, 3788,
	3, 2, 2, 2, 3791, 3792, 7, 546, 2, 2, 3792, 3793, 7, 565, 2, 2, 3793, 3794,
	5, 358, 180, 2, 3794, 3796, 3, 2, 2, 2, 3795, 3778, 3, 2, 2, 2, 3795, 3782,
	3, 2, 2, 2, 3796, 471, 3, 2, 2, 2, 3797, 3799, 7, 111, 2, 2, 3798, 3800,
	7, 165, 2, 2, 3799, 3798, 3, 2, 2, 2, 3799, 3800, 3, 2, 2, 2, 3800, 3801,
	3, 2, 2, 2, 3801, 3803, 5, 512, 257, 2, 3802, 3804, 5, 652, 327, 2, 3803,
	3802, 3, 2, 2, 2, 3803, 3804, 3, 2, 2, 2, 3804, 3806, 3, 2, 2, 2, 3805,
	3807, 5, 514, 258, 2, 3806, 3805, 3, 2, 2, 2, 3806, 3807, 3, 2, 2, 2, 3807,
	3809, 3, 2, 2, 2, 3808, 3810, 5, 516, 259, 2, 3809, 3808, 3, 2, 2, 2, 3809,
	3810, 3, 2, 2, 2, 3810, 473, 3, 2, 2, 2, 3811, 3814, 7, 197, 2, 2, 3812,
	3815, 5, 476, 239, 2, 3813, 3815, 5, 478, 240, 2, 3814, 3812, 3, 2, 2,
	2, 3814, 3813, 3, 2, 2, 2, 3815, 475, 3, 2, 2, 2, 3816, 3822, 5, 488, 245,
	2, 3817, 3819, 5, 490, 246, 2, 3818, 3820, 5, 514, 258, 2, 3819, 3818,
	3, 2, 2, 2, 3819, 3820, 3, 2, 2, 2, 3820, 3823, 3, 2, 2, 2, 3821, 3823,
	5, 348, 175, 2, 3822, 3817, 3, 2, 2, 2, 3822, 3821, 3, 2, 2, 2, 3823, 3825,
	3, 2, 2, 2, 3824, 3826, 5, 516, 259, 2, 3825, 3824, 3, 2, 2, 2, 3825, 3826,
	3, 2, 2, 2, 3826, 477, 3, 2, 2, 2, 3827, 3829, 7, 8, 2, 2, 3828, 3830,
	5, 480, 241, 2, 3829, 3828, 3, 2, 2, 2, 3830, 3831, 3, 2, 2, 2, 3831, 3829,
	3, 2, 2, 2, 3831, 3832, 3, 2, 2, 2, 3832, 3835, 3, 2, 2, 2, 3833, 3835,
	5, 482, 242, 2, 3834, 3827, 3, 2, 2, 2, 3834, 3833, 3, 2, 2, 2, 3835, 3836,
	3, 2, 2, 2, 3836, 3837, 5, 348, 175, 2, 3837, 479, 3, 2, 2, 2, 3838, 3840,
	5, 488, 245, 2, 3839, 3841, 5, 490, 246, 2, 3840, 3839, 3, 2, 2, 2, 3840,
	3841, 3, 2, 2, 2, 3841, 3843, 3, 2, 2, 2, 3842, 3844, 5, 516, 259, 2, 3843,
	3842, 3, 2, 2, 2, 3843, 3844, 3, 2, 2, 2, 3844, 481, 3, 2, 2, 2, 3845,
	3847, 9, 50, 2, 2, 3846, 3845, 3, 2, 2, 2, 3846, 3847, 3, 2, 2, 2, 3847,
	3849, 3, 2, 2, 2, 3848, 3850, 5, 484, 243, 2, 3849, 3848, 3, 2, 2, 2, 3850,
	3851, 3, 2, 2, 2, 3851, 3849, 3, 2, 2, 2, 3851, 3852, 3, 2, 2, 2, 3852,
	3854, 3, 2, 2, 2, 3853, 3855, 5, 486, 244, 2, 3854, 3853, 3, 2, 2, 2, 3854,
	3855, 3, 2, 2, 2, 3855, 483, 3, 2, 2, 2, 3856, 3857, 7, 470, 2, 2, 3857,
	3858, 5, 532, 267, 2, 3858, 3860, 7, 423, 2, 2, 3859, 3861, 5, 480, 241,
	2, 3860, 3859, 3, 2, 2, 2, 3861, 3862, 3, 2, 2, 2, 3862, 3860, 3, 2, 2,
	2, 3862, 3863, 3, 2, 2, 2, 3863, 485, 3, 2, 2, 2, 3864, 3866, 7, 125, 2,
	2, 3865, 3867, 5, 480, 241, 2, 3866, 3865, 3, 2, 2, 2, 3867, 3868, 3, 2,
	2, 2, 3868, 3866, 3, 2, 2, 2, 3868, 3869, 3, 2, 2, 2, 3869, 487, 3, 2,
	2, 2, 3870, 3871, 7, 204, 2, 2, 3871, 3883, 5, 512, 257, 2, 3872, 3873,
	7, 545, 2, 2, 3873, 3878, 5, 714, 358, 2, 3874, 3875, 7, 551, 2, 2, 3875,
	3877, 5, 714, 358, 2, 3876, 3874, 3, 2, 2, 2, 3877, 3880, 3, 2, 2, 2, 3878,
	3876, 3, 2, 2, 2, 3878, 3879, 3, 2, 2, 2, 3879, 3881, 3, 2, 2, 2, 3880,
	3878, 3, 2, 2, 2, 3881, 3882, 7, 546, 2, 2, 3882, 3884, 3, 2, 2, 2, 3883,
	3872, 3, 2, 2, 2, 3883, 3884, 3, 2, 2, 2, 3884, 489, 3, 2, 2, 2, 3885,
	3886, 7, 457, 2, 2, 3886, 3888, 7, 545, 2, 2, 3887, 3889, 5, 534, 268,
	2, 3888, 3887, 3, 2, 2, 2, 3888, 3889, 3, 2, 2, 2, 3889, 3890, 3, 2, 2,
	2, 3890, 3891, 7, 546, 2, 2, 3891, 491, 3, 2, 2, 2, 3892, 3893, 7, 242,
	2, 2, 3893, 3894, 7, 204, 2, 2, 3894, 3896, 5, 716, 359, 2, 3895, 3897,
	5, 650, 326, 2, 3896, 3895, 3, 2, 2, 2, 3896, 3897, 3, 2, 2, 2, 3897, 3898,
	3, 2, 2, 2, 3898, 3899, 7, 455, 2, 2, 3899, 3900, 5, 502, 252, 2, 3900,
	3901, 7, 291, 2, 2, 3901, 3902, 7, 545, 2, 2, 3902, 3903, 5, 532, 267,
	2, 3903, 3912, 7, 546, 2, 2, 3904, 3906, 5, 494, 248, 2, 3905, 3907, 5,
	500, 251, 2, 3906, 3905, 3, 2, 2, 2, 3906, 3907, 3, 2, 2, 2, 3907, 3913,
	3, 2, 2, 2, 3908, 3910, 5, 500, 251, 2, 3909, 3911, 5, 494, 248, 2, 3910,
	3909, 3, 2, 2, 2, 3910, 3911, 3, 2, 2, 2, 3911, 3913, 3, 2, 2, 2, 3912,
	3904, 3, 2, 2, 2, 3912, 3908, 3, 2, 2, 2, 3912, 3913, 3, 2, 2, 2, 3913,
	3915, 3, 2, 2, 2, 3914, 3916, 5, 516, 259, 2, 3915, 3914, 3, 2, 2, 2, 3915,
	3916, 3, 2, 2, 2, 3916, 493, 3, 2, 2, 2, 3917, 3918, 7, 470, 2, 2, 3918,
	3919, 7, 238, 2, 2, 3919, 3920, 7, 423, 2, 2, 3920, 3921, 7, 451, 2, 2,
	3921, 3922, 7, 386, 2, 2, 3922, 3927, 5, 496, 249, 2, 3923, 3924, 7, 551,
	2, 2, 3924, 3926, 5, 496, 249, 2, 3925, 3923, 3, 2, 2, 2, 3926, 3929, 3,
	2, 2, 2, 3927, 3925, 3, 2, 2, 2, 3927, 3928, 3, 2, 2, 2, 3928, 3931, 3,
	2, 2, 2, 3929, 3927, 3, 2, 2, 2, 3930, 3932, 5, 652, 327, 2, 3931, 3930,
	3, 2, 2, 2, 3931, 3932, 3, 2, 2, 2, 3932, 3934, 3, 2, 2, 2, 3933, 3935,
	5, 498, 250, 2, 3934, 3933, 3, 2, 2, 2, 3934, 3935, 3, 2, 2, 2, 3935, 495,
	3, 2, 2, 2, 3936, 3937, 5, 714, 358, 2, 3937, 3938, 7, 565, 2, 2, 3938,
	3939, 5, 536, 269, 2, 3939, 497, 3, 2, 2, 2, 3940, 3941, 7, 111, 2, 2,
	3941, 3942, 5, 652, 327, 2, 3942, 499, 3, 2, 2, 2, 3943, 3944, 7, 470,
	2, 2, 3944, 3945, 7, 277, 2, 2, 3945, 3946, 7, 238, 2, 2, 3946, 3947, 7,
	423, 2, 2, 3947, 3959, 7, 197, 2, 2, 3948, 3949, 7, 545, 2, 2, 3949, 3954,
	5, 714, 358, 2, 3950, 3951, 7, 551, 2, 2, 3951, 3953, 5, 714, 358, 2, 3952,
	3950, 3, 2, 2, 2, 3953, 3956, 3, 2, 2, 2, 3954, 3952, 3, 2, 2, 2, 3954,
	3955, 3, 2, 2, 2, 3955, 3957, 3, 2, 2, 2, 3956, 3954, 3, 2, 2, 2, 3957,
	3958, 7, 546, 2, 2, 3958, 3960, 3, 2, 2, 2, 3959, 3948, 3, 2, 2, 2, 3959,
	3960, 3, 2, 2, 2, 3960, 3961, 3, 2, 2, 2, 3961, 3962, 7, 457, 2, 2, 3962,
	3964, 7, 545, 2, 2, 3963, 3965, 5, 534, 268, 2, 3964, 3963, 3, 2, 2, 2,
	3964, 3965, 3, 2, 2, 2, 3965, 3966, 3, 2, 2, 2, 3966, 3968, 7, 546, 2,
	2, 3967, 3969, 5, 652, 327, 2, 3968, 3967, 3, 2, 2, 2, 3968, 3969, 3, 2,
	2, 2, 3969, 501, 3, 2, 2, 2, 3970, 3976, 5, 716, 359, 2, 3971, 3972, 7,
	545, 2, 2, 3972, 3973, 5, 348, 175, 2, 3973, 3974, 7, 546, 2, 2, 3974,
	3976, 3, 2, 2, 2, 3975, 3970, 3, 2, 2, 2, 3975, 3971, 3, 2, 2, 2, 3976,
	3978, 3, 2, 2, 2, 3977, 3979, 5, 650, 326, 2, 3978, 3977, 3, 2, 2, 2, 3978,
	3979, 3, 2, 2, 2, 3979, 503, 3, 2, 2, 2, 3980, 3981, 7, 228, 2, 2, 3981,
	3982, 7, 421, 2, 2, 3982, 3987, 5, 508, 255, 2, 3983, 3984, 7, 551, 2,
	2, 3984, 3986, 5, 508, 255, 2, 3985, 3983, 3, 2, 2, 2, 3986, 3989, 3, 2,
	2, 2, 3987, 3985, 3, 2, 2, 2, 3987, 3988, 3, 2, 2, 2, 3988, 3990, 3, 2,
	2, 2, 3989, 3987, 3, 2, 2, 2, 3990, 3991, 7, 191, 2, 2, 3991, 3992, 5,
	510, 256, 2, 3992, 3994, 7, 249, 2, 2, 3993, 3995, 5, 506, 254, 2, 3994,
	3993, 3, 2, 2, 2, 3994, 3995, 3, 2, 2, 2, 3995, 505, 3, 2, 2, 2, 3996,
	3997, 7, 466, 2, 2, 3997, 4000, 5, 536, 269, 2, 3998, 4000, 7, 278, 2,
	2, 3999, 3996, 3, 2, 2, 2, 3999, 3998, 3, 2, 2, 2, 4000, 507, 3, 2, 2,
	2, 4001, 4003, 5, 716, 359, 2, 4002, 4004, 5, 646, 324, 2, 4003, 4002,
	3, 2, 2, 2, 4003, 4004, 3, 2, 2, 2, 4004, 509, 3, 2, 2, 2, 4005, 4006,
	7, 365, 2, 2, 4006, 4018, 7, 389, 2, 2, 4007, 4008, 7, 365, 2, 2, 4008,
	4018, 7, 141, 2, 2, 4009, 4011, 7, 389, 2, 2, 4010, 4012, 7, 451, 2, 2,
	4011, 4010, 3, 2, 2, 2, 4011, 4012, 3, 2, 2, 2, 4012, 4018, 3, 2, 2, 2,
	4013, 4014, 7, 389, 2, 2, 4014, 4015, 7, 365, 2, 2, 4015, 4018, 7, 141,
	2, 2, 4016, 4018, 7, 141, 2, 2, 4017, 4005, 3, 2, 2, 2, 4017, 4007, 3,
	2, 2, 2, 4017, 4009, 3, 2, 2, 2, 4017, 4013, 3, 2, 2, 2, 4017, 4016, 3,
	2, 2, 2, 4018, 511, 3, 2, 2, 2, 4019, 4026, 5, 522, 262, 2, 4020, 4021,
	7, 290, 2, 2, 4021, 4022, 7, 545, 2, 2, 4022, 4023, 5, 522, 262, 2, 4023,
	4024, 7, 546, 2, 2, 4024, 4026, 3, 2, 2, 2, 4025, 4019, 3, 2, 2, 2, 4025,
	4020, 3, 2, 2, 2, 4026, 4028, 3, 2, 2, 2, 4027, 4029, 5, 650, 326, 2, 4028,
	4027, 3, 2, 2, 2, 4028, 4029, 3, 2, 2, 2, 4029, 513, 3, 2, 2, 2, 4030,
	4031, 9, 32, 2, 2, 4031, 4032, 5, 534, 268, 2, 4032, 4033, 5, 654, 328,
	2, 4033, 515, 3, 2, 2, 2, 4034, 4035, 7, 230, 2, 2, 4035, 4037, 7, 134,
	2, 2, 4036, 4038, 5, 518, 260, 2, 4037, 4036, 3, 2, 2, 2, 4037, 4038, 3,
	2, 2, 2, 4038, 4040, 3, 2, 2, 2, 4039, 4041, 5, 536, 269, 2, 4040, 4039,
	3, 2, 2, 2, 4040, 4041, 3, 2, 2, 2, 4041, 4043, 3, 2, 2, 2, 4042, 4044,
	5, 520, 261, 2, 4043, 4042, 3, 2, 2, 2, 4043, 4044, 3, 2, 2, 2, 4044, 517,
	3, 2, 2, 2, 4045, 4046, 7, 204, 2, 2, 4046, 4047, 5, 716, 359, 2, 4047,
	519, 3, 2, 2, 2, 4048, 4049, 7, 348, 2, 2, 4049, 4052, 7, 224, 2, 2, 4050,
	4053, 7, 447, 2, 2, 4051, 4053, 5, 536, 269, 2, 4052, 4050, 3, 2, 2, 2,
	4052, 4051, 3, 2, 2, 2, 4053, 521, 3, 2, 2, 2, 4054, 4067, 5, 524, 263,
	2, 4055, 4056, 7, 545, 2, 2, 4056, 4058, 5, 348, 175, 2, 4057, 4059, 5,
	526, 264, 2, 4058, 4057, 3, 2, 2, 2, 4058, 4059, 3, 2, 2, 2, 4059, 4060,
	3, 2, 2, 2, 4060, 4061, 7, 546, 2, 2, 4061, 4067, 3, 2, 2, 2, 4062, 4064,
	5, 716, 359, 2, 4063, 4065, 5, 528, 265, 2, 4064, 4063, 3, 2, 2, 2, 4064,
	4065, 3, 2, 2, 2, 4065, 4067, 3, 2, 2, 2, 4066, 4054, 3, 2, 2, 2, 4066,
	4055, 3, 2, 2, 2, 4066, 4062, 3, 2, 2, 2, 4067, 523, 3, 2, 2, 2, 4068,
	4081, 9, 51, 2, 2, 4069, 4070, 7, 545, 2, 2, 4070, 4071, 5, 358, 180, 2,
	4071, 4072, 7, 546, 2, 2, 4072, 4082, 3, 2, 2, 2, 4073, 4074, 7, 545, 2,
	2, 4074, 4075, 5, 536, 269, 2, 4075, 4079, 7, 546, 2, 2, 4076, 4077, 7,
	545, 2, 2, 4077, 4078, 7, 549, 2, 2, 4078, 4080, 7, 546, 2, 2, 4079, 4076,
	3, 2, 2, 2, 4079, 4080, 3, 2, 2, 2, 4080, 4082, 3, 2, 2, 2, 4081, 4069,
	3, 2, 2, 2, 4081, 4073, 3, 2, 2, 2, 4082, 525, 3, 2, 2, 2, 4083, 4092,
	7, 474, 2, 2, 4084, 4085, 7, 340, 2, 2, 4085, 4093, 7, 290, 2, 2, 4086,
	4087, 7, 53, 2, 2, 4087, 4090, 7, 294, 2, 2, 4088, 4089, 7, 74, 2, 2, 4089,
	4091, 5, 686, 344, 2, 4090, 4088, 3, 2, 2, 2, 4090, 4091, 3, 2, 2, 2, 4091,
	4093, 3, 2, 2, 2, 4092, 4084, 3, 2, 2, 2, 4092, 4086, 3, 2, 2, 2, 4093,
	527, 3, 2, 2, 2, 4094, 4096, 7, 368, 2, 2, 4095, 4097, 7, 35, 2, 2, 4096,
	4095, 3, 2, 2, 2, 4096, 4097, 3, 2, 2, 2, 4097, 4098, 3, 2, 2, 2, 4098,
	4099, 7, 545, 2, 2, 4099, 4102, 5, 536, 269, 2, 4100, 4101, 7, 551, 2,
	2, 4101, 4103, 5, 536, 269, 2, 4102, 4100, 3, 2, 2, 2, 4102, 4103, 3, 2,
	2, 2, 4103, 4104, 3, 2, 2, 2, 4104, 4106, 7, 546, 2, 2, 4105, 4107, 5,
	530, 266, 2, 4106, 4105, 3, 2, 2, 2, 4106, 4107, 3, 2, 2, 2, 4107, 529,
	3, 2, 2, 2, 4108, 4109, 7, 376, 2, 2, 4109, 4110, 7, 545, 2, 2, 4110, 4111,
	5, 536, 269, 2, 4111, 4112, 7, 546, 2, 2, 4112, 531, 3, 2, 2, 2, 4113,
	4114, 5, 536, 269, 2, 4114, 533, 3, 2, 2, 2, 4115, 4120, 5, 536, 269, 2,
	4116, 4117, 7, 551, 2, 2, 4117, 4119, 5, 536, 269, 2, 4118, 4116, 3, 2,
	2, 2, 4119, 4122, 3, 2, 2, 2, 4120, 4118, 3, 2, 2, 2, 4120, 4121, 3, 2,
	2, 2, 4121, 535, 3, 2, 2, 2, 4122, 4120, 3, 2, 2, 2, 4123, 4126, 5, 538,
	270, 2, 4124, 4126, 5, 540, 271, 2, 4125, 4123, 3, 2, 2, 2, 4125, 4124,
	3, 2, 2, 2, 4126, 537, 3, 2, 2, 2, 4127, 4128, 7, 91, 2, 2, 4128, 4129,
	7, 545, 2, 2, 4129, 4130, 5, 358, 180, 2, 4130, 4131, 7, 546, 2, 2, 4131,
	539, 3, 2, 2, 2, 4132, 4133, 8, 271, 1, 2, 4133, 4167, 5, 542, 272, 2,
	4134, 4136, 7, 206, 2, 2, 4135, 4137, 7, 277, 2, 2, 4136, 4135, 3, 2, 2,
	2, 4136, 4137, 3, 2, 2, 2, 4137, 4163, 3, 2, 2, 2, 4138, 4164, 7, 279,
	2, 2, 4139, 4164, 7, 254, 2, 2, 4140, 4164, 7, 330, 2, 2, 4141, 4164, 7,
	190, 2, 2, 4142, 4143, 7, 7, 2, 2, 4143, 4164, 7, 386, 2, 2, 4144, 4164,
	7, 127, 2, 2, 4145, 4147, 7, 286, 2, 2, 4146, 4148, 7, 442, 2, 2, 4147,
	4146, 3, 2, 2, 2, 4147, 4148, 3, 2, 2, 2, 4148, 4149, 3, 2, 2, 2, 4149,
	4151, 7, 545, 2, 2, 4150, 4152, 7, 290, 2, 2, 4151, 4150, 3, 2, 2, 2, 4151,
	4152, 3, 2, 2, 2, 4152, 4153, 3, 2, 2, 2, 4153, 4158, 5, 736, 369, 2, 4154,
	4155, 7, 551, 2, 2, 4155, 4157, 5, 736, 369, 2, 4156, 4154, 3, 2, 2, 2,
	4157, 4160, 3, 2, 2, 2, 4158, 4156, 3, 2, 2, 2, 4158, 4159, 3, 2, 2, 2,
	4159, 4161, 3, 2, 2, 2, 4160, 4158, 3, 2, 2, 2, 4161, 4162, 7, 546, 2,
	2, 4162, 4164, 3, 2, 2, 2, 4163, 4138, 3, 2, 2, 2, 4163, 4139, 3, 2, 2,
	2, 4163, 4140, 3, 2, 2, 2, 4163, 4141, 3, 2, 2, 2, 4163, 4142, 3, 2, 2,
	2, 4163, 4144, 3, 2, 2, 2, 4163, 4145, 3, 2, 2, 2, 4164, 4166, 3, 2, 2,
	2, 4165, 4134, 3, 2, 2, 2, 4166, 4169, 3, 2, 2, 2, 4167, 4165, 3, 2, 2,
	2, 4167, 4168, 3, 2, 2, 2, 4168, 4173, 3, 2, 2, 2, 4169, 4167, 3, 2, 2,
	2, 4170, 4171, 7, 277, 2, 2, 4171, 4173, 5, 540, 271, 5, 4172, 4132, 3,
	2, 2, 2, 4172, 4170, 3, 2, 2, 2, 4173, 4182, 3, 2, 2, 2, 4174, 4175, 12,
	4, 2, 2, 4175, 4176, 7, 11, 2, 2, 4176, 4181, 5, 540, 271, 5, 4177, 4178,
	12, 3, 2, 2, 4178, 4179, 7, 298, 2, 2, 4179, 4181, 5, 540, 271, 4, 4180,
	4174, 3, 2, 2, 2, 4180, 4177, 3, 2, 2, 2, 4181, 4184, 3, 2, 2, 2, 4182,
	4180, 3, 2, 2, 2, 4182, 4183, 3, 2, 2, 2, 4183, 541, 3, 2, 2, 2, 4184,
	4182, 3, 2, 2, 2, 4185, 4191, 5, 544, 273, 2, 4186, 4188, 9, 52, 2, 2,
	4187, 4189, 7, 286, 2, 2, 4188, 4187, 3, 2, 2, 2, 4188, 4189, 3, 2, 2,
	2, 4189, 4190, 3, 2, 2, 2, 4190, 4192, 5, 554, 278, 2, 4191, 4186, 3, 2,
	2, 2, 4191, 4192, 3, 2, 2, 2, 4192, 543, 3, 2, 2, 2, 4193, 4194, 8, 273,
	1, 2, 4194, 4195, 5, 546, 274, 2, 4195, 4202, 3, 2, 2, 2, 4196, 4197, 12,
	4, 2, 2, 4197, 4198, 5, 548, 275, 2, 4198, 4199, 5, 544, 273, 5, 4199,
	4201, 3, 2, 2, 2, 4200, 4196, 3, 2, 2, 2, 4201, 4204, 3, 2, 2, 2, 4202,
	4200, 3, 2, 2, 2, 4202, 4203, 3, 2, 2, 2, 4203, 545, 3, 2, 2, 2, 4204,
	4202, 3, 2, 2, 2, 4205, 4221, 5, 554, 278, 2, 4206, 4208, 7, 277, 2, 2,
	4207, 4206, 3, 2, 2, 2, 4207, 4208, 3, 2, 2, 2, 4208, 4219, 3, 2, 2, 2,
	4209, 4210, 7, 191, 2, 2, 4210, 4220, 5, 550, 276, 2, 4211, 4212, 7, 29,
	2, 2, 4212, 4220, 5, 552, 277, 2, 4213, 4214, 9, 53, 2, 2, 4214, 4217,
	5, 554, 278, 2, 4215, 4216, 7, 135, 2, 2, 4216, 4218, 5, 554, 278, 2, 4217,
	4215, 3, 2, 2, 2, 4217, 4218, 3, 2, 2, 2, 4218, 4220, 3, 2, 2, 2, 4219,
	4209, 3, 2, 2, 2, 4219, 4211, 3, 2, 2, 2, 4219, 4213, 3, 2, 2, 2, 4220,
	4222, 3, 2, 2, 2, 4221, 4207, 3, 2, 2, 2, 4221, 4222, 3, 2, 2, 2, 4222,
	547, 3, 2, 2, 2, 4223, 4238, 7, 565, 2, 2, 4224, 4232, 7, 556, 2, 2, 4225,
	4226, 7, 561, 2, 2, 4226, 4232, 7, 560, 2, 2, 4227, 4228, 7, 559, 2, 2,
	4228, 4232, 7, 565, 2, 2, 4229, 4230, 7, 557, 2, 2, 4230, 4232, 7, 565,
	2, 2, 4231, 4224, 3, 2, 2, 2, 4231, 4225, 3, 2, 2, 2, 4231, 4227, 3, 2,
	2, 2, 4231, 4229, 3, 2, 2, 2, 4232, 4238, 3, 2, 2, 2, 4233, 4235, 9, 54,
	2, 2, 4234, 4236, 7, 565, 2, 2, 4235, 4234, 3, 2, 2, 2, 4235, 4236, 3,
	2, 2, 2, 4236, 4238, 3, 2, 2, 2, 4237, 4223, 3, 2, 2, 2, 4237, 4231, 3,
	2, 2, 2, 4237, 4233, 3, 2, 2, 2, 4238, 549, 3, 2, 2, 2, 4239, 4240, 7,
	545, 2, 2, 4240, 4241, 5, 358, 180, 2, 4241, 4242, 7, 546, 2, 2, 4242,
	4258, 3, 2, 2, 2, 4243, 4244, 7, 545, 2, 2, 4244, 4249, 5, 554, 278, 2,
	4245, 4246, 7, 551, 2, 2, 4246, 4248, 5, 554, 278, 2, 4247, 4245, 3, 2,
	2, 2, 4248, 4251, 3, 2, 2, 2, 4249, 4247, 3, 2, 2, 2, 4249, 4250, 3, 2,
	2, 2, 4250, 4252, 3, 2, 2, 2, 4251, 4249, 3, 2, 2, 2, 4252, 4253, 7, 546,
	2, 2, 4253, 4258, 3, 2, 2, 2, 4254, 4258, 5, 752, 377, 2, 4255, 4258, 5,
	744, 373, 2, 4256, 4258, 5, 746, 374, 2, 4257, 4239, 3, 2, 2, 2, 4257,
	4243, 3, 2, 2, 2, 4257, 4254, 3, 2, 2, 2, 4257, 4255, 3, 2, 2, 2, 4257,
	4256, 3, 2, 2, 2, 4258, 551, 3, 2, 2, 2, 4259, 4260, 5, 554, 278, 2, 4260,
	4261, 7, 11, 2, 2, 4261, 4262, 5, 554, 278, 2, 4262, 553, 3, 2, 2, 2, 4263,
	4264, 8, 278, 1, 2, 4264, 4273, 5, 558, 280, 2, 4265, 4270, 7, 18, 2, 2,
	4266, 4271, 7, 226, 2, 2, 4267, 4268, 7, 429, 2, 2, 4268, 4269, 7, 495,
	2, 2, 4269, 4271, 5, 554, 278, 2, 4270, 4266, 3, 2, 2, 2, 4270, 4267, 3,
	2, 2, 2, 4271, 4274, 3, 2, 2, 2, 4272, 4274, 5, 556, 279, 2, 4273, 4265,
	3, 2, 2, 2, 4273, 4272, 3, 2, 2, 2, 4273, 4274, 3, 2, 2, 2, 4274, 4287,
	3, 2, 2, 2, 4275, 4276, 12, 5, 2, 2, 4276, 4277, 9, 55, 2, 2, 4277, 4286,
	5, 554, 278, 6, 4278, 4279, 12, 4, 2, 2, 4279, 4280, 9, 56, 2, 2, 4280,
	4286, 5, 554, 278, 5, 4281, 4282, 12, 3, 2, 2, 4282, 4283, 7, 564, 2, 2,
	4283, 4284, 7, 564, 2, 2, 4284, 4286, 5, 554, 278, 4, 4285, 4275, 3, 2,
	2, 2, 4285, 4278, 3, 2, 2, 2, 4285, 4281, 3, 2, 2, 2, 4286, 4289, 3, 2,
	2, 2, 4287, 4285, 3, 2, 2, 2, 4287, 4288, 3, 2, 2, 2, 4288, 555, 3, 2,
	2, 2, 4289, 4287, 3, 2, 2, 2, 4290, 4295, 7, 97, 2, 2, 4291, 4292, 7, 545,
	2, 2, 4292, 4293, 5, 554, 278, 2, 4293, 4294, 7, 546, 2, 2, 4294, 4296,
	3, 2, 2, 2, 4295, 4291, 3, 2, 2, 2, 4295, 4296, 3, 2, 2, 2, 4296, 4297,
	3, 2, 2, 2, 4297, 4298, 7, 434, 2, 2, 4298, 4303, 7, 375, 2, 2, 4299, 4300,
	7, 545, 2, 2, 4300, 4301, 5, 554, 278, 2, 4301, 4302, 7, 546, 2, 2, 4302,
	4304, 3, 2, 2, 2, 4303, 4299, 3, 2, 2, 2, 4303, 4304, 3, 2, 2, 2, 4304,
	4315, 3, 2, 2, 2, 4305, 4310, 7, 492, 2, 2, 4306, 4307, 7, 545, 2, 2, 4307,
	4308, 5, 554, 278, 2, 4308, 4309, 7, 546, 2, 2, 4309, 4311, 3, 2, 2, 2,
	4310, 4306, 3, 2, 2, 2, 4310, 4311, 3, 2, 2, 2, 4311, 4312, 3, 2, 2, 2,
	4312, 4313, 7, 434, 2, 2, 4313, 4315, 7, 251, 2, 2, 4314, 4290, 3, 2, 2,
	2, 4314, 4305, 3, 2, 2, 2, 4315, 557, 3, 2, 2, 2, 4316, 4321, 5, 566, 284,
	2, 4317, 4318, 7, 566, 2, 2, 4318, 4319, 5, 560, 281, 2, 4319, 4320, 7,
	567, 2, 2, 4320, 4322, 3, 2, 2, 2, 4321, 4317, 3, 2, 2, 2, 4321, 4322,
	3, 2, 2, 2, 4322, 559, 3, 2, 2, 2, 4323, 4326, 7, 12, 2, 2, 4324, 4326,
	5, 536, 269, 2, 4325, 4323, 3, 2, 2, 2, 4325, 4324, 3, 2, 2, 2, 4326, 4334,
	3, 2, 2, 2, 4327, 4330, 7, 551, 2, 2, 4328, 4331, 7, 12, 2, 2, 4329, 4331,
	5, 536, 269, 2, 4330, 4328, 3, 2, 2, 2, 4330, 4329, 3, 2, 2, 2, 4331, 4333,
	3, 2, 2, 2, 4332, 4327, 3, 2, 2, 2, 4333, 4336, 3, 2, 2, 2, 4334, 4332,
	3, 2, 2, 2, 4334, 4335, 3, 2, 2, 2, 4335, 4347, 3, 2, 2, 2, 4336, 4334,
	3, 2, 2, 2, 4337, 4342, 5, 562, 282, 2, 4338, 4339, 7, 551, 2, 2, 4339,
	4341, 5, 562, 282, 2, 4340, 4338, 3, 2, 2, 2, 4341, 4344, 3, 2, 2, 2, 4342,
	4340, 3, 2, 2, 2, 4342, 4343, 3, 2, 2, 2, 4343, 4347, 3, 2, 2, 2, 4344,
	4342, 3, 2, 2, 2, 4345, 4347, 5, 564, 283, 2, 4346, 4325, 3, 2, 2, 2, 4346,
	4337, 3, 2, 2, 2, 4346, 4345, 3, 2, 2, 2, 4347, 561, 3, 2, 2, 2, 4348,
	4349, 7, 162, 2, 2, 4349, 4367, 5, 714, 358, 2, 4350, 4351, 7, 191, 2,
	2, 4351, 4353, 7, 545, 2, 2, 4352, 4354, 5, 534, 268, 2, 4353, 4352, 3,
	2, 2, 2, 4353, 4354, 3, 2, 2, 2, 4354, 4355, 3, 2, 2, 2, 4355, 4368, 7,
	546, 2, 2, 4356, 4357, 7, 223, 2, 2, 4357, 4359, 5, 536, 269, 2, 4358,
	4356, 3, 2, 2, 2, 4358, 4359, 3, 2, 2, 2, 4359, 4360, 3, 2, 2, 2, 4360,
	4361, 7, 165, 2, 2, 4361, 4362, 5, 536, 269, 2, 4362, 4363, 7, 434, 2,
	2, 4363, 4364, 5, 536, 269, 2, 4364, 4365, 9, 57, 2, 2, 4365, 4366, 5,
	536, 269, 2, 4366, 4368, 3, 2, 2, 2, 4367, 4350, 3, 2, 2, 2, 4367, 4358,
	3, 2, 2, 2, 4368, 563, 3, 2, 2, 2, 4369, 4370, 7, 162, 2, 2, 4370, 4371,
	7, 545, 2, 2, 4371, 4376, 5, 714, 358, 2, 4372, 4373, 7, 551, 2, 2, 4373,
	4375, 5, 714, 358, 2, 4374, 4372, 3, 2, 2, 2, 4375, 4378, 3, 2, 2, 2, 4376,
	4374, 3, 2, 2, 2, 4376, 4377, 3, 2, 2, 2, 4377, 4379, 3, 2, 2, 2, 4378,
	4376, 3, 2, 2, 2, 4379, 4380, 7, 546, 2, 2, 4380, 4381, 7, 191, 2, 2, 4381,
	4388, 7, 545, 2, 2, 4382, 4389, 5, 358, 180, 2, 4383, 4385, 7, 545, 2,
	2, 4384, 4386, 5, 534, 268, 2, 4385, 4384, 3, 2, 2, 2, 4385, 4386, 3, 2,
	2, 2, 4386, 4387, 3, 2, 2, 2, 4387, 4389, 7, 546, 2, 2, 4388, 4382, 3,
	2, 2, 2, 4388, 4383, 3, 2, 2, 2, 4389, 4390, 3, 2, 2, 2, 4390, 4391, 7,
	546, 2, 2, 4391, 565, 3, 2, 2, 2, 4392, 4393, 9, 56, 2, 2, 4393, 4409,
	5, 566, 284, 2, 4394, 4395, 7, 333, 2, 2, 4395, 4409, 5, 566, 284, 2, 4396,
	4397, 7, 71, 2, 2, 4397, 4409, 5, 566, 284, 2, 4398, 4399, 7, 262, 2, 2,
	4399, 4409, 5, 566, 284, 2, 4400, 4401, 7, 118, 2, 2, 4401, 4409, 5, 566,
	284, 2, 4402, 4403, 7, 8, 2, 2, 4403, 4409, 5, 566, 284, 2, 4404, 4409,
	5, 568, 285, 2, 4405, 4409, 5, 582, 292, 2, 4406, 4409, 5, 586, 294, 2,
	4407, 4409, 5, 580, 291, 2, 4408, 4392, 3, 2, 2, 2, 4408, 4394, 3, 2, 2,
	2, 4408, 4396, 3, 2, 2, 2, 4408, 4398, 3, 2, 2, 2, 4408, 4400, 3, 2, 2,
	2, 4408, 4402, 3, 2, 2, 2, 4408, 4404, 3, 2, 2, 2, 4408, 4405, 3, 2, 2,
	2, 4408, 4406, 3, 2, 2, 2, 4408, 4407, 3, 2, 2, 2, 4409, 567, 3, 2, 2,
	2, 4410, 4413, 5, 574, 288, 2, 4411, 4413, 5, 570, 286, 2, 4412, 4410,
	3, 2, 2, 2, 4412, 4411, 3, 2, 2, 2, 4413, 569, 3, 2, 2, 2, 4414, 4416,
	5, 688, 345, 2, 4415, 4414, 3, 2, 2, 2, 4415, 4416, 3, 2, 2, 2, 4416, 4417,
	3, 2, 2, 2, 4417, 4418, 7, 48, 2, 2, 4418, 4420, 5, 536, 269, 2, 4419,
	4421, 5, 572, 287, 2, 4420, 4419, 3, 2, 2, 2, 4421, 4422, 3, 2, 2, 2, 4422,
	4420, 3, 2, 2, 2, 4422, 4423, 3, 2, 2, 2, 4423, 4425, 3, 2, 2, 2, 4424,
	4426, 5, 578, 290, 2, 4425, 4424, 3, 2, 2, 2, 4425, 4426, 3, 2, 2, 2, 4426,
	4427, 3, 2, 2, 2, 4427, 4429, 7, 131, 2, 2, 4428, 4430, 7, 48, 2, 2, 4429,
	4428, 3, 2, 2, 2, 4429, 4430, 3, 2, 2, 2, 4430, 4432, 3, 2, 2, 2, 4431,
	4433, 5, 688, 345, 2, 4432, 4431, 3, 2, 2, 2, 4432, 4433, 3, 2, 2, 2, 4433,
	571, 3, 2, 2, 2, 4434, 4435, 7, 470, 2, 2, 4435, 4436, 5, 536, 269, 2,
	4436, 4439, 7, 423, 2, 2, 4437, 4440, 5, 260, 131, 2, 4438, 4440, 5, 536,
	269, 2, 4439, 4437, 3, 2, 2, 2, 4439, 4438, 3, 2, 2, 2, 4440, 573, 3, 2,
	2, 2, 4441, 4443, 5, 688, 345, 2, 4442, 4441, 3, 2, 2, 2, 4442, 4443, 3,
	2, 2, 2, 4443, 4444, 3, 2, 2, 2, 4444, 4446, 7, 48, 2, 2, 4445, 4447, 5,
	576, 289, 2, 4446, 4445, 3, 2, 2, 2, 4447, 4448, 3, 2, 2, 2, 4448, 4446,
	3, 2, 2, 2, 4448, 4449, 3, 2, 2, 2, 4449, 4451, 3, 2, 2, 2, 4450, 4452,
	5, 578, 290, 2, 4451, 4450, 3, 2, 2, 2, 4451, 4452, 3, 2, 2, 2, 4452, 4453,
	3, 2, 2, 2, 4453, 4455, 7, 131, 2, 2, 4454, 4456, 7, 48, 2, 2, 4455, 4454,
	3, 2, 2, 2, 4455, 4456, 3, 2, 2, 2, 4456, 4458, 3, 2, 2, 2, 4457, 4459,
	5, 688, 345, 2, 4458, 4457, 3, 2, 2, 2, 4458, 4459, 3, 2, 2, 2, 4459, 575,
	3, 2, 2, 2, 4460, 4461, 7, 470, 2, 2, 4461, 4462, 5, 536, 269, 2, 4462,
	4465, 7, 423, 2, 2, 4463, 4466, 5, 260, 131, 2, 4464, 4466, 5, 536, 269,
	2, 4465, 4463, 3, 2, 2, 2, 4465, 4464, 3, 2, 2, 2, 4466, 577, 3, 2, 2,
	2, 4467, 4470, 7, 125, 2, 2, 4468, 4471, 5, 260, 131, 2, 4469, 4471, 5,
	536, 269, 2, 4470, 4468, 3, 2, 2, 2, 4470, 4469, 3, 2, 2, 2, 4471, 579,
	3, 2, 2, 2, 4472, 4473, 5, 750, 376, 2, 4473, 4474, 5, 764, 383, 2, 4474,
	4492, 3, 2, 2, 2, 4475, 4492, 5, 744, 373, 2, 4476, 4492, 5, 752, 377,
	2, 4477, 4492, 5, 746, 374, 2, 4478, 4479, 7, 545, 2, 2, 4479, 4480, 5,
	358, 180, 2, 4480, 4484, 7, 546, 2, 2, 4481, 4483, 5, 362, 182, 2, 4482,
	4481, 3, 2, 2, 2, 4483, 4486, 3, 2, 2, 2, 4484, 4482, 3, 2, 2, 2, 4484,
	4485, 3, 2, 2, 2, 4485, 4492, 3, 2, 2, 2, 4486, 4484, 3, 2, 2, 2, 4487,
	4488, 7, 545, 2, 2, 4488, 4489, 5, 534, 268, 2, 4489, 4490, 7, 546, 2,
	2, 4490, 4492, 3, 2, 2, 2, 4491, 4472, 3, 2, 2, 2, 4491, 4475, 3, 2, 2,
	2, 4491, 4476, 3, 2, 2, 2, 4491, 4477, 3, 2, 2, 2, 4491, 4478, 3, 2, 2,
	2, 4491, 4487, 3, 2, 2, 2, 4492, 581, 3, 2, 2, 2, 4493, 4502, 9, 58, 2,
	2, 4494, 4495, 7, 545, 2, 2, 4495, 4496, 5, 358, 180, 2, 4496, 4497, 7,
	546, 2, 2, 4497, 4503, 3, 2, 2, 2, 4498, 4499, 7, 545, 2, 2, 4499, 4500,
	5, 536, 269, 2, 4500, 4501, 7, 546, 2, 2, 4501, 4503, 3, 2, 2, 2, 4502,
	4494, 3, 2, 2, 2, 4502, 4498, 3, 2, 2, 2, 4503, 583, 3, 2, 2, 2, 4504,
	4505, 7, 524, 2, 2, 4505, 4506, 7, 545, 2, 2, 4506, 4507, 5, 536, 269,
	2, 4507, 4508, 7, 551, 2, 2, 4508, 4511, 5, 536, 269, 2, 4509, 4510, 7,
	551, 2, 2, 4510, 4512, 5, 536, 269, 2, 4511, 4509, 3, 2, 2, 2, 4511, 4512,
	3, 2, 2, 2, 4512, 4513, 3, 2, 2, 2, 4513, 4514, 7, 546, 2, 2, 4514, 4575,
	3, 2, 2, 2, 4515, 4516, 7, 525, 2, 2, 4516, 4520, 7, 545, 2, 2, 4517, 4521,
	5, 750, 376, 2, 4518, 4521, 5, 586, 294, 2, 4519, 4521, 5, 536, 269, 2,
	4520, 4517, 3, 2, 2, 2, 4520, 4518, 3, 2, 2, 2, 4520, 4519, 3, 2, 2, 2,
	4521, 4524, 3, 2, 2, 2, 4522, 4523, 7, 551, 2, 2, 4523, 4525, 5, 758, 380,
	2, 4524, 4522, 3, 2, 2, 2, 4524, 4525, 3, 2, 2, 2, 4525, 4528, 3, 2, 2,
	2, 4526, 4527, 7, 551, 2, 2, 4527, 4529, 5, 758, 380, 2, 4528, 4526, 3,
	2, 2, 2, 4528, 4529, 3, 2, 2, 2, 4529, 4530, 3, 2, 2, 2, 4530, 4531, 7,
	546, 2, 2, 4531, 4575, 3, 2, 2, 2, 4532, 4533, 7, 512, 2, 2, 4533, 4534,
	7, 545, 2, 2, 4534, 4535, 5, 534, 268, 2, 4535, 4536, 7, 546, 2, 2, 4536,
	4575, 3, 2, 2, 2, 4537, 4538, 7, 54, 2, 2, 4538, 4539, 7, 545, 2, 2, 4539,
	4540, 5, 554, 278, 2, 4540, 4541, 7, 455, 2, 2, 4541, 4542, 7, 258, 2,
	2, 4542, 4543, 7, 546, 2, 2, 4543, 4575, 3, 2, 2, 2, 4544, 4545, 7, 519,
	2, 2, 4545, 4546, 7, 545, 2, 2, 4546, 4547, 5, 536, 269, 2, 4547, 4548,
	7, 551, 2, 2, 4548, 4549, 5, 536, 269, 2, 4549, 4550, 7, 546, 2, 2, 4550,
	4575, 3, 2, 2, 2, 4551, 4552, 7, 526, 2, 2, 4552, 4560, 7, 545, 2, 2, 4553,
	4555, 9, 59, 2, 2, 4554, 4553, 3, 2, 2, 2, 4554, 4555, 3, 2, 2, 2, 4555,
	4557, 3, 2, 2, 2, 4556, 4558, 5, 758, 380, 2, 4557, 4556, 3, 2, 2, 2, 4557,
	4558, 3, 2, 2, 2, 4558, 4559, 3, 2, 2, 2, 4559, 4561, 7, 165, 2, 2, 4560,
	4554, 3, 2, 2, 2, 4560, 4561, 3, 2, 2, 2, 4561, 4562, 3, 2, 2, 2, 4562,
	4563, 5, 554, 278, 2, 4563, 4564, 7, 546, 2, 2, 4564, 4575, 3, 2, 2, 2,
	4565, 4566, 7, 533, 2, 2, 4566, 4567, 7, 545, 2, 2, 4567, 4570, 5, 536,
	269, 2, 4568, 4569, 7, 551, 2, 2, 4569, 4571, 5, 758, 380, 2, 4570, 4568,
	3, 2, 2, 2, 4570, 4571, 3, 2, 2, 2, 4571, 4572, 3, 2, 2, 2, 4572, 4573,
	7, 546, 2, 2, 4573, 4575, 3, 2, 2, 2, 4574, 4504, 3, 2, 2, 2, 4574, 4515,
	3, 2, 2, 2, 4574, 4532, 3, 2, 2, 2, 4574, 4537, 3, 2, 2, 2, 4574, 4544,
	3, 2, 2, 2, 4574, 4551, 3, 2, 2, 2, 4574, 4565, 3, 2, 2, 2, 4575, 585,
	3, 2, 2, 2, 4576, 4580, 5, 584, 293, 2, 4577, 4580, 5, 588, 295, 2, 4578,
	4580, 5, 592, 297, 2, 4579, 4576, 3, 2, 2, 2, 4579, 4577, 3, 2, 2, 2, 4579,
	4578, 3, 2, 2, 2, 4580, 587, 3, 2, 2, 2, 4581, 4584, 5, 590, 296, 2, 4582,
	4585, 5, 562, 282, 2, 4583, 4585, 5, 564, 283, 2, 4584, 4582, 3, 2, 2,
	2, 4584, 4583, 3, 2, 2, 2, 4584, 4585, 3, 2, 2, 2, 4585, 589, 3, 2, 2,
	2, 4586, 4587, 7, 527, 2, 2, 4587, 4589, 7, 545, 2, 2, 4588, 4590, 9, 60,
	2, 2, 4589, 4588, 3, 2, 2, 2, 4589, 4590, 3, 2, 2, 2, 4590, 4591, 3, 2,
	2, 2, 4591, 4592, 5, 536, 269, 2, 4592, 4593, 7, 546, 2, 2, 4593, 4645,
	3, 2, 2, 2, 4594, 4595, 7, 84, 2, 2, 4595, 4603, 7, 545, 2, 2, 4596, 4604,
	7, 548, 2, 2, 4597, 4599, 9, 38, 2, 2, 4598, 4597, 3, 2, 2, 2, 4598, 4599,
	3, 2, 2, 2, 4599, 4600, 3, 2, 2, 2, 4600, 4602, 5, 554, 278, 2, 4601, 4598,
	3, 2, 2, 2, 4601, 4602, 3, 2, 2, 2, 4602, 4604, 3, 2, 2, 2, 4603, 4596,
	3, 2, 2, 2, 4603, 4601, 3, 2, 2, 2, 4604, 4605, 3, 2, 2, 2, 4605, 4607,
	7, 546, 2, 2, 4606, 4608, 5, 600, 301, 2, 4607, 4606, 3, 2, 2, 2, 4607,
	4608, 3, 2, 2, 2, 4608, 4645, 3, 2, 2, 2, 4609, 4610, 7, 522, 2, 2, 4610,
	4611, 7, 545, 2, 2, 4611, 4614, 5, 536, 269, 2, 4612, 4613, 7, 551, 2,
	2, 4613, 4615, 7, 539, 2, 2, 4614, 4612, 3, 2, 2, 2, 4614, 4615, 3, 2,
	2, 2, 4615, 4616, 3, 2, 2, 2, 4616, 4617, 7, 546, 2, 2, 4617, 4645, 3,
	2, 2, 2, 4618, 4619, 7, 509, 2, 2, 4619, 4621, 7, 545, 2, 2, 4620, 4622,
	9, 60, 2, 2, 4621, 4620, 3, 2, 2, 2, 4621, 4622, 3, 2, 2, 2, 4622, 4623,
	3, 2, 2, 2, 4623, 4624, 5, 536, 269, 2, 4624, 4625, 7, 546, 2, 2, 4625,
	4645, 3, 2, 2, 2, 4626, 4627, 7, 515, 2, 2, 4627, 4629, 7, 545, 2, 2, 4628,
	4630, 9, 60, 2, 2, 4629, 4628, 3, 2, 2, 2, 4629, 4630, 3, 2, 2, 2, 4630,
	4631, 3, 2, 2, 2, 4631, 4632, 5, 536, 269, 2, 4632, 4633, 7, 546, 2, 2,
	4633, 4645, 3, 2, 2, 2, 4634, 4635, 7, 531, 2, 2, 4635, 4636, 7, 545, 2,
	2, 4636, 4637, 5, 534, 268, 2, 4637, 4638, 7, 546, 2, 2, 4638, 4645, 3,
	2, 2, 2, 4639, 4640, 7, 532, 2, 2, 4640, 4641, 7, 545, 2, 2, 4641, 4642,
	5, 534, 268, 2, 4642, 4643, 7, 546, 2, 2, 4643, 4645, 3, 2, 2, 2, 4644,
	4586, 3, 2, 2, 2, 4644, 4594, 3, 2, 2, 2, 4644, 4609, 3, 2, 2, 2, 4644,
	4618, 3, 2, 2, 2, 4644, 4626, 3, 2, 2, 2, 4644, 4634, 3, 2, 2, 2, 4644,
	4639, 3, 2, 2, 2, 4645, 591, 3, 2, 2, 2, 4646, 4647, 5, 594, 298, 2, 4647,
	4649, 5, 728, 365, 2, 4648, 4650, 5, 600, 301, 2, 4649, 4648, 3, 2, 2,
	2, 4649, 4650, 3, 2, 2, 2, 4650, 4962, 3, 2, 2, 2, 4651, 4652, 5, 766,
	384, 2, 4652, 4654, 5, 730, 366, 2, 4653, 4655, 5, 608, 305, 2, 4654, 4653,
	3, 2, 2, 2, 4654, 4655, 3, 2, 2, 2, 4655, 4962, 3, 2, 2, 2, 4656, 4657,
	7, 84, 2, 2, 4657, 4663, 7, 545, 2, 2, 4658, 4664, 7, 548, 2, 2, 4659,
	4661, 9, 38, 2, 2, 4660, 4659, 3, 2, 2, 2, 4660, 4661, 3, 2, 2, 2, 4661,
	4662, 3, 2, 2, 2, 4662, 4664, 5, 554, 278, 2, 4663, 4658, 3, 2, 2, 2, 4663,
	4660, 3, 2, 2, 2, 4664, 4665, 3, 2, 2, 2, 4665, 4667, 7, 546, 2, 2, 4666,
	4668, 5, 600, 301, 2, 4667, 4666, 3, 2, 2, 2, 4667, 4668, 3, 2, 2, 2, 4668,
	4962, 3, 2, 2, 2, 4669, 4670, 9, 61, 2, 2, 4670, 4677, 7, 545, 2, 2, 4671,
	4672, 7, 252, 2, 2, 4672, 4673, 7, 545, 2, 2, 4673, 4674, 5, 358, 180,
	2, 4674, 4675, 7, 546, 2, 2, 4675, 4678, 3, 2, 2, 2, 4676, 4678, 5, 554,
	278, 2, 4677, 4671, 3, 2, 2, 2, 4677, 4676, 3, 2, 2, 2, 4678, 4679, 3,
	2, 2, 2, 4679, 4680, 7, 15, 2, 2, 4680, 4681, 5, 736, 369, 2, 4681, 4682,
	7, 546, 2, 2, 4682, 4962, 3, 2, 2, 2, 4683, 4684, 7, 59, 2, 2, 4684, 4685,
	7, 545, 2, 2, 4685, 4691, 5, 750, 376, 2, 4686, 4689, 7, 551, 2, 2, 4687,
	4690, 5, 754, 378, 2, 4688, 4690, 5, 758, 380, 2, 4689, 4687, 3, 2, 2,
	2, 4689, 4688, 3, 2, 2, 2, 4690, 4692, 3, 2, 2, 2, 4691, 4686, 3, 2, 2,
	2, 4691, 4692, 3, 2, 2, 2, 4692, 4693, 3, 2, 2, 2, 4693, 4694, 7, 546,
	2, 2, 4694, 4962, 3, 2, 2, 2, 4695, 4696, 7, 60, 2, 2, 4696, 4698, 7, 545,
	2, 2, 4697, 4699, 9, 62, 2, 2, 4698, 4697, 3, 2, 2, 2, 4698, 4699, 3, 2,
	2, 2, 4699, 4700, 3, 2, 2, 2, 4700, 4702, 5, 554, 278, 2, 4701, 4703, 5,
	612, 307, 2, 4702, 4701, 3, 2, 2, 2, 4702, 4703, 3, 2, 2, 2, 4703, 4704,
	3, 2, 2, 2, 4704, 4705, 7, 546, 2, 2, 4705, 4962, 3, 2, 2, 2, 4706, 4707,
	5, 596, 299, 2, 4707, 4709, 5, 726, 364, 2, 4708, 4710, 5, 614, 308, 2,
	4709, 4708, 3, 2, 2, 2, 4710, 4711, 3, 2, 2, 2, 4711, 4709, 3, 2, 2, 2,
	4711, 4712, 3, 2, 2, 2, 4712, 4962, 3, 2, 2, 2, 4713, 4714, 5, 706, 354,
	2, 4714, 4715, 9, 63, 2, 2, 4715, 4962, 3, 2, 2, 2, 4716, 4717, 7, 105,
	2, 2, 4717, 4718, 7, 545, 2, 2, 4718, 4720, 5, 554, 278, 2, 4719, 4721,
	9, 64, 2, 2, 4720, 4719, 3, 2, 2, 2, 4720, 4721, 3, 2, 2, 2, 4721, 4722,
	3, 2, 2, 2, 4722, 4723, 7, 546, 2, 2, 4723, 4962, 3, 2, 2, 2, 4724, 4725,
	7, 147, 2, 2, 4725, 4726, 7, 545, 2, 2, 4726, 4727, 5, 766, 384, 2, 4727,
	4728, 7, 165, 2, 2, 4728, 4729, 5, 554, 278, 2, 4729, 4730, 7, 546, 2,
	2, 4730, 4962, 3, 2, 2, 2, 4731, 4732, 9, 65, 2, 2, 4732, 4734, 5, 728,
	365, 2, 4733, 4735, 5, 732, 367, 2, 4734, 4733, 3, 2, 2, 2, 4734, 4735,
	3, 2, 2, 2, 4735, 4736, 3, 2, 2, 2, 4736, 4737, 5, 600, 301, 2, 4737, 4962,
	3, 2, 2, 2, 4738, 4739, 5, 598, 300, 2, 4739, 4740, 7, 545, 2, 2, 4740,
	4742, 5, 534, 268, 2, 4741, 4743, 5, 616, 309, 2, 4742, 4741, 3, 2, 2,
	2, 4742, 4743, 3, 2, 2, 2, 4743, 4745, 3, 2, 2, 2, 4744, 4746, 5, 608,
	305, 2, 4745, 4744, 3, 2, 2, 2, 4745, 4746, 3, 2, 2, 2, 4746, 4747, 3,
	2, 2, 2, 4747, 4748, 7, 546, 2, 2, 4748, 4962, 3, 2, 2, 2, 4749, 4750,
	7, 437, 2, 2, 4750, 4751, 7, 545, 2, 2, 4751, 4754, 5, 536, 269, 2, 4752,
	4753, 7, 455, 2, 2, 4753, 4755, 9, 66, 2, 2, 4754, 4752, 3, 2, 2, 2, 4754,
	4755, 3, 2, 2, 2, 4755, 4760, 3, 2, 2, 2, 4756, 4757, 7, 551, 2, 2, 4757,
	4759, 5, 536, 269, 2, 4758, 4756, 3, 2, 2, 2, 4759, 4762, 3, 2, 2, 2, 4760,
	4758, 3, 2, 2, 2, 4760, 4761, 3, 2, 2, 2, 4761, 4763, 3, 2, 2, 2, 4762,
	4760, 3, 2, 2, 2, 4763, 4764, 7, 546, 2, 2, 4764, 4962, 3, 2, 2, 2, 4765,
	4766, 7, 438, 2, 2, 4766, 4767, 7, 545, 2, 2, 4767, 4768, 5, 536, 269,
	2, 4768, 4770, 7, 15, 2, 2, 4769, 4771, 7, 347, 2, 2, 4770, 4769, 3, 2,
	2, 2, 4770, 4771, 3, 2, 2, 2, 4771, 4772, 3, 2, 2, 2, 4772, 4773, 5, 736,
	369, 2, 4773, 4774, 7, 546, 2, 2, 4774, 4962, 3, 2, 2, 2, 4775, 4776, 7,
	526, 2, 2, 4776, 4784, 7, 545, 2, 2, 4777, 4779, 9, 59, 2, 2, 4778, 4777,
	3, 2, 2, 2, 4778, 4779, 3, 2, 2, 2, 4779, 4781, 3, 2, 2, 2, 4780, 4782,
	5, 758, 380, 2, 4781, 4780, 3, 2, 2, 2, 4781, 4782, 3, 2, 2, 2, 4782, 4783,
	3, 2, 2, 2, 4783, 4785, 7, 165, 2, 2, 4784, 4778, 3, 2, 2, 2, 4784, 4785,
	3, 2, 2, 2, 4785, 4786, 3, 2, 2, 2, 4786, 4787, 5, 554, 278, 2, 4787, 4788,
	7, 546, 2, 2, 4788, 4962, 3, 2, 2, 2, 4789, 4790, 7, 477, 2, 2, 4790, 4791,
	7, 545, 2, 2, 4791, 4793, 5, 536, 269, 2, 4792, 4794, 5, 456, 229, 2, 4793,
	4792, 3, 2, 2, 2, 4793, 4794, 3, 2, 2, 2, 4794, 4795, 3, 2, 2, 2, 4795,
	4798, 7, 546, 2, 2, 4796, 4797, 7, 538, 2, 2, 4797, 4799, 5, 748, 375,
	2, 4798, 4796, 3, 2, 2, 2, 4798, 4799, 3, 2, 2, 2, 4799, 4962, 3, 2, 2,
	2, 4800, 4801, 9, 67, 2, 2, 4801, 4802, 7, 545, 2, 2, 4802, 4807, 5, 628,
	315, 2, 4803, 4804, 7, 551, 2, 2, 4804, 4806, 5, 628, 315, 2, 4805, 4803,
	3, 2, 2, 2, 4806, 4809, 3, 2, 2, 2, 4807, 4805, 3, 2, 2, 2, 4807, 4808,
	3, 2, 2, 2, 4808, 4810, 3, 2, 2, 2, 4809, 4807, 3, 2, 2, 2, 4810, 4813,
	7, 546, 2, 2, 4811, 4812, 7, 538, 2, 2, 4812, 4814, 5, 748, 375, 2, 4813,
	4811, 3, 2, 2, 2, 4813, 4814, 3, 2, 2, 2, 4814, 4962, 3, 2, 2, 2, 4815,
	4816, 7, 481, 2, 2, 4816, 4818, 7, 545, 2, 2, 4817, 4819, 9, 68, 2, 2,
	4818, 4817, 3, 2, 2, 2, 4818, 4819, 3, 2, 2, 2, 4819, 4821, 3, 2, 2, 2,
	4820, 4822, 9, 69, 2, 2, 4821, 4820, 3, 2, 2, 2, 4821, 4822, 3, 2, 2, 2,
	4822, 4823, 3, 2, 2, 2, 4823, 4826, 5, 536, 269, 2, 4824, 4825, 7, 551,
	2, 2, 4825, 4827, 5, 620, 311, 2, 4826, 4824, 3, 2, 2, 2, 4826, 4827, 3,
	2, 2, 2, 4827, 4835, 3, 2, 2, 2, 4828, 4829, 7, 551, 2, 2, 4829, 4831,
	5, 536, 269, 2, 4830, 4832, 5, 648, 325, 2, 4831, 4830, 3, 2, 2, 2, 4831,
	4832, 3, 2, 2, 2, 4832, 4834, 3, 2, 2, 2, 4833, 4828, 3, 2, 2, 2, 4834,
	4837, 3, 2, 2, 2, 4835, 4833, 3, 2, 2, 2, 4835, 4836, 3, 2, 2, 2, 4836,
	4838, 3, 2, 2, 2, 4837, 4835, 3, 2, 2, 2, 4838, 4841, 7, 546, 2, 2, 4839,
	4840, 7, 538, 2, 2, 4840, 4842, 5, 748, 375, 2, 4841, 4839, 3, 2, 2, 2,
	4841, 4842, 3, 2, 2, 2, 4842, 4962, 3, 2, 2, 2, 4843, 4844, 7, 482, 2,
	2, 4844, 4845, 7, 545, 2, 2, 4845, 4847, 5, 536, 269, 2, 4846, 4848, 5,
	618, 310, 2, 4847, 4846, 3, 2, 2, 2, 4847, 4848, 3, 2, 2, 2, 4848, 4849,
	3, 2, 2, 2, 4849, 4850, 7, 546, 2, 2, 4850, 4962, 3, 2, 2, 2, 4851, 4852,
	7, 485, 2, 2, 4852, 4853, 7, 545, 2, 2, 4853, 4854, 9, 70, 2, 2, 4854,
	4856, 5, 554, 278, 2, 4855, 4857, 7, 468, 2, 2, 4856, 4855, 3, 2, 2, 2,
	4856, 4857, 3, 2, 2, 2, 4857, 4858, 3, 2, 2, 2, 4858, 4861, 7, 546, 2,
	2, 4859, 4860, 7, 538, 2, 2, 4860, 4862, 5, 748, 375, 2, 4861, 4859, 3,
	2, 2, 2, 4861, 4862, 3, 2, 2, 2, 4862, 4962, 3, 2, 2, 2, 4863, 4864, 7,
	486, 2, 2, 4864, 4869, 7, 545, 2, 2, 4865, 4866, 7, 253, 2, 2, 4866, 4870,
	5, 760, 381, 2, 4867, 4868, 7, 136, 2, 2, 4868, 4870, 5, 554, 278, 2, 4869,
	4865, 3, 2, 2, 2, 4869, 4867, 3, 2, 2, 2, 4870, 4873, 3, 2, 2, 2, 4871,
	4872, 7, 551, 2, 2, 4872, 4874, 5, 554, 278, 2, 4873, 4871, 3, 2, 2, 2,
	4873, 4874, 3, 2, 2, 2, 4874, 4875, 3, 2, 2, 2, 4875, 4878, 7, 546, 2,
	2, 4876, 4877, 7, 538, 2, 2, 4877, 4879, 5, 748, 375, 2, 4878, 4876, 3,
	2, 2, 2, 4878, 4879, 3, 2, 2, 2, 4879, 4962, 3, 2, 2, 2, 4880, 4881, 7,
	487, 2, 2, 4881, 4882, 7, 545, 2, 2, 4882, 4884, 5, 554, 278, 2, 4883,
	4885, 5, 618, 310, 2, 4884, 4883, 3, 2, 2, 2, 4884, 4885, 3, 2, 2, 2, 4885,
	4886, 3, 2, 2, 2, 4886, 4887, 7, 356, 2, 2, 4887, 4891, 7, 77, 2, 2, 4888,
	4889, 7, 279, 2, 2, 4889, 4890, 7, 291, 2, 2, 4890, 4892, 7, 127, 2, 2,
	4891, 4888, 3, 2, 2, 2, 4891, 4892, 3, 2, 2, 2, 4892, 4893, 3, 2, 2, 2,
	4893, 4896, 7, 546, 2, 2, 4894, 4895, 7, 538, 2, 2, 4895, 4897, 5, 748,
	375, 2, 4896, 4894, 3, 2, 2, 2, 4896, 4897, 3, 2, 2, 2, 4897, 4962, 3,
	2, 2, 2, 4898, 4899, 7, 488, 2, 2, 4899, 4900, 7, 545, 2, 2, 4900, 4903,
	5, 554, 278, 2, 4901, 4902, 7, 551, 2, 2, 4902, 4904, 5, 630, 316, 2, 4903,
	4901, 3, 2, 2, 2, 4903, 4904, 3, 2, 2, 2, 4904, 4907, 3, 2, 2, 2, 4905,
	4906, 7, 551, 2, 2, 4906, 4908, 5, 632, 317, 2, 4907, 4905, 3, 2, 2, 2,
	4907, 4908, 3, 2, 2, 2, 4908, 4909, 3, 2, 2, 2, 4909, 4912, 7, 546, 2,
	2, 4910, 4911, 7, 538, 2, 2, 4911, 4913, 5, 748, 375, 2, 4912, 4910, 3,
	2, 2, 2, 4912, 4913, 3, 2, 2, 2, 4913, 4962, 3, 2, 2, 2, 4914, 4915, 7,
	489, 2, 2, 4915, 4916, 7, 545, 2, 2, 4916, 4917, 9, 70, 2, 2, 4917, 4920,
	5, 554, 278, 2, 4918, 4919, 7, 15, 2, 2, 4919, 4921, 5, 736, 369, 2, 4920,
	4918, 3, 2, 2, 2, 4920, 4921, 3, 2, 2, 2, 4921, 4923, 3, 2, 2, 2, 4922,
	4924, 5, 634, 318, 2, 4923, 4922, 3, 2, 2, 2, 4923, 4924, 3, 2, 2, 2, 4924,
	4926, 3, 2, 2, 2, 4925, 4927, 5, 636, 319, 2, 4926, 4925, 3, 2, 2, 2, 4926,
	4927, 3, 2, 2, 2, 4927, 4929, 3, 2, 2, 2, 4928, 4930, 5, 638, 320, 2, 4929,
	4928, 3, 2, 2, 2, 4929, 4930, 3, 2, 2, 2, 4930, 4933, 3, 2, 2, 2, 4931,
	4932, 9, 71, 2, 2, 4932, 4934, 7, 108, 2, 2, 4933, 4931, 3, 2, 2, 2, 4933,
	4934, 3, 2, 2, 2, 4934, 4935, 3, 2, 2, 2, 4935, 4938, 7, 546, 2, 2, 4936,
	4937, 7, 538, 2, 2, 4937, 4939, 5, 748, 375, 2, 4938, 4936, 3, 2, 2, 2,
	4938, 4939, 3, 2, 2, 2, 4939, 4962, 3, 2, 2, 2, 4940, 4941, 7, 490, 2,
	2, 4941, 4943, 7, 545, 2, 2, 4942, 4944, 5, 622, 312, 2, 4943, 4942, 3,
	2, 2, 2, 4943, 4944, 3, 2, 2, 2, 4944, 4945, 3, 2, 2, 2, 4945, 4947, 5,
	554, 278, 2, 4946, 4948, 5, 618, 310, 2, 4947, 4946, 3, 2, 2, 2, 4947,
	4948, 3, 2, 2, 2, 4948, 4954, 3, 2, 2, 2, 4949, 4950, 7, 62, 2, 2, 4950,
	4951, 5, 624, 313, 2, 4951, 4952, 7, 551, 2, 2, 4952, 4953, 5, 624, 313,
	2, 4953, 4955, 3, 2, 2, 2, 4954, 4949, 3, 2, 2, 2, 4954, 4955, 3, 2, 2,
	2, 4955, 4956, 3, 2, 2, 2, 4956, 4959, 7, 546, 2, 2, 4957, 4958, 7, 538,
	2, 2, 4958, 4960, 5, 748, 375, 2, 4959, 4957, 3, 2, 2, 2, 4959, 4960, 3,
	2, 2, 2, 4960, 4962, 3, 2, 2, 2, 4961, 4646, 3, 2, 2, 2, 4961, 4651, 3,
	2, 2, 2, 4961, 4656, 3, 2, 2, 2, 4961, 4669, 3, 2, 2, 2, 4961, 4683, 3,
	2, 2, 2, 4961, 4695, 3, 2, 2, 2, 4961, 4706, 3, 2, 2, 2, 4961, 4713, 3,
	2, 2, 2, 4961, 4716, 3, 2, 2, 2, 4961, 4724, 3, 2, 2, 2, 4961, 4731, 3,
	2, 2, 2, 4961, 4738, 3, 2, 2, 2, 4961, 4749, 3, 2, 2, 2, 4961, 4765, 3,
	2, 2, 2, 4961, 4775, 3, 2, 2, 2, 4961, 4789, 3, 2, 2, 2, 4961, 4800, 3,
	2, 2, 2, 4961, 4815, 3, 2, 2, 2, 4961, 4843, 3, 2, 2, 2, 4961, 4851, 3,
	2, 2, 2, 4961, 4863, 3, 2, 2, 2, 4961, 4880, 3, 2, 2, 2, 4961, 4898, 3,
	2, 2, 2, 4961, 4914, 3, 2, 2, 2, 4961, 4940, 3, 2, 2, 2, 4962, 593, 3,
	2, 2, 2, 4963, 4964, 9, 72, 2, 2, 4964, 595, 3, 2, 2, 2, 4965, 4966, 9,
	73, 2, 2, 4966, 597, 3, 2, 2, 2, 4967, 4968, 9, 74, 2, 2, 4968, 599, 3,
	2, 2, 2, 4969, 4970, 7, 302, 2, 2, 4970, 4972, 7, 545, 2, 2, 4971, 4973,
	5, 388, 195, 2, 4972, 4971, 3, 2, 2, 2, 4972, 4973, 3, 2, 2, 2, 4973, 4978,
	3, 2, 2, 2, 4974, 4976, 5, 456, 229, 2, 4975, 4977, 5, 602, 302, 2, 4976,
	4975, 3, 2, 2, 2, 4976, 4977, 3, 2, 2, 2, 4977, 4979, 3, 2, 2, 2, 4978,
	4974, 3, 2, 2, 2, 4978, 4979, 3, 2, 2, 2, 4979, 4980, 3, 2, 2, 2, 4980,
	4981, 7, 546, 2, 2, 4981, 601, 3, 2, 2, 2, 4982, 4989, 5, 604, 303, 2,
	4983, 4984, 7, 29, 2, 2, 4984, 4985, 5, 606, 304, 2, 4985, 4986, 7, 11,
	2, 2, 4986, 4987, 5, 606, 304, 2, 4987, 4990, 3, 2, 2, 2, 4988, 4990, 5,
	606, 304, 2, 4989, 4983, 3, 2, 2, 2, 4989, 4988, 3, 2, 2, 2, 4990, 603,
	3, 2, 2, 2, 4991, 4992, 9, 75, 2, 2, 4992, 605, 3, 2, 2, 2, 4993, 4994,
	7, 443, 2, 2, 4994, 5001, 7, 328, 2, 2, 4995, 4996, 7, 89, 2, 2, 4996,
	5001, 7, 365, 2, 2, 4997, 4998, 5, 554, 278, 2, 4998, 4999, 9, 76, 2, 2,
	4999, 5001, 3, 2, 2, 2, 5000, 4993, 3, 2, 2, 2, 5000, 4995, 3, 2, 2, 2,
	5000, 4997, 3, 2, 2, 2, 5001, 607, 3, 2, 2, 2, 5002, 5012, 7, 455, 2, 2,
	5003, 5013, 7, 548, 2, 2, 5004, 5009, 5, 610, 306, 2, 5005, 5006, 7, 551,
	2, 2, 5006, 5008, 5, 610, 306, 2, 5007, 5005, 3, 2, 2, 2, 5008, 5011, 3,
	2, 2, 2, 5009, 5007, 3, 2, 2, 2, 5009, 5010, 3, 2, 2, 2, 5010, 5013, 3,
	2, 2, 2, 5011, 5009, 3, 2, 2, 2, 5012, 5003, 3, 2, 2, 2, 5012, 5004, 3,
	2, 2, 2, 5013, 609, 3, 2, 2, 2, 5014, 5016, 7, 191, 2, 2, 5015, 5017, 7,
	301, 2, 2, 5016, 5015, 3, 2, 2, 2, 5016, 5017, 3, 2, 2, 2, 5017, 5020,
	3, 2, 2, 2, 5018, 5020, 7, 301, 2, 2, 5019, 5014, 3, 2, 2, 2, 5019, 5018,
	3, 2, 2, 2, 5019, 5020, 3, 2, 2, 2, 5020, 5021, 3, 2, 2, 2, 5021, 5023,
	5, 370, 186, 2, 5022, 5024, 5, 648, 325, 2, 5023, 5022, 3, 2, 2, 2, 5023,
	5024, 3, 2, 2, 2, 5024, 611, 3, 2, 2, 2, 5025, 5026, 7, 296, 2, 2, 5026,
	5027, 7, 42, 2, 2, 5027, 5028, 5, 554, 278, 2, 5028, 613, 3, 2, 2, 2, 5029,
	5030, 7, 473, 2, 2, 5030, 5031, 7, 171, 2, 2, 5031, 5032, 7, 545, 2, 2,
	5032, 5033, 5, 456, 229, 2, 5033, 5034, 7, 546, 2, 2, 5034, 5037, 3, 2,
	2, 2, 5035, 5037, 5, 600, 301, 2, 5036, 5029, 3, 2, 2, 2, 5036, 5035, 3,
	2, 2, 2, 5037, 615, 3, 2, 2, 2, 5038, 5060, 7, 83, 2, 2, 5039, 5041, 7,
	248, 2, 2, 5040, 5042, 7, 22, 2, 2, 5041, 5040, 3, 2, 2, 2, 5041, 5042,
	3, 2, 2, 2, 5042, 5061, 3, 2, 2, 2, 5043, 5044, 7, 545, 2, 2, 5044, 5049,
	5, 658, 330, 2, 5045, 5046, 7, 551, 2, 2, 5046, 5048, 5, 658, 330, 2, 5047,
	5045, 3, 2, 2, 2, 5048, 5051, 3, 2, 2, 2, 5049, 5047, 3, 2, 2, 2, 5049,
	5050, 3, 2, 2, 2, 5050, 5052, 3, 2, 2, 2, 5051, 5049, 3, 2, 2, 2, 5052,
	5053, 7, 546, 2, 2, 5053, 5054, 7, 457, 2, 2, 5054, 5056, 7, 545, 2, 2,
	5055, 5057, 5, 534, 268, 2, 5056, 5055, 3, 2, 2, 2, 5056, 5057, 3, 2, 2,
	2, 5057, 5058, 3, 2, 2, 2, 5058, 5059, 7, 546, 2, 2, 5059, 5061, 3, 2,
	2, 2, 5060, 5039, 3, 2, 2, 2, 5060, 5043, 3, 2, 2, 2, 5061, 617, 3, 2,
	2, 2, 5062, 5065, 7, 309, 2, 2, 5063, 5064, 7, 42, 2, 2, 5064, 5066, 7,
	458, 2, 2, 5065, 5063, 3, 2, 2, 2, 5065, 5066, 3, 2, 2, 2, 5066, 5067,
	3, 2, 2, 2, 5067, 5069, 5, 536, 269, 2, 5068, 5070, 5, 648, 325, 2, 5069,
	5068, 3, 2, 2, 2, 5069, 5070, 3, 2, 2, 2, 5070, 5071, 3, 2, 2, 2, 5071,
	5072, 7, 551, 2, 2, 5072, 5074, 5, 536, 269, 2, 5073, 5075, 5, 648, 325,
	2, 5074, 5073, 3, 2, 2, 2, 5074, 5075, 3, 2, 2, 2, 5075, 619, 3, 2, 2,
	2, 5076, 5077, 7, 478, 2, 2, 5077, 5079, 7, 545, 2, 2, 5078, 5080, 9, 68,
	2, 2, 5079, 5078, 3, 2, 2, 2, 5079, 5080, 3, 2, 2, 2, 5080, 5082, 3, 2,
	2, 2, 5081, 5083, 9, 77, 2, 2, 5082, 5081, 3, 2, 2, 2, 5082, 5083, 3, 2,
	2, 2, 5083, 5084, 3, 2, 2, 2, 5084, 5089, 5, 628, 315, 2, 5085, 5086, 7,
	551, 2, 2, 5086, 5088, 5, 628, 315, 2, 5087, 5085, 3, 2, 2, 2, 5088, 5091,
	3, 2, 2, 2, 5089, 5087, 3, 2, 2, 2, 5089, 5090, 3, 2, 2, 2, 5090, 5092,
	3, 2, 2, 2, 5091, 5089, 3, 2, 2, 2, 5092, 5093, 7, 546, 2, 2, 5093, 621,
	3, 2, 2, 2, 5094, 5095, 7, 484, 2, 2, 5095, 5099, 7, 545, 2, 2, 5096, 5097,
	5, 554, 278, 2, 5097, 5098, 5, 648, 325, 2, 5098, 5100, 3, 2, 2, 2, 5099,
	5096, 3, 2, 2, 2, 5099, 5100, 3, 2, 2, 2, 5100, 5107, 3, 2, 2, 2, 5101,
	5102, 7, 551, 2, 2, 5102, 5103, 5, 554, 278, 2, 5103, 5104, 5, 648, 325,
	2, 5104, 5106, 3, 2, 2, 2, 5105, 5101, 3, 2, 2, 2, 5106, 5109, 3, 2, 2,
	2, 5107, 5105, 3, 2, 2, 2, 5107, 5108, 3, 2, 2, 2, 5108, 5111, 3, 2, 2,
	2, 5109, 5107, 3, 2, 2, 2, 5110, 5112, 5, 626, 314, 2, 5111, 5110, 3, 2,
	2, 2, 5111, 5112, 3, 2, 2, 2, 5112, 5113, 3, 2, 2, 2, 5113, 5114, 7, 546,
	2, 2, 5114, 623, 3, 2, 2, 2, 5115, 5126, 5, 656, 329, 2, 5116, 5117, 7,
	162, 2, 2, 5117, 5127, 7, 297, 2, 2, 5118, 5121, 5, 736, 369, 2, 5119,
	5120, 7, 310, 2, 2, 5120, 5122, 5, 554, 278, 2, 5121, 5119, 3, 2, 2, 2,
	5121, 5122, 3, 2, 2, 2, 5122, 5124, 3, 2, 2, 2, 5123, 5125, 5, 626, 314,
	2, 5124, 5123, 3, 2, 2, 2, 5124, 5125, 3, 2, 2, 2, 5125, 5127, 3, 2, 2,
	2, 5126, 5116, 3, 2, 2, 2, 5126, 5118, 3, 2, 2, 2, 5127, 625, 3, 2, 2,
	2, 5128, 5129, 7, 107, 2, 2, 5129, 5130, 5, 554, 278, 2, 5130, 627, 3,
	2, 2, 2, 5131, 5138, 5, 536, 269, 2, 5132, 5136, 7, 15, 2, 2, 5133, 5137,
	5, 762, 382, 2, 5134, 5135, 7, 136, 2, 2, 5135, 5137, 5, 554, 278, 2, 5136,
	5133, 3, 2, 2, 2, 5136, 5134, 3, 2, 2, 2, 5137, 5139, 3, 2, 2, 2, 5138,
	5132, 3, 2, 2, 2, 5138, 5139, 3, 2, 2, 2, 5139, 629, 3, 2, 2, 2, 5140,
	5144, 7, 465, 2, 2, 5141, 5142, 7, 274, 2, 2, 5142, 5145, 7, 458, 2, 2,
	5143, 5145, 5, 536, 269, 2, 5144, 5141, 3, 2, 2, 2, 5144, 5143, 3, 2, 2,
	2, 5145, 631, 3, 2, 2, 2, 5146, 5152, 7, 404, 2, 2, 5147, 5153, 7, 493,
	2, 2, 5148, 5150, 7, 274, 2, 2, 5149, 5151, 7, 458, 2, 2, 5150, 5149, 3,
	2, 2, 2, 5150, 5151, 3, 2, 2, 2, 5151, 5153, 3, 2, 2, 2, 5152, 5147, 3,
	2, 2, 2, 5152, 5148, 3, 2, 2, 2, 5153, 633, 3, 2, 2, 2, 5154, 5155, 7,
	129, 2, 2, 5155, 5156, 5, 554, 278, 2, 5156, 635, 3, 2, 2, 2, 5157, 5158,
	7, 465, 2, 2, 5158, 5159, 5, 554, 278, 2, 5159, 637, 3, 2, 2, 2, 5160,
	5161, 7, 274, 2, 2, 5161, 5169, 7, 185, 2, 2, 5162, 5166, 7, 185, 2, 2,
	5163, 5164, 7, 396, 2, 2, 5164, 5165, 7, 565, 2, 2, 5165, 5167, 5, 554,
	278, 2, 5166, 5163, 3, 2, 2, 2, 5166, 5167, 3, 2, 2, 2, 5167, 5169, 3,
	2, 2, 2, 5168, 5160, 3, 2, 2, 2, 5168, 5162, 3, 2, 2, 2, 5169, 639, 3,
	2, 2, 2, 5170, 5179, 7, 552, 2, 2, 5171, 5179, 7, 144, 2, 2, 5172, 5179,
	7, 572, 2, 2, 5173, 5174, 7, 390, 2, 2, 5174, 5179, 9, 78, 2, 2, 5175,
	5179, 7, 573, 2, 2, 5176, 5179, 5, 642, 322, 2, 5177, 5179, 5, 644, 323,
	2, 5178, 5170, 3, 2, 2, 2, 5178, 5171, 3, 2, 2, 2, 5178, 5172, 3, 2, 2,
	2, 5178, 5173, 3, 2, 2, 2, 5178, 5175, 3, 2, 2, 2, 5178, 5176, 3, 2, 2,
	2, 5178, 5177, 3, 2, 2, 2, 5179, 641, 3, 2, 2, 2, 5180, 5181, 7, 469, 2,
	2, 5181, 5187, 9, 79, 2, 2, 5182, 5183, 7, 144, 2, 2, 5183, 5184, 9, 80,
	2, 2, 5184, 5188, 9, 81, 2, 2, 5185, 5186, 7, 79, 2, 2, 5186, 5188, 9,
	82, 2, 2, 5187, 5182, 3, 2, 2, 2, 5187, 5185, 3, 2, 2, 2, 5188, 643, 3,
	2, 2, 2, 5189, 5190, 7, 386, 2, 2, 5190, 5196, 5, 766, 384, 2, 5191, 5197,
	7, 541, 2, 2, 5192, 5197, 7, 291, 2, 2, 5193, 5197, 7, 285, 2, 2, 5194,
	5197, 5, 754, 378, 2, 5195, 5197, 5, 766, 384, 2, 5196, 5191, 3, 2, 2,
	2, 5196, 5192, 3, 2, 2, 2, 5196, 5193, 3, 2, 2, 2, 5196, 5194, 3, 2, 2,
	2, 5196, 5195, 3, 2, 2, 2, 5197, 645, 3, 2, 2, 2, 5198, 5200, 9, 83, 2,
	2, 5199, 5201, 7, 162, 2, 2, 5200, 5199, 3, 2, 2, 2, 5200, 5201, 3, 2,
	2, 2, 5201, 5202, 3, 2, 2, 2, 5202, 5204, 7, 545, 2, 2, 5203, 5205, 5,
	534, 268, 2, 5204, 5203, 3, 2, 2, 2, 5204, 5205, 3, 2, 2, 2, 5205, 5206,
	3, 2, 2, 2, 5206, 5207, 7, 546, 2, 2, 5207, 647, 3, 2, 2, 2, 5208, 5210,
	7, 15, 2, 2, 5209, 5208, 3, 2, 2, 2, 5209, 5210, 3, 2, 2, 2, 5210, 5213,
	3, 2, 2, 2, 5211, 5214, 5, 760, 381, 2, 5212, 5214, 5, 758, 380, 2, 5213,
	5211, 3, 2, 2, 2, 5213, 5212, 3, 2, 2, 2, 5214, 5217, 3, 2, 2, 2, 5215,
	5217, 7, 15, 2, 2, 5216, 5209, 3, 2, 2, 2, 5216, 5215, 3, 2, 2, 2, 5217,
	649, 3, 2, 2, 2, 5218, 5221, 5, 760, 381, 2, 5219, 5221, 5, 758, 380, 2,
	5220, 5218, 3, 2, 2, 2, 5220, 5219, 3, 2, 2, 2, 5221, 651, 3, 2, 2, 2,
	5222, 5227, 7, 471, 2, 2, 5223, 5224, 7, 89, 2, 2, 5224, 5225, 7, 286,
	2, 2, 5225, 5228, 5, 706, 354, 2, 5226, 5228, 5, 536, 269, 2, 5227, 5223,
	3, 2, 2, 2, 5227, 5226, 3, 2, 2, 2, 5228, 653, 3, 2, 2, 2, 5229, 5230,
	7, 41, 2, 2, 5230, 5232, 7, 60, 2, 2, 5231, 5229, 3, 2, 2, 2, 5231, 5232,
	3, 2, 2, 2, 5232, 5233, 3, 2, 2, 2, 5233, 5234, 7, 204, 2, 2, 5234, 5239,
	5, 702, 352, 2, 5235, 5236, 7, 551, 2, 2, 5236, 5238, 5, 702, 352, 2, 5237,
	5235, 3, 2, 2, 2, 5238, 5241, 3, 2, 2, 2, 5239, 5237, 3, 2, 2, 2, 5239,
	5240, 3, 2, 2, 2, 5240, 655, 3, 2, 2, 2, 5241, 5239, 3, 2, 2, 2, 5242,
	5245, 5, 760, 381, 2, 5243, 5245, 5, 758, 380, 2, 5244, 5242, 3, 2, 2,
	2, 5244, 5243, 3, 2, 2, 2, 5245, 657, 3, 2, 2, 2, 5246, 5247, 5, 760, 381,
	2, 5247, 659, 3, 2, 2, 2, 5248, 5249, 5, 760, 381, 2, 5249, 661, 3, 2,
	2, 2, 5250, 5251, 5, 760, 381, 2, 5251, 663, 3, 2, 2, 2, 5252, 5253, 5,
	760, 381, 2, 5253, 665, 3, 2, 2, 2, 5254, 5255, 5, 760, 381, 2, 5255, 667,
	3, 2, 2, 2, 5256, 5257, 5, 760, 381, 2, 5257, 669, 3, 2, 2, 2, 5258, 5263,
	5, 760, 381, 2, 5259, 5260, 7, 538, 2, 2, 5260, 5262, 5, 762, 382, 2, 5261,
	5259, 3, 2, 2, 2, 5262, 5265, 3, 2, 2, 2, 5263, 5261, 3, 2, 2, 2, 5263,
	5264, 3, 2, 2, 2, 5264, 5268, 3, 2, 2, 2, 5265, 5263, 3, 2, 2, 2, 5266,
	5267, 7, 553, 2, 2, 5267, 5269, 5, 712, 357, 2, 5268, 5266, 3, 2, 2, 2,
	5268, 5269, 3, 2, 2, 2, 5269, 671, 3, 2, 2, 2, 5270, 5271, 5, 760, 381,
	2, 5271, 673, 3, 2, 2, 2, 5272, 5275, 5, 760, 381, 2, 5273, 5274, 7, 538,
	2, 2, 5274, 5276, 5, 762, 382, 2, 5275, 5273, 3, 2, 2, 2, 5275, 5276, 3,
	2, 2, 2, 5276, 675, 3, 2, 2, 2, 5277, 5278, 5, 760, 381, 2, 5278, 677,
	3, 2, 2, 2, 5279, 5280, 5, 760, 381, 2, 5280, 679, 3, 2, 2, 2, 5281, 5282,
	5, 760, 381, 2, 5282, 681, 3, 2, 2, 2, 5283, 5288, 5, 760, 381, 2, 5284,
	5285, 7, 538, 2, 2, 5285, 5287, 5, 762, 382, 2, 5286, 5284, 3, 2, 2, 2,
	5287, 5290, 3, 2, 2, 2, 5288, 5286, 3, 2, 2, 2, 5288, 5289, 3, 2, 2, 2,
	5289, 683, 3, 2, 2, 2, 5290, 5288, 3, 2, 2, 2, 5291, 5292, 5, 760, 381,
	2, 5292, 685, 3, 2, 2, 2, 5293, 5298, 5, 760, 381, 2, 5294, 5295, 7, 538,
	2, 2, 5295, 5297, 5, 762, 382, 2, 5296, 5294, 3, 2, 2, 2, 5297, 5300, 3,
	2, 2, 2, 5298, 5296, 3, 2, 2, 2, 5298, 5299, 3, 2, 2, 2, 5299, 5303, 3,
	2, 2, 2, 5300, 5298, 3, 2, 2, 2, 5301, 5302, 7, 553, 2, 2, 5302, 5304,
	5, 712, 357, 2, 5303, 5301, 3, 2, 2, 2, 5303, 5304, 3, 2, 2, 2, 5304, 687,
	3, 2, 2, 2, 5305, 5306, 5, 762, 382, 2, 5306, 689, 3, 2, 2, 2, 5307, 5312,
	5, 762, 382, 2, 5308, 5309, 7, 538, 2, 2, 5309, 5311, 5, 762, 382, 2, 5310,
	5308, 3, 2, 2, 2, 5311, 5314, 3, 2, 2, 2, 5312, 5310, 3, 2, 2, 2, 5312,
	5313, 3, 2, 2, 2, 5313, 691, 3, 2, 2, 2, 5314, 5312, 3, 2, 2, 2, 5315,
	5320, 5, 762, 382, 2, 5316, 5317, 7, 538, 2, 2, 5317, 5319, 5, 762, 382,
	2, 5318, 5316, 3, 2, 2, 2, 5319, 5322, 3, 2, 2, 2, 5320, 5318, 3, 2, 2,
	2, 5320, 5321, 3, 2, 2, 2, 5321, 693, 3, 2, 2, 2, 5322, 5320, 3, 2, 2,
	2, 5323, 5328, 5, 760, 381, 2, 5324, 5325, 7, 538, 2, 2, 5325, 5327, 5,
	762, 382, 2, 5326, 5324, 3, 2, 2, 2, 5327, 5330, 3, 2, 2, 2, 5328, 5326,
	3, 2, 2, 2, 5328, 5329, 3, 2, 2, 2, 5329, 695, 3, 2, 2, 2, 5330, 5328,
	3, 2, 2, 2, 5331, 5334, 5, 760, 381, 2, 5332, 5333, 7, 538, 2, 2, 5333,
	5335, 5, 762, 382, 2, 5334, 5332, 3, 2, 2, 2, 5334, 5335, 3, 2, 2, 2, 5335,
	697, 3, 2, 2, 2, 5336, 5339, 5, 760, 381, 2, 5337, 5338, 7, 538, 2, 2,
	5338, 5340, 5, 762, 382, 2, 5339, 5337, 3, 2, 2, 2, 5339, 5340, 3, 2, 2,
	2, 5340, 699, 3, 2, 2, 2, 5341, 5344, 5, 760, 381, 2, 5342, 5343, 7, 538,
	2, 2, 5343, 5345, 5, 762, 382, 2, 5344, 5342, 3, 2, 2, 2, 5344, 5345, 3,
	2, 2, 2, 5345, 701, 3, 2, 2, 2, 5346, 5347, 7, 568, 2, 2, 5347, 5349, 5,
	718, 360, 2, 5348, 5346, 3, 2, 2, 2, 5348, 5349, 3, 2, 2, 2, 5349, 5350,
	3, 2, 2, 2, 5350, 5353, 5, 762, 382, 2, 5351, 5352, 7, 538, 2, 2, 5352,
	5354, 5, 762, 382, 2, 5353, 5351, 3, 2, 2, 2, 5353, 5354, 3, 2, 2, 2, 5354,
	5357, 3, 2, 2, 2, 5355, 5357, 5, 744, 373, 2, 5356, 5348, 3, 2, 2, 2, 5356,
	5355, 3, 2, 2, 2, 5357, 703, 3, 2, 2, 2, 5358, 5359, 5, 760, 381, 2, 5359,
	705, 3, 2, 2, 2, 5360, 5363, 5, 760, 381, 2, 5361, 5363, 5, 744, 373, 2,
	5362, 5360, 3, 2, 2, 2, 5362, 5361, 3, 2, 2, 2, 5363, 707, 3, 2, 2, 2,
	5364, 5367, 5, 760, 381, 2, 5365, 5367, 5, 744, 373, 2, 5366, 5364, 3,
	2, 2, 2, 5366, 5365, 3, 2, 2, 2, 5367, 709, 3, 2, 2, 2, 5368, 5371, 5,
	760, 381, 2, 5369, 5370, 7, 538, 2, 2, 5370, 5372, 5, 762, 382, 2, 5371,
	5369, 3, 2, 2, 2, 5371, 5372, 3, 2, 2, 2, 5372, 711, 3, 2, 2, 2, 5373,
	5374, 5, 760, 381, 2, 5374, 713, 3, 2, 2, 2, 5375, 5380, 5, 760, 381, 2,
	5376, 5377, 7, 538, 2, 2, 5377, 5379, 5, 762, 382, 2, 5378, 5376, 3, 2,
	2, 2, 5379, 5382, 3, 2, 2, 2, 5380, 5378, 3, 2, 2, 2, 5380, 5381, 3, 2,
	2, 2, 5381, 715, 3, 2, 2, 2, 5382, 5380, 3, 2, 2, 2, 5383, 5386, 5, 760,
	381, 2, 5384, 5385, 7, 538, 2, 2, 5385, 5387, 5, 762, 382, 2, 5386, 5384,
	3, 2, 2, 2, 5386, 5387, 3, 2, 2, 2, 5387, 5391, 3, 2, 2, 2, 5388, 5389,
	7, 553, 2, 2, 5389, 5392, 5, 712, 357, 2, 5390, 5392, 5, 646, 324, 2, 5391,
	5388, 3, 2, 2, 2, 5391, 5390, 3, 2, 2, 2, 5391, 5392, 3, 2, 2, 2, 5392,
	717, 3, 2, 2, 2, 5393, 5398, 5, 762, 382, 2, 5394, 5395, 7, 538, 2, 2,
	5395, 5397, 5, 762, 382, 2, 5396, 5394, 3, 2, 2, 2, 5397, 5400, 3, 2, 2,
	2, 5398, 5396, 3, 2, 2, 2, 5398, 5399, 3, 2, 2, 2, 5399, 719, 3, 2, 2,
	2, 5400, 5398, 3, 2, 2, 2, 5401, 5402, 5, 760, 381, 2, 5402, 721, 3, 2,
	2, 2, 5403, 5404, 5, 762, 382, 2, 5404, 723, 3, 2, 2, 2, 5405, 5406, 7,
	211, 2, 2, 5406, 5407, 7, 545, 2, 2, 5407, 5408, 7, 503, 2, 2, 5408, 5409,
	9, 49, 2, 2, 5409, 5410, 5, 456, 229, 2, 5410, 5412, 7, 546, 2, 2, 5411,
	5413, 5, 600, 301, 2, 5412, 5411, 3, 2, 2, 2, 5412, 5413, 3, 2, 2, 2, 5413,
	725, 3, 2, 2, 2, 5414, 5416, 7, 545, 2, 2, 5415, 5417, 5, 734, 368, 2,
	5416, 5415, 3, 2, 2, 2, 5416, 5417, 3, 2, 2, 2, 5417, 5422, 3, 2, 2, 2,
	5418, 5419, 7, 551, 2, 2, 5419, 5421, 5, 734, 368, 2, 5420, 5418, 3, 2,
	2, 2, 5421, 5424, 3, 2, 2, 2, 5422, 5420, 3, 2, 2, 2, 5422, 5423, 3, 2,
	2, 2, 5423, 5425, 3, 2, 2, 2, 5424, 5422, 3, 2, 2, 2, 5425, 5427, 7, 546,
	2, 2, 5426, 5428, 5, 724, 363, 2, 5427, 5426, 3, 2, 2, 2, 5427, 5428, 3,
	2, 2, 2, 5428, 727, 3, 2, 2, 2, 5429, 5434, 7, 545, 2, 2, 5430, 5432, 5,
	734, 368, 2, 5431, 5433, 5, 732, 367, 2, 5432, 5431, 3, 2, 2, 2, 5432,
	5433, 3, 2, 2, 2, 5433, 5435, 3, 2, 2, 2, 5434, 5430, 3, 2, 2, 2, 5434,
	5435, 3, 2, 2, 2, 5435, 5443, 3, 2, 2, 2, 5436, 5437, 7, 551, 2, 2, 5437,
	5439, 5, 734, 368, 2, 5438, 5440, 5, 732, 367, 2, 5439, 5438, 3, 2, 2,
	2, 5439, 5440, 3, 2, 2, 2, 5440, 5442, 3, 2, 2, 2, 5441, 5436, 3, 2, 2,
	2, 5442, 5445, 3, 2, 2, 2, 5443, 5441, 3, 2, 2, 2, 5443, 5444, 3, 2, 2,
	2, 5444, 5446, 3, 2, 2, 2, 5445, 5443, 3, 2, 2, 2, 5446, 5448, 7, 546,
	2, 2, 5447, 5449, 5, 724, 363, 2, 5448, 5447, 3, 2, 2, 2, 5448, 5449, 3,
	2, 2, 2, 5449, 729, 3, 2, 2, 2, 5450, 5451, 7, 545, 2, 2, 5451, 5464, 5,
	714, 358, 2, 5452, 5455, 7, 551, 2, 2, 5453, 5456, 5, 754, 378, 2, 5454,
	5456, 7, 279, 2, 2, 5455, 5453, 3, 2, 2, 2, 5455, 5454, 3, 2, 2, 2, 5456,
	5462, 3, 2, 2, 2, 5457, 5460, 7, 551, 2, 2, 5458, 5461, 5, 754, 378, 2,
	5459, 5461, 7, 279, 2, 2, 5460, 5458, 3, 2, 2, 2, 5460, 5459, 3, 2, 2,
	2, 5461, 5463, 3, 2, 2, 2, 5462, 5457, 3, 2, 2, 2, 5462, 5463, 3, 2, 2,
	2, 5463, 5465, 3, 2, 2, 2, 5464, 5452, 3, 2, 2, 2, 5464, 5465, 3, 2, 2,
	2, 5465, 5466, 3, 2, 2, 2, 5466, 5486, 7, 455, 2, 2, 5467, 5468, 5, 716,
	359, 2, 5468, 5469, 7, 538, 2, 2, 5469, 5470, 7, 548, 2, 2, 5470, 5487,
	3, 2, 2, 2, 5471, 5487, 7, 548, 2, 2, 5472, 5474, 5, 536, 269, 2, 5473,
	5475, 5, 648, 325, 2, 5474, 5473, 3, 2, 2, 2, 5474, 5475, 3, 2, 2, 2, 5475,
	5483, 3, 2, 2, 2, 5476, 5477, 7, 551, 2, 2, 5477, 5479, 5, 536, 269, 2,
	5478, 5480, 5, 648, 325, 2, 5479, 5478, 3, 2, 2, 2, 5479, 5480, 3, 2, 2,
	2, 5480, 5482, 3, 2, 2, 2, 5481, 5476, 3, 2, 2, 2, 5482, 5485, 3, 2, 2,
	2, 5483, 5481, 3, 2, 2, 2, 5483, 5484, 3, 2, 2, 2, 5484, 5487, 3, 2, 2,
	2, 5485, 5483, 3, 2, 2, 2, 5486, 5467, 3, 2, 2, 2, 5486, 5471, 3, 2, 2,
	2, 5486, 5472, 3, 2, 2, 2, 5487, 5488, 3, 2, 2, 2, 5488, 5490, 7, 546,
	2, 2, 5489, 5491, 5, 724, 363, 2, 5490, 5489, 3, 2, 2, 2, 5490, 5491, 3,
	2, 2, 2, 5491, 731, 3, 2, 2, 2, 5492, 5493, 9, 84, 2, 2, 5493, 5494, 7,
	280, 2, 2, 5494, 733, 3, 2, 2, 2, 5495, 5496, 5, 760, 381, 2, 5496, 5497,
	7, 565, 2, 2, 5497, 5498, 7, 560, 2, 2, 5498, 5500, 3, 2, 2, 2, 5499, 5495,
	3, 2, 2, 2, 5499, 5500, 3, 2, 2, 2, 5500, 5501, 3, 2, 2, 2, 5501, 5502,
	5, 536, 269, 2, 5502, 735, 3, 2, 2, 2, 5503, 5512, 5, 738, 370, 2, 5504,
	5506, 7, 347, 2, 2, 5505, 5504, 3, 2, 2, 2, 5505, 5506, 3, 2, 2, 2, 5506,
	5507, 3, 2, 2, 2, 5507, 5509, 5, 690, 346, 2, 5508, 5510, 9, 85, 2, 2,
	5509, 5508, 3, 2, 2, 2, 5509, 5510, 3, 2, 2, 2, 5510, 5512, 3, 2, 2, 2,
	5511, 5503, 3, 2, 2, 2, 5511, 5505, 3, 2, 2, 2, 5512, 737, 3, 2, 2, 2,
	5513, 5515, 5, 742, 372, 2, 5514, 5516, 5, 740, 371, 2, 5515, 5514, 3,
	2, 2, 2, 5515, 5516, 3, 2, 2, 2, 5516, 5526, 3, 2, 2, 2, 5517, 5519, 7,
	474, 2, 2, 5518, 5520, 7, 226, 2, 2, 5519, 5518, 3, 2, 2, 2, 5519, 5520,
	3, 2, 2, 2, 5520, 5521, 3, 2, 2, 2, 5521, 5522, 7, 429, 2, 2, 5522, 5527,
	7, 495, 2, 2, 5523, 5524, 7, 50, 2, 2, 5524, 5525, 7, 386, 2, 2, 5525,
	5527, 5, 718, 360, 2, 5526, 5517, 3, 2, 2, 2, 5526, 5523, 3, 2, 2, 2, 5526,
	5527, 3, 2, 2, 2, 5527, 5545, 3, 2, 2, 2, 5528, 5529, 7, 202, 2, 2, 5529,
	5534, 9, 86, 2, 2, 5530, 5531, 7, 545, 2, 2, 5531, 5532, 5, 536, 269, 2,
	5532, 5533, 7, 546, 2, 2, 5533, 5535, 3, 2, 2, 2, 5534, 5530, 3, 2, 2,
	2, 5534, 5535, 3, 2, 2, 2, 5535, 5536, 3, 2, 2, 2, 5536, 5537, 7, 434,
	2, 2, 5537, 5542, 9, 87, 2, 2, 5538, 5539, 7, 545, 2, 2, 5539, 5540, 5,
	536, 269, 2, 5540, 5541, 7, 546, 2, 2, 5541, 5543, 3, 2, 2, 2, 5542, 5538,
	3, 2, 2, 2, 5542, 5543, 3, 2, 2, 2, 5543, 5545, 3, 2, 2, 2, 5544, 5513,
	3, 2, 2, 2, 5544, 5528, 3, 2, 2, 2, 5545, 739, 3, 2, 2, 2, 5546, 5547,
	7, 545, 2, 2, 5547, 5550, 5, 754, 378, 2, 5548, 5549, 7, 551, 2, 2, 5549,
	5551, 5, 754, 378, 2, 5550, 5548, 3, 2, 2, 2, 5550, 5551, 3, 2, 2, 2, 5551,
	5553, 3, 2, 2, 2, 5552, 5554, 9, 88, 2, 2, 5553, 5552, 3, 2, 2, 2, 5553,
	5554, 3, 2, 2, 2, 5554, 5555, 3, 2, 2, 2, 5555, 5556, 7, 546, 2, 2, 5556,
	741, 3, 2, 2, 2, 5557, 5618, 7, 33, 2, 2, 5558, 5618, 7, 324, 2, 2, 5559,
	5618, 7, 255, 2, 2, 5560, 5618, 7, 32, 2, 2, 5561, 5618, 7, 31, 2, 2, 5562,
	5618, 7, 256, 2, 2, 5563, 5618, 7, 326, 2, 2, 5564, 5618, 7, 325, 2, 2,
	5565, 5618, 7, 393, 2, 2, 5566, 5618, 7, 394, 2, 2, 5567, 5618, 7, 283,
	2, 2, 5568, 5618, 7, 102, 2, 2, 5569, 5618, 7, 200, 2, 2, 5570, 5618, 7,
	203, 2, 2, 5571, 5618, 7, 282, 2, 2, 5572, 5618, 7, 398, 2, 2, 5573, 5618,
	7, 281, 2, 2, 5574, 5618, 7, 103, 2, 2, 5575, 5577, 7, 120, 2, 2, 5576,
	5578, 7, 329, 2, 2, 5577, 5576, 3, 2, 2, 2, 5577, 5578, 3, 2, 2, 2, 5578,
	5618, 3, 2, 2, 2, 5579, 5618, 7, 156, 2, 2, 5580, 5618, 7, 341, 2, 2, 5581,
	5618, 7, 259, 2, 2, 5582, 5584, 7, 233, 2, 2, 5583, 5585, 7, 339, 2, 2,
	5584, 5583, 3, 2, 2, 2, 5584, 5585, 3, 2, 2, 2, 5585, 5618, 3, 2, 2, 2,
	5586, 5618, 7, 51, 2, 2, 5587, 5618, 7, 50, 2, 2, 5588, 5618, 7, 459, 2,
	2, 5589, 5618, 7, 460, 2, 2, 5590, 5618, 7, 412, 2, 2, 5591, 5618, 7, 339,
	2, 2, 5592, 5618, 7, 37, 2, 2, 5593, 5618, 7, 96, 2, 2, 5594, 5618, 7,
	364, 2, 2, 5595, 5618, 7, 453, 2, 2, 5596, 5618, 7, 492, 2, 2, 5597, 5618,
	7, 251, 2, 2, 5598, 5618, 7, 97, 2, 2, 5599, 5618, 7, 178, 2, 2, 5600,
	5618, 7, 245, 2, 2, 5601, 5618, 7, 375, 2, 2, 5602, 5618, 7, 431, 2, 2,
	5603, 5618, 7, 432, 2, 2, 5604, 5618, 7, 433, 2, 2, 5605, 5618, 7, 430,
	2, 2, 5606, 5618, 7, 426, 2, 2, 5607, 5618, 7, 428, 2, 2, 5608, 5618, 7,
	427, 2, 2, 5609, 5618, 7, 425, 2, 2, 5610, 5618, 7, 494, 2, 2, 5611, 5618,
	7, 122, 2, 2, 5612, 5618, 7, 30, 2, 2, 5613, 5618, 7, 34, 2, 2, 5614, 5618,
	7, 56, 2, 2, 5615, 5618, 7, 260, 2, 2, 5616, 5618, 7, 247, 2, 2, 5617,
	5557, 3, 2, 2, 2, 5617, 5558, 3, 2, 2, 2, 5617, 5559, 3, 2, 2, 2, 5617,
	5560, 3, 2, 2, 2, 5617, 5561, 3, 2, 2, 2, 5617, 5562, 3, 2, 2, 2, 5617,
	5563, 3, 2, 2, 2, 5617, 5564, 3, 2, 2, 2, 5617, 5565, 3, 2, 2, 2, 5617,
	5566, 3, 2, 2, 2, 5617, 5567, 3, 2, 2, 2, 5617, 5568, 3, 2, 2, 2, 5617,
	5569, 3, 2, 2, 2, 5617, 5570, 3, 2, 2, 2, 5617, 5571, 3, 2, 2, 2, 5617,
	5572, 3, 2, 2, 2, 5617, 5573, 3, 2, 2, 2, 5617, 5574, 3, 2, 2, 2, 5617,
	5575, 3, 2, 2, 2, 5617, 5579, 3, 2, 2, 2, 5617, 5580, 3, 2, 2, 2, 5617,
	5581, 3, 2, 2, 2, 5617, 5582, 3, 2, 2, 2, 5617, 5586, 3, 2, 2, 2, 5617,
	5587, 3, 2, 2, 2, 5617, 5588, 3, 2, 2, 2, 5617, 5589, 3, 2, 2, 2, 5617,
	5590, 3, 2, 2, 2, 5617, 5591, 3, 2, 2, 2, 5617, 5592, 3, 2, 2, 2, 5617,
	5593, 3, 2, 2, 2, 5617, 5594, 3, 2, 2, 2, 5617, 5595, 3, 2, 2, 2, 5617,
	5596, 3, 2, 2, 2, 5617, 5597, 3, 2, 2, 2, 5617, 5598, 3, 2, 2, 2, 5617,
	5599, 3, 2, 2, 2, 5617, 5600, 3, 2, 2, 2, 5617, 5601, 3, 2, 2, 2, 5617,
	5602, 3, 2, 2, 2, 5617, 5603, 3, 2, 2, 2, 5617, 5604, 3, 2, 2, 2, 5617,
	5605, 3, 2, 2, 2, 5617, 5606, 3, 2, 2, 2, 5617, 5607, 3, 2, 2, 2, 5617,
	5608, 3, 2, 2, 2, 5617, 5609, 3, 2, 2, 2, 5617, 5610, 3, 2, 2, 2, 5617,
	5611, 3, 2, 2, 2, 5617, 5612, 3, 2, 2, 2, 5617, 5613, 3, 2, 2, 2, 5617,
	5614, 3, 2, 2, 2, 5617, 5615, 3, 2, 2, 2, 5617, 5616, 3, 2, 2, 2, 5618,
	743, 3, 2, 2, 2, 5619, 5623, 7, 555, 2, 2, 5620, 5621, 7, 562, 2, 2, 5621,
	5623, 7, 539, 2, 2, 5622, 5619, 3, 2, 2, 2, 5622, 5620, 3, 2, 2, 2, 5623,
	5632, 3, 2, 2, 2, 5624, 5626, 7, 188, 2, 2, 5625, 5624, 3, 2, 2, 2, 5625,
	5626, 3, 2, 2, 2, 5626, 5630, 3, 2, 2, 2, 5627, 5631, 7, 555, 2, 2, 5628,
	5629, 7, 562, 2, 2, 5629, 5631, 7, 539, 2, 2, 5630, 5627, 3, 2, 2, 2, 5630,
	5628, 3, 2, 2, 2, 5631, 5633, 3, 2, 2, 2, 5632, 5625, 3, 2, 2, 2, 5632,
	5633, 3, 2, 2, 2, 5633, 5638, 3, 2, 2, 2, 5634, 5635, 7, 538, 2, 2, 5635,
	5637, 5, 748, 375, 2, 5636, 5634, 3, 2, 2, 2, 5637, 5640, 3, 2, 2, 2, 5638,
	5636, 3, 2, 2, 2, 5638, 5639, 3, 2, 2, 2, 5639, 745, 3, 2, 2, 2, 5640,
	5638, 3, 2, 2, 2, 5641, 5646, 5, 748, 375, 2, 5642, 5643, 7, 538, 2, 2,
	5643, 5645, 5, 748, 375, 2, 5644, 5642, 3, 2, 2, 2, 5645, 5648, 3, 2, 2,
	2, 5646, 5644, 3, 2, 2, 2, 5646, 5647, 3, 2, 2, 2, 5647, 747, 3, 2, 2,
	2, 5648, 5646, 3, 2, 2, 2, 5649, 5650, 7, 568, 2, 2, 5650, 5652, 5, 718,
	360, 2, 5651, 5649, 3, 2, 2, 2, 5651, 5652, 3, 2, 2, 2, 5652, 5653, 3,
	2, 2, 2, 5653, 5658, 5, 762, 382, 2, 5654, 5655, 7, 538, 2, 2, 5655, 5657,
	5, 762, 382, 2, 5656, 5654, 3, 2, 2, 2, 5657, 5660, 3, 2, 2, 2, 5658, 5656,
	3, 2, 2, 2, 5658, 5659, 3, 2, 2, 2, 5659, 5663, 3, 2, 2, 2, 5660, 5658,
	3, 2, 2, 2, 5661, 5662, 7, 553, 2, 2, 5662, 5664, 5, 712, 357, 2, 5663,
	5661, 3, 2, 2, 2, 5663, 5664, 3, 2, 2, 2, 5664, 5666, 3, 2, 2, 2, 5665,
	5667, 5, 726, 364, 2, 5666, 5665, 3, 2, 2, 2, 5666, 5667, 3, 2, 2, 2, 5667,
	749, 3, 2, 2, 2, 5668, 5669, 7, 568, 2, 2, 5669, 5671, 5, 718, 360, 2,
	5670, 5668, 3, 2, 2, 2, 5670, 5671, 3, 2, 2, 2, 5671, 5672, 3, 2, 2, 2,
	5672, 5677, 5, 762, 382, 2, 5673, 5674, 7, 538, 2, 2, 5674, 5676, 5, 762,
	382, 2, 5675, 5673, 3, 2, 2, 2, 5676, 5679, 3, 2, 2, 2, 5677, 5675, 3,
	2, 2, 2, 5677, 5678, 3, 2, 2, 2, 5678, 751, 3, 2, 2, 2, 5679, 5677, 3,
	2, 2, 2, 5680, 5683, 7, 426, 2, 2, 5681, 5684, 5, 758, 380, 2, 5682, 5684,
	5, 744, 373, 2, 5683, 5681, 3, 2, 2, 2, 5683, 5682, 3, 2, 2, 2, 5684, 5689,
	3, 2, 2, 2, 5685, 5686, 7, 18, 2, 2, 5686, 5687, 7, 429, 2, 2, 5687, 5688,
	7, 495, 2, 2, 5688, 5690, 5, 758, 380, 2, 5689, 5685, 3, 2, 2, 2, 5689,
	5690, 3, 2, 2, 2, 5690, 5743, 3, 2, 2, 2, 5691, 5695, 7, 202, 2, 2, 5692,
	5696, 5, 758, 380, 2, 5693, 5696, 5, 744, 373, 2, 5694, 5696, 5, 748, 375,
	2, 5695, 5692, 3, 2, 2, 2, 5695, 5693, 3, 2, 2, 2, 5695, 5694, 3, 2, 2,
	2, 5696, 5697, 3, 2, 2, 2, 5697, 5711, 9, 89, 2, 2, 5698, 5701, 7, 545,
	2, 2, 5699, 5702, 7, 539, 2, 2, 5700, 5702, 5, 744, 373, 2, 5701, 5699,
	3, 2, 2, 2, 5701, 5700, 3, 2, 2, 2, 5702, 5708, 3, 2, 2, 2, 5703, 5706,
	7, 551, 2, 2, 5704, 5707, 7, 539, 2, 2, 5705, 5707, 5, 744, 373, 2, 5706,
	5704, 3, 2, 2, 2, 5706, 5705, 3, 2, 2, 2, 5707, 5709, 3, 2, 2, 2, 5708,
	5703, 3, 2, 2, 2, 5708, 5709, 3, 2, 2, 2, 5709, 5710, 3, 2, 2, 2, 5710,
	5712, 7, 546, 2, 2, 5711, 5698, 3, 2, 2, 2, 5711, 5712, 3, 2, 2, 2, 5712,
	5728, 3, 2, 2, 2, 5713, 5726, 7, 434, 2, 2, 5714, 5727, 7, 97, 2, 2, 5715,
	5727, 7, 178, 2, 2, 5716, 5727, 7, 245, 2, 2, 5717, 5724, 7, 375, 2, 2,
	5718, 5721, 7, 545, 2, 2, 5719, 5722, 7, 539, 2, 2, 5720, 5722, 5, 744,
	373, 2, 5721, 5719, 3, 2, 2, 2, 5721, 5720, 3, 2, 2, 2, 5722, 5723, 3,
	2, 2, 2, 5723, 5725, 7, 546, 2, 2, 5724, 5718, 3, 2, 2, 2, 5724, 5725,
	3, 2, 2, 2, 5725, 5727, 3, 2, 2, 2, 5726, 5714, 3, 2, 2, 2, 5726, 5715,
	3, 2, 2, 2, 5726, 5716, 3, 2, 2, 2, 5726, 5717, 3, 2, 2, 2, 5727, 5729,
	3, 2, 2, 2, 5728, 5713, 3, 2, 2, 2, 5728, 5729, 3, 2, 2, 2, 5729, 5743,
	3, 2, 2, 2, 5730, 5743, 5, 754, 378, 2, 5731, 5732, 7, 96, 2, 2, 5732,
	5743, 5, 758, 380, 2, 5733, 5743, 5, 758, 380, 2, 5734, 5743, 7, 279, 2,
	2, 5735, 5743, 7, 440, 2, 2, 5736, 5743, 7, 149, 2, 2, 5737, 5743, 7, 99,
	2, 2, 5738, 5743, 7, 385, 2, 2, 5739, 5743, 7, 246, 2, 2, 5740, 5743, 7,
	239, 2, 2, 5741, 5743, 7, 107, 2, 2, 5742, 5680, 3, 2, 2, 2, 5742, 5691,
	3, 2, 2, 2, 5742, 5730, 3, 2, 2, 2, 5742, 5731, 3, 2, 2, 2, 5742, 5733,
	3, 2, 2, 2, 5742, 5734, 3, 2, 2, 2, 5742, 5735, 3, 2, 2, 2, 5742, 5736,
	3, 2, 2, 2, 5742, 5737, 3, 2, 2, 2, 5742, 5738, 3, 2, 2, 2, 5742, 5739,
	3, 2, 2, 2, 5742, 5740, 3, 2, 2, 2, 5742, 5741, 3, 2, 2, 2, 5743, 753,
	3, 2, 2, 2, 5744, 5745, 9, 90, 2, 2, 5745, 755, 3, 2, 2, 2, 5746, 5747,
	7, 550, 2, 2, 5747, 5748, 5, 754, 378, 2, 5748, 757, 3, 2, 2, 2, 5749,
	5750, 9, 91, 2, 2, 5750, 759, 3, 2, 2, 2, 5751, 5752, 7, 568, 2, 2, 5752,
	5754, 5, 718, 360, 2, 5753, 5751, 3, 2, 2, 2, 5753, 5754, 3, 2, 2, 2, 5754,
	5755, 3, 2, 2, 2, 5755, 5756, 5, 762, 382, 2, 5756, 761, 3, 2, 2, 2, 5757,
	5760, 5, 766, 384, 2, 5758, 5760, 7, 542, 2, 2, 5759, 5757, 3, 2, 2, 2,
	5759, 5758, 3, 2, 2, 2, 5760, 763, 3, 2, 2, 2, 5761, 5762, 7, 545, 2, 2,
	5762, 5763, 7, 549, 2, 2, 5763, 5764, 7, 546, 2, 2, 5764, 765, 3, 2, 2,
	2, 5765, 5766, 9, 92, 2, 2, 5766, 767, 3, 2, 2, 2, 5767, 5768, 9, 93, 2,
	2, 5768, 769, 3, 2, 2, 2, 5769, 5770, 9, 94, 2, 2, 5770, 771, 3, 2, 2,
	2, 766, 774, 777, 781, 816, 828, 833, 838, 845, 855, 860, 868, 870, 874,
	878, 883, 888, 893, 899, 913, 918, 921, 927, 936, 950, 958, 963, 973, 976,
	981, 986, 993, 999, 1003, 1009, 1014, 1021, 1028, 1035, 1042, 1044, 1056,
	1066, 1071, 1083, 1088, 1093, 1096, 1109, 1121, 1126, 1131, 1143, 1148,
	1156, 1158, 1162, 1166, 1171, 1176, 1181, 1193, 1198, 1202, 1207, 1213,
	1220, 1230, 1235, 1238, 1242, 1247, 1253, 1271, 1276, 1281, 1283, 1290,
	1297, 1300, 1303, 1306, 1317, 1329, 1333, 1336, 1345, 1353, 1361, 1364,
	1371, 1375, 1382, 1388, 1429, 1457, 1464, 1469, 1480, 1483, 1494, 1502,
	1506, 1518, 1521, 1527, 1530, 1535, 1540, 1544, 1554, 1564, 1570, 1581,
	1586, 1590, 1598, 1606, 1611, 1614, 1616, 1619, 1628, 1633, 1640, 1643,
	1646, 1650, 1653, 1661, 1666, 1671, 1678, 1688, 1704, 1710, 1720, 1730,
	1737, 1742, 1748, 1758, 1763, 1770, 1775, 1781, 1784, 1787, 1804, 1809,
	1818, 1823, 1829, 1832, 1839, 1842, 1849, 1854, 1858, 1863, 1868, 1878,
	1884, 1894, 1899, 1906, 1912, 1916, 1919, 1922, 1939, 1944, 1952, 1966,
	1973, 1989, 1998, 2000, 2021, 2029, 2041, 2047, 2067, 2080, 2088, 2093,
	2101, 2103, 2124, 2131, 2133, 2136, 2140, 2143, 2151, 2153, 2155, 2158,
	2182, 2191, 2196, 2201, 2207, 2214, 2219, 2221, 2237, 2242, 2248, 2255,
	2277, 2283, 2293, 2303, 2312, 2325, 2345, 2354, 2359, 2363, 2366, 2380,
	2388, 2392, 2395, 2410, 2414, 2419, 2422, 2435, 2439, 2451, 2456, 2460,
	2464, 2470, 2473, 2476, 2503, 2509, 2513, 2524, 2531, 2535, 2538, 2544,
	2553, 2561, 2565, 2569, 2577, 2586, 2592, 2594, 2608, 2629, 2634, 2638,
	2645, 2649, 2653, 2657, 2669, 2673, 2687, 2693, 2700, 2705, 2716, 2719,
	2725, 2727, 2736, 2746, 2751, 2766, 2770, 2773, 2777, 2791, 2793, 2797,
	2805, 2812, 2817, 2819, 2824, 2829, 2837, 2844, 2848, 2851, 2863, 2869,
	2878, 2881, 2891, 2902, 2905, 2912, 2915, 2922, 2933, 2939, 2943, 2953,
	2956, 2962, 2973, 2975, 2977, 2980, 2984, 2987, 2991, 2995, 3000, 3011,
	3015, 3023, 3026, 3031, 3033, 3042, 3052, 3057, 3063, 3067, 3070, 3078,
	3081, 3085, 3089, 3094, 3097, 3101, 3105, 3109, 3121, 3135, 3143, 3147,
	3151, 3157, 3165, 3168, 3171, 3175, 3178, 3181, 3184, 3188, 3200, 3203,
	3210, 3217, 3222, 3228, 3232, 3237, 3244, 3250, 3257, 3260, 3263, 3267,
	3272, 3276, 3278, 3291, 3298, 3305, 3309, 3319, 3323, 3331, 3343, 3353,
	3358, 3368, 3376, 3379, 3385, 3390, 3393, 3398, 3408, 3413, 3426, 3438,
	3443, 3453, 3458, 3460, 3465, 3469, 3475, 3479, 3492, 3496, 3506, 3509,
	3511, 3516, 3525, 3538, 3546, 3550, 3559, 3563, 3568, 3579, 3581, 3597,
	3602, 3608, 3614, 3632, 3639, 3642, 3645, 3653, 3656, 3664, 3666, 3670,
	3673, 3678, 3680, 3684, 3696, 3705, 3713, 3718, 3722, 3727, 3730, 3738,
	3746, 3752, 3755, 3758, 3766, 3776, 3788, 3795, 3799, 3803, 3806, 3809,
	3814, 3819, 3822, 3825, 3831, 3834, 3840, 3843, 3846, 3851, 3854, 3862,
	3868, 3878, 3883, 3888, 3896, 3906, 3910, 3912, 3915, 3927, 3931, 3934,
	3954, 3959, 3964, 3968, 3975, 3978, 3987, 3994, 3999, 4003, 4011, 4017,
	4025, 4028, 4037, 4040, 4043, 4052, 4058, 4064, 4066, 4079, 4081, 4090,
	4092, 4096, 4102, 4106, 4120, 4125, 4136, 4147, 4151, 4158, 4163, 4167,
	4172, 4180, 4182, 4188, 4191, 4202, 4207, 4217, 4219, 4221, 4231, 4235,
	4237, 4249, 4257, 4270, 4273, 4285, 4287, 4295, 4303, 4310, 4314, 4321,
	4325, 4330, 4334, 4342, 4346, 4353, 4358, 4367, 4376, 4385, 4388, 4408,
	4412, 4415, 4422, 4425, 4429, 4432, 4439, 4442, 4448, 4451, 4455, 4458,
	4465, 4470, 4484, 4491, 4502, 4511, 4520, 4524, 4528, 4554, 4557, 4560,
	4570, 4574, 4579, 4584, 4589, 4598, 4601, 4603, 4607, 4614, 4621, 4629,
	4644, 4649, 4654, 4660, 4663, 4667, 4677, 4689, 4691, 4698, 4702, 4711,
	4720, 4734, 4742, 4745, 4754, 4760, 4770, 4778, 4781, 4784, 4793, 4798,
	4807, 4813, 4818, 4821, 4826, 4831, 4835, 4841, 4847, 4856, 4861, 4869,
	4873, 4878, 4884, 4891, 4896, 4903, 4907, 4912, 4920, 4923, 4926, 4929,
	4933, 4938, 4943, 4947, 4954, 4959, 4961, 4972, 4976, 4978, 4989, 5000,
	5009, 5012, 5016, 5019, 5023, 5036, 5041, 5049, 5056, 5060, 5065, 5069,
	5074, 5079, 5082, 5089, 5099, 5107, 5111, 5121, 5124, 5126, 5136, 5138,
	5144, 5150, 5152, 5166, 5168, 5178, 5187, 5196, 5200, 5204, 5209, 5213,
	5216, 5220, 5227, 5231, 5239, 5244, 5263, 5268, 5275, 5288, 5298, 5303,
	5312, 5320, 5328, 5334, 5339, 5344, 5348, 5353, 5356, 5362, 5366, 5371,
	5380, 5386, 5391, 5398, 5412, 5416, 5422, 5427, 5432, 5434, 5439, 5443,
	5448, 5455, 5460, 5462, 5464, 5474, 5479, 5483, 5486, 5490, 5499, 5505,
	5509, 5511, 5515, 5519, 5526, 5534, 5542, 5544, 5550, 5553, 5577, 5584,
	5617, 5622, 5625, 5630, 5632, 5638, 5646, 5651, 5658, 5663, 5666, 5670,
	5677, 5683, 5689, 5695, 5701, 5706, 5708, 5711, 5721, 5724, 5726, 5728,
	5742, 5753, 5759,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'ADD'", "'AFTER'", "'AGENT'", "'AGGREGATE'", "'A'", "'ALL'", "'ALTER'",
	"'ANALYZE'", "'AND'", "'ANY'", "'ARCHIVE'", "'ARRAY'", "'AS'", "'ASC'",
	"'ASSOCIATE'", "'AT'", "'ATTRIBUTE'", "'AUDIT'", "'AUTHID'", "'AUTO'",
	"'AUTOMATIC'", "'AUTONOMOUS_TRANSACTION'", "'BASIC'", "'BATCH'", "'BEFORE'",
	"'BEGIN'", "'BETWEEN'", "'BFILE'", "'BINARY_DOUBLE'", "'BINARY_FLOAT'",
	"'BINARY_INTEGER'", "'BLOB'", "'BLOCK'", "'BODY'", "'BOOLEAN'", "'BOTH'",
	"'BREADTH'", "'BUFFER_POOL'", "'BULK'", "'BY'", "'BYTE'", "'CACHE'", "'CALL'",
	"'CANONICAL'", "'CASCADE'", "'CASE'", "'CAST'", "'CHARACTER'", "'CHAR'",
	"'CHAR_CS'", "'CHECK'", "'CHR'", "'C'", "'CLOB'", "'CLOSE'", "'CLUSTER'",
	"'COALESCE'", "'COLLECT'", "'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'",
	"'COMMITTED'", "'COMPATIBILITY'", "'COMPILE'", "'COMPOUND'", "'COMPRESS'",
	"'COMPUTE'", "'CONNECT_BY_ROOT'", "'CONNECT'", "'CONSTANT'", "'CONSTRAINT'",
	"'CONSTRAINTS'", "'CONSTRUCTOR'", "'CONTENT'", "'CONTEXT'", "'CONTINUE'",
	"'CONVERT'", "'CORRUPT_XID_ALL'", "'CORRUPT_XID'", "'COST'", "'COUNT'",
	"'CREATE'", "'CREATION'", "'CROSS'", "'CUBE'", "'CURRENT'", "'CURRENT_USER'",
	"'CURSOR'", "'CUSTOMDATUM'", "'CYCLE'", "'DATABASE'", "'DATA'", "'DATE'",
	"'DAY'", "'DB_ROLE_CHANGE'", "'DBTIMEZONE'", "'DDL'", "'DEBUG'", "'DEC'",
	"'DECIMAL'", "'DECLARE'", "'DECOMPOSE'", "'DECREMENT'", "'DEFAULT'", "'DEFAULTS'",
	"'DEFERRED'", "'DEFINER'", "'DELETE'", "'DEPTH'", "'DESC'", "'DETERMINISTIC'",
	"'DIMENSION'", "'DISABLE'", "'DISASSOCIATE'", "'DISTINCT'", "'DOCUMENT'",
	"'DOUBLE'", "'DROP'", "'DSINTERVAL_UNCONSTRAINED'", "'EACH'", "'ELEMENT'",
	"'ELSE'", "'ELSIF'", "'EMPTY'", "'ENABLE'", "'ENCODING'", "'ENCRYPT'",
	"'END'", "'ENTITYESCAPING'", "'ERR'", "'ERRORS'", "'ESCAPE'", "'EVALNAME'",
	"'EXCEPTION'", "'EXCEPTION_INIT'", "'EXCEPTIONS'", "'EXCLUDE'", "'EXCLUSIVE'",
	"'EXECUTE'", "'EXISTS'", "'EXIT'", "'EXPLAIN'", "'EXTERNAL'", "'EXTRACT'",
	"'FAILURE'", "'FALSE'", "'FETCH'", "'FILESYSTEM_LIKE_LOGGING'", "'FINAL'",
	"'FIRST'", "'FIRST_VALUE'", "'FLASH_CACHE'", "'FLOAT'", "'FOLLOWING'",
	"'FOLLOWS'", "'FORALL'", "'FORCE'", "'FOREIGN'", "'FOR'", "'FREELIST'",
	"'FREELISTS'", "'FROM'", "'FULL'", "'FUNCTION'", "'GLOBAL'", "'GOTO'",
	"'GRANT'", "'GROUP'", "'GROUPING'", "'GROUPS'", "'HASH'", "'HAVING'", "'HIDE'",
	"'HIGH'", "'HOUR'", "'IF'", "'IGNORE'", "'IMMEDIATE'", "'INCLUDE'", "'INCLUDING'",
	"'INCREMENT'", "'INDENT'", "'INDEXED'", "'INDEX'", "'INDICATOR'", "'INDICES'",
	"'INFINITE'", "'IN'", "'INITIAL'", "'INITRANS'", "'INLINE'", "'INNER'",
	"'INOUT'", "'INSERT'", "'INSTANTIABLE'", "'INSTEAD'", "'INTEGER'", "'INTERSECT'",
	"'INTERVAL'", "'INT'", "'INTO'", "'INVALIDATE'", "'IS'", "'ISOLATION'",
	"'ITERATE'", "'JAVA'", "'JOIN'", "'KEEP'", "'KEY'", "'LANGUAGE'", "'LAST'",
	"'LAST_VALUE'", "'LEADING'", "'LEFT'", "'LEVEL'", "'LIBRARY'", "'LIKE2'",
	"'LIKE4'", "'LIKEC'", "'LIKE'", "'LIMIT'", "'LIST'", "'LOCAL'", "'LOCKED'",
	"'LOCK'", "'LOGGING'", "'LOG'", "'LOGOFF'", "'LOGON'", "'LONG'", "'LOOP'",
	"'LOW'", "'MAIN'", "'MAP'", "'MATCHED'", "'MAXVALUE'", "'MEASURES'", "'MEMBER'",
	"'MERGE'", "'MINEXTENTS'", "'MINUS'", "'MINUTE'", "'MINVALUE'", "'MLSLABEL'",
	"'MODEL'", "'MODE'", "'MODIFY'", "'MONTH'", "'MULTISET'", "'NAME'", "'NAN'",
	"'NATURAL'", "'NATURALN'", "'NAV'", "'NCHAR_CS'", "'NCHAR'", "'NCLOB'",
	"'NESTED'", "'NEW'", "'NEXT'", "'NOAUDIT'", "'NOCACHE'", "'NOCOMPRESS'",
	"'NOCOPY'", "'NOCYCLE'", "'NOENTITYESCAPING'", "'NOLOGGING'", "'NOMAXVALUE'",
	"'NOMINVALUE'", "'NONE'", "'NO'", "'NOORDER'", "'NOSCHEMACHECK'", "'NOT'",
	"'NOWAIT'", "'NULL'", "'NULLS'", "'NUMBER'", "'NUMERIC'", "'NVARCHAR2'",
	"'OBJECT'", "'OFF'", "'OF'", "'OID'", "'OLD'", "'OLTP'", "'ONLY'", "'ON'",
	"'OPEN'", "'OPTIMAL'", "'OPTION'", "'ORADATA'", "'ORDER'", "'ORDINALITY'",
	"'OR'", "'OSERROR'", "'OUTER'", "'OUT'", "'OVER'", "'OVERRIDING'", "'PACKAGE'",
	"'PARALLEL_ENABLE'", "'PARAMETERS'", "'PARENT'", "'PARTITION'", "'PASSING'",
	"'PATH'", "'PCTFREE'", "'PCTINCREASE'", "'PCTUSED'", "'%FOUND'", "'%ISOPEN'",
	"'%NOTFOUND'", "'%ROWCOUNT'", "'%ROWTYPE'", "'%TYPE'", "'PIPELINED'", "'PIPE'",
	"'PIVOT'", "'PLAN'", "'PLS_INTEGER'", "'POSITIVEN'", "'POSITIVE'", "'PRAGMA'",
	"'PRECEDING'", "'PRECISION'", "'PRESENT'", "'PRESERVE'", "'PRIMARY'", "'PRIOR'",
	"'PROCEDURE'", "'PUBLIC'", "'QUERY'", "'RAISE'", "'RANGE'", "'RAW'", "'READ'",
	"'REAL'", "'RECORD'", "'RECYCLE'", "'REFERENCE'", "'REFERENCES'", "'REFERENCING'",
	"'REF'", "'REJECT'", "'RELIES_ON'", "'RENAME'", "'REPLACE'", "'RESPECT'",
	"'RESTRICT_REFERENCES'", "'RESULT_CACHE'", "'RESULT'", "'RETURNING'", "'RETURN'",
	"'REUSE'", "'REVERSE'", "'REVOKE'", "'RIGHT'", "'ROLLBACK'", "'ROLLUP'",
	"'ROWID'", "'ROW'", "'ROWS'", "'RULES'", "'SAMPLE'", "'SAVEPOINT'", "'SAVE'",
	"'SCHEMACHECK'", "'SCHEMA'", "'SCN'", "'SEARCH'", "'SECOND'", "'SEED'",
	"'SEGMENT'", "'SELECT'", "'SELF'", "'SEQUENCE'", "'SEQUENTIAL'", "'SERIALIZABLE'",
	"'SERIALLY_REUSABLE'", "'SERVERERROR'", "'SESSIONTIMEZONE'", "'SET'", "'SETS'",
	"'SETTINGS'", "'SHARE'", "'SHOW'", "'SHUTDOWN'", "'SIBLINGS'", "'SIGNTYPE'",
	"'SIMPLE_INTEGER'", "'SINGLE'", "'SIZE'", "'SKIP'", "'SMALLINT'", "'SNAPSHOT'",
	"'SOME'", "'SPECIFICATION'", "'SQLDATA'", "'SQLERROR'", "'STANDALONE'",
	"'START'", "'STARTUP'", "'STATEMENT_ID'", "'STATEMENT'", "'STATIC'", "'STATISTICS'",
	"'STORAGE'", "'STRING'", "'SUBMULTISET'", "'SUBPARTITION'", "'SUBSTITUTABLE'",
	"'SUBTYPE'", "'SUCCESS'", "'SUSPEND'", "'SYNONYM'", "'TABLESPACE'", "'TABLE'",
	"'TEMPORARY'", "'THEN'", "'THE'", "'TIMESTAMP_LTZ_UNCONSTRAINED'", "'TIMESTAMP'",
	"'TIMESTAMP_TZ_UNCONSTRAINED'", "'TIMESTAMP_UNCONSTRAINED'", "'TIME'",
	"'TIMEZONE_ABBR'", "'TIMEZONE_HOUR'", "'TIMEZONE_MINUTE'", "'TIMEZONE_REGION'",
	"'TO'", "'TRAILING'", "'TRANSACTION'", "'TRANSLATE'", "'TREAT'", "'TRIGGER'",
	"'TRUE'", "'TRUNCATE'", "'TYPE'", "'UNBOUNDED'", "'UNDER'", "'UNION'",
	"'UNIQUE'", "'UNLIMITED'", "'UNPIVOT'", "'UNTIL'", "'UPDATED'", "'UPDATE'",
	"'UPSERT'", "'UROWID'", "'USE'", "'USING'", "'VALIDATE'", "'VALUES'", "'VALUE'",
	"'VARCHAR2'", "'VARCHAR'", "'VARIABLE'", "'VARRAY'", "'VARYING'", "'VERSIONS'",
	"'VERSION'", "'WAIT'", "'WARNING'", "'WELLFORMED'", "'WHENEVER'", "'WHEN'",
	"'WHERE'", "'WHILE'", "'WITHIN'", "'WITH'", "'WORK'", "'WRITE'", "'XMLAGG'",
	"'XMLATTRIBUTES'", "'XMLCAST'", "'XMLCOLATTVAL'", "'XMLELEMENT'", "'XMLEXISTS'",
	"'XMLFOREST'", "'XMLNAMESPACES'", "'XMLPARSE'", "'XMLPI'", "'XMLQUERY'",
	"'XMLROOT'", "'XMLSERIALIZE'", "'XMLTABLE'", "'XML'", "'YEAR'", "'YES'",
	"'YMINTERVAL_UNCONSTRAINED'", "'ZONE'", "'PREDICTION'", "'PREDICTION_BOUNDS'",
	"'PREDICTION_COST'", "'PREDICTION_DETAILS'", "'PREDICTION_PROBABILITY'",
	"'PREDICTION_SET'", "'CUME_DIST'", "'DENSE_RANK'", "'LISTAGG'", "'PERCENT_RANK'",
	"'PERCENTILE_CONT'", "'PERCENTILE_DISC'", "'RANK'", "'AVG'", "'CORR'",
	"'COVAR_'", "'DECODE'", "'LAG'", "'LEAD'", "'MAX'", "'MEDIAN'", "'MIN'",
	"'NTILE'", "'NVL'", "'RATIO_TO_REPORT'", "'REGR_'", "'ROUND'", "'ROW_NUMBER'",
	"'SUBSTR'", "'TO_CHAR'", "'TRIM'", "'SUM'", "'STDDEV'", "'VAR_'", "'VARIANCE'",
	"'LEAST'", "'GREATEST'", "'TO_DATE'", "", "", "", "'..'", "'.'", "", "",
	"", "", "'%'", "'&'", "'('", "')'", "'**'", "'*'", "'+'", "'-'", "','",
	"'/'", "'@'", "':='", "", "", "'^'", "'~'", "'!'", "'>'", "'<'", "':'",
	"';'", "'|'", "'='", "'['", "']'", "'_'", "", "", "", "", "", "", "'@!'",
}
var symbolicNames = []string{
	"", "ADD", "AFTER", "AGENT", "AGGREGATE", "A_LETTER", "ALL", "ALTER", "ANALYZE",
	"AND", "ANY", "ARCHIVE", "ARRAY", "AS", "ASC", "ASSOCIATE", "AT", "ATTRIBUTE",
	"AUDIT", "AUTHID", "AUTO", "AUTOMATIC", "AUTONOMOUS_TRANSACTION", "BASIC",
	"BATCH", "BEFORE", "BEGIN", "BETWEEN", "BFILE", "BINARY_DOUBLE", "BINARY_FLOAT",
	"BINARY_INTEGER", "BLOB", "BLOCK", "BODY", "BOOLEAN", "BOTH", "BREADTH",
	"BUFFER_POOL", "BULK", "BY", "BYTE", "CACHE", "CALL", "CANONICAL", "CASCADE",
	"CASE", "CAST", "CHARACTER", "CHAR", "CHAR_CS", "CHECK", "CHR", "C_LETTER",
	"CLOB", "CLOSE", "CLUSTER", "COALESCE", "COLLECT", "COLUMN", "COLUMNS",
	"COMMENT", "COMMIT", "COMMITTED", "COMPATIBILITY", "COMPILE", "COMPOUND",
	"COMPRESS", "COMPUTE", "CONNECT_BY_ROOT", "CONNECT", "CONSTANT", "CONSTRAINT",
	"CONSTRAINTS", "CONSTRUCTOR", "CONTENT", "CONTEXT", "CONTINUE", "CONVERT",
	"CORRUPT_XID_ALL", "CORRUPT_XID", "COST", "COUNT", "CREATE", "CREATION",
	"CROSS", "CUBE", "CURRENT", "CURRENT_USER", "CURSOR", "CUSTOMDATUM", "CYCLE",
	"DATABASE", "DATA", "DATE", "DAY", "DB_ROLE_CHANGE", "DBTIMEZONE", "DDL",
	"DEBUG", "DEC", "DECIMAL", "DECLARE", "DECOMPOSE", "DECREMENT", "DEFAULT",
	"DEFAULTS", "DEFERRED", "DEFINER", "DELETE", "DEPTH", "DESC", "DETERMINISTIC",
	"DIMENSION", "DISABLE", "DISASSOCIATE", "DISTINCT", "DOCUMENT", "DOUBLE",
	"DROP", "DSINTERVAL_UNCONSTRAINED", "EACH", "ELEMENT", "ELSE", "ELSIF",
	"EMPTY", "ENABLE", "ENCODING", "ENCRYPT", "END", "ENTITYESCAPING", "ERR",
	"ERRORS", "ESCAPE", "EVALNAME", "EXCEPTION", "EXCEPTION_INIT", "EXCEPTIONS",
	"EXCLUDE", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTERNAL",
	"EXTRACT", "FAILURE", "FALSE", "FETCH", "FILESYSTEM_LIKE_LOGGING", "FINAL",
	"FIRST", "FIRST_VALUE", "FLASH_CACHE", "FLOAT", "FOLLOWING", "FOLLOWS",
	"FORALL", "FORCE", "FOREIGN", "FOR", "FREELIST", "FREELISTS", "FROM", "FULL",
	"FUNCTION", "GLOBAL", "GOTO", "GRANT", "GROUP", "GROUPING", "GROUPS", "HASH",
	"HAVING", "HIDE", "HIGH", "HOUR", "IF", "IGNORE", "IMMEDIATE", "INCLUDE",
	"INCLUDING", "INCREMENT", "INDENT", "INDEXED", "INDEX", "INDICATOR", "INDICES",
	"INFINITE", "IN", "INITIAL", "INITRANS", "INLINE", "INNER", "INOUT", "INSERT",
	"INSTANTIABLE", "INSTEAD", "INTEGER", "INTERSECT", "INTERVAL", "INT", "INTO",
	"INVALIDATE", "IS", "ISOLATION", "ITERATE", "JAVA", "JOIN", "KEEP", "KEY",
	"LANGUAGE", "LAST", "LAST_VALUE", "LEADING", "LEFT", "LEVEL", "LIBRARY",
	"LIKE2", "LIKE4", "LIKEC", "LIKE", "LIMIT", "LIST", "LOCAL", "LOCKED",
	"LOCK", "LOGGING", "LOG", "LOGOFF", "LOGON", "LONG", "LOOP", "LOW", "MAIN",
	"MAP", "MATCHED", "MAXVALUE", "MEASURES", "MEMBER", "MERGE", "MINEXTENTS",
	"MINUS", "MINUTE", "MINVALUE", "MLSLABEL", "MODEL", "MODE", "MODIFY", "MONTH",
	"MULTISET", "NAME", "NAN", "NATURAL", "NATURALN", "NAV", "NCHAR_CS", "NCHAR",
	"NCLOB", "NESTED", "NEW", "NEXT", "NOAUDIT", "NOCACHE", "NOCOMPRESS", "NOCOPY",
	"NOCYCLE", "NOENTITYESCAPING", "NOLOGGING", "NOMAXVALUE", "NOMINVALUE",
	"NONE", "NO", "NOORDER", "NOSCHEMACHECK", "NOT", "NOWAIT", "NULL", "NULLS",
	"NUMBER", "NUMERIC", "NVARCHAR2", "OBJECT", "OFF", "OF", "OID", "OLD",
	"OLTP", "ONLY", "ON", "OPEN", "OPTIMAL", "OPTION", "ORADATA", "ORDER",
	"ORDINALITY", "OR", "OSERROR", "OUTER", "OUT", "OVER", "OVERRIDING", "PACKAGE",
	"PARALLEL_ENABLE", "PARAMETERS", "PARENT", "PARTITION", "PASSING", "PATH",
	"PCTFREE", "PCTINCREASE", "PCTUSED", "PERCENT_FOUND", "PERCENT_ISOPEN",
	"PERCENT_NOTFOUND", "PERCENT_ROWCOUNT", "PERCENT_ROWTYPE", "PERCENT_TYPE",
	"PIPELINED", "PIPE", "PIVOT", "PLAN", "PLS_INTEGER", "POSITIVEN", "POSITIVE",
	"PRAGMA", "PRECEDING", "PRECISION", "PRESENT", "PRESERVE", "PRIMARY", "PRIOR",
	"PROCEDURE", "PUBLIC", "QUERY", "RAISE", "RANGE", "RAW", "READ", "REAL",
	"RECORD", "RECYCLE", "REFERENCE", "REFERENCES", "REFERENCING", "REF", "REJECT",
	"RELIES_ON", "RENAME", "REPLACE", "RESPECT", "RESTRICT_REFERENCES", "RESULT_CACHE",
	"RESULT", "RETURNING", "RETURN", "REUSE", "REVERSE", "REVOKE", "RIGHT",
	"ROLLBACK", "ROLLUP", "ROWID", "ROW", "ROWS", "RULES", "SAMPLE", "SAVEPOINT",
	"SAVE", "SCHEMACHECK", "SCHEMA", "SCN", "SEARCH", "SECOND", "SEED", "SEGMENT",
	"SELECT", "SELF", "SEQUENCE", "SEQUENTIAL", "SERIALIZABLE", "SERIALLY_REUSABLE",
	"SERVERERROR", "SESSIONTIMEZONE", "SET", "SETS", "SETTINGS", "SHARE", "SHOW",
	"SHUTDOWN", "SIBLINGS", "SIGNTYPE", "SIMPLE_INTEGER", "SINGLE", "SIZE",
	"SKIP_", "SMALLINT", "SNAPSHOT", "SOME", "SPECIFICATION", "SQLDATA", "SQLERROR",
	"STANDALONE", "START", "STARTUP", "STATEMENT_ID", "STATEMENT", "STATIC",
	"STATISTICS", "STORAGE", "STRING", "SUBMULTISET", "SUBPARTITION", "SUBSTITUTABLE",
	"SUBTYPE", "SUCCESS", "SUSPEND", "SYNONYM", "TABLESPACE", "TABLE", "TEMPORARY",
	"THEN", "THE", "TIMESTAMP_LTZ_UNCONSTRAINED", "TIMESTAMP", "TIMESTAMP_TZ_UNCONSTRAINED",
	"TIMESTAMP_UNCONSTRAINED", "TIME", "TIMEZONE_ABBR", "TIMEZONE_HOUR", "TIMEZONE_MINUTE",
	"TIMEZONE_REGION", "TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TREAT",
	"TRIGGER", "TRUE", "TRUNCATE", "TYPE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE",
	"UNLIMITED", "UNPIVOT", "UNTIL", "UPDATED", "UPDATE", "UPSERT", "UROWID",
	"USE", "USING", "VALIDATE", "VALUES", "VALUE", "VARCHAR2", "VARCHAR", "VARIABLE",
	"VARRAY", "VARYING", "VERSIONS", "VERSION", "WAIT", "WARNING", "WELLFORMED",
	"WHENEVER", "WHEN", "WHERE", "WHILE", "WITHIN", "WITH", "WORK", "WRITE",
	"XMLAGG", "XMLATTRIBUTES", "XMLCAST", "XMLCOLATTVAL", "XMLELEMENT", "XMLEXISTS",
	"XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT",
	"XMLSERIALIZE", "XMLTABLE", "XML", "YEAR", "YES", "YMINTERVAL_UNCONSTRAINED",
	"ZONE", "PREDICTION", "PREDICTION_BOUNDS", "PREDICTION_COST", "PREDICTION_DETAILS",
	"PREDICTION_PROBABILITY", "PREDICTION_SET", "CUME_DIST", "DENSE_RANK",
	"LISTAGG", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK",
	"AVG", "CORR", "COVAR_", "DECODE", "LAG", "LEAD", "MAX", "MEDIAN", "MIN",
	"NTILE", "NVL", "RATIO_TO_REPORT", "REGR_", "ROUND", "ROW_NUMBER", "SUBSTR",
	"TO_CHAR", "TRIM", "SUM", "STDDEV", "VAR_", "VARIANCE", "LEAST", "GREATEST",
	"TO_DATE", "NATIONAL_CHAR_STRING_LIT", "BIT_STRING_LIT", "HEX_STRING_LIT",
	"DOUBLE_PERIOD", "PERIOD", "UNSIGNED_INTEGER", "APPROXIMATE_NUM_LIT", "CHAR_STRING",
	"DELIMITED_ID", "PERCENT", "AMPERSAND", "LEFT_PAREN", "RIGHT_PAREN", "DOUBLE_ASTERISK",
	"ASTERISK", "PLUS_SIGN", "MINUS_SIGN", "COMMA", "SOLIDUS", "AT_SIGN", "ASSIGN_OP",
	"BINDVAR", "NOT_EQUAL_OP", "CARRET_OPERATOR_PART", "TILDE_OPERATOR_PART",
	"EXCLAMATION_OPERATOR_PART", "GREATER_THAN_OP", "LESS_THAN_OP", "COLON",
	"SEMICOLON", "BAR", "EQUALS_OP", "LEFT_BRACKET", "RIGHT_BRACKET", "INTRODUCER",
	"SPACES", "SINGLE_LINE_COMMENT", "MULTI_LINE_COMMENT", "PROMPT", "START_CMD",
	"REGULAR_ID", "ZV",
}

var ruleNames = []string{
	"sql_script", "unit_statement", "drop_function", "alter_function", "create_function_body",
	"parallel_enable_clause", "partition_by_clause", "result_cache_clause",
	"relies_on_part", "streaming_clause", "drop_package", "alter_package",
	"create_package", "create_package_body", "package_obj_spec", "procedure_spec",
	"function_spec", "package_obj_body", "drop_procedure", "alter_procedure",
	"function_body", "procedure_body", "create_procedure_body", "drop_trigger",
	"alter_trigger", "create_trigger", "trigger_follows_clause", "trigger_when_clause",
	"simple_dml_trigger", "for_each_row", "compound_dml_trigger", "non_dml_trigger",
	"trigger_body", "routine_clause", "compound_trigger_block", "timing_point_section",
	"non_dml_event", "dml_event_clause", "dml_event_element", "dml_event_nested_clause",
	"referencing_clause", "referencing_element", "drop_type", "alter_type",
	"compile_type_clause", "replace_type_clause", "alter_method_spec", "alter_method_element",
	"alter_attribute_definition", "attribute_definition", "alter_collection_clauses",
	"dependent_handling_clause", "dependent_exceptions_part", "create_type",
	"type_definition", "object_type_def", "object_as_part", "object_under_part",
	"nested_table_type_def", "sqlj_object_type", "type_body", "type_body_elements",
	"map_order_func_declaration", "subprog_decl_in_type", "proc_decl_in_type",
	"func_decl_in_type", "constructor_declaration", "modifier_clause", "object_member_spec",
	"sqlj_object_type_attr", "element_spec", "element_spec_options", "subprogram_spec",
	"type_procedure_spec", "type_function_spec", "constructor_spec", "map_order_function_spec",
	"pragma_clause", "pragma_elements", "type_elements_parameter", "drop_sequence",
	"alter_sequence", "create_sequence", "sequence_spec", "sequence_start_clause",
	"create_index", "alter_index", "drop_index", "create_table", "size_clause",
	"drop_table", "comment_on_column", "create_synonym", "comment_on_table",
	"alter_table", "add_constraint", "check_constraint", "drop_constraint",
	"enable_constraint", "disable_constraint", "foreign_key_clause", "references_clause",
	"on_delete_clause", "unique_key_clause", "primary_key_clause", "anonymous_block",
	"invoker_rights_clause", "compiler_parameters_clause", "call_spec", "java_spec",
	"c_spec", "c_agent_in_clause", "c_parameters_clause", "parameter", "default_value_part",
	"declare_spec", "variable_declaration", "subtype_declaration", "cursor_declaration",
	"parameter_spec", "exception_declaration", "pragma_declaration", "record_type_def",
	"field_spec", "ref_cursor_type_def", "type_declaration", "table_type_def",
	"table_indexed_by_part", "varray_type_def", "seq_of_statements", "label_declaration",
	"statement", "swallow_to_semi", "assignment_statement", "continue_statement",
	"exit_statement", "goto_statement", "if_statement", "elsif_part", "else_part",
	"loop_statement", "cursor_loop_param", "forall_statement", "bounds_clause",
	"between_bound", "lower_bound", "upper_bound", "null_statement", "raise_statement",
	"return_statement", "function_call", "pipe_row_statement", "body", "exception_handler",
	"trigger_block", "block", "sql_statement", "execute_immediate", "dynamic_returning_clause",
	"data_manipulation_language_statements", "cursor_manipulation_statements",
	"close_statement", "open_statement", "fetch_statement", "open_for_statement",
	"transaction_control_statements", "set_transaction_command", "set_constraint_command",
	"commit_statement", "write_clause", "rollback_statement", "savepoint_statement",
	"explain_statement", "select_statement", "subquery_factoring_clause", "factoring_element",
	"search_clause", "cycle_clause", "subquery", "subquery_basic_elements",
	"subquery_operation_part", "query_block", "selected_element", "from_clause",
	"select_list_elements", "table_ref_list", "table_ref", "table_ref_aux",
	"table_ref_aux_internal", "join_clause", "join_on_part", "join_using_part",
	"outer_join_type", "query_partition_clause", "flashback_query_clause",
	"pivot_clause", "pivot_element", "pivot_for_clause", "pivot_in_clause",
	"pivot_in_clause_element", "pivot_in_clause_elements", "unpivot_clause",
	"unpivot_in_clause", "unpivot_in_elements", "hierarchical_query_clause",
	"start_part", "group_by_clause", "group_by_elements", "rollup_cube_clause",
	"grouping_sets_clause", "grouping_sets_elements", "having_clause", "model_clause",
	"cell_reference_options", "return_rows_clause", "reference_model", "main_model",
	"model_column_clauses", "model_column_partition_part", "model_column_list",
	"model_column", "model_rules_clause", "model_rules_part", "model_rules_element",
	"cell_assignment", "model_iterate_clause", "until_part", "order_by_clause",
	"order_by_elements", "for_update_clause", "for_update_of_part", "for_update_options",
	"update_statement", "update_set_clause", "column_based_update_set_clause",
	"delete_statement", "insert_statement", "single_table_insert", "multi_table_insert",
	"multi_table_element", "conditional_insert_clause", "conditional_insert_when_part",
	"conditional_insert_else_part", "insert_into_clause", "values_clause",
	"merge_statement", "merge_update_clause", "merge_element", "merge_update_delete_part",
	"merge_insert_clause", "selected_tableview", "lock_table_statement", "wait_nowait_part",
	"lock_table_element", "lock_mode", "general_table_ref", "static_returning_clause",
	"error_logging_clause", "error_logging_into_part", "error_logging_reject_part",
	"dml_table_expression_clause", "table_collection_expression", "subquery_restriction_clause",
	"sample_clause", "seed_part", "condition", "expressions", "expression",
	"cursor_expression", "logical_expression", "multiset_expression", "relational_expression",
	"compound_expression", "relational_operator", "in_elements", "between_elements",
	"concatenation", "interval_expression", "model_expression", "model_expression_element",
	"single_column_for_loop", "multi_column_for_loop", "unary_expression",
	"case_statement", "simple_case_statement", "simple_case_when_part", "searched_case_statement",
	"searched_case_when_part", "case_else_part", "atom", "quantified_expression",
	"string_function", "standard_function", "numeric_function_wrapper", "numeric_function",
	"other_function", "over_clause_keyword", "within_or_over_clause_keyword",
	"standard_prediction_function_keyword", "over_clause", "windowing_clause",
	"windowing_type", "windowing_elements", "using_clause", "using_element",
	"collect_order_by_part", "within_or_over_part", "cost_matrix_clause", "xml_passing_clause",
	"xml_attributes_clause", "xml_namespaces_clause", "xml_table_column", "xml_general_default_part",
	"xml_multiuse_expression_element", "xmlroot_param_version_part", "xmlroot_param_standalone_part",
	"xmlserialize_param_enconding_part", "xmlserialize_param_version_part",
	"xmlserialize_param_ident_part", "sql_plus_command", "whenever_command",
	"set_command", "partition_extension_clause", "column_alias", "table_alias",
	"where_clause", "into_clause", "xml_column_name", "cost_class_name", "attribute_name",
	"savepoint_name", "rollback_segment_name", "table_var_name", "schema_name",
	"routine_name", "package_name", "implementation_type_name", "parameter_name",
	"reference_model_name", "main_model_name", "aggregate_function_name", "query_name",
	"constraint_name", "label_name", "type_name", "sequence_name", "exception_name",
	"function_name", "procedure_name", "trigger_name", "variable_name", "index_name",
	"cursor_name", "record_name", "collection_name", "link_name", "column_name",
	"tableview_name", "char_set_name", "synonym_name", "schema_object_name",
	"keep_clause", "function_argument", "function_argument_analytic", "function_argument_modeling",
	"respect_or_ignore_nulls", "argument", "type_spec", "datatype", "precision_part",
	"native_datatype_element", "bind_variable", "general_element", "general_element_part",
	"table_element", "constant", "numeric", "numeric_negative", "quoted_string",
	"identifier", "id_expression", "outer_join_sign", "regular_id", "string_function_name",
	"numeric_function_name",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type PlSqlParser struct {
	*antlr.BaseParser
}

func NewPlSqlParser(input antlr.TokenStream) *PlSqlParser {
	this := new(PlSqlParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "PlSqlParser.g4"

	return this
}

// PlSqlParser tokens.
const (
	PlSqlParserEOF                         = antlr.TokenEOF
	PlSqlParserADD                         = 1
	PlSqlParserAFTER                       = 2
	PlSqlParserAGENT                       = 3
	PlSqlParserAGGREGATE                   = 4
	PlSqlParserA_LETTER                    = 5
	PlSqlParserALL                         = 6
	PlSqlParserALTER                       = 7
	PlSqlParserANALYZE                     = 8
	PlSqlParserAND                         = 9
	PlSqlParserANY                         = 10
	PlSqlParserARCHIVE                     = 11
	PlSqlParserARRAY                       = 12
	PlSqlParserAS                          = 13
	PlSqlParserASC                         = 14
	PlSqlParserASSOCIATE                   = 15
	PlSqlParserAT                          = 16
	PlSqlParserATTRIBUTE                   = 17
	PlSqlParserAUDIT                       = 18
	PlSqlParserAUTHID                      = 19
	PlSqlParserAUTO                        = 20
	PlSqlParserAUTOMATIC                   = 21
	PlSqlParserAUTONOMOUS_TRANSACTION      = 22
	PlSqlParserBASIC                       = 23
	PlSqlParserBATCH                       = 24
	PlSqlParserBEFORE                      = 25
	PlSqlParserBEGIN                       = 26
	PlSqlParserBETWEEN                     = 27
	PlSqlParserBFILE                       = 28
	PlSqlParserBINARY_DOUBLE               = 29
	PlSqlParserBINARY_FLOAT                = 30
	PlSqlParserBINARY_INTEGER              = 31
	PlSqlParserBLOB                        = 32
	PlSqlParserBLOCK                       = 33
	PlSqlParserBODY                        = 34
	PlSqlParserBOOLEAN                     = 35
	PlSqlParserBOTH                        = 36
	PlSqlParserBREADTH                     = 37
	PlSqlParserBUFFER_POOL                 = 38
	PlSqlParserBULK                        = 39
	PlSqlParserBY                          = 40
	PlSqlParserBYTE                        = 41
	PlSqlParserCACHE                       = 42
	PlSqlParserCALL                        = 43
	PlSqlParserCANONICAL                   = 44
	PlSqlParserCASCADE                     = 45
	PlSqlParserCASE                        = 46
	PlSqlParserCAST                        = 47
	PlSqlParserCHARACTER                   = 48
	PlSqlParserCHAR                        = 49
	PlSqlParserCHAR_CS                     = 50
	PlSqlParserCHECK                       = 51
	PlSqlParserCHR                         = 52
	PlSqlParserC_LETTER                    = 53
	PlSqlParserCLOB                        = 54
	PlSqlParserCLOSE                       = 55
	PlSqlParserCLUSTER                     = 56
	PlSqlParserCOALESCE                    = 57
	PlSqlParserCOLLECT                     = 58
	PlSqlParserCOLUMN                      = 59
	PlSqlParserCOLUMNS                     = 60
	PlSqlParserCOMMENT                     = 61
	PlSqlParserCOMMIT                      = 62
	PlSqlParserCOMMITTED                   = 63
	PlSqlParserCOMPATIBILITY               = 64
	PlSqlParserCOMPILE                     = 65
	PlSqlParserCOMPOUND                    = 66
	PlSqlParserCOMPRESS                    = 67
	PlSqlParserCOMPUTE                     = 68
	PlSqlParserCONNECT_BY_ROOT             = 69
	PlSqlParserCONNECT                     = 70
	PlSqlParserCONSTANT                    = 71
	PlSqlParserCONSTRAINT                  = 72
	PlSqlParserCONSTRAINTS                 = 73
	PlSqlParserCONSTRUCTOR                 = 74
	PlSqlParserCONTENT                     = 75
	PlSqlParserCONTEXT                     = 76
	PlSqlParserCONTINUE                    = 77
	PlSqlParserCONVERT                     = 78
	PlSqlParserCORRUPT_XID_ALL             = 79
	PlSqlParserCORRUPT_XID                 = 80
	PlSqlParserCOST                        = 81
	PlSqlParserCOUNT                       = 82
	PlSqlParserCREATE                      = 83
	PlSqlParserCREATION                    = 84
	PlSqlParserCROSS                       = 85
	PlSqlParserCUBE                        = 86
	PlSqlParserCURRENT                     = 87
	PlSqlParserCURRENT_USER                = 88
	PlSqlParserCURSOR                      = 89
	PlSqlParserCUSTOMDATUM                 = 90
	PlSqlParserCYCLE                       = 91
	PlSqlParserDATABASE                    = 92
	PlSqlParserDATA                        = 93
	PlSqlParserDATE                        = 94
	PlSqlParserDAY                         = 95
	PlSqlParserDB_ROLE_CHANGE              = 96
	PlSqlParserDBTIMEZONE                  = 97
	PlSqlParserDDL                         = 98
	PlSqlParserDEBUG                       = 99
	PlSqlParserDEC                         = 100
	PlSqlParserDECIMAL                     = 101
	PlSqlParserDECLARE                     = 102
	PlSqlParserDECOMPOSE                   = 103
	PlSqlParserDECREMENT                   = 104
	PlSqlParserDEFAULT                     = 105
	PlSqlParserDEFAULTS                    = 106
	PlSqlParserDEFERRED                    = 107
	PlSqlParserDEFINER                     = 108
	PlSqlParserDELETE                      = 109
	PlSqlParserDEPTH                       = 110
	PlSqlParserDESC                        = 111
	PlSqlParserDETERMINISTIC               = 112
	PlSqlParserDIMENSION                   = 113
	PlSqlParserDISABLE                     = 114
	PlSqlParserDISASSOCIATE                = 115
	PlSqlParserDISTINCT                    = 116
	PlSqlParserDOCUMENT                    = 117
	PlSqlParserDOUBLE                      = 118
	PlSqlParserDROP                        = 119
	PlSqlParserDSINTERVAL_UNCONSTRAINED    = 120
	PlSqlParserEACH                        = 121
	PlSqlParserELEMENT                     = 122
	PlSqlParserELSE                        = 123
	PlSqlParserELSIF                       = 124
	PlSqlParserEMPTY                       = 125
	PlSqlParserENABLE                      = 126
	PlSqlParserENCODING                    = 127
	PlSqlParserENCRYPT                     = 128
	PlSqlParserEND                         = 129
	PlSqlParserENTITYESCAPING              = 130
	PlSqlParserERR                         = 131
	PlSqlParserERRORS                      = 132
	PlSqlParserESCAPE                      = 133
	PlSqlParserEVALNAME                    = 134
	PlSqlParserEXCEPTION                   = 135
	PlSqlParserEXCEPTION_INIT              = 136
	PlSqlParserEXCEPTIONS                  = 137
	PlSqlParserEXCLUDE                     = 138
	PlSqlParserEXCLUSIVE                   = 139
	PlSqlParserEXECUTE                     = 140
	PlSqlParserEXISTS                      = 141
	PlSqlParserEXIT                        = 142
	PlSqlParserEXPLAIN                     = 143
	PlSqlParserEXTERNAL                    = 144
	PlSqlParserEXTRACT                     = 145
	PlSqlParserFAILURE                     = 146
	PlSqlParserFALSE                       = 147
	PlSqlParserFETCH                       = 148
	PlSqlParserFILESYSTEM_LIKE_LOGGING     = 149
	PlSqlParserFINAL                       = 150
	PlSqlParserFIRST                       = 151
	PlSqlParserFIRST_VALUE                 = 152
	PlSqlParserFLASH_CACHE                 = 153
	PlSqlParserFLOAT                       = 154
	PlSqlParserFOLLOWING                   = 155
	PlSqlParserFOLLOWS                     = 156
	PlSqlParserFORALL                      = 157
	PlSqlParserFORCE                       = 158
	PlSqlParserFOREIGN                     = 159
	PlSqlParserFOR                         = 160
	PlSqlParserFREELIST                    = 161
	PlSqlParserFREELISTS                   = 162
	PlSqlParserFROM                        = 163
	PlSqlParserFULL                        = 164
	PlSqlParserFUNCTION                    = 165
	PlSqlParserGLOBAL                      = 166
	PlSqlParserGOTO                        = 167
	PlSqlParserGRANT                       = 168
	PlSqlParserGROUP                       = 169
	PlSqlParserGROUPING                    = 170
	PlSqlParserGROUPS                      = 171
	PlSqlParserHASH                        = 172
	PlSqlParserHAVING                      = 173
	PlSqlParserHIDE                        = 174
	PlSqlParserHIGH                        = 175
	PlSqlParserHOUR                        = 176
	PlSqlParserIF                          = 177
	PlSqlParserIGNORE                      = 178
	PlSqlParserIMMEDIATE                   = 179
	PlSqlParserINCLUDE                     = 180
	PlSqlParserINCLUDING                   = 181
	PlSqlParserINCREMENT                   = 182
	PlSqlParserINDENT                      = 183
	PlSqlParserINDEXED                     = 184
	PlSqlParserINDEX                       = 185
	PlSqlParserINDICATOR                   = 186
	PlSqlParserINDICES                     = 187
	PlSqlParserINFINITE                    = 188
	PlSqlParserIN                          = 189
	PlSqlParserINITIAL                     = 190
	PlSqlParserINITRANS                    = 191
	PlSqlParserINLINE                      = 192
	PlSqlParserINNER                       = 193
	PlSqlParserINOUT                       = 194
	PlSqlParserINSERT                      = 195
	PlSqlParserINSTANTIABLE                = 196
	PlSqlParserINSTEAD                     = 197
	PlSqlParserINTEGER                     = 198
	PlSqlParserINTERSECT                   = 199
	PlSqlParserINTERVAL                    = 200
	PlSqlParserINT                         = 201
	PlSqlParserINTO                        = 202
	PlSqlParserINVALIDATE                  = 203
	PlSqlParserIS                          = 204
	PlSqlParserISOLATION                   = 205
	PlSqlParserITERATE                     = 206
	PlSqlParserJAVA                        = 207
	PlSqlParserJOIN                        = 208
	PlSqlParserKEEP                        = 209
	PlSqlParserKEY                         = 210
	PlSqlParserLANGUAGE                    = 211
	PlSqlParserLAST                        = 212
	PlSqlParserLAST_VALUE                  = 213
	PlSqlParserLEADING                     = 214
	PlSqlParserLEFT                        = 215
	PlSqlParserLEVEL                       = 216
	PlSqlParserLIBRARY                     = 217
	PlSqlParserLIKE2                       = 218
	PlSqlParserLIKE4                       = 219
	PlSqlParserLIKEC                       = 220
	PlSqlParserLIKE                        = 221
	PlSqlParserLIMIT                       = 222
	PlSqlParserLIST                        = 223
	PlSqlParserLOCAL                       = 224
	PlSqlParserLOCKED                      = 225
	PlSqlParserLOCK                        = 226
	PlSqlParserLOGGING                     = 227
	PlSqlParserLOG                         = 228
	PlSqlParserLOGOFF                      = 229
	PlSqlParserLOGON                       = 230
	PlSqlParserLONG                        = 231
	PlSqlParserLOOP                        = 232
	PlSqlParserLOW                         = 233
	PlSqlParserMAIN                        = 234
	PlSqlParserMAP                         = 235
	PlSqlParserMATCHED                     = 236
	PlSqlParserMAXVALUE                    = 237
	PlSqlParserMEASURES                    = 238
	PlSqlParserMEMBER                      = 239
	PlSqlParserMERGE                       = 240
	PlSqlParserMINEXTENTS                  = 241
	PlSqlParserMINUS                       = 242
	PlSqlParserMINUTE                      = 243
	PlSqlParserMINVALUE                    = 244
	PlSqlParserMLSLABEL                    = 245
	PlSqlParserMODEL                       = 246
	PlSqlParserMODE                        = 247
	PlSqlParserMODIFY                      = 248
	PlSqlParserMONTH                       = 249
	PlSqlParserMULTISET                    = 250
	PlSqlParserNAME                        = 251
	PlSqlParserNAN                         = 252
	PlSqlParserNATURAL                     = 253
	PlSqlParserNATURALN                    = 254
	PlSqlParserNAV                         = 255
	PlSqlParserNCHAR_CS                    = 256
	PlSqlParserNCHAR                       = 257
	PlSqlParserNCLOB                       = 258
	PlSqlParserNESTED                      = 259
	PlSqlParserNEW                         = 260
	PlSqlParserNEXT                        = 261
	PlSqlParserNOAUDIT                     = 262
	PlSqlParserNOCACHE                     = 263
	PlSqlParserNOCOMPRESS                  = 264
	PlSqlParserNOCOPY                      = 265
	PlSqlParserNOCYCLE                     = 266
	PlSqlParserNOENTITYESCAPING            = 267
	PlSqlParserNOLOGGING                   = 268
	PlSqlParserNOMAXVALUE                  = 269
	PlSqlParserNOMINVALUE                  = 270
	PlSqlParserNONE                        = 271
	PlSqlParserNO                          = 272
	PlSqlParserNOORDER                     = 273
	PlSqlParserNOSCHEMACHECK               = 274
	PlSqlParserNOT                         = 275
	PlSqlParserNOWAIT                      = 276
	PlSqlParserNULL                        = 277
	PlSqlParserNULLS                       = 278
	PlSqlParserNUMBER                      = 279
	PlSqlParserNUMERIC                     = 280
	PlSqlParserNVARCHAR2                   = 281
	PlSqlParserOBJECT                      = 282
	PlSqlParserOFF                         = 283
	PlSqlParserOF                          = 284
	PlSqlParserOID                         = 285
	PlSqlParserOLD                         = 286
	PlSqlParserOLTP                        = 287
	PlSqlParserONLY                        = 288
	PlSqlParserON                          = 289
	PlSqlParserOPEN                        = 290
	PlSqlParserOPTIMAL                     = 291
	PlSqlParserOPTION                      = 292
	PlSqlParserORADATA                     = 293
	PlSqlParserORDER                       = 294
	PlSqlParserORDINALITY                  = 295
	PlSqlParserOR                          = 296
	PlSqlParserOSERROR                     = 297
	PlSqlParserOUTER                       = 298
	PlSqlParserOUT                         = 299
	PlSqlParserOVER                        = 300
	PlSqlParserOVERRIDING                  = 301
	PlSqlParserPACKAGE                     = 302
	PlSqlParserPARALLEL_ENABLE             = 303
	PlSqlParserPARAMETERS                  = 304
	PlSqlParserPARENT                      = 305
	PlSqlParserPARTITION                   = 306
	PlSqlParserPASSING                     = 307
	PlSqlParserPATH                        = 308
	PlSqlParserPCTFREE                     = 309
	PlSqlParserPCTINCREASE                 = 310
	PlSqlParserPCTUSED                     = 311
	PlSqlParserPERCENT_FOUND               = 312
	PlSqlParserPERCENT_ISOPEN              = 313
	PlSqlParserPERCENT_NOTFOUND            = 314
	PlSqlParserPERCENT_ROWCOUNT            = 315
	PlSqlParserPERCENT_ROWTYPE             = 316
	PlSqlParserPERCENT_TYPE                = 317
	PlSqlParserPIPELINED                   = 318
	PlSqlParserPIPE                        = 319
	PlSqlParserPIVOT                       = 320
	PlSqlParserPLAN                        = 321
	PlSqlParserPLS_INTEGER                 = 322
	PlSqlParserPOSITIVEN                   = 323
	PlSqlParserPOSITIVE                    = 324
	PlSqlParserPRAGMA                      = 325
	PlSqlParserPRECEDING                   = 326
	PlSqlParserPRECISION                   = 327
	PlSqlParserPRESENT                     = 328
	PlSqlParserPRESERVE                    = 329
	PlSqlParserPRIMARY                     = 330
	PlSqlParserPRIOR                       = 331
	PlSqlParserPROCEDURE                   = 332
	PlSqlParserPUBLIC                      = 333
	PlSqlParserQUERY                       = 334
	PlSqlParserRAISE                       = 335
	PlSqlParserRANGE                       = 336
	PlSqlParserRAW                         = 337
	PlSqlParserREAD                        = 338
	PlSqlParserREAL                        = 339
	PlSqlParserRECORD                      = 340
	PlSqlParserRECYCLE                     = 341
	PlSqlParserREFERENCE                   = 342
	PlSqlParserREFERENCES                  = 343
	PlSqlParserREFERENCING                 = 344
	PlSqlParserREF                         = 345
	PlSqlParserREJECT                      = 346
	PlSqlParserRELIES_ON                   = 347
	PlSqlParserRENAME                      = 348
	PlSqlParserREPLACE                     = 349
	PlSqlParserRESPECT                     = 350
	PlSqlParserRESTRICT_REFERENCES         = 351
	PlSqlParserRESULT_CACHE                = 352
	PlSqlParserRESULT                      = 353
	PlSqlParserRETURNING                   = 354
	PlSqlParserRETURN                      = 355
	PlSqlParserREUSE                       = 356
	PlSqlParserREVERSE                     = 357
	PlSqlParserREVOKE                      = 358
	PlSqlParserRIGHT                       = 359
	PlSqlParserROLLBACK                    = 360
	PlSqlParserROLLUP                      = 361
	PlSqlParserROWID                       = 362
	PlSqlParserROW                         = 363
	PlSqlParserROWS                        = 364
	PlSqlParserRULES                       = 365
	PlSqlParserSAMPLE                      = 366
	PlSqlParserSAVEPOINT                   = 367
	PlSqlParserSAVE                        = 368
	PlSqlParserSCHEMACHECK                 = 369
	PlSqlParserSCHEMA                      = 370
	PlSqlParserSCN                         = 371
	PlSqlParserSEARCH                      = 372
	PlSqlParserSECOND                      = 373
	PlSqlParserSEED                        = 374
	PlSqlParserSEGMENT                     = 375
	PlSqlParserSELECT                      = 376
	PlSqlParserSELF                        = 377
	PlSqlParserSEQUENCE                    = 378
	PlSqlParserSEQUENTIAL                  = 379
	PlSqlParserSERIALIZABLE                = 380
	PlSqlParserSERIALLY_REUSABLE           = 381
	PlSqlParserSERVERERROR                 = 382
	PlSqlParserSESSIONTIMEZONE             = 383
	PlSqlParserSET                         = 384
	PlSqlParserSETS                        = 385
	PlSqlParserSETTINGS                    = 386
	PlSqlParserSHARE                       = 387
	PlSqlParserSHOW                        = 388
	PlSqlParserSHUTDOWN                    = 389
	PlSqlParserSIBLINGS                    = 390
	PlSqlParserSIGNTYPE                    = 391
	PlSqlParserSIMPLE_INTEGER              = 392
	PlSqlParserSINGLE                      = 393
	PlSqlParserSIZE                        = 394
	PlSqlParserSKIP_                       = 395
	PlSqlParserSMALLINT                    = 396
	PlSqlParserSNAPSHOT                    = 397
	PlSqlParserSOME                        = 398
	PlSqlParserSPECIFICATION               = 399
	PlSqlParserSQLDATA                     = 400
	PlSqlParserSQLERROR                    = 401
	PlSqlParserSTANDALONE                  = 402
	PlSqlParserSTART                       = 403
	PlSqlParserSTARTUP                     = 404
	PlSqlParserSTATEMENT_ID                = 405
	PlSqlParserSTATEMENT                   = 406
	PlSqlParserSTATIC                      = 407
	PlSqlParserSTATISTICS                  = 408
	PlSqlParserSTORAGE                     = 409
	PlSqlParserSTRING                      = 410
	PlSqlParserSUBMULTISET                 = 411
	PlSqlParserSUBPARTITION                = 412
	PlSqlParserSUBSTITUTABLE               = 413
	PlSqlParserSUBTYPE                     = 414
	PlSqlParserSUCCESS                     = 415
	PlSqlParserSUSPEND                     = 416
	PlSqlParserSYNONYM                     = 417
	PlSqlParserTABLESPACE                  = 418
	PlSqlParserTABLE                       = 419
	PlSqlParserTEMPORARY                   = 420
	PlSqlParserTHEN                        = 421
	PlSqlParserTHE                         = 422
	PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED = 423
	PlSqlParserTIMESTAMP                   = 424
	PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED  = 425
	PlSqlParserTIMESTAMP_UNCONSTRAINED     = 426
	PlSqlParserTIME                        = 427
	PlSqlParserTIMEZONE_ABBR               = 428
	PlSqlParserTIMEZONE_HOUR               = 429
	PlSqlParserTIMEZONE_MINUTE             = 430
	PlSqlParserTIMEZONE_REGION             = 431
	PlSqlParserTO                          = 432
	PlSqlParserTRAILING                    = 433
	PlSqlParserTRANSACTION                 = 434
	PlSqlParserTRANSLATE                   = 435
	PlSqlParserTREAT                       = 436
	PlSqlParserTRIGGER                     = 437
	PlSqlParserTRUE                        = 438
	PlSqlParserTRUNCATE                    = 439
	PlSqlParserTYPE                        = 440
	PlSqlParserUNBOUNDED                   = 441
	PlSqlParserUNDER                       = 442
	PlSqlParserUNION                       = 443
	PlSqlParserUNIQUE                      = 444
	PlSqlParserUNLIMITED                   = 445
	PlSqlParserUNPIVOT                     = 446
	PlSqlParserUNTIL                       = 447
	PlSqlParserUPDATED                     = 448
	PlSqlParserUPDATE                      = 449
	PlSqlParserUPSERT                      = 450
	PlSqlParserUROWID                      = 451
	PlSqlParserUSE                         = 452
	PlSqlParserUSING                       = 453
	PlSqlParserVALIDATE                    = 454
	PlSqlParserVALUES                      = 455
	PlSqlParserVALUE                       = 456
	PlSqlParserVARCHAR2                    = 457
	PlSqlParserVARCHAR                     = 458
	PlSqlParserVARIABLE                    = 459
	PlSqlParserVARRAY                      = 460
	PlSqlParserVARYING                     = 461
	PlSqlParserVERSIONS                    = 462
	PlSqlParserVERSION                     = 463
	PlSqlParserWAIT                        = 464
	PlSqlParserWARNING                     = 465
	PlSqlParserWELLFORMED                  = 466
	PlSqlParserWHENEVER                    = 467
	PlSqlParserWHEN                        = 468
	PlSqlParserWHERE                       = 469
	PlSqlParserWHILE                       = 470
	PlSqlParserWITHIN                      = 471
	PlSqlParserWITH                        = 472
	PlSqlParserWORK                        = 473
	PlSqlParserWRITE                       = 474
	PlSqlParserXMLAGG                      = 475
	PlSqlParserXMLATTRIBUTES               = 476
	PlSqlParserXMLCAST                     = 477
	PlSqlParserXMLCOLATTVAL                = 478
	PlSqlParserXMLELEMENT                  = 479
	PlSqlParserXMLEXISTS                   = 480
	PlSqlParserXMLFOREST                   = 481
	PlSqlParserXMLNAMESPACES               = 482
	PlSqlParserXMLPARSE                    = 483
	PlSqlParserXMLPI                       = 484
	PlSqlParserXMLQUERY                    = 485
	PlSqlParserXMLROOT                     = 486
	PlSqlParserXMLSERIALIZE                = 487
	PlSqlParserXMLTABLE                    = 488
	PlSqlParserXML                         = 489
	PlSqlParserYEAR                        = 490
	PlSqlParserYES                         = 491
	PlSqlParserYMINTERVAL_UNCONSTRAINED    = 492
	PlSqlParserZONE                        = 493
	PlSqlParserPREDICTION                  = 494
	PlSqlParserPREDICTION_BOUNDS           = 495
	PlSqlParserPREDICTION_COST             = 496
	PlSqlParserPREDICTION_DETAILS          = 497
	PlSqlParserPREDICTION_PROBABILITY      = 498
	PlSqlParserPREDICTION_SET              = 499
	PlSqlParserCUME_DIST                   = 500
	PlSqlParserDENSE_RANK                  = 501
	PlSqlParserLISTAGG                     = 502
	PlSqlParserPERCENT_RANK                = 503
	PlSqlParserPERCENTILE_CONT             = 504
	PlSqlParserPERCENTILE_DISC             = 505
	PlSqlParserRANK                        = 506
	PlSqlParserAVG                         = 507
	PlSqlParserCORR                        = 508
	PlSqlParserCOVAR_                      = 509
	PlSqlParserDECODE                      = 510
	PlSqlParserLAG                         = 511
	PlSqlParserLEAD                        = 512
	PlSqlParserMAX                         = 513
	PlSqlParserMEDIAN                      = 514
	PlSqlParserMIN                         = 515
	PlSqlParserNTILE                       = 516
	PlSqlParserNVL                         = 517
	PlSqlParserRATIO_TO_REPORT             = 518
	PlSqlParserREGR_                       = 519
	PlSqlParserROUND                       = 520
	PlSqlParserROW_NUMBER                  = 521
	PlSqlParserSUBSTR                      = 522
	PlSqlParserTO_CHAR                     = 523
	PlSqlParserTRIM                        = 524
	PlSqlParserSUM                         = 525
	PlSqlParserSTDDEV                      = 526
	PlSqlParserVAR_                        = 527
	PlSqlParserVARIANCE                    = 528
	PlSqlParserLEAST                       = 529
	PlSqlParserGREATEST                    = 530
	PlSqlParserTO_DATE                     = 531
	PlSqlParserNATIONAL_CHAR_STRING_LIT    = 532
	PlSqlParserBIT_STRING_LIT              = 533
	PlSqlParserHEX_STRING_LIT              = 534
	PlSqlParserDOUBLE_PERIOD               = 535
	PlSqlParserPERIOD                      = 536
	PlSqlParserUNSIGNED_INTEGER            = 537
	PlSqlParserAPPROXIMATE_NUM_LIT         = 538
	PlSqlParserCHAR_STRING                 = 539
	PlSqlParserDELIMITED_ID                = 540
	PlSqlParserPERCENT                     = 541
	PlSqlParserAMPERSAND                   = 542
	PlSqlParserLEFT_PAREN                  = 543
	PlSqlParserRIGHT_PAREN                 = 544
	PlSqlParserDOUBLE_ASTERISK             = 545
	PlSqlParserASTERISK                    = 546
	PlSqlParserPLUS_SIGN                   = 547
	PlSqlParserMINUS_SIGN                  = 548
	PlSqlParserCOMMA                       = 549
	PlSqlParserSOLIDUS                     = 550
	PlSqlParserAT_SIGN                     = 551
	PlSqlParserASSIGN_OP                   = 552
	PlSqlParserBINDVAR                     = 553
	PlSqlParserNOT_EQUAL_OP                = 554
	PlSqlParserCARRET_OPERATOR_PART        = 555
	PlSqlParserTILDE_OPERATOR_PART         = 556
	PlSqlParserEXCLAMATION_OPERATOR_PART   = 557
	PlSqlParserGREATER_THAN_OP             = 558
	PlSqlParserLESS_THAN_OP                = 559
	PlSqlParserCOLON                       = 560
	PlSqlParserSEMICOLON                   = 561
	PlSqlParserBAR                         = 562
	PlSqlParserEQUALS_OP                   = 563
	PlSqlParserLEFT_BRACKET                = 564
	PlSqlParserRIGHT_BRACKET               = 565
	PlSqlParserINTRODUCER                  = 566
	PlSqlParserSPACES                      = 567
	PlSqlParserSINGLE_LINE_COMMENT         = 568
	PlSqlParserMULTI_LINE_COMMENT          = 569
	PlSqlParserPROMPT                      = 570
	PlSqlParserSTART_CMD                   = 571
	PlSqlParserREGULAR_ID                  = 572
	PlSqlParserZV                          = 573
)

// PlSqlParser rules.
const (
	PlSqlParserRULE_sql_script                            = 0
	PlSqlParserRULE_unit_statement                        = 1
	PlSqlParserRULE_drop_function                         = 2
	PlSqlParserRULE_alter_function                        = 3
	PlSqlParserRULE_create_function_body                  = 4
	PlSqlParserRULE_parallel_enable_clause                = 5
	PlSqlParserRULE_partition_by_clause                   = 6
	PlSqlParserRULE_result_cache_clause                   = 7
	PlSqlParserRULE_relies_on_part                        = 8
	PlSqlParserRULE_streaming_clause                      = 9
	PlSqlParserRULE_drop_package                          = 10
	PlSqlParserRULE_alter_package                         = 11
	PlSqlParserRULE_create_package                        = 12
	PlSqlParserRULE_create_package_body                   = 13
	PlSqlParserRULE_package_obj_spec                      = 14
	PlSqlParserRULE_procedure_spec                        = 15
	PlSqlParserRULE_function_spec                         = 16
	PlSqlParserRULE_package_obj_body                      = 17
	PlSqlParserRULE_drop_procedure                        = 18
	PlSqlParserRULE_alter_procedure                       = 19
	PlSqlParserRULE_function_body                         = 20
	PlSqlParserRULE_procedure_body                        = 21
	PlSqlParserRULE_create_procedure_body                 = 22
	PlSqlParserRULE_drop_trigger                          = 23
	PlSqlParserRULE_alter_trigger                         = 24
	PlSqlParserRULE_create_trigger                        = 25
	PlSqlParserRULE_trigger_follows_clause                = 26
	PlSqlParserRULE_trigger_when_clause                   = 27
	PlSqlParserRULE_simple_dml_trigger                    = 28
	PlSqlParserRULE_for_each_row                          = 29
	PlSqlParserRULE_compound_dml_trigger                  = 30
	PlSqlParserRULE_non_dml_trigger                       = 31
	PlSqlParserRULE_trigger_body                          = 32
	PlSqlParserRULE_routine_clause                        = 33
	PlSqlParserRULE_compound_trigger_block                = 34
	PlSqlParserRULE_timing_point_section                  = 35
	PlSqlParserRULE_non_dml_event                         = 36
	PlSqlParserRULE_dml_event_clause                      = 37
	PlSqlParserRULE_dml_event_element                     = 38
	PlSqlParserRULE_dml_event_nested_clause               = 39
	PlSqlParserRULE_referencing_clause                    = 40
	PlSqlParserRULE_referencing_element                   = 41
	PlSqlParserRULE_drop_type                             = 42
	PlSqlParserRULE_alter_type                            = 43
	PlSqlParserRULE_compile_type_clause                   = 44
	PlSqlParserRULE_replace_type_clause                   = 45
	PlSqlParserRULE_alter_method_spec                     = 46
	PlSqlParserRULE_alter_method_element                  = 47
	PlSqlParserRULE_alter_attribute_definition            = 48
	PlSqlParserRULE_attribute_definition                  = 49
	PlSqlParserRULE_alter_collection_clauses              = 50
	PlSqlParserRULE_dependent_handling_clause             = 51
	PlSqlParserRULE_dependent_exceptions_part             = 52
	PlSqlParserRULE_create_type                           = 53
	PlSqlParserRULE_type_definition                       = 54
	PlSqlParserRULE_object_type_def                       = 55
	PlSqlParserRULE_object_as_part                        = 56
	PlSqlParserRULE_object_under_part                     = 57
	PlSqlParserRULE_nested_table_type_def                 = 58
	PlSqlParserRULE_sqlj_object_type                      = 59
	PlSqlParserRULE_type_body                             = 60
	PlSqlParserRULE_type_body_elements                    = 61
	PlSqlParserRULE_map_order_func_declaration            = 62
	PlSqlParserRULE_subprog_decl_in_type                  = 63
	PlSqlParserRULE_proc_decl_in_type                     = 64
	PlSqlParserRULE_func_decl_in_type                     = 65
	PlSqlParserRULE_constructor_declaration               = 66
	PlSqlParserRULE_modifier_clause                       = 67
	PlSqlParserRULE_object_member_spec                    = 68
	PlSqlParserRULE_sqlj_object_type_attr                 = 69
	PlSqlParserRULE_element_spec                          = 70
	PlSqlParserRULE_element_spec_options                  = 71
	PlSqlParserRULE_subprogram_spec                       = 72
	PlSqlParserRULE_type_procedure_spec                   = 73
	PlSqlParserRULE_type_function_spec                    = 74
	PlSqlParserRULE_constructor_spec                      = 75
	PlSqlParserRULE_map_order_function_spec               = 76
	PlSqlParserRULE_pragma_clause                         = 77
	PlSqlParserRULE_pragma_elements                       = 78
	PlSqlParserRULE_type_elements_parameter               = 79
	PlSqlParserRULE_drop_sequence                         = 80
	PlSqlParserRULE_alter_sequence                        = 81
	PlSqlParserRULE_create_sequence                       = 82
	PlSqlParserRULE_sequence_spec                         = 83
	PlSqlParserRULE_sequence_start_clause                 = 84
	PlSqlParserRULE_create_index                          = 85
	PlSqlParserRULE_alter_index                           = 86
	PlSqlParserRULE_drop_index                            = 87
	PlSqlParserRULE_create_table                          = 88
	PlSqlParserRULE_size_clause                           = 89
	PlSqlParserRULE_drop_table                            = 90
	PlSqlParserRULE_comment_on_column                     = 91
	PlSqlParserRULE_create_synonym                        = 92
	PlSqlParserRULE_comment_on_table                      = 93
	PlSqlParserRULE_alter_table                           = 94
	PlSqlParserRULE_add_constraint                        = 95
	PlSqlParserRULE_check_constraint                      = 96
	PlSqlParserRULE_drop_constraint                       = 97
	PlSqlParserRULE_enable_constraint                     = 98
	PlSqlParserRULE_disable_constraint                    = 99
	PlSqlParserRULE_foreign_key_clause                    = 100
	PlSqlParserRULE_references_clause                     = 101
	PlSqlParserRULE_on_delete_clause                      = 102
	PlSqlParserRULE_unique_key_clause                     = 103
	PlSqlParserRULE_primary_key_clause                    = 104
	PlSqlParserRULE_anonymous_block                       = 105
	PlSqlParserRULE_invoker_rights_clause                 = 106
	PlSqlParserRULE_compiler_parameters_clause            = 107
	PlSqlParserRULE_call_spec                             = 108
	PlSqlParserRULE_java_spec                             = 109
	PlSqlParserRULE_c_spec                                = 110
	PlSqlParserRULE_c_agent_in_clause                     = 111
	PlSqlParserRULE_c_parameters_clause                   = 112
	PlSqlParserRULE_parameter                             = 113
	PlSqlParserRULE_default_value_part                    = 114
	PlSqlParserRULE_declare_spec                          = 115
	PlSqlParserRULE_variable_declaration                  = 116
	PlSqlParserRULE_subtype_declaration                   = 117
	PlSqlParserRULE_cursor_declaration                    = 118
	PlSqlParserRULE_parameter_spec                        = 119
	PlSqlParserRULE_exception_declaration                 = 120
	PlSqlParserRULE_pragma_declaration                    = 121
	PlSqlParserRULE_record_type_def                       = 122
	PlSqlParserRULE_field_spec                            = 123
	PlSqlParserRULE_ref_cursor_type_def                   = 124
	PlSqlParserRULE_type_declaration                      = 125
	PlSqlParserRULE_table_type_def                        = 126
	PlSqlParserRULE_table_indexed_by_part                 = 127
	PlSqlParserRULE_varray_type_def                       = 128
	PlSqlParserRULE_seq_of_statements                     = 129
	PlSqlParserRULE_label_declaration                     = 130
	PlSqlParserRULE_statement                             = 131
	PlSqlParserRULE_swallow_to_semi                       = 132
	PlSqlParserRULE_assignment_statement                  = 133
	PlSqlParserRULE_continue_statement                    = 134
	PlSqlParserRULE_exit_statement                        = 135
	PlSqlParserRULE_goto_statement                        = 136
	PlSqlParserRULE_if_statement                          = 137
	PlSqlParserRULE_elsif_part                            = 138
	PlSqlParserRULE_else_part                             = 139
	PlSqlParserRULE_loop_statement                        = 140
	PlSqlParserRULE_cursor_loop_param                     = 141
	PlSqlParserRULE_forall_statement                      = 142
	PlSqlParserRULE_bounds_clause                         = 143
	PlSqlParserRULE_between_bound                         = 144
	PlSqlParserRULE_lower_bound                           = 145
	PlSqlParserRULE_upper_bound                           = 146
	PlSqlParserRULE_null_statement                        = 147
	PlSqlParserRULE_raise_statement                       = 148
	PlSqlParserRULE_return_statement                      = 149
	PlSqlParserRULE_function_call                         = 150
	PlSqlParserRULE_pipe_row_statement                    = 151
	PlSqlParserRULE_body                                  = 152
	PlSqlParserRULE_exception_handler                     = 153
	PlSqlParserRULE_trigger_block                         = 154
	PlSqlParserRULE_block                                 = 155
	PlSqlParserRULE_sql_statement                         = 156
	PlSqlParserRULE_execute_immediate                     = 157
	PlSqlParserRULE_dynamic_returning_clause              = 158
	PlSqlParserRULE_data_manipulation_language_statements = 159
	PlSqlParserRULE_cursor_manipulation_statements        = 160
	PlSqlParserRULE_close_statement                       = 161
	PlSqlParserRULE_open_statement                        = 162
	PlSqlParserRULE_fetch_statement                       = 163
	PlSqlParserRULE_open_for_statement                    = 164
	PlSqlParserRULE_transaction_control_statements        = 165
	PlSqlParserRULE_set_transaction_command               = 166
	PlSqlParserRULE_set_constraint_command                = 167
	PlSqlParserRULE_commit_statement                      = 168
	PlSqlParserRULE_write_clause                          = 169
	PlSqlParserRULE_rollback_statement                    = 170
	PlSqlParserRULE_savepoint_statement                   = 171
	PlSqlParserRULE_explain_statement                     = 172
	PlSqlParserRULE_select_statement                      = 173
	PlSqlParserRULE_subquery_factoring_clause             = 174
	PlSqlParserRULE_factoring_element                     = 175
	PlSqlParserRULE_search_clause                         = 176
	PlSqlParserRULE_cycle_clause                          = 177
	PlSqlParserRULE_subquery                              = 178
	PlSqlParserRULE_subquery_basic_elements               = 179
	PlSqlParserRULE_subquery_operation_part               = 180
	PlSqlParserRULE_query_block                           = 181
	PlSqlParserRULE_selected_element                      = 182
	PlSqlParserRULE_from_clause                           = 183
	PlSqlParserRULE_select_list_elements                  = 184
	PlSqlParserRULE_table_ref_list                        = 185
	PlSqlParserRULE_table_ref                             = 186
	PlSqlParserRULE_table_ref_aux                         = 187
	PlSqlParserRULE_table_ref_aux_internal                = 188
	PlSqlParserRULE_join_clause                           = 189
	PlSqlParserRULE_join_on_part                          = 190
	PlSqlParserRULE_join_using_part                       = 191
	PlSqlParserRULE_outer_join_type                       = 192
	PlSqlParserRULE_query_partition_clause                = 193
	PlSqlParserRULE_flashback_query_clause                = 194
	PlSqlParserRULE_pivot_clause                          = 195
	PlSqlParserRULE_pivot_element                         = 196
	PlSqlParserRULE_pivot_for_clause                      = 197
	PlSqlParserRULE_pivot_in_clause                       = 198
	PlSqlParserRULE_pivot_in_clause_element               = 199
	PlSqlParserRULE_pivot_in_clause_elements              = 200
	PlSqlParserRULE_unpivot_clause                        = 201
	PlSqlParserRULE_unpivot_in_clause                     = 202
	PlSqlParserRULE_unpivot_in_elements                   = 203
	PlSqlParserRULE_hierarchical_query_clause             = 204
	PlSqlParserRULE_start_part                            = 205
	PlSqlParserRULE_group_by_clause                       = 206
	PlSqlParserRULE_group_by_elements                     = 207
	PlSqlParserRULE_rollup_cube_clause                    = 208
	PlSqlParserRULE_grouping_sets_clause                  = 209
	PlSqlParserRULE_grouping_sets_elements                = 210
	PlSqlParserRULE_having_clause                         = 211
	PlSqlParserRULE_model_clause                          = 212
	PlSqlParserRULE_cell_reference_options                = 213
	PlSqlParserRULE_return_rows_clause                    = 214
	PlSqlParserRULE_reference_model                       = 215
	PlSqlParserRULE_main_model                            = 216
	PlSqlParserRULE_model_column_clauses                  = 217
	PlSqlParserRULE_model_column_partition_part           = 218
	PlSqlParserRULE_model_column_list                     = 219
	PlSqlParserRULE_model_column                          = 220
	PlSqlParserRULE_model_rules_clause                    = 221
	PlSqlParserRULE_model_rules_part                      = 222
	PlSqlParserRULE_model_rules_element                   = 223
	PlSqlParserRULE_cell_assignment                       = 224
	PlSqlParserRULE_model_iterate_clause                  = 225
	PlSqlParserRULE_until_part                            = 226
	PlSqlParserRULE_order_by_clause                       = 227
	PlSqlParserRULE_order_by_elements                     = 228
	PlSqlParserRULE_for_update_clause                     = 229
	PlSqlParserRULE_for_update_of_part                    = 230
	PlSqlParserRULE_for_update_options                    = 231
	PlSqlParserRULE_update_statement                      = 232
	PlSqlParserRULE_update_set_clause                     = 233
	PlSqlParserRULE_column_based_update_set_clause        = 234
	PlSqlParserRULE_delete_statement                      = 235
	PlSqlParserRULE_insert_statement                      = 236
	PlSqlParserRULE_single_table_insert                   = 237
	PlSqlParserRULE_multi_table_insert                    = 238
	PlSqlParserRULE_multi_table_element                   = 239
	PlSqlParserRULE_conditional_insert_clause             = 240
	PlSqlParserRULE_conditional_insert_when_part          = 241
	PlSqlParserRULE_conditional_insert_else_part          = 242
	PlSqlParserRULE_insert_into_clause                    = 243
	PlSqlParserRULE_values_clause                         = 244
	PlSqlParserRULE_merge_statement                       = 245
	PlSqlParserRULE_merge_update_clause                   = 246
	PlSqlParserRULE_merge_element                         = 247
	PlSqlParserRULE_merge_update_delete_part              = 248
	PlSqlParserRULE_merge_insert_clause                   = 249
	PlSqlParserRULE_selected_tableview                    = 250
	PlSqlParserRULE_lock_table_statement                  = 251
	PlSqlParserRULE_wait_nowait_part                      = 252
	PlSqlParserRULE_lock_table_element                    = 253
	PlSqlParserRULE_lock_mode                             = 254
	PlSqlParserRULE_general_table_ref                     = 255
	PlSqlParserRULE_static_returning_clause               = 256
	PlSqlParserRULE_error_logging_clause                  = 257
	PlSqlParserRULE_error_logging_into_part               = 258
	PlSqlParserRULE_error_logging_reject_part             = 259
	PlSqlParserRULE_dml_table_expression_clause           = 260
	PlSqlParserRULE_table_collection_expression           = 261
	PlSqlParserRULE_subquery_restriction_clause           = 262
	PlSqlParserRULE_sample_clause                         = 263
	PlSqlParserRULE_seed_part                             = 264
	PlSqlParserRULE_condition                             = 265
	PlSqlParserRULE_expressions                           = 266
	PlSqlParserRULE_expression                            = 267
	PlSqlParserRULE_cursor_expression                     = 268
	PlSqlParserRULE_logical_expression                    = 269
	PlSqlParserRULE_multiset_expression                   = 270
	PlSqlParserRULE_relational_expression                 = 271
	PlSqlParserRULE_compound_expression                   = 272
	PlSqlParserRULE_relational_operator                   = 273
	PlSqlParserRULE_in_elements                           = 274
	PlSqlParserRULE_between_elements                      = 275
	PlSqlParserRULE_concatenation                         = 276
	PlSqlParserRULE_interval_expression                   = 277
	PlSqlParserRULE_model_expression                      = 278
	PlSqlParserRULE_model_expression_element              = 279
	PlSqlParserRULE_single_column_for_loop                = 280
	PlSqlParserRULE_multi_column_for_loop                 = 281
	PlSqlParserRULE_unary_expression                      = 282
	PlSqlParserRULE_case_statement                        = 283
	PlSqlParserRULE_simple_case_statement                 = 284
	PlSqlParserRULE_simple_case_when_part                 = 285
	PlSqlParserRULE_searched_case_statement               = 286
	PlSqlParserRULE_searched_case_when_part               = 287
	PlSqlParserRULE_case_else_part                        = 288
	PlSqlParserRULE_atom                                  = 289
	PlSqlParserRULE_quantified_expression                 = 290
	PlSqlParserRULE_string_function                       = 291
	PlSqlParserRULE_standard_function                     = 292
	PlSqlParserRULE_numeric_function_wrapper              = 293
	PlSqlParserRULE_numeric_function                      = 294
	PlSqlParserRULE_other_function                        = 295
	PlSqlParserRULE_over_clause_keyword                   = 296
	PlSqlParserRULE_within_or_over_clause_keyword         = 297
	PlSqlParserRULE_standard_prediction_function_keyword  = 298
	PlSqlParserRULE_over_clause                           = 299
	PlSqlParserRULE_windowing_clause                      = 300
	PlSqlParserRULE_windowing_type                        = 301
	PlSqlParserRULE_windowing_elements                    = 302
	PlSqlParserRULE_using_clause                          = 303
	PlSqlParserRULE_using_element                         = 304
	PlSqlParserRULE_collect_order_by_part                 = 305
	PlSqlParserRULE_within_or_over_part                   = 306
	PlSqlParserRULE_cost_matrix_clause                    = 307
	PlSqlParserRULE_xml_passing_clause                    = 308
	PlSqlParserRULE_xml_attributes_clause                 = 309
	PlSqlParserRULE_xml_namespaces_clause                 = 310
	PlSqlParserRULE_xml_table_column                      = 311
	PlSqlParserRULE_xml_general_default_part              = 312
	PlSqlParserRULE_xml_multiuse_expression_element       = 313
	PlSqlParserRULE_xmlroot_param_version_part            = 314
	PlSqlParserRULE_xmlroot_param_standalone_part         = 315
	PlSqlParserRULE_xmlserialize_param_enconding_part     = 316
	PlSqlParserRULE_xmlserialize_param_version_part       = 317
	PlSqlParserRULE_xmlserialize_param_ident_part         = 318
	PlSqlParserRULE_sql_plus_command                      = 319
	PlSqlParserRULE_whenever_command                      = 320
	PlSqlParserRULE_set_command                           = 321
	PlSqlParserRULE_partition_extension_clause            = 322
	PlSqlParserRULE_column_alias                          = 323
	PlSqlParserRULE_table_alias                           = 324
	PlSqlParserRULE_where_clause                          = 325
	PlSqlParserRULE_into_clause                           = 326
	PlSqlParserRULE_xml_column_name                       = 327
	PlSqlParserRULE_cost_class_name                       = 328
	PlSqlParserRULE_attribute_name                        = 329
	PlSqlParserRULE_savepoint_name                        = 330
	PlSqlParserRULE_rollback_segment_name                 = 331
	PlSqlParserRULE_table_var_name                        = 332
	PlSqlParserRULE_schema_name                           = 333
	PlSqlParserRULE_routine_name                          = 334
	PlSqlParserRULE_package_name                          = 335
	PlSqlParserRULE_implementation_type_name              = 336
	PlSqlParserRULE_parameter_name                        = 337
	PlSqlParserRULE_reference_model_name                  = 338
	PlSqlParserRULE_main_model_name                       = 339
	PlSqlParserRULE_aggregate_function_name               = 340
	PlSqlParserRULE_query_name                            = 341
	PlSqlParserRULE_constraint_name                       = 342
	PlSqlParserRULE_label_name                            = 343
	PlSqlParserRULE_type_name                             = 344
	PlSqlParserRULE_sequence_name                         = 345
	PlSqlParserRULE_exception_name                        = 346
	PlSqlParserRULE_function_name                         = 347
	PlSqlParserRULE_procedure_name                        = 348
	PlSqlParserRULE_trigger_name                          = 349
	PlSqlParserRULE_variable_name                         = 350
	PlSqlParserRULE_index_name                            = 351
	PlSqlParserRULE_cursor_name                           = 352
	PlSqlParserRULE_record_name                           = 353
	PlSqlParserRULE_collection_name                       = 354
	PlSqlParserRULE_link_name                             = 355
	PlSqlParserRULE_column_name                           = 356
	PlSqlParserRULE_tableview_name                        = 357
	PlSqlParserRULE_char_set_name                         = 358
	PlSqlParserRULE_synonym_name                          = 359
	PlSqlParserRULE_schema_object_name                    = 360
	PlSqlParserRULE_keep_clause                           = 361
	PlSqlParserRULE_function_argument                     = 362
	PlSqlParserRULE_function_argument_analytic            = 363
	PlSqlParserRULE_function_argument_modeling            = 364
	PlSqlParserRULE_respect_or_ignore_nulls               = 365
	PlSqlParserRULE_argument                              = 366
	PlSqlParserRULE_type_spec                             = 367
	PlSqlParserRULE_datatype                              = 368
	PlSqlParserRULE_precision_part                        = 369
	PlSqlParserRULE_native_datatype_element               = 370
	PlSqlParserRULE_bind_variable                         = 371
	PlSqlParserRULE_general_element                       = 372
	PlSqlParserRULE_general_element_part                  = 373
	PlSqlParserRULE_table_element                         = 374
	PlSqlParserRULE_constant                              = 375
	PlSqlParserRULE_numeric                               = 376
	PlSqlParserRULE_numeric_negative                      = 377
	PlSqlParserRULE_quoted_string                         = 378
	PlSqlParserRULE_identifier                            = 379
	PlSqlParserRULE_id_expression                         = 380
	PlSqlParserRULE_outer_join_sign                       = 381
	PlSqlParserRULE_regular_id                            = 382
	PlSqlParserRULE_string_function_name                  = 383
	PlSqlParserRULE_numeric_function_name                 = 384
)

// ISql_scriptContext is an interface to support dynamic dispatch.
type ISql_scriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSql_scriptContext differentiates from other interfaces.
	IsSql_scriptContext()
}

type Sql_scriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_scriptContext() *Sql_scriptContext {
	var p = new(Sql_scriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_sql_script
	return p
}

func (*Sql_scriptContext) IsSql_scriptContext() {}

func NewSql_scriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_scriptContext {
	var p = new(Sql_scriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_sql_script

	return p
}

func (s *Sql_scriptContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_scriptContext) EOF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEOF, 0)
}

func (s *Sql_scriptContext) AllUnit_statement() []IUnit_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnit_statementContext)(nil)).Elem())
	var tst = make([]IUnit_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnit_statementContext)
		}
	}

	return tst
}

func (s *Sql_scriptContext) Unit_statement(i int) IUnit_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnit_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnit_statementContext)
}

func (s *Sql_scriptContext) AllSql_plus_command() []ISql_plus_commandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISql_plus_commandContext)(nil)).Elem())
	var tst = make([]ISql_plus_commandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISql_plus_commandContext)
		}
	}

	return tst
}

func (s *Sql_scriptContext) Sql_plus_command(i int) ISql_plus_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISql_plus_commandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISql_plus_commandContext)
}

func (s *Sql_scriptContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserSEMICOLON)
}

func (s *Sql_scriptContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEMICOLON, i)
}

func (s *Sql_scriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_scriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_scriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSql_script(s)
	}
}

func (s *Sql_scriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSql_script(s)
	}
}

func (p *PlSqlParser) Sql_script() (localctx ISql_scriptContext) {
	localctx = NewSql_scriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PlSqlParserRULE_sql_script)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserALTER || _la == PlSqlParserBEGIN || _la == PlSqlParserCOMMENT || _la == PlSqlParserCREATE || _la == PlSqlParserDELETE || _la == PlSqlParserDROP || _la == PlSqlParserEXIT || _la == PlSqlParserEXPLAIN || _la == PlSqlParserINSERT || _la == PlSqlParserLOCK || _la == PlSqlParserMERGE || (((_la-376)&-(0x1f+1)) == 0 && ((1<<uint((_la-376)))&((1<<(PlSqlParserSELECT-376))|(1<<(PlSqlParserSET-376))|(1<<(PlSqlParserSHOW-376)))) != 0) || (((_la-449)&-(0x1f+1)) == 0 && ((1<<uint((_la-449)))&((1<<(PlSqlParserUPDATE-449))|(1<<(PlSqlParserWHENEVER-449))|(1<<(PlSqlParserWITH-449)))) != 0) || (((_la-543)&-(0x1f+1)) == 0 && ((1<<uint((_la-543)))&((1<<(PlSqlParserLEFT_PAREN-543))|(1<<(PlSqlParserSOLIDUS-543))|(1<<(PlSqlParserPROMPT-543))|(1<<(PlSqlParserSTART_CMD-543)))) != 0) {
		p.SetState(772)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserALTER, PlSqlParserBEGIN, PlSqlParserCOMMENT, PlSqlParserCREATE, PlSqlParserDELETE, PlSqlParserDROP, PlSqlParserEXPLAIN, PlSqlParserINSERT, PlSqlParserLOCK, PlSqlParserMERGE, PlSqlParserSELECT, PlSqlParserUPDATE, PlSqlParserWITH, PlSqlParserLEFT_PAREN:
			{
				p.SetState(770)
				p.Unit_statement()
			}

		case PlSqlParserEXIT, PlSqlParserSET, PlSqlParserSHOW, PlSqlParserWHENEVER, PlSqlParserSOLIDUS, PlSqlParserPROMPT, PlSqlParserSTART_CMD:
			{
				p.SetState(771)
				p.Sql_plus_command()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserSEMICOLON {
			{
				p.SetState(774)
				p.Match(PlSqlParserSEMICOLON)
			}

		}

		p.SetState(781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(782)
		p.Match(PlSqlParserEOF)
	}

	return localctx
}

// IUnit_statementContext is an interface to support dynamic dispatch.
type IUnit_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnit_statementContext differentiates from other interfaces.
	IsUnit_statementContext()
}

type Unit_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnit_statementContext() *Unit_statementContext {
	var p = new(Unit_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_unit_statement
	return p
}

func (*Unit_statementContext) IsUnit_statementContext() {}

func NewUnit_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unit_statementContext {
	var p = new(Unit_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_unit_statement

	return p
}

func (s *Unit_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Unit_statementContext) Alter_function() IAlter_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_functionContext)
}

func (s *Unit_statementContext) Alter_package() IAlter_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_packageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_packageContext)
}

func (s *Unit_statementContext) Alter_procedure() IAlter_procedureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_procedureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_procedureContext)
}

func (s *Unit_statementContext) Alter_sequence() IAlter_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_sequenceContext)
}

func (s *Unit_statementContext) Alter_trigger() IAlter_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_triggerContext)
}

func (s *Unit_statementContext) Alter_type() IAlter_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_typeContext)
}

func (s *Unit_statementContext) Alter_table() IAlter_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_tableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_tableContext)
}

func (s *Unit_statementContext) Alter_index() IAlter_indexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_indexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_indexContext)
}

func (s *Unit_statementContext) Create_function_body() ICreate_function_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_function_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_function_bodyContext)
}

func (s *Unit_statementContext) Create_procedure_body() ICreate_procedure_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_procedure_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_procedure_bodyContext)
}

func (s *Unit_statementContext) Create_package() ICreate_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_packageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_packageContext)
}

func (s *Unit_statementContext) Create_package_body() ICreate_package_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_package_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_package_bodyContext)
}

func (s *Unit_statementContext) Create_index() ICreate_indexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_indexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_indexContext)
}

func (s *Unit_statementContext) Create_table() ICreate_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_tableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_tableContext)
}

func (s *Unit_statementContext) Create_sequence() ICreate_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_sequenceContext)
}

func (s *Unit_statementContext) Create_trigger() ICreate_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_triggerContext)
}

func (s *Unit_statementContext) Create_type() ICreate_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_typeContext)
}

func (s *Unit_statementContext) Create_synonym() ICreate_synonymContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_synonymContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_synonymContext)
}

func (s *Unit_statementContext) Drop_function() IDrop_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_functionContext)
}

func (s *Unit_statementContext) Drop_package() IDrop_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_packageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_packageContext)
}

func (s *Unit_statementContext) Drop_procedure() IDrop_procedureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_procedureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_procedureContext)
}

func (s *Unit_statementContext) Drop_sequence() IDrop_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_sequenceContext)
}

func (s *Unit_statementContext) Drop_trigger() IDrop_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_triggerContext)
}

func (s *Unit_statementContext) Drop_type() IDrop_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_typeContext)
}

func (s *Unit_statementContext) Data_manipulation_language_statements() IData_manipulation_language_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_manipulation_language_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_manipulation_language_statementsContext)
}

func (s *Unit_statementContext) Drop_table() IDrop_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_tableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_tableContext)
}

func (s *Unit_statementContext) Drop_index() IDrop_indexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_indexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_indexContext)
}

func (s *Unit_statementContext) Comment_on_column() IComment_on_columnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComment_on_columnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComment_on_columnContext)
}

func (s *Unit_statementContext) Comment_on_table() IComment_on_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComment_on_tableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComment_on_tableContext)
}

func (s *Unit_statementContext) Anonymous_block() IAnonymous_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymous_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnonymous_blockContext)
}

func (s *Unit_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unit_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unit_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUnit_statement(s)
	}
}

func (s *Unit_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUnit_statement(s)
	}
}

func (p *PlSqlParser) Unit_statement() (localctx IUnit_statementContext) {
	localctx = NewUnit_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PlSqlParserRULE_unit_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(784)
			p.Alter_function()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(785)
			p.Alter_package()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(786)
			p.Alter_procedure()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(787)
			p.Alter_sequence()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(788)
			p.Alter_trigger()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(789)
			p.Alter_type()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(790)
			p.Alter_table()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(791)
			p.Alter_index()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(792)
			p.Create_function_body()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(793)
			p.Create_procedure_body()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(794)
			p.Create_package()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(795)
			p.Create_package_body()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(796)
			p.Create_index()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(797)
			p.Create_table()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(798)
			p.Create_sequence()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(799)
			p.Create_trigger()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(800)
			p.Create_type()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(801)
			p.Create_synonym()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(802)
			p.Drop_function()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(803)
			p.Drop_package()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(804)
			p.Drop_procedure()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(805)
			p.Drop_sequence()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(806)
			p.Drop_trigger()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(807)
			p.Drop_type()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(808)
			p.Data_manipulation_language_statements()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(809)
			p.Drop_table()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(810)
			p.Drop_index()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(811)
			p.Comment_on_column()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(812)
			p.Comment_on_table()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(813)
			p.Anonymous_block()
		}

	}

	return localctx
}

// IDrop_functionContext is an interface to support dynamic dispatch.
type IDrop_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_functionContext differentiates from other interfaces.
	IsDrop_functionContext()
}

type Drop_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_functionContext() *Drop_functionContext {
	var p = new(Drop_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_drop_function
	return p
}

func (*Drop_functionContext) IsDrop_functionContext() {}

func NewDrop_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_functionContext {
	var p = new(Drop_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_drop_function

	return p
}

func (s *Drop_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_functionContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Drop_functionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Drop_functionContext) Function_name() IFunction_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Drop_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDrop_function(s)
	}
}

func (s *Drop_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDrop_function(s)
	}
}

func (p *PlSqlParser) Drop_function() (localctx IDrop_functionContext) {
	localctx = NewDrop_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PlSqlParserRULE_drop_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Match(PlSqlParserDROP)
	}
	{
		p.SetState(817)
		p.Match(PlSqlParserFUNCTION)
	}
	{
		p.SetState(818)
		p.Function_name()
	}
	{
		p.SetState(819)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IAlter_functionContext is an interface to support dynamic dispatch.
type IAlter_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_functionContext differentiates from other interfaces.
	IsAlter_functionContext()
}

type Alter_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_functionContext() *Alter_functionContext {
	var p = new(Alter_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_function
	return p
}

func (*Alter_functionContext) IsAlter_functionContext() {}

func NewAlter_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_functionContext {
	var p = new(Alter_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_function

	return p
}

func (s *Alter_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_functionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *Alter_functionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Alter_functionContext) Function_name() IFunction_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Alter_functionContext) COMPILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPILE, 0)
}

func (s *Alter_functionContext) DEBUG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEBUG, 0)
}

func (s *Alter_functionContext) AllCompiler_parameters_clause() []ICompiler_parameters_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem())
	var tst = make([]ICompiler_parameters_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompiler_parameters_clauseContext)
		}
	}

	return tst
}

func (s *Alter_functionContext) Compiler_parameters_clause(i int) ICompiler_parameters_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompiler_parameters_clauseContext)
}

func (s *Alter_functionContext) REUSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREUSE, 0)
}

func (s *Alter_functionContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSETTINGS, 0)
}

func (s *Alter_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_function(s)
	}
}

func (s *Alter_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_function(s)
	}
}

func (p *PlSqlParser) Alter_function() (localctx IAlter_functionContext) {
	localctx = NewAlter_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PlSqlParserRULE_alter_function)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.Match(PlSqlParserALTER)
	}
	{
		p.SetState(822)
		p.Match(PlSqlParserFUNCTION)
	}
	{
		p.SetState(823)
		p.Function_name()
	}
	{
		p.SetState(824)
		p.Match(PlSqlParserCOMPILE)
	}
	p.SetState(826)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(825)
			p.Match(PlSqlParserDEBUG)
		}

	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(828)
				p.Compiler_parameters_clause()
			}

		}
		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserREUSE {
		{
			p.SetState(834)
			p.Match(PlSqlParserREUSE)
		}
		{
			p.SetState(835)
			p.Match(PlSqlParserSETTINGS)
		}

	}
	{
		p.SetState(838)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ICreate_function_bodyContext is an interface to support dynamic dispatch.
type ICreate_function_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_function_bodyContext differentiates from other interfaces.
	IsCreate_function_bodyContext()
}

type Create_function_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_function_bodyContext() *Create_function_bodyContext {
	var p = new(Create_function_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_function_body
	return p
}

func (*Create_function_bodyContext) IsCreate_function_bodyContext() {}

func NewCreate_function_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_function_bodyContext {
	var p = new(Create_function_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_function_body

	return p
}

func (s *Create_function_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_function_bodyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_function_bodyContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Create_function_bodyContext) Function_name() IFunction_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Create_function_bodyContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Create_function_bodyContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Create_function_bodyContext) USING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSING, 0)
}

func (s *Create_function_bodyContext) Implementation_type_name() IImplementation_type_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementation_type_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementation_type_nameContext)
}

func (s *Create_function_bodyContext) OR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, 0)
}

func (s *Create_function_bodyContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREPLACE, 0)
}

func (s *Create_function_bodyContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *Create_function_bodyContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *Create_function_bodyContext) AllInvoker_rights_clause() []IInvoker_rights_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInvoker_rights_clauseContext)(nil)).Elem())
	var tst = make([]IInvoker_rights_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInvoker_rights_clauseContext)
		}
	}

	return tst
}

func (s *Create_function_bodyContext) Invoker_rights_clause(i int) IInvoker_rights_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvoker_rights_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInvoker_rights_clauseContext)
}

func (s *Create_function_bodyContext) AllParallel_enable_clause() []IParallel_enable_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParallel_enable_clauseContext)(nil)).Elem())
	var tst = make([]IParallel_enable_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParallel_enable_clauseContext)
		}
	}

	return tst
}

func (s *Create_function_bodyContext) Parallel_enable_clause(i int) IParallel_enable_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_enable_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParallel_enable_clauseContext)
}

func (s *Create_function_bodyContext) AllResult_cache_clause() []IResult_cache_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IResult_cache_clauseContext)(nil)).Elem())
	var tst = make([]IResult_cache_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IResult_cache_clauseContext)
		}
	}

	return tst
}

func (s *Create_function_bodyContext) Result_cache_clause(i int) IResult_cache_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResult_cache_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IResult_cache_clauseContext)
}

func (s *Create_function_bodyContext) AllDETERMINISTIC() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserDETERMINISTIC)
}

func (s *Create_function_bodyContext) DETERMINISTIC(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserDETERMINISTIC, i)
}

func (s *Create_function_bodyContext) PIPELINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPIPELINED, 0)
}

func (s *Create_function_bodyContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAGGREGATE, 0)
}

func (s *Create_function_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Create_function_bodyContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Create_function_bodyContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Create_function_bodyContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Create_function_bodyContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECLARE, 0)
}

func (s *Create_function_bodyContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *Create_function_bodyContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *Create_function_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_function_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_function_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_function_body(s)
	}
}

func (s *Create_function_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_function_body(s)
	}
}

func (p *PlSqlParser) Create_function_body() (localctx ICreate_function_bodyContext) {
	localctx = NewCreate_function_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PlSqlParserRULE_create_function_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.Match(PlSqlParserCREATE)
	}
	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOR {
		{
			p.SetState(841)
			p.Match(PlSqlParserOR)
		}
		{
			p.SetState(842)
			p.Match(PlSqlParserREPLACE)
		}

	}
	{
		p.SetState(845)
		p.Match(PlSqlParserFUNCTION)
	}
	{
		p.SetState(846)
		p.Function_name()
	}
	p.SetState(858)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(847)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(848)
			p.Parameter()
		}
		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(849)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(850)
				p.Parameter()
			}

			p.SetState(855)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(856)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(860)
		p.Match(PlSqlParserRETURN)
	}
	{
		p.SetState(861)
		p.Type_spec()
	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserAUTHID || _la == PlSqlParserDETERMINISTIC || _la == PlSqlParserPARALLEL_ENABLE || _la == PlSqlParserRESULT_CACHE {
		p.SetState(866)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserAUTHID:
			{
				p.SetState(862)
				p.Invoker_rights_clause()
			}

		case PlSqlParserPARALLEL_ENABLE:
			{
				p.SetState(863)
				p.Parallel_enable_clause()
			}

		case PlSqlParserRESULT_CACHE:
			{
				p.SetState(864)
				p.Result_cache_clause()
			}

		case PlSqlParserDETERMINISTIC:
			{
				p.SetState(865)
				p.Match(PlSqlParserDETERMINISTIC)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(870)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserPIPELINED {
			{
				p.SetState(871)
				p.Match(PlSqlParserPIPELINED)
			}

		}
		{
			p.SetState(874)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
		case 1:
			p.SetState(876)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserDECLARE {
				{
					p.SetState(875)
					p.Match(PlSqlParserDECLARE)
				}

			}
			p.SetState(881)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
				{
					p.SetState(878)
					p.Declare_spec()
				}

				p.SetState(883)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(884)
				p.Body()
			}

		case 2:
			{
				p.SetState(885)
				p.Call_spec()
			}

		}

	case 2:
		{
			p.SetState(888)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserAGGREGATE || _la == PlSqlParserPIPELINED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(889)
			p.Match(PlSqlParserUSING)
		}
		{
			p.SetState(890)
			p.Implementation_type_name()
		}

	}
	{
		p.SetState(893)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IParallel_enable_clauseContext is an interface to support dynamic dispatch.
type IParallel_enable_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_enable_clauseContext differentiates from other interfaces.
	IsParallel_enable_clauseContext()
}

type Parallel_enable_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_enable_clauseContext() *Parallel_enable_clauseContext {
	var p = new(Parallel_enable_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_parallel_enable_clause
	return p
}

func (*Parallel_enable_clauseContext) IsParallel_enable_clauseContext() {}

func NewParallel_enable_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_enable_clauseContext {
	var p = new(Parallel_enable_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_parallel_enable_clause

	return p
}

func (s *Parallel_enable_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_enable_clauseContext) PARALLEL_ENABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARALLEL_ENABLE, 0)
}

func (s *Parallel_enable_clauseContext) Partition_by_clause() IPartition_by_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartition_by_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartition_by_clauseContext)
}

func (s *Parallel_enable_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_enable_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_enable_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterParallel_enable_clause(s)
	}
}

func (s *Parallel_enable_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitParallel_enable_clause(s)
	}
}

func (p *PlSqlParser) Parallel_enable_clause() (localctx IParallel_enable_clauseContext) {
	localctx = NewParallel_enable_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, PlSqlParserRULE_parallel_enable_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.Match(PlSqlParserPARALLEL_ENABLE)
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(896)
			p.Partition_by_clause()
		}

	}

	return localctx
}

// IPartition_by_clauseContext is an interface to support dynamic dispatch.
type IPartition_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartition_by_clauseContext differentiates from other interfaces.
	IsPartition_by_clauseContext()
}

type Partition_by_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_by_clauseContext() *Partition_by_clauseContext {
	var p = new(Partition_by_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_partition_by_clause
	return p
}

func (*Partition_by_clauseContext) IsPartition_by_clauseContext() {}

func NewPartition_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_by_clauseContext {
	var p = new(Partition_by_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_partition_by_clause

	return p
}

func (s *Partition_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_by_clauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARTITION, 0)
}

func (s *Partition_by_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Partition_by_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Partition_by_clauseContext) ANY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserANY, 0)
}

func (s *Partition_by_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Partition_by_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Partition_by_clauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserHASH, 0)
}

func (s *Partition_by_clauseContext) RANGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRANGE, 0)
}

func (s *Partition_by_clauseContext) LIST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIST, 0)
}

func (s *Partition_by_clauseContext) Streaming_clause() IStreaming_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStreaming_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStreaming_clauseContext)
}

func (s *Partition_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPartition_by_clause(s)
	}
}

func (s *Partition_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPartition_by_clause(s)
	}
}

func (p *PlSqlParser) Partition_by_clause() (localctx IPartition_by_clauseContext) {
	localctx = NewPartition_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PlSqlParserRULE_partition_by_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(899)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(900)
		p.Match(PlSqlParserPARTITION)
	}
	{
		p.SetState(901)
		p.Expression()
	}
	{
		p.SetState(902)
		p.Match(PlSqlParserBY)
	}
	p.SetState(916)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserANY:
		{
			p.SetState(903)
			p.Match(PlSqlParserANY)
		}

	case PlSqlParserHASH, PlSqlParserLIST, PlSqlParserRANGE:
		{
			p.SetState(904)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserHASH || _la == PlSqlParserLIST || _la == PlSqlParserRANGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(905)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(906)
			p.Column_name()
		}
		p.SetState(911)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(907)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(908)
				p.Column_name()
			}

			p.SetState(913)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(914)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserCLUSTER || _la == PlSqlParserORDER {
		{
			p.SetState(918)
			p.Streaming_clause()
		}

	}
	{
		p.SetState(921)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IResult_cache_clauseContext is an interface to support dynamic dispatch.
type IResult_cache_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResult_cache_clauseContext differentiates from other interfaces.
	IsResult_cache_clauseContext()
}

type Result_cache_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResult_cache_clauseContext() *Result_cache_clauseContext {
	var p = new(Result_cache_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_result_cache_clause
	return p
}

func (*Result_cache_clauseContext) IsResult_cache_clauseContext() {}

func NewResult_cache_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Result_cache_clauseContext {
	var p = new(Result_cache_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_result_cache_clause

	return p
}

func (s *Result_cache_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Result_cache_clauseContext) RESULT_CACHE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESULT_CACHE, 0)
}

func (s *Result_cache_clauseContext) Relies_on_part() IRelies_on_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelies_on_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelies_on_partContext)
}

func (s *Result_cache_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Result_cache_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Result_cache_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterResult_cache_clause(s)
	}
}

func (s *Result_cache_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitResult_cache_clause(s)
	}
}

func (p *PlSqlParser) Result_cache_clause() (localctx IResult_cache_clauseContext) {
	localctx = NewResult_cache_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PlSqlParserRULE_result_cache_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(923)
		p.Match(PlSqlParserRESULT_CACHE)
	}
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserRELIES_ON {
		{
			p.SetState(924)
			p.Relies_on_part()
		}

	}

	return localctx
}

// IRelies_on_partContext is an interface to support dynamic dispatch.
type IRelies_on_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelies_on_partContext differentiates from other interfaces.
	IsRelies_on_partContext()
}

type Relies_on_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelies_on_partContext() *Relies_on_partContext {
	var p = new(Relies_on_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_relies_on_part
	return p
}

func (*Relies_on_partContext) IsRelies_on_partContext() {}

func NewRelies_on_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relies_on_partContext {
	var p = new(Relies_on_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_relies_on_part

	return p
}

func (s *Relies_on_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Relies_on_partContext) RELIES_ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRELIES_ON, 0)
}

func (s *Relies_on_partContext) AllTableview_name() []ITableview_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem())
	var tst = make([]ITableview_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableview_nameContext)
		}
	}

	return tst
}

func (s *Relies_on_partContext) Tableview_name(i int) ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Relies_on_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relies_on_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relies_on_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRelies_on_part(s)
	}
}

func (s *Relies_on_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRelies_on_part(s)
	}
}

func (p *PlSqlParser) Relies_on_part() (localctx IRelies_on_partContext) {
	localctx = NewRelies_on_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PlSqlParserRULE_relies_on_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(927)
		p.Match(PlSqlParserRELIES_ON)
	}
	{
		p.SetState(928)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(929)
		p.Tableview_name()
	}
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(930)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(931)
			p.Tableview_name()
		}

		p.SetState(936)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(937)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IStreaming_clauseContext is an interface to support dynamic dispatch.
type IStreaming_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStreaming_clauseContext differentiates from other interfaces.
	IsStreaming_clauseContext()
}

type Streaming_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStreaming_clauseContext() *Streaming_clauseContext {
	var p = new(Streaming_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_streaming_clause
	return p
}

func (*Streaming_clauseContext) IsStreaming_clauseContext() {}

func NewStreaming_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Streaming_clauseContext {
	var p = new(Streaming_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_streaming_clause

	return p
}

func (s *Streaming_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Streaming_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Streaming_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Streaming_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Streaming_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Streaming_clauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORDER, 0)
}

func (s *Streaming_clauseContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCLUSTER, 0)
}

func (s *Streaming_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Streaming_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Streaming_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterStreaming_clause(s)
	}
}

func (s *Streaming_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitStreaming_clause(s)
	}
}

func (p *PlSqlParser) Streaming_clause() (localctx IStreaming_clauseContext) {
	localctx = NewStreaming_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PlSqlParserRULE_streaming_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserCLUSTER || _la == PlSqlParserORDER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(940)
		p.Expression()
	}
	{
		p.SetState(941)
		p.Match(PlSqlParserBY)
	}
	{
		p.SetState(942)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(943)
		p.Column_name()
	}
	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(944)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(945)
			p.Column_name()
		}

		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(951)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IDrop_packageContext is an interface to support dynamic dispatch.
type IDrop_packageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_packageContext differentiates from other interfaces.
	IsDrop_packageContext()
}

type Drop_packageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_packageContext() *Drop_packageContext {
	var p = new(Drop_packageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_drop_package
	return p
}

func (*Drop_packageContext) IsDrop_packageContext() {}

func NewDrop_packageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_packageContext {
	var p = new(Drop_packageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_drop_package

	return p
}

func (s *Drop_packageContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_packageContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Drop_packageContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPACKAGE, 0)
}

func (s *Drop_packageContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *Drop_packageContext) BODY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBODY, 0)
}

func (s *Drop_packageContext) Schema_object_name() ISchema_object_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchema_object_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchema_object_nameContext)
}

func (s *Drop_packageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_packageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_packageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDrop_package(s)
	}
}

func (s *Drop_packageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDrop_package(s)
	}
}

func (p *PlSqlParser) Drop_package() (localctx IDrop_packageContext) {
	localctx = NewDrop_packageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PlSqlParserRULE_drop_package)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(953)
		p.Match(PlSqlParserDROP)
	}
	{
		p.SetState(954)
		p.Match(PlSqlParserPACKAGE)
	}
	p.SetState(956)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(955)
			p.Match(PlSqlParserBODY)
		}

	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(958)
			p.Schema_object_name()
		}
		{
			p.SetState(959)
			p.Match(PlSqlParserPERIOD)
		}

	}
	{
		p.SetState(963)
		p.Package_name()
	}
	{
		p.SetState(964)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IAlter_packageContext is an interface to support dynamic dispatch.
type IAlter_packageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_packageContext differentiates from other interfaces.
	IsAlter_packageContext()
}

type Alter_packageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_packageContext() *Alter_packageContext {
	var p = new(Alter_packageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_package
	return p
}

func (*Alter_packageContext) IsAlter_packageContext() {}

func NewAlter_packageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_packageContext {
	var p = new(Alter_packageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_package

	return p
}

func (s *Alter_packageContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_packageContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *Alter_packageContext) AllPACKAGE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserPACKAGE)
}

func (s *Alter_packageContext) PACKAGE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserPACKAGE, i)
}

func (s *Alter_packageContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *Alter_packageContext) COMPILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPILE, 0)
}

func (s *Alter_packageContext) DEBUG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEBUG, 0)
}

func (s *Alter_packageContext) AllCompiler_parameters_clause() []ICompiler_parameters_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem())
	var tst = make([]ICompiler_parameters_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompiler_parameters_clauseContext)
		}
	}

	return tst
}

func (s *Alter_packageContext) Compiler_parameters_clause(i int) ICompiler_parameters_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompiler_parameters_clauseContext)
}

func (s *Alter_packageContext) REUSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREUSE, 0)
}

func (s *Alter_packageContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSETTINGS, 0)
}

func (s *Alter_packageContext) BODY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBODY, 0)
}

func (s *Alter_packageContext) SPECIFICATION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSPECIFICATION, 0)
}

func (s *Alter_packageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_packageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_packageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_package(s)
	}
}

func (s *Alter_packageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_package(s)
	}
}

func (p *PlSqlParser) Alter_package() (localctx IAlter_packageContext) {
	localctx = NewAlter_packageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PlSqlParserRULE_alter_package)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(966)
		p.Match(PlSqlParserALTER)
	}
	{
		p.SetState(967)
		p.Match(PlSqlParserPACKAGE)
	}
	{
		p.SetState(968)
		p.Package_name()
	}
	{
		p.SetState(969)
		p.Match(PlSqlParserCOMPILE)
	}
	p.SetState(971)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(970)
			p.Match(PlSqlParserDEBUG)
		}

	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(973)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserBODY || _la == PlSqlParserPACKAGE || _la == PlSqlParserSPECIFICATION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(976)
				p.Compiler_parameters_clause()
			}

		}
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserREUSE {
		{
			p.SetState(982)
			p.Match(PlSqlParserREUSE)
		}
		{
			p.SetState(983)
			p.Match(PlSqlParserSETTINGS)
		}

	}
	{
		p.SetState(986)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ICreate_packageContext is an interface to support dynamic dispatch.
type ICreate_packageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_packageContext differentiates from other interfaces.
	IsCreate_packageContext()
}

type Create_packageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_packageContext() *Create_packageContext {
	var p = new(Create_packageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_package
	return p
}

func (*Create_packageContext) IsCreate_packageContext() {}

func NewCreate_packageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_packageContext {
	var p = new(Create_packageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_package

	return p
}

func (s *Create_packageContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_packageContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_packageContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPACKAGE, 0)
}

func (s *Create_packageContext) AllPackage_name() []IPackage_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem())
	var tst = make([]IPackage_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_nameContext)
		}
	}

	return tst
}

func (s *Create_packageContext) Package_name(i int) IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *Create_packageContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *Create_packageContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Create_packageContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Create_packageContext) OR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, 0)
}

func (s *Create_packageContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREPLACE, 0)
}

func (s *Create_packageContext) Schema_object_name() ISchema_object_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchema_object_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchema_object_nameContext)
}

func (s *Create_packageContext) Invoker_rights_clause() IInvoker_rights_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvoker_rights_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvoker_rights_clauseContext)
}

func (s *Create_packageContext) AllPackage_obj_spec() []IPackage_obj_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_obj_specContext)(nil)).Elem())
	var tst = make([]IPackage_obj_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_obj_specContext)
		}
	}

	return tst
}

func (s *Create_packageContext) Package_obj_spec(i int) IPackage_obj_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_obj_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_obj_specContext)
}

func (s *Create_packageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_packageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_packageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_package(s)
	}
}

func (s *Create_packageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_package(s)
	}
}

func (p *PlSqlParser) Create_package() (localctx ICreate_packageContext) {
	localctx = NewCreate_packageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PlSqlParserRULE_create_package)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.Match(PlSqlParserCREATE)
	}
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOR {
		{
			p.SetState(989)
			p.Match(PlSqlParserOR)
		}
		{
			p.SetState(990)
			p.Match(PlSqlParserREPLACE)
		}

	}
	{
		p.SetState(993)
		p.Match(PlSqlParserPACKAGE)
	}
	p.SetState(997)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(994)
			p.Schema_object_name()
		}
		{
			p.SetState(995)
			p.Match(PlSqlParserPERIOD)
		}

	}
	{
		p.SetState(999)
		p.Package_name()
	}
	p.SetState(1001)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAUTHID {
		{
			p.SetState(1000)
			p.Invoker_rights_clause()
		}

	}
	{
		p.SetState(1003)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(1004)
			p.Package_obj_spec()
		}

		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1010)
		p.Match(PlSqlParserEND)
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(1011)
			p.Package_name()
		}

	}
	{
		p.SetState(1014)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ICreate_package_bodyContext is an interface to support dynamic dispatch.
type ICreate_package_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_package_bodyContext differentiates from other interfaces.
	IsCreate_package_bodyContext()
}

type Create_package_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_package_bodyContext() *Create_package_bodyContext {
	var p = new(Create_package_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_package_body
	return p
}

func (*Create_package_bodyContext) IsCreate_package_bodyContext() {}

func NewCreate_package_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_package_bodyContext {
	var p = new(Create_package_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_package_body

	return p
}

func (s *Create_package_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_package_bodyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_package_bodyContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPACKAGE, 0)
}

func (s *Create_package_bodyContext) BODY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBODY, 0)
}

func (s *Create_package_bodyContext) AllPackage_name() []IPackage_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem())
	var tst = make([]IPackage_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_nameContext)
		}
	}

	return tst
}

func (s *Create_package_bodyContext) Package_name(i int) IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *Create_package_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Create_package_bodyContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Create_package_bodyContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBEGIN, 0)
}

func (s *Create_package_bodyContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *Create_package_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *Create_package_bodyContext) OR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, 0)
}

func (s *Create_package_bodyContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREPLACE, 0)
}

func (s *Create_package_bodyContext) Schema_object_name() ISchema_object_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchema_object_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchema_object_nameContext)
}

func (s *Create_package_bodyContext) AllPackage_obj_body() []IPackage_obj_bodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_obj_bodyContext)(nil)).Elem())
	var tst = make([]IPackage_obj_bodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_obj_bodyContext)
		}
	}

	return tst
}

func (s *Create_package_bodyContext) Package_obj_body(i int) IPackage_obj_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_obj_bodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_obj_bodyContext)
}

func (s *Create_package_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_package_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_package_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_package_body(s)
	}
}

func (s *Create_package_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_package_body(s)
	}
}

func (p *PlSqlParser) Create_package_body() (localctx ICreate_package_bodyContext) {
	localctx = NewCreate_package_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PlSqlParserRULE_create_package_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1016)
		p.Match(PlSqlParserCREATE)
	}
	p.SetState(1019)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOR {
		{
			p.SetState(1017)
			p.Match(PlSqlParserOR)
		}
		{
			p.SetState(1018)
			p.Match(PlSqlParserREPLACE)
		}

	}
	{
		p.SetState(1021)
		p.Match(PlSqlParserPACKAGE)
	}
	{
		p.SetState(1022)
		p.Match(PlSqlParserBODY)
	}
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1023)
			p.Schema_object_name()
		}
		{
			p.SetState(1024)
			p.Match(PlSqlParserPERIOD)
		}

	}
	{
		p.SetState(1028)
		p.Package_name()
	}
	{
		p.SetState(1029)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(1030)
			p.Package_obj_body()
		}

		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserBEGIN:
		{
			p.SetState(1036)
			p.Match(PlSqlParserBEGIN)
		}
		{
			p.SetState(1037)
			p.Seq_of_statements()
		}

	case PlSqlParserEND:
		{
			p.SetState(1038)
			p.Match(PlSqlParserEND)
		}
		p.SetState(1040)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
			{
				p.SetState(1039)
				p.Package_name()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1044)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IPackage_obj_specContext is an interface to support dynamic dispatch.
type IPackage_obj_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_obj_specContext differentiates from other interfaces.
	IsPackage_obj_specContext()
}

type Package_obj_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_obj_specContext() *Package_obj_specContext {
	var p = new(Package_obj_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_package_obj_spec
	return p
}

func (*Package_obj_specContext) IsPackage_obj_specContext() {}

func NewPackage_obj_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_obj_specContext {
	var p = new(Package_obj_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_package_obj_spec

	return p
}

func (s *Package_obj_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_obj_specContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Package_obj_specContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Package_obj_specContext) Cursor_declaration() ICursor_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_declarationContext)
}

func (s *Package_obj_specContext) Exception_declaration() IException_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_declarationContext)
}

func (s *Package_obj_specContext) Pragma_declaration() IPragma_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPragma_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPragma_declarationContext)
}

func (s *Package_obj_specContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Package_obj_specContext) Procedure_spec() IProcedure_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_specContext)
}

func (s *Package_obj_specContext) Function_spec() IFunction_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_specContext)
}

func (s *Package_obj_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_obj_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_obj_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPackage_obj_spec(s)
	}
}

func (s *Package_obj_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPackage_obj_spec(s)
	}
}

func (p *PlSqlParser) Package_obj_spec() (localctx IPackage_obj_specContext) {
	localctx = NewPackage_obj_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, PlSqlParserRULE_package_obj_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1046)
			p.Variable_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1047)
			p.Subtype_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1048)
			p.Cursor_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1049)
			p.Exception_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1050)
			p.Pragma_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1051)
			p.Type_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1052)
			p.Procedure_spec()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1053)
			p.Function_spec()
		}

	}

	return localctx
}

// IProcedure_specContext is an interface to support dynamic dispatch.
type IProcedure_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedure_specContext differentiates from other interfaces.
	IsProcedure_specContext()
}

type Procedure_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_specContext() *Procedure_specContext {
	var p = new(Procedure_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_procedure_spec
	return p
}

func (*Procedure_specContext) IsProcedure_specContext() {}

func NewProcedure_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_specContext {
	var p = new(Procedure_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_procedure_spec

	return p
}

func (s *Procedure_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_specContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPROCEDURE, 0)
}

func (s *Procedure_specContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Procedure_specContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *Procedure_specContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *Procedure_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterProcedure_spec(s)
	}
}

func (s *Procedure_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitProcedure_spec(s)
	}
}

func (p *PlSqlParser) Procedure_spec() (localctx IProcedure_specContext) {
	localctx = NewProcedure_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PlSqlParserRULE_procedure_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		p.Match(PlSqlParserPROCEDURE)
	}
	{
		p.SetState(1057)
		p.Identifier()
	}
	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1058)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(1059)
			p.Parameter()
		}
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1060)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1061)
				p.Parameter()
			}

			p.SetState(1066)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1067)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(1071)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IFunction_specContext is an interface to support dynamic dispatch.
type IFunction_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_specContext differentiates from other interfaces.
	IsFunction_specContext()
}

type Function_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_specContext() *Function_specContext {
	var p = new(Function_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_function_spec
	return p
}

func (*Function_specContext) IsFunction_specContext() {}

func NewFunction_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_specContext {
	var p = new(Function_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_function_spec

	return p
}

func (s *Function_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_specContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Function_specContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_specContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Function_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Function_specContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *Function_specContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *Function_specContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDETERMINISTIC, 0)
}

func (s *Function_specContext) RESULT_CACHE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESULT_CACHE, 0)
}

func (s *Function_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFunction_spec(s)
	}
}

func (s *Function_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFunction_spec(s)
	}
}

func (p *PlSqlParser) Function_spec() (localctx IFunction_specContext) {
	localctx = NewFunction_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, PlSqlParserRULE_function_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		p.Match(PlSqlParserFUNCTION)
	}
	{
		p.SetState(1074)
		p.Identifier()
	}
	p.SetState(1086)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1075)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(1076)
			p.Parameter()
		}
		p.SetState(1081)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1077)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1078)
				p.Parameter()
			}

			p.SetState(1083)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1084)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(1088)
		p.Match(PlSqlParserRETURN)
	}
	{
		p.SetState(1089)
		p.Type_spec()
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserDETERMINISTIC {
		{
			p.SetState(1090)
			p.Match(PlSqlParserDETERMINISTIC)
		}

	}
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserRESULT_CACHE {
		{
			p.SetState(1093)
			p.Match(PlSqlParserRESULT_CACHE)
		}

	}
	{
		p.SetState(1096)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IPackage_obj_bodyContext is an interface to support dynamic dispatch.
type IPackage_obj_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_obj_bodyContext differentiates from other interfaces.
	IsPackage_obj_bodyContext()
}

type Package_obj_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_obj_bodyContext() *Package_obj_bodyContext {
	var p = new(Package_obj_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_package_obj_body
	return p
}

func (*Package_obj_bodyContext) IsPackage_obj_bodyContext() {}

func NewPackage_obj_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_obj_bodyContext {
	var p = new(Package_obj_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_package_obj_body

	return p
}

func (s *Package_obj_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_obj_bodyContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Package_obj_bodyContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Package_obj_bodyContext) Cursor_declaration() ICursor_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_declarationContext)
}

func (s *Package_obj_bodyContext) Exception_declaration() IException_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_declarationContext)
}

func (s *Package_obj_bodyContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Package_obj_bodyContext) Procedure_body() IProcedure_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_bodyContext)
}

func (s *Package_obj_bodyContext) Function_body() IFunction_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_bodyContext)
}

func (s *Package_obj_bodyContext) Procedure_spec() IProcedure_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_specContext)
}

func (s *Package_obj_bodyContext) Function_spec() IFunction_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_specContext)
}

func (s *Package_obj_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_obj_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_obj_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPackage_obj_body(s)
	}
}

func (s *Package_obj_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPackage_obj_body(s)
	}
}

func (p *PlSqlParser) Package_obj_body() (localctx IPackage_obj_bodyContext) {
	localctx = NewPackage_obj_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PlSqlParserRULE_package_obj_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1098)
			p.Variable_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1099)
			p.Subtype_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1100)
			p.Cursor_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1101)
			p.Exception_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1102)
			p.Type_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1103)
			p.Procedure_body()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1104)
			p.Function_body()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1105)
			p.Procedure_spec()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1106)
			p.Function_spec()
		}

	}

	return localctx
}

// IDrop_procedureContext is an interface to support dynamic dispatch.
type IDrop_procedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_procedureContext differentiates from other interfaces.
	IsDrop_procedureContext()
}

type Drop_procedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_procedureContext() *Drop_procedureContext {
	var p = new(Drop_procedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_drop_procedure
	return p
}

func (*Drop_procedureContext) IsDrop_procedureContext() {}

func NewDrop_procedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_procedureContext {
	var p = new(Drop_procedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_drop_procedure

	return p
}

func (s *Drop_procedureContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_procedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Drop_procedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPROCEDURE, 0)
}

func (s *Drop_procedureContext) Procedure_name() IProcedure_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_nameContext)
}

func (s *Drop_procedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_procedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_procedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDrop_procedure(s)
	}
}

func (s *Drop_procedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDrop_procedure(s)
	}
}

func (p *PlSqlParser) Drop_procedure() (localctx IDrop_procedureContext) {
	localctx = NewDrop_procedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, PlSqlParserRULE_drop_procedure)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.Match(PlSqlParserDROP)
	}
	{
		p.SetState(1110)
		p.Match(PlSqlParserPROCEDURE)
	}
	{
		p.SetState(1111)
		p.Procedure_name()
	}
	{
		p.SetState(1112)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IAlter_procedureContext is an interface to support dynamic dispatch.
type IAlter_procedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_procedureContext differentiates from other interfaces.
	IsAlter_procedureContext()
}

type Alter_procedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_procedureContext() *Alter_procedureContext {
	var p = new(Alter_procedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_procedure
	return p
}

func (*Alter_procedureContext) IsAlter_procedureContext() {}

func NewAlter_procedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_procedureContext {
	var p = new(Alter_procedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_procedure

	return p
}

func (s *Alter_procedureContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_procedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *Alter_procedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPROCEDURE, 0)
}

func (s *Alter_procedureContext) Procedure_name() IProcedure_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_nameContext)
}

func (s *Alter_procedureContext) COMPILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPILE, 0)
}

func (s *Alter_procedureContext) DEBUG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEBUG, 0)
}

func (s *Alter_procedureContext) AllCompiler_parameters_clause() []ICompiler_parameters_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem())
	var tst = make([]ICompiler_parameters_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompiler_parameters_clauseContext)
		}
	}

	return tst
}

func (s *Alter_procedureContext) Compiler_parameters_clause(i int) ICompiler_parameters_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompiler_parameters_clauseContext)
}

func (s *Alter_procedureContext) REUSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREUSE, 0)
}

func (s *Alter_procedureContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSETTINGS, 0)
}

func (s *Alter_procedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_procedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_procedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_procedure(s)
	}
}

func (s *Alter_procedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_procedure(s)
	}
}

func (p *PlSqlParser) Alter_procedure() (localctx IAlter_procedureContext) {
	localctx = NewAlter_procedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, PlSqlParserRULE_alter_procedure)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1114)
		p.Match(PlSqlParserALTER)
	}
	{
		p.SetState(1115)
		p.Match(PlSqlParserPROCEDURE)
	}
	{
		p.SetState(1116)
		p.Procedure_name()
	}
	{
		p.SetState(1117)
		p.Match(PlSqlParserCOMPILE)
	}
	p.SetState(1119)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1118)
			p.Match(PlSqlParserDEBUG)
		}

	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1121)
				p.Compiler_parameters_clause()
			}

		}
		p.SetState(1126)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
	}
	p.SetState(1129)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserREUSE {
		{
			p.SetState(1127)
			p.Match(PlSqlParserREUSE)
		}
		{
			p.SetState(1128)
			p.Match(PlSqlParserSETTINGS)
		}

	}
	{
		p.SetState(1131)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IFunction_bodyContext is an interface to support dynamic dispatch.
type IFunction_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_bodyContext differentiates from other interfaces.
	IsFunction_bodyContext()
}

type Function_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_bodyContext() *Function_bodyContext {
	var p = new(Function_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_function_body
	return p
}

func (*Function_bodyContext) IsFunction_bodyContext() {}

func NewFunction_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_bodyContext {
	var p = new(Function_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_function_body

	return p
}

func (s *Function_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_bodyContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Function_bodyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_bodyContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Function_bodyContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Function_bodyContext) USING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSING, 0)
}

func (s *Function_bodyContext) Implementation_type_name() IImplementation_type_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementation_type_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementation_type_nameContext)
}

func (s *Function_bodyContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *Function_bodyContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *Function_bodyContext) AllInvoker_rights_clause() []IInvoker_rights_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInvoker_rights_clauseContext)(nil)).Elem())
	var tst = make([]IInvoker_rights_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInvoker_rights_clauseContext)
		}
	}

	return tst
}

func (s *Function_bodyContext) Invoker_rights_clause(i int) IInvoker_rights_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvoker_rights_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInvoker_rights_clauseContext)
}

func (s *Function_bodyContext) AllParallel_enable_clause() []IParallel_enable_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParallel_enable_clauseContext)(nil)).Elem())
	var tst = make([]IParallel_enable_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParallel_enable_clauseContext)
		}
	}

	return tst
}

func (s *Function_bodyContext) Parallel_enable_clause(i int) IParallel_enable_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_enable_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParallel_enable_clauseContext)
}

func (s *Function_bodyContext) AllResult_cache_clause() []IResult_cache_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IResult_cache_clauseContext)(nil)).Elem())
	var tst = make([]IResult_cache_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IResult_cache_clauseContext)
		}
	}

	return tst
}

func (s *Function_bodyContext) Result_cache_clause(i int) IResult_cache_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResult_cache_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IResult_cache_clauseContext)
}

func (s *Function_bodyContext) AllDETERMINISTIC() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserDETERMINISTIC)
}

func (s *Function_bodyContext) DETERMINISTIC(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserDETERMINISTIC, i)
}

func (s *Function_bodyContext) PIPELINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPIPELINED, 0)
}

func (s *Function_bodyContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAGGREGATE, 0)
}

func (s *Function_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Function_bodyContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Function_bodyContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Function_bodyContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Function_bodyContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECLARE, 0)
}

func (s *Function_bodyContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *Function_bodyContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *Function_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFunction_body(s)
	}
}

func (s *Function_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFunction_body(s)
	}
}

func (p *PlSqlParser) Function_body() (localctx IFunction_bodyContext) {
	localctx = NewFunction_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, PlSqlParserRULE_function_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1133)
		p.Match(PlSqlParserFUNCTION)
	}
	{
		p.SetState(1134)
		p.Identifier()
	}
	p.SetState(1146)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1135)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(1136)
			p.Parameter()
		}
		p.SetState(1141)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1137)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1138)
				p.Parameter()
			}

			p.SetState(1143)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1144)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(1148)
		p.Match(PlSqlParserRETURN)
	}
	{
		p.SetState(1149)
		p.Type_spec()
	}
	p.SetState(1156)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserAUTHID || _la == PlSqlParserDETERMINISTIC || _la == PlSqlParserPARALLEL_ENABLE || _la == PlSqlParserRESULT_CACHE {
		p.SetState(1154)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserAUTHID:
			{
				p.SetState(1150)
				p.Invoker_rights_clause()
			}

		case PlSqlParserPARALLEL_ENABLE:
			{
				p.SetState(1151)
				p.Parallel_enable_clause()
			}

		case PlSqlParserRESULT_CACHE:
			{
				p.SetState(1152)
				p.Result_cache_clause()
			}

		case PlSqlParserDETERMINISTIC:
			{
				p.SetState(1153)
				p.Match(PlSqlParserDETERMINISTIC)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1160)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserPIPELINED {
			{
				p.SetState(1159)
				p.Match(PlSqlParserPIPELINED)
			}

		}
		{
			p.SetState(1162)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1174)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1164)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserDECLARE {
				{
					p.SetState(1163)
					p.Match(PlSqlParserDECLARE)
				}

			}
			p.SetState(1169)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
				{
					p.SetState(1166)
					p.Declare_spec()
				}

				p.SetState(1171)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1172)
				p.Body()
			}

		case 2:
			{
				p.SetState(1173)
				p.Call_spec()
			}

		}

	case 2:
		{
			p.SetState(1176)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserAGGREGATE || _la == PlSqlParserPIPELINED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1177)
			p.Match(PlSqlParserUSING)
		}
		{
			p.SetState(1178)
			p.Implementation_type_name()
		}

	}
	{
		p.SetState(1181)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IProcedure_bodyContext is an interface to support dynamic dispatch.
type IProcedure_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedure_bodyContext differentiates from other interfaces.
	IsProcedure_bodyContext()
}

type Procedure_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_bodyContext() *Procedure_bodyContext {
	var p = new(Procedure_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_procedure_body
	return p
}

func (*Procedure_bodyContext) IsProcedure_bodyContext() {}

func NewProcedure_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_bodyContext {
	var p = new(Procedure_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_procedure_body

	return p
}

func (s *Procedure_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_bodyContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPROCEDURE, 0)
}

func (s *Procedure_bodyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Procedure_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Procedure_bodyContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Procedure_bodyContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Procedure_bodyContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Procedure_bodyContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXTERNAL, 0)
}

func (s *Procedure_bodyContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *Procedure_bodyContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *Procedure_bodyContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECLARE, 0)
}

func (s *Procedure_bodyContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *Procedure_bodyContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *Procedure_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterProcedure_body(s)
	}
}

func (s *Procedure_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitProcedure_body(s)
	}
}

func (p *PlSqlParser) Procedure_body() (localctx IProcedure_bodyContext) {
	localctx = NewProcedure_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, PlSqlParserRULE_procedure_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1183)
		p.Match(PlSqlParserPROCEDURE)
	}
	{
		p.SetState(1184)
		p.Identifier()
	}
	p.SetState(1196)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1185)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(1186)
			p.Parameter()
		}
		p.SetState(1191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1187)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1188)
				p.Parameter()
			}

			p.SetState(1193)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1194)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(1198)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserDECLARE {
			{
				p.SetState(1199)
				p.Match(PlSqlParserDECLARE)
			}

		}
		p.SetState(1205)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
			{
				p.SetState(1202)
				p.Declare_spec()
			}

			p.SetState(1207)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1208)
			p.Body()
		}

	case 2:
		{
			p.SetState(1209)
			p.Call_spec()
		}

	case 3:
		{
			p.SetState(1210)
			p.Match(PlSqlParserEXTERNAL)
		}

	}
	{
		p.SetState(1213)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ICreate_procedure_bodyContext is an interface to support dynamic dispatch.
type ICreate_procedure_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_procedure_bodyContext differentiates from other interfaces.
	IsCreate_procedure_bodyContext()
}

type Create_procedure_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_procedure_bodyContext() *Create_procedure_bodyContext {
	var p = new(Create_procedure_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_procedure_body
	return p
}

func (*Create_procedure_bodyContext) IsCreate_procedure_bodyContext() {}

func NewCreate_procedure_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_procedure_bodyContext {
	var p = new(Create_procedure_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_procedure_body

	return p
}

func (s *Create_procedure_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_procedure_bodyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_procedure_bodyContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPROCEDURE, 0)
}

func (s *Create_procedure_bodyContext) Procedure_name() IProcedure_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_nameContext)
}

func (s *Create_procedure_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Create_procedure_bodyContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Create_procedure_bodyContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Create_procedure_bodyContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Create_procedure_bodyContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXTERNAL, 0)
}

func (s *Create_procedure_bodyContext) OR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, 0)
}

func (s *Create_procedure_bodyContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREPLACE, 0)
}

func (s *Create_procedure_bodyContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *Create_procedure_bodyContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *Create_procedure_bodyContext) Invoker_rights_clause() IInvoker_rights_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvoker_rights_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvoker_rights_clauseContext)
}

func (s *Create_procedure_bodyContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECLARE, 0)
}

func (s *Create_procedure_bodyContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *Create_procedure_bodyContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *Create_procedure_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_procedure_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_procedure_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_procedure_body(s)
	}
}

func (s *Create_procedure_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_procedure_body(s)
	}
}

func (p *PlSqlParser) Create_procedure_body() (localctx ICreate_procedure_bodyContext) {
	localctx = NewCreate_procedure_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, PlSqlParserRULE_create_procedure_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1215)
		p.Match(PlSqlParserCREATE)
	}
	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOR {
		{
			p.SetState(1216)
			p.Match(PlSqlParserOR)
		}
		{
			p.SetState(1217)
			p.Match(PlSqlParserREPLACE)
		}

	}
	{
		p.SetState(1220)
		p.Match(PlSqlParserPROCEDURE)
	}
	{
		p.SetState(1221)
		p.Procedure_name()
	}
	p.SetState(1233)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1222)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(1223)
			p.Parameter()
		}
		p.SetState(1228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1224)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1225)
				p.Parameter()
			}

			p.SetState(1230)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1231)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAUTHID {
		{
			p.SetState(1235)
			p.Invoker_rights_clause()
		}

	}
	{
		p.SetState(1238)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1240)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserDECLARE {
			{
				p.SetState(1239)
				p.Match(PlSqlParserDECLARE)
			}

		}
		p.SetState(1245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
			{
				p.SetState(1242)
				p.Declare_spec()
			}

			p.SetState(1247)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1248)
			p.Body()
		}

	case 2:
		{
			p.SetState(1249)
			p.Call_spec()
		}

	case 3:
		{
			p.SetState(1250)
			p.Match(PlSqlParserEXTERNAL)
		}

	}
	{
		p.SetState(1253)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IDrop_triggerContext is an interface to support dynamic dispatch.
type IDrop_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_triggerContext differentiates from other interfaces.
	IsDrop_triggerContext()
}

type Drop_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_triggerContext() *Drop_triggerContext {
	var p = new(Drop_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_drop_trigger
	return p
}

func (*Drop_triggerContext) IsDrop_triggerContext() {}

func NewDrop_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_triggerContext {
	var p = new(Drop_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_drop_trigger

	return p
}

func (s *Drop_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_triggerContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Drop_triggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIGGER, 0)
}

func (s *Drop_triggerContext) Trigger_name() ITrigger_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrigger_nameContext)
}

func (s *Drop_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDrop_trigger(s)
	}
}

func (s *Drop_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDrop_trigger(s)
	}
}

func (p *PlSqlParser) Drop_trigger() (localctx IDrop_triggerContext) {
	localctx = NewDrop_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PlSqlParserRULE_drop_trigger)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1255)
		p.Match(PlSqlParserDROP)
	}
	{
		p.SetState(1256)
		p.Match(PlSqlParserTRIGGER)
	}
	{
		p.SetState(1257)
		p.Trigger_name()
	}
	{
		p.SetState(1258)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IAlter_triggerContext is an interface to support dynamic dispatch.
type IAlter_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlter_trigger_name returns the alter_trigger_name rule contexts.
	GetAlter_trigger_name() ITrigger_nameContext

	// GetRename_trigger_name returns the rename_trigger_name rule contexts.
	GetRename_trigger_name() ITrigger_nameContext

	// SetAlter_trigger_name sets the alter_trigger_name rule contexts.
	SetAlter_trigger_name(ITrigger_nameContext)

	// SetRename_trigger_name sets the rename_trigger_name rule contexts.
	SetRename_trigger_name(ITrigger_nameContext)

	// IsAlter_triggerContext differentiates from other interfaces.
	IsAlter_triggerContext()
}

type Alter_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser              antlr.Parser
	alter_trigger_name  ITrigger_nameContext
	rename_trigger_name ITrigger_nameContext
}

func NewEmptyAlter_triggerContext() *Alter_triggerContext {
	var p = new(Alter_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_trigger
	return p
}

func (*Alter_triggerContext) IsAlter_triggerContext() {}

func NewAlter_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_triggerContext {
	var p = new(Alter_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_trigger

	return p
}

func (s *Alter_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_triggerContext) GetAlter_trigger_name() ITrigger_nameContext {
	return s.alter_trigger_name
}

func (s *Alter_triggerContext) GetRename_trigger_name() ITrigger_nameContext {
	return s.rename_trigger_name
}

func (s *Alter_triggerContext) SetAlter_trigger_name(v ITrigger_nameContext) { s.alter_trigger_name = v }

func (s *Alter_triggerContext) SetRename_trigger_name(v ITrigger_nameContext) {
	s.rename_trigger_name = v
}

func (s *Alter_triggerContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *Alter_triggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIGGER, 0)
}

func (s *Alter_triggerContext) AllTrigger_name() []ITrigger_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITrigger_nameContext)(nil)).Elem())
	var tst = make([]ITrigger_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITrigger_nameContext)
		}
	}

	return tst
}

func (s *Alter_triggerContext) Trigger_name(i int) ITrigger_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITrigger_nameContext)
}

func (s *Alter_triggerContext) RENAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRENAME, 0)
}

func (s *Alter_triggerContext) TO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO, 0)
}

func (s *Alter_triggerContext) COMPILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPILE, 0)
}

func (s *Alter_triggerContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserENABLE, 0)
}

func (s *Alter_triggerContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISABLE, 0)
}

func (s *Alter_triggerContext) DEBUG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEBUG, 0)
}

func (s *Alter_triggerContext) AllCompiler_parameters_clause() []ICompiler_parameters_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem())
	var tst = make([]ICompiler_parameters_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompiler_parameters_clauseContext)
		}
	}

	return tst
}

func (s *Alter_triggerContext) Compiler_parameters_clause(i int) ICompiler_parameters_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompiler_parameters_clauseContext)
}

func (s *Alter_triggerContext) REUSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREUSE, 0)
}

func (s *Alter_triggerContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSETTINGS, 0)
}

func (s *Alter_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_trigger(s)
	}
}

func (s *Alter_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_trigger(s)
	}
}

func (p *PlSqlParser) Alter_trigger() (localctx IAlter_triggerContext) {
	localctx = NewAlter_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PlSqlParserRULE_alter_trigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1260)
		p.Match(PlSqlParserALTER)
	}
	{
		p.SetState(1261)
		p.Match(PlSqlParserTRIGGER)
	}
	{
		p.SetState(1262)

		var _x = p.Trigger_name()

		localctx.(*Alter_triggerContext).alter_trigger_name = _x
	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserDISABLE, PlSqlParserENABLE:
		{
			p.SetState(1263)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserDISABLE || _la == PlSqlParserENABLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case PlSqlParserRENAME:
		{
			p.SetState(1264)
			p.Match(PlSqlParserRENAME)
		}
		{
			p.SetState(1265)
			p.Match(PlSqlParserTO)
		}
		{
			p.SetState(1266)

			var _x = p.Trigger_name()

			localctx.(*Alter_triggerContext).rename_trigger_name = _x
		}

	case PlSqlParserCOMPILE:
		{
			p.SetState(1267)
			p.Match(PlSqlParserCOMPILE)
		}
		p.SetState(1269)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1268)
				p.Match(PlSqlParserDEBUG)
			}

		}
		p.SetState(1274)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1271)
					p.Compiler_parameters_clause()
				}

			}
			p.SetState(1276)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserREUSE {
			{
				p.SetState(1277)
				p.Match(PlSqlParserREUSE)
			}
			{
				p.SetState(1278)
				p.Match(PlSqlParserSETTINGS)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1283)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ICreate_triggerContext is an interface to support dynamic dispatch.
type ICreate_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_triggerContext differentiates from other interfaces.
	IsCreate_triggerContext()
}

type Create_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_triggerContext() *Create_triggerContext {
	var p = new(Create_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_trigger
	return p
}

func (*Create_triggerContext) IsCreate_triggerContext() {}

func NewCreate_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_triggerContext {
	var p = new(Create_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_trigger

	return p
}

func (s *Create_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_triggerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_triggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIGGER, 0)
}

func (s *Create_triggerContext) Trigger_name() ITrigger_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrigger_nameContext)
}

func (s *Create_triggerContext) Trigger_body() ITrigger_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrigger_bodyContext)
}

func (s *Create_triggerContext) Simple_dml_trigger() ISimple_dml_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_dml_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_dml_triggerContext)
}

func (s *Create_triggerContext) Compound_dml_trigger() ICompound_dml_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_dml_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_dml_triggerContext)
}

func (s *Create_triggerContext) Non_dml_trigger() INon_dml_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_dml_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_dml_triggerContext)
}

func (s *Create_triggerContext) OR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, 0)
}

func (s *Create_triggerContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREPLACE, 0)
}

func (s *Create_triggerContext) Trigger_follows_clause() ITrigger_follows_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_follows_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrigger_follows_clauseContext)
}

func (s *Create_triggerContext) Trigger_when_clause() ITrigger_when_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_when_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrigger_when_clauseContext)
}

func (s *Create_triggerContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserENABLE, 0)
}

func (s *Create_triggerContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISABLE, 0)
}

func (s *Create_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_trigger(s)
	}
}

func (s *Create_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_trigger(s)
	}
}

func (p *PlSqlParser) Create_trigger() (localctx ICreate_triggerContext) {
	localctx = NewCreate_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PlSqlParserRULE_create_trigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1285)
		p.Match(PlSqlParserCREATE)
	}
	p.SetState(1288)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOR {
		{
			p.SetState(1286)
			p.Match(PlSqlParserOR)
		}
		{
			p.SetState(1287)
			p.Match(PlSqlParserREPLACE)
		}

	}
	{
		p.SetState(1290)
		p.Match(PlSqlParserTRIGGER)
	}
	{
		p.SetState(1291)
		p.Trigger_name()
	}
	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1292)
			p.Simple_dml_trigger()
		}

	case 2:
		{
			p.SetState(1293)
			p.Compound_dml_trigger()
		}

	case 3:
		{
			p.SetState(1294)
			p.Non_dml_trigger()
		}

	}
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1297)
			p.Trigger_follows_clause()
		}

	}
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1300)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserDISABLE || _la == PlSqlParserENABLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1304)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWHEN {
		{
			p.SetState(1303)
			p.Trigger_when_clause()
		}

	}
	{
		p.SetState(1306)
		p.Trigger_body()
	}
	{
		p.SetState(1307)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ITrigger_follows_clauseContext is an interface to support dynamic dispatch.
type ITrigger_follows_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrigger_follows_clauseContext differentiates from other interfaces.
	IsTrigger_follows_clauseContext()
}

type Trigger_follows_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrigger_follows_clauseContext() *Trigger_follows_clauseContext {
	var p = new(Trigger_follows_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_trigger_follows_clause
	return p
}

func (*Trigger_follows_clauseContext) IsTrigger_follows_clauseContext() {}

func NewTrigger_follows_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trigger_follows_clauseContext {
	var p = new(Trigger_follows_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_trigger_follows_clause

	return p
}

func (s *Trigger_follows_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Trigger_follows_clauseContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOLLOWS, 0)
}

func (s *Trigger_follows_clauseContext) AllTrigger_name() []ITrigger_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITrigger_nameContext)(nil)).Elem())
	var tst = make([]ITrigger_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITrigger_nameContext)
		}
	}

	return tst
}

func (s *Trigger_follows_clauseContext) Trigger_name(i int) ITrigger_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITrigger_nameContext)
}

func (s *Trigger_follows_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trigger_follows_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trigger_follows_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTrigger_follows_clause(s)
	}
}

func (s *Trigger_follows_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTrigger_follows_clause(s)
	}
}

func (p *PlSqlParser) Trigger_follows_clause() (localctx ITrigger_follows_clauseContext) {
	localctx = NewTrigger_follows_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PlSqlParserRULE_trigger_follows_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1309)
		p.Match(PlSqlParserFOLLOWS)
	}
	{
		p.SetState(1310)
		p.Trigger_name()
	}
	p.SetState(1315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(1311)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(1312)
			p.Trigger_name()
		}

		p.SetState(1317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITrigger_when_clauseContext is an interface to support dynamic dispatch.
type ITrigger_when_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrigger_when_clauseContext differentiates from other interfaces.
	IsTrigger_when_clauseContext()
}

type Trigger_when_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrigger_when_clauseContext() *Trigger_when_clauseContext {
	var p = new(Trigger_when_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_trigger_when_clause
	return p
}

func (*Trigger_when_clauseContext) IsTrigger_when_clauseContext() {}

func NewTrigger_when_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trigger_when_clauseContext {
	var p = new(Trigger_when_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_trigger_when_clause

	return p
}

func (s *Trigger_when_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Trigger_when_clauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHEN, 0)
}

func (s *Trigger_when_clauseContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Trigger_when_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trigger_when_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trigger_when_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTrigger_when_clause(s)
	}
}

func (s *Trigger_when_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTrigger_when_clause(s)
	}
}

func (p *PlSqlParser) Trigger_when_clause() (localctx ITrigger_when_clauseContext) {
	localctx = NewTrigger_when_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PlSqlParserRULE_trigger_when_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1318)
		p.Match(PlSqlParserWHEN)
	}
	{
		p.SetState(1319)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(1320)
		p.Condition()
	}
	{
		p.SetState(1321)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// ISimple_dml_triggerContext is an interface to support dynamic dispatch.
type ISimple_dml_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_dml_triggerContext differentiates from other interfaces.
	IsSimple_dml_triggerContext()
}

type Simple_dml_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_dml_triggerContext() *Simple_dml_triggerContext {
	var p = new(Simple_dml_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_simple_dml_trigger
	return p
}

func (*Simple_dml_triggerContext) IsSimple_dml_triggerContext() {}

func NewSimple_dml_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_dml_triggerContext {
	var p = new(Simple_dml_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_simple_dml_trigger

	return p
}

func (s *Simple_dml_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_dml_triggerContext) Dml_event_clause() IDml_event_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDml_event_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDml_event_clauseContext)
}

func (s *Simple_dml_triggerContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBEFORE, 0)
}

func (s *Simple_dml_triggerContext) AFTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAFTER, 0)
}

func (s *Simple_dml_triggerContext) INSTEAD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINSTEAD, 0)
}

func (s *Simple_dml_triggerContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Simple_dml_triggerContext) Referencing_clause() IReferencing_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferencing_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferencing_clauseContext)
}

func (s *Simple_dml_triggerContext) For_each_row() IFor_each_rowContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_each_rowContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_each_rowContext)
}

func (s *Simple_dml_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_dml_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_dml_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSimple_dml_trigger(s)
	}
}

func (s *Simple_dml_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSimple_dml_trigger(s)
	}
}

func (p *PlSqlParser) Simple_dml_trigger() (localctx ISimple_dml_triggerContext) {
	localctx = NewSimple_dml_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PlSqlParserRULE_simple_dml_trigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1327)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserBEFORE:
		{
			p.SetState(1323)
			p.Match(PlSqlParserBEFORE)
		}

	case PlSqlParserAFTER:
		{
			p.SetState(1324)
			p.Match(PlSqlParserAFTER)
		}

	case PlSqlParserINSTEAD:
		{
			p.SetState(1325)
			p.Match(PlSqlParserINSTEAD)
		}
		{
			p.SetState(1326)
			p.Match(PlSqlParserOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1329)
		p.Dml_event_clause()
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1330)
			p.Referencing_clause()
		}

	}
	p.SetState(1334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserFOR {
		{
			p.SetState(1333)
			p.For_each_row()
		}

	}

	return localctx
}

// IFor_each_rowContext is an interface to support dynamic dispatch.
type IFor_each_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_each_rowContext differentiates from other interfaces.
	IsFor_each_rowContext()
}

type For_each_rowContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_each_rowContext() *For_each_rowContext {
	var p = new(For_each_rowContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_for_each_row
	return p
}

func (*For_each_rowContext) IsFor_each_rowContext() {}

func NewFor_each_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_each_rowContext {
	var p = new(For_each_rowContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_for_each_row

	return p
}

func (s *For_each_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *For_each_rowContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *For_each_rowContext) EACH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEACH, 0)
}

func (s *For_each_rowContext) ROW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROW, 0)
}

func (s *For_each_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_each_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_each_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFor_each_row(s)
	}
}

func (s *For_each_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFor_each_row(s)
	}
}

func (p *PlSqlParser) For_each_row() (localctx IFor_each_rowContext) {
	localctx = NewFor_each_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PlSqlParserRULE_for_each_row)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1336)
		p.Match(PlSqlParserFOR)
	}
	{
		p.SetState(1337)
		p.Match(PlSqlParserEACH)
	}
	{
		p.SetState(1338)
		p.Match(PlSqlParserROW)
	}

	return localctx
}

// ICompound_dml_triggerContext is an interface to support dynamic dispatch.
type ICompound_dml_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_dml_triggerContext differentiates from other interfaces.
	IsCompound_dml_triggerContext()
}

type Compound_dml_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_dml_triggerContext() *Compound_dml_triggerContext {
	var p = new(Compound_dml_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_compound_dml_trigger
	return p
}

func (*Compound_dml_triggerContext) IsCompound_dml_triggerContext() {}

func NewCompound_dml_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_dml_triggerContext {
	var p = new(Compound_dml_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_compound_dml_trigger

	return p
}

func (s *Compound_dml_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_dml_triggerContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Compound_dml_triggerContext) Dml_event_clause() IDml_event_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDml_event_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDml_event_clauseContext)
}

func (s *Compound_dml_triggerContext) Referencing_clause() IReferencing_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferencing_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferencing_clauseContext)
}

func (s *Compound_dml_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_dml_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_dml_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCompound_dml_trigger(s)
	}
}

func (s *Compound_dml_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCompound_dml_trigger(s)
	}
}

func (p *PlSqlParser) Compound_dml_trigger() (localctx ICompound_dml_triggerContext) {
	localctx = NewCompound_dml_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PlSqlParserRULE_compound_dml_trigger)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1340)
		p.Match(PlSqlParserFOR)
	}
	{
		p.SetState(1341)
		p.Dml_event_clause()
	}
	p.SetState(1343)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1342)
			p.Referencing_clause()
		}

	}

	return localctx
}

// INon_dml_triggerContext is an interface to support dynamic dispatch.
type INon_dml_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_dml_triggerContext differentiates from other interfaces.
	IsNon_dml_triggerContext()
}

type Non_dml_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_dml_triggerContext() *Non_dml_triggerContext {
	var p = new(Non_dml_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_non_dml_trigger
	return p
}

func (*Non_dml_triggerContext) IsNon_dml_triggerContext() {}

func NewNon_dml_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_dml_triggerContext {
	var p = new(Non_dml_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_non_dml_trigger

	return p
}

func (s *Non_dml_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_dml_triggerContext) AllNon_dml_event() []INon_dml_eventContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INon_dml_eventContext)(nil)).Elem())
	var tst = make([]INon_dml_eventContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INon_dml_eventContext)
		}
	}

	return tst
}

func (s *Non_dml_triggerContext) Non_dml_event(i int) INon_dml_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_dml_eventContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INon_dml_eventContext)
}

func (s *Non_dml_triggerContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Non_dml_triggerContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBEFORE, 0)
}

func (s *Non_dml_triggerContext) AFTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAFTER, 0)
}

func (s *Non_dml_triggerContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDATABASE, 0)
}

func (s *Non_dml_triggerContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSCHEMA, 0)
}

func (s *Non_dml_triggerContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserOR)
}

func (s *Non_dml_triggerContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, i)
}

func (s *Non_dml_triggerContext) Schema_name() ISchema_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchema_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchema_nameContext)
}

func (s *Non_dml_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_dml_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_dml_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNon_dml_trigger(s)
	}
}

func (s *Non_dml_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNon_dml_trigger(s)
	}
}

func (p *PlSqlParser) Non_dml_trigger() (localctx INon_dml_triggerContext) {
	localctx = NewNon_dml_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PlSqlParserRULE_non_dml_trigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1345)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAFTER || _la == PlSqlParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1346)
		p.Non_dml_event()
	}
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserOR {
		{
			p.SetState(1347)
			p.Match(PlSqlParserOR)
		}
		{
			p.SetState(1348)
			p.Non_dml_event()
		}

		p.SetState(1353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1354)
		p.Match(PlSqlParserON)
	}
	p.SetState(1362)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1355)
			p.Match(PlSqlParserDATABASE)
		}

	case 2:
		p.SetState(1359)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1356)
				p.Schema_name()
			}
			{
				p.SetState(1357)
				p.Match(PlSqlParserPERIOD)
			}

		}
		{
			p.SetState(1361)
			p.Match(PlSqlParserSCHEMA)
		}

	}

	return localctx
}

// ITrigger_bodyContext is an interface to support dynamic dispatch.
type ITrigger_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrigger_bodyContext differentiates from other interfaces.
	IsTrigger_bodyContext()
}

type Trigger_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrigger_bodyContext() *Trigger_bodyContext {
	var p = new(Trigger_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_trigger_body
	return p
}

func (*Trigger_bodyContext) IsTrigger_bodyContext() {}

func NewTrigger_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trigger_bodyContext {
	var p = new(Trigger_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_trigger_body

	return p
}

func (s *Trigger_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Trigger_bodyContext) COMPOUND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPOUND, 0)
}

func (s *Trigger_bodyContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIGGER, 0)
}

func (s *Trigger_bodyContext) CALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCALL, 0)
}

func (s *Trigger_bodyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Trigger_bodyContext) Trigger_block() ITrigger_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrigger_blockContext)
}

func (s *Trigger_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trigger_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trigger_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTrigger_body(s)
	}
}

func (s *Trigger_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTrigger_body(s)
	}
}

func (p *PlSqlParser) Trigger_body() (localctx ITrigger_bodyContext) {
	localctx = NewTrigger_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PlSqlParserRULE_trigger_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1364)
			p.Match(PlSqlParserCOMPOUND)
		}
		{
			p.SetState(1365)
			p.Match(PlSqlParserTRIGGER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1366)
			p.Match(PlSqlParserCALL)
		}
		{
			p.SetState(1367)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1368)
			p.Trigger_block()
		}

	}

	return localctx
}

// IRoutine_clauseContext is an interface to support dynamic dispatch.
type IRoutine_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutine_clauseContext differentiates from other interfaces.
	IsRoutine_clauseContext()
}

type Routine_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutine_clauseContext() *Routine_clauseContext {
	var p = new(Routine_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_routine_clause
	return p
}

func (*Routine_clauseContext) IsRoutine_clauseContext() {}

func NewRoutine_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Routine_clauseContext {
	var p = new(Routine_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_routine_clause

	return p
}

func (s *Routine_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Routine_clauseContext) Routine_name() IRoutine_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutine_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutine_nameContext)
}

func (s *Routine_clauseContext) Function_argument() IFunction_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_argumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_argumentContext)
}

func (s *Routine_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Routine_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Routine_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRoutine_clause(s)
	}
}

func (s *Routine_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRoutine_clause(s)
	}
}

func (p *PlSqlParser) Routine_clause() (localctx IRoutine_clauseContext) {
	localctx = NewRoutine_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PlSqlParserRULE_routine_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1371)
		p.Routine_name()
	}
	p.SetState(1373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1372)
			p.Function_argument()
		}

	}

	return localctx
}

// ICompound_trigger_blockContext is an interface to support dynamic dispatch.
type ICompound_trigger_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_trigger_blockContext differentiates from other interfaces.
	IsCompound_trigger_blockContext()
}

type Compound_trigger_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_trigger_blockContext() *Compound_trigger_blockContext {
	var p = new(Compound_trigger_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_compound_trigger_block
	return p
}

func (*Compound_trigger_blockContext) IsCompound_trigger_blockContext() {}

func NewCompound_trigger_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_trigger_blockContext {
	var p = new(Compound_trigger_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_compound_trigger_block

	return p
}

func (s *Compound_trigger_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_trigger_blockContext) COMPOUND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPOUND, 0)
}

func (s *Compound_trigger_blockContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIGGER, 0)
}

func (s *Compound_trigger_blockContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *Compound_trigger_blockContext) Trigger_name() ITrigger_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrigger_nameContext)
}

func (s *Compound_trigger_blockContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *Compound_trigger_blockContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *Compound_trigger_blockContext) AllTiming_point_section() []ITiming_point_sectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITiming_point_sectionContext)(nil)).Elem())
	var tst = make([]ITiming_point_sectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITiming_point_sectionContext)
		}
	}

	return tst
}

func (s *Compound_trigger_blockContext) Timing_point_section(i int) ITiming_point_sectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_point_sectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITiming_point_sectionContext)
}

func (s *Compound_trigger_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_trigger_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_trigger_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCompound_trigger_block(s)
	}
}

func (s *Compound_trigger_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCompound_trigger_block(s)
	}
}

func (p *PlSqlParser) Compound_trigger_block() (localctx ICompound_trigger_blockContext) {
	localctx = NewCompound_trigger_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PlSqlParserRULE_compound_trigger_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1375)
		p.Match(PlSqlParserCOMPOUND)
	}
	{
		p.SetState(1376)
		p.Match(PlSqlParserTRIGGER)
	}
	p.SetState(1380)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1377)
				p.Declare_spec()
			}

		}
		p.SetState(1382)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
	}
	p.SetState(1384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PlSqlParserAFTER || _la == PlSqlParserBEFORE {
		{
			p.SetState(1383)
			p.Timing_point_section()
		}

		p.SetState(1386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1388)
		p.Match(PlSqlParserEND)
	}
	{
		p.SetState(1389)
		p.Trigger_name()
	}

	return localctx
}

// ITiming_point_sectionContext is an interface to support dynamic dispatch.
type ITiming_point_sectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBk returns the bk token.
	GetBk() antlr.Token

	// GetAk returns the ak token.
	GetAk() antlr.Token

	// SetBk sets the bk token.
	SetBk(antlr.Token)

	// SetAk sets the ak token.
	SetAk(antlr.Token)

	// IsTiming_point_sectionContext differentiates from other interfaces.
	IsTiming_point_sectionContext()
}

type Timing_point_sectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	bk     antlr.Token
	ak     antlr.Token
}

func NewEmptyTiming_point_sectionContext() *Timing_point_sectionContext {
	var p = new(Timing_point_sectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_timing_point_section
	return p
}

func (*Timing_point_sectionContext) IsTiming_point_sectionContext() {}

func NewTiming_point_sectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timing_point_sectionContext {
	var p = new(Timing_point_sectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_timing_point_section

	return p
}

func (s *Timing_point_sectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Timing_point_sectionContext) GetBk() antlr.Token { return s.bk }

func (s *Timing_point_sectionContext) GetAk() antlr.Token { return s.ak }

func (s *Timing_point_sectionContext) SetBk(v antlr.Token) { s.bk = v }

func (s *Timing_point_sectionContext) SetAk(v antlr.Token) { s.ak = v }

func (s *Timing_point_sectionContext) AllSTATEMENT() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserSTATEMENT)
}

func (s *Timing_point_sectionContext) STATEMENT(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATEMENT, i)
}

func (s *Timing_point_sectionContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Timing_point_sectionContext) Trigger_block() ITrigger_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrigger_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrigger_blockContext)
}

func (s *Timing_point_sectionContext) AllBEFORE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserBEFORE)
}

func (s *Timing_point_sectionContext) BEFORE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserBEFORE, i)
}

func (s *Timing_point_sectionContext) AllEACH() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserEACH)
}

func (s *Timing_point_sectionContext) EACH(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserEACH, i)
}

func (s *Timing_point_sectionContext) AllROW() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserROW)
}

func (s *Timing_point_sectionContext) ROW(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserROW, i)
}

func (s *Timing_point_sectionContext) AllAFTER() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserAFTER)
}

func (s *Timing_point_sectionContext) AFTER(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserAFTER, i)
}

func (s *Timing_point_sectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timing_point_sectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timing_point_sectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTiming_point_section(s)
	}
}

func (s *Timing_point_sectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTiming_point_section(s)
	}
}

func (p *PlSqlParser) Timing_point_section() (localctx ITiming_point_sectionContext) {
	localctx = NewTiming_point_sectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PlSqlParserRULE_timing_point_section)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1427)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1391)

			var _m = p.Match(PlSqlParserBEFORE)

			localctx.(*Timing_point_sectionContext).bk = _m
		}
		{
			p.SetState(1392)
			p.Match(PlSqlParserSTATEMENT)
		}
		{
			p.SetState(1393)
			p.Match(PlSqlParserIS)
		}
		{
			p.SetState(1394)
			p.Trigger_block()
		}
		{
			p.SetState(1395)
			p.Match(PlSqlParserBEFORE)
		}
		{
			p.SetState(1396)
			p.Match(PlSqlParserSTATEMENT)
		}
		{
			p.SetState(1397)
			p.Match(PlSqlParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1399)

			var _m = p.Match(PlSqlParserBEFORE)

			localctx.(*Timing_point_sectionContext).bk = _m
		}
		{
			p.SetState(1400)
			p.Match(PlSqlParserEACH)
		}
		{
			p.SetState(1401)
			p.Match(PlSqlParserROW)
		}
		{
			p.SetState(1402)
			p.Match(PlSqlParserIS)
		}
		{
			p.SetState(1403)
			p.Trigger_block()
		}
		{
			p.SetState(1404)
			p.Match(PlSqlParserBEFORE)
		}
		{
			p.SetState(1405)
			p.Match(PlSqlParserEACH)
		}
		{
			p.SetState(1406)
			p.Match(PlSqlParserROW)
		}
		{
			p.SetState(1407)
			p.Match(PlSqlParserSEMICOLON)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1409)

			var _m = p.Match(PlSqlParserAFTER)

			localctx.(*Timing_point_sectionContext).ak = _m
		}
		{
			p.SetState(1410)
			p.Match(PlSqlParserSTATEMENT)
		}
		{
			p.SetState(1411)
			p.Match(PlSqlParserIS)
		}
		{
			p.SetState(1412)
			p.Trigger_block()
		}
		{
			p.SetState(1413)
			p.Match(PlSqlParserAFTER)
		}
		{
			p.SetState(1414)
			p.Match(PlSqlParserSTATEMENT)
		}
		{
			p.SetState(1415)
			p.Match(PlSqlParserSEMICOLON)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1417)

			var _m = p.Match(PlSqlParserAFTER)

			localctx.(*Timing_point_sectionContext).ak = _m
		}
		{
			p.SetState(1418)
			p.Match(PlSqlParserEACH)
		}
		{
			p.SetState(1419)
			p.Match(PlSqlParserROW)
		}
		{
			p.SetState(1420)
			p.Match(PlSqlParserIS)
		}
		{
			p.SetState(1421)
			p.Trigger_block()
		}
		{
			p.SetState(1422)
			p.Match(PlSqlParserAFTER)
		}
		{
			p.SetState(1423)
			p.Match(PlSqlParserEACH)
		}
		{
			p.SetState(1424)
			p.Match(PlSqlParserROW)
		}
		{
			p.SetState(1425)
			p.Match(PlSqlParserSEMICOLON)
		}

	}

	return localctx
}

// INon_dml_eventContext is an interface to support dynamic dispatch.
type INon_dml_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_dml_eventContext differentiates from other interfaces.
	IsNon_dml_eventContext()
}

type Non_dml_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_dml_eventContext() *Non_dml_eventContext {
	var p = new(Non_dml_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_non_dml_event
	return p
}

func (*Non_dml_eventContext) IsNon_dml_eventContext() {}

func NewNon_dml_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_dml_eventContext {
	var p = new(Non_dml_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_non_dml_event

	return p
}

func (s *Non_dml_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_dml_eventContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *Non_dml_eventContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserANALYZE, 0)
}

func (s *Non_dml_eventContext) ASSOCIATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserASSOCIATE, 0)
}

func (s *Non_dml_eventContext) STATISTICS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATISTICS, 0)
}

func (s *Non_dml_eventContext) AUDIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUDIT, 0)
}

func (s *Non_dml_eventContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMENT, 0)
}

func (s *Non_dml_eventContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Non_dml_eventContext) DISASSOCIATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISASSOCIATE, 0)
}

func (s *Non_dml_eventContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Non_dml_eventContext) GRANT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserGRANT, 0)
}

func (s *Non_dml_eventContext) NOAUDIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOAUDIT, 0)
}

func (s *Non_dml_eventContext) RENAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRENAME, 0)
}

func (s *Non_dml_eventContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREVOKE, 0)
}

func (s *Non_dml_eventContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRUNCATE, 0)
}

func (s *Non_dml_eventContext) DDL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDDL, 0)
}

func (s *Non_dml_eventContext) STARTUP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTARTUP, 0)
}

func (s *Non_dml_eventContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSHUTDOWN, 0)
}

func (s *Non_dml_eventContext) DB_ROLE_CHANGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDB_ROLE_CHANGE, 0)
}

func (s *Non_dml_eventContext) LOGON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOGON, 0)
}

func (s *Non_dml_eventContext) LOGOFF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOGOFF, 0)
}

func (s *Non_dml_eventContext) SERVERERROR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSERVERERROR, 0)
}

func (s *Non_dml_eventContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUSPEND, 0)
}

func (s *Non_dml_eventContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDATABASE, 0)
}

func (s *Non_dml_eventContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSCHEMA, 0)
}

func (s *Non_dml_eventContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOLLOWS, 0)
}

func (s *Non_dml_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_dml_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_dml_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNon_dml_event(s)
	}
}

func (s *Non_dml_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNon_dml_event(s)
	}
}

func (p *PlSqlParser) Non_dml_event() (localctx INon_dml_eventContext) {
	localctx = NewNon_dml_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PlSqlParserRULE_non_dml_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1455)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserALTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1429)
			p.Match(PlSqlParserALTER)
		}

	case PlSqlParserANALYZE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1430)
			p.Match(PlSqlParserANALYZE)
		}

	case PlSqlParserASSOCIATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1431)
			p.Match(PlSqlParserASSOCIATE)
		}
		{
			p.SetState(1432)
			p.Match(PlSqlParserSTATISTICS)
		}

	case PlSqlParserAUDIT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1433)
			p.Match(PlSqlParserAUDIT)
		}

	case PlSqlParserCOMMENT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1434)
			p.Match(PlSqlParserCOMMENT)
		}

	case PlSqlParserCREATE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1435)
			p.Match(PlSqlParserCREATE)
		}

	case PlSqlParserDISASSOCIATE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1436)
			p.Match(PlSqlParserDISASSOCIATE)
		}
		{
			p.SetState(1437)
			p.Match(PlSqlParserSTATISTICS)
		}

	case PlSqlParserDROP:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1438)
			p.Match(PlSqlParserDROP)
		}

	case PlSqlParserGRANT:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1439)
			p.Match(PlSqlParserGRANT)
		}

	case PlSqlParserNOAUDIT:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1440)
			p.Match(PlSqlParserNOAUDIT)
		}

	case PlSqlParserRENAME:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1441)
			p.Match(PlSqlParserRENAME)
		}

	case PlSqlParserREVOKE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1442)
			p.Match(PlSqlParserREVOKE)
		}

	case PlSqlParserTRUNCATE:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1443)
			p.Match(PlSqlParserTRUNCATE)
		}

	case PlSqlParserDDL:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1444)
			p.Match(PlSqlParserDDL)
		}

	case PlSqlParserSTARTUP:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1445)
			p.Match(PlSqlParserSTARTUP)
		}

	case PlSqlParserSHUTDOWN:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1446)
			p.Match(PlSqlParserSHUTDOWN)
		}

	case PlSqlParserDB_ROLE_CHANGE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1447)
			p.Match(PlSqlParserDB_ROLE_CHANGE)
		}

	case PlSqlParserLOGON:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1448)
			p.Match(PlSqlParserLOGON)
		}

	case PlSqlParserLOGOFF:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1449)
			p.Match(PlSqlParserLOGOFF)
		}

	case PlSqlParserSERVERERROR:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1450)
			p.Match(PlSqlParserSERVERERROR)
		}

	case PlSqlParserSUSPEND:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1451)
			p.Match(PlSqlParserSUSPEND)
		}

	case PlSqlParserDATABASE:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1452)
			p.Match(PlSqlParserDATABASE)
		}

	case PlSqlParserSCHEMA:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1453)
			p.Match(PlSqlParserSCHEMA)
		}

	case PlSqlParserFOLLOWS:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1454)
			p.Match(PlSqlParserFOLLOWS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDml_event_clauseContext is an interface to support dynamic dispatch.
type IDml_event_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDml_event_clauseContext differentiates from other interfaces.
	IsDml_event_clauseContext()
}

type Dml_event_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDml_event_clauseContext() *Dml_event_clauseContext {
	var p = new(Dml_event_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_dml_event_clause
	return p
}

func (*Dml_event_clauseContext) IsDml_event_clauseContext() {}

func NewDml_event_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dml_event_clauseContext {
	var p = new(Dml_event_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_dml_event_clause

	return p
}

func (s *Dml_event_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Dml_event_clauseContext) AllDml_event_element() []IDml_event_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDml_event_elementContext)(nil)).Elem())
	var tst = make([]IDml_event_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDml_event_elementContext)
		}
	}

	return tst
}

func (s *Dml_event_clauseContext) Dml_event_element(i int) IDml_event_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDml_event_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDml_event_elementContext)
}

func (s *Dml_event_clauseContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Dml_event_clauseContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Dml_event_clauseContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserOR)
}

func (s *Dml_event_clauseContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, i)
}

func (s *Dml_event_clauseContext) Dml_event_nested_clause() IDml_event_nested_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDml_event_nested_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDml_event_nested_clauseContext)
}

func (s *Dml_event_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dml_event_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dml_event_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDml_event_clause(s)
	}
}

func (s *Dml_event_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDml_event_clause(s)
	}
}

func (p *PlSqlParser) Dml_event_clause() (localctx IDml_event_clauseContext) {
	localctx = NewDml_event_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PlSqlParserRULE_dml_event_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1457)
		p.Dml_event_element()
	}
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserOR {
		{
			p.SetState(1458)
			p.Match(PlSqlParserOR)
		}
		{
			p.SetState(1459)
			p.Dml_event_element()
		}

		p.SetState(1464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1465)
		p.Match(PlSqlParserON)
	}
	p.SetState(1467)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1466)
			p.Dml_event_nested_clause()
		}

	}
	{
		p.SetState(1469)
		p.Tableview_name()
	}

	return localctx
}

// IDml_event_elementContext is an interface to support dynamic dispatch.
type IDml_event_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDml_event_elementContext differentiates from other interfaces.
	IsDml_event_elementContext()
}

type Dml_event_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDml_event_elementContext() *Dml_event_elementContext {
	var p = new(Dml_event_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_dml_event_element
	return p
}

func (*Dml_event_elementContext) IsDml_event_elementContext() {}

func NewDml_event_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dml_event_elementContext {
	var p = new(Dml_event_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_dml_event_element

	return p
}

func (s *Dml_event_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Dml_event_elementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDELETE, 0)
}

func (s *Dml_event_elementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINSERT, 0)
}

func (s *Dml_event_elementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPDATE, 0)
}

func (s *Dml_event_elementContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Dml_event_elementContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Dml_event_elementContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Dml_event_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dml_event_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dml_event_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDml_event_element(s)
	}
}

func (s *Dml_event_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDml_event_element(s)
	}
}

func (p *PlSqlParser) Dml_event_element() (localctx IDml_event_elementContext) {
	localctx = NewDml_event_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PlSqlParserRULE_dml_event_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1471)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserDELETE || _la == PlSqlParserINSERT || _la == PlSqlParserUPDATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOF {
		{
			p.SetState(1472)
			p.Match(PlSqlParserOF)
		}
		{
			p.SetState(1473)
			p.Column_name()
		}
		p.SetState(1478)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1474)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1475)
				p.Column_name()
			}

			p.SetState(1480)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IDml_event_nested_clauseContext is an interface to support dynamic dispatch.
type IDml_event_nested_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDml_event_nested_clauseContext differentiates from other interfaces.
	IsDml_event_nested_clauseContext()
}

type Dml_event_nested_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDml_event_nested_clauseContext() *Dml_event_nested_clauseContext {
	var p = new(Dml_event_nested_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_dml_event_nested_clause
	return p
}

func (*Dml_event_nested_clauseContext) IsDml_event_nested_clauseContext() {}

func NewDml_event_nested_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dml_event_nested_clauseContext {
	var p = new(Dml_event_nested_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_dml_event_nested_clause

	return p
}

func (s *Dml_event_nested_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Dml_event_nested_clauseContext) NESTED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNESTED, 0)
}

func (s *Dml_event_nested_clauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Dml_event_nested_clauseContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Dml_event_nested_clauseContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Dml_event_nested_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dml_event_nested_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dml_event_nested_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDml_event_nested_clause(s)
	}
}

func (s *Dml_event_nested_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDml_event_nested_clause(s)
	}
}

func (p *PlSqlParser) Dml_event_nested_clause() (localctx IDml_event_nested_clauseContext) {
	localctx = NewDml_event_nested_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, PlSqlParserRULE_dml_event_nested_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1483)
		p.Match(PlSqlParserNESTED)
	}
	{
		p.SetState(1484)
		p.Match(PlSqlParserTABLE)
	}
	{
		p.SetState(1485)
		p.Tableview_name()
	}
	{
		p.SetState(1486)
		p.Match(PlSqlParserOF)
	}

	return localctx
}

// IReferencing_clauseContext is an interface to support dynamic dispatch.
type IReferencing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferencing_clauseContext differentiates from other interfaces.
	IsReferencing_clauseContext()
}

type Referencing_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferencing_clauseContext() *Referencing_clauseContext {
	var p = new(Referencing_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_referencing_clause
	return p
}

func (*Referencing_clauseContext) IsReferencing_clauseContext() {}

func NewReferencing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Referencing_clauseContext {
	var p = new(Referencing_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_referencing_clause

	return p
}

func (s *Referencing_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Referencing_clauseContext) REFERENCING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREFERENCING, 0)
}

func (s *Referencing_clauseContext) AllReferencing_element() []IReferencing_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReferencing_elementContext)(nil)).Elem())
	var tst = make([]IReferencing_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReferencing_elementContext)
		}
	}

	return tst
}

func (s *Referencing_clauseContext) Referencing_element(i int) IReferencing_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferencing_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReferencing_elementContext)
}

func (s *Referencing_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Referencing_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Referencing_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterReferencing_clause(s)
	}
}

func (s *Referencing_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitReferencing_clause(s)
	}
}

func (p *PlSqlParser) Referencing_clause() (localctx IReferencing_clauseContext) {
	localctx = NewReferencing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, PlSqlParserRULE_referencing_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.Match(PlSqlParserREFERENCING)
	}
	p.SetState(1490)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1489)
				p.Referencing_element()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1492)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())
	}

	return localctx
}

// IReferencing_elementContext is an interface to support dynamic dispatch.
type IReferencing_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferencing_elementContext differentiates from other interfaces.
	IsReferencing_elementContext()
}

type Referencing_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferencing_elementContext() *Referencing_elementContext {
	var p = new(Referencing_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_referencing_element
	return p
}

func (*Referencing_elementContext) IsReferencing_elementContext() {}

func NewReferencing_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Referencing_elementContext {
	var p = new(Referencing_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_referencing_element

	return p
}

func (s *Referencing_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Referencing_elementContext) Column_alias() IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Referencing_elementContext) NEW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNEW, 0)
}

func (s *Referencing_elementContext) OLD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOLD, 0)
}

func (s *Referencing_elementContext) PARENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARENT, 0)
}

func (s *Referencing_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Referencing_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Referencing_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterReferencing_element(s)
	}
}

func (s *Referencing_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitReferencing_element(s)
	}
}

func (p *PlSqlParser) Referencing_element() (localctx IReferencing_elementContext) {
	localctx = NewReferencing_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, PlSqlParserRULE_referencing_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1494)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserNEW || _la == PlSqlParserOLD || _la == PlSqlParserPARENT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1495)
		p.Column_alias()
	}

	return localctx
}

// IDrop_typeContext is an interface to support dynamic dispatch.
type IDrop_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_typeContext differentiates from other interfaces.
	IsDrop_typeContext()
}

type Drop_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_typeContext() *Drop_typeContext {
	var p = new(Drop_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_drop_type
	return p
}

func (*Drop_typeContext) IsDrop_typeContext() {}

func NewDrop_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_typeContext {
	var p = new(Drop_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_drop_type

	return p
}

func (s *Drop_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_typeContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Drop_typeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTYPE, 0)
}

func (s *Drop_typeContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Drop_typeContext) BODY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBODY, 0)
}

func (s *Drop_typeContext) FORCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFORCE, 0)
}

func (s *Drop_typeContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALIDATE, 0)
}

func (s *Drop_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDrop_type(s)
	}
}

func (s *Drop_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDrop_type(s)
	}
}

func (p *PlSqlParser) Drop_type() (localctx IDrop_typeContext) {
	localctx = NewDrop_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, PlSqlParserRULE_drop_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1497)
		p.Match(PlSqlParserDROP)
	}
	{
		p.SetState(1498)
		p.Match(PlSqlParserTYPE)
	}
	p.SetState(1500)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1499)
			p.Match(PlSqlParserBODY)
		}

	}
	{
		p.SetState(1502)
		p.Type_name()
	}
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserFORCE || _la == PlSqlParserVALIDATE {
		{
			p.SetState(1503)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserFORCE || _la == PlSqlParserVALIDATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1506)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IAlter_typeContext is an interface to support dynamic dispatch.
type IAlter_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_typeContext differentiates from other interfaces.
	IsAlter_typeContext()
}

type Alter_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_typeContext() *Alter_typeContext {
	var p = new(Alter_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_type
	return p
}

func (*Alter_typeContext) IsAlter_typeContext() {}

func NewAlter_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_typeContext {
	var p = new(Alter_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_type

	return p
}

func (s *Alter_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_typeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *Alter_typeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTYPE, 0)
}

func (s *Alter_typeContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Alter_typeContext) Compile_type_clause() ICompile_type_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompile_type_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompile_type_clauseContext)
}

func (s *Alter_typeContext) Replace_type_clause() IReplace_type_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReplace_type_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReplace_type_clauseContext)
}

func (s *Alter_typeContext) Alter_method_spec() IAlter_method_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_method_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_method_specContext)
}

func (s *Alter_typeContext) Alter_collection_clauses() IAlter_collection_clausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_collection_clausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_collection_clausesContext)
}

func (s *Alter_typeContext) Modifier_clause() IModifier_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifier_clauseContext)
}

func (s *Alter_typeContext) Dependent_handling_clause() IDependent_handling_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDependent_handling_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDependent_handling_clauseContext)
}

func (s *Alter_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_type(s)
	}
}

func (s *Alter_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_type(s)
	}
}

func (p *PlSqlParser) Alter_type() (localctx IAlter_typeContext) {
	localctx = NewAlter_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, PlSqlParserRULE_alter_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1508)
		p.Match(PlSqlParserALTER)
	}
	{
		p.SetState(1509)
		p.Match(PlSqlParserTYPE)
	}
	{
		p.SetState(1510)
		p.Type_name()
	}
	p.SetState(1516)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserCOMPILE:
		{
			p.SetState(1511)
			p.Compile_type_clause()
		}

	case PlSqlParserREPLACE:
		{
			p.SetState(1512)
			p.Replace_type_clause()
		}

	case PlSqlParserADD, PlSqlParserDROP:
		{
			p.SetState(1513)
			p.Alter_method_spec()
		}

	case PlSqlParserMODIFY:
		{
			p.SetState(1514)
			p.Alter_collection_clauses()
		}

	case PlSqlParserFINAL, PlSqlParserINSTANTIABLE, PlSqlParserNOT, PlSqlParserOVERRIDING:
		{
			p.SetState(1515)
			p.Modifier_clause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserCASCADE || _la == PlSqlParserINVALIDATE {
		{
			p.SetState(1518)
			p.Dependent_handling_clause()
		}

	}
	{
		p.SetState(1521)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ICompile_type_clauseContext is an interface to support dynamic dispatch.
type ICompile_type_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompile_type_clauseContext differentiates from other interfaces.
	IsCompile_type_clauseContext()
}

type Compile_type_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompile_type_clauseContext() *Compile_type_clauseContext {
	var p = new(Compile_type_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_compile_type_clause
	return p
}

func (*Compile_type_clauseContext) IsCompile_type_clauseContext() {}

func NewCompile_type_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compile_type_clauseContext {
	var p = new(Compile_type_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_compile_type_clause

	return p
}

func (s *Compile_type_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Compile_type_clauseContext) COMPILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPILE, 0)
}

func (s *Compile_type_clauseContext) DEBUG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEBUG, 0)
}

func (s *Compile_type_clauseContext) AllCompiler_parameters_clause() []ICompiler_parameters_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem())
	var tst = make([]ICompiler_parameters_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompiler_parameters_clauseContext)
		}
	}

	return tst
}

func (s *Compile_type_clauseContext) Compiler_parameters_clause(i int) ICompiler_parameters_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompiler_parameters_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompiler_parameters_clauseContext)
}

func (s *Compile_type_clauseContext) REUSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREUSE, 0)
}

func (s *Compile_type_clauseContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSETTINGS, 0)
}

func (s *Compile_type_clauseContext) SPECIFICATION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSPECIFICATION, 0)
}

func (s *Compile_type_clauseContext) BODY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBODY, 0)
}

func (s *Compile_type_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compile_type_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compile_type_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCompile_type_clause(s)
	}
}

func (s *Compile_type_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCompile_type_clause(s)
	}
}

func (p *PlSqlParser) Compile_type_clause() (localctx ICompile_type_clauseContext) {
	localctx = NewCompile_type_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, PlSqlParserRULE_compile_type_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1523)
		p.Match(PlSqlParserCOMPILE)
	}
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1524)
			p.Match(PlSqlParserDEBUG)
		}

	}
	p.SetState(1528)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1527)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserBODY || _la == PlSqlParserSPECIFICATION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1530)
				p.Compiler_parameters_clause()
			}

		}
		p.SetState(1535)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())
	}
	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserREUSE {
		{
			p.SetState(1536)
			p.Match(PlSqlParserREUSE)
		}
		{
			p.SetState(1537)
			p.Match(PlSqlParserSETTINGS)
		}

	}

	return localctx
}

// IReplace_type_clauseContext is an interface to support dynamic dispatch.
type IReplace_type_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReplace_type_clauseContext differentiates from other interfaces.
	IsReplace_type_clauseContext()
}

type Replace_type_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplace_type_clauseContext() *Replace_type_clauseContext {
	var p = new(Replace_type_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_replace_type_clause
	return p
}

func (*Replace_type_clauseContext) IsReplace_type_clauseContext() {}

func NewReplace_type_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replace_type_clauseContext {
	var p = new(Replace_type_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_replace_type_clause

	return p
}

func (s *Replace_type_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Replace_type_clauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREPLACE, 0)
}

func (s *Replace_type_clauseContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Replace_type_clauseContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOBJECT, 0)
}

func (s *Replace_type_clauseContext) AllObject_member_spec() []IObject_member_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObject_member_specContext)(nil)).Elem())
	var tst = make([]IObject_member_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObject_member_specContext)
		}
	}

	return tst
}

func (s *Replace_type_clauseContext) Object_member_spec(i int) IObject_member_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_member_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObject_member_specContext)
}

func (s *Replace_type_clauseContext) Invoker_rights_clause() IInvoker_rights_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvoker_rights_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvoker_rights_clauseContext)
}

func (s *Replace_type_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replace_type_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Replace_type_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterReplace_type_clause(s)
	}
}

func (s *Replace_type_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitReplace_type_clause(s)
	}
}

func (p *PlSqlParser) Replace_type_clause() (localctx IReplace_type_clauseContext) {
	localctx = NewReplace_type_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, PlSqlParserRULE_replace_type_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1540)
		p.Match(PlSqlParserREPLACE)
	}
	p.SetState(1542)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAUTHID {
		{
			p.SetState(1541)
			p.Invoker_rights_clause()
		}

	}
	{
		p.SetState(1544)
		p.Match(PlSqlParserAS)
	}
	{
		p.SetState(1545)
		p.Match(PlSqlParserOBJECT)
	}
	{
		p.SetState(1546)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(1547)
		p.Object_member_spec()
	}
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(1548)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(1549)
			p.Object_member_spec()
		}

		p.SetState(1554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1555)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IAlter_method_specContext is an interface to support dynamic dispatch.
type IAlter_method_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_method_specContext differentiates from other interfaces.
	IsAlter_method_specContext()
}

type Alter_method_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_method_specContext() *Alter_method_specContext {
	var p = new(Alter_method_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_method_spec
	return p
}

func (*Alter_method_specContext) IsAlter_method_specContext() {}

func NewAlter_method_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_method_specContext {
	var p = new(Alter_method_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_method_spec

	return p
}

func (s *Alter_method_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_method_specContext) AllAlter_method_element() []IAlter_method_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlter_method_elementContext)(nil)).Elem())
	var tst = make([]IAlter_method_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlter_method_elementContext)
		}
	}

	return tst
}

func (s *Alter_method_specContext) Alter_method_element(i int) IAlter_method_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_method_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlter_method_elementContext)
}

func (s *Alter_method_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_method_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_method_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_method_spec(s)
	}
}

func (s *Alter_method_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_method_spec(s)
	}
}

func (p *PlSqlParser) Alter_method_spec() (localctx IAlter_method_specContext) {
	localctx = NewAlter_method_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, PlSqlParserRULE_alter_method_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1557)
		p.Alter_method_element()
	}
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(1558)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(1559)
			p.Alter_method_element()
		}

		p.SetState(1564)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlter_method_elementContext is an interface to support dynamic dispatch.
type IAlter_method_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_method_elementContext differentiates from other interfaces.
	IsAlter_method_elementContext()
}

type Alter_method_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_method_elementContext() *Alter_method_elementContext {
	var p = new(Alter_method_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_method_element
	return p
}

func (*Alter_method_elementContext) IsAlter_method_elementContext() {}

func NewAlter_method_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_method_elementContext {
	var p = new(Alter_method_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_method_element

	return p
}

func (s *Alter_method_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_method_elementContext) ADD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserADD, 0)
}

func (s *Alter_method_elementContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Alter_method_elementContext) Map_order_function_spec() IMap_order_function_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMap_order_function_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMap_order_function_specContext)
}

func (s *Alter_method_elementContext) Subprogram_spec() ISubprogram_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_specContext)
}

func (s *Alter_method_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_method_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_method_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_method_element(s)
	}
}

func (s *Alter_method_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_method_element(s)
	}
}

func (p *PlSqlParser) Alter_method_element() (localctx IAlter_method_elementContext) {
	localctx = NewAlter_method_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, PlSqlParserRULE_alter_method_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1565)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserADD || _la == PlSqlParserDROP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserMAP, PlSqlParserORDER:
		{
			p.SetState(1566)
			p.Map_order_function_spec()
		}

	case PlSqlParserMEMBER, PlSqlParserSTATIC:
		{
			p.SetState(1567)
			p.Subprogram_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlter_attribute_definitionContext is an interface to support dynamic dispatch.
type IAlter_attribute_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_attribute_definitionContext differentiates from other interfaces.
	IsAlter_attribute_definitionContext()
}

type Alter_attribute_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_attribute_definitionContext() *Alter_attribute_definitionContext {
	var p = new(Alter_attribute_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_attribute_definition
	return p
}

func (*Alter_attribute_definitionContext) IsAlter_attribute_definitionContext() {}

func NewAlter_attribute_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_attribute_definitionContext {
	var p = new(Alter_attribute_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_attribute_definition

	return p
}

func (s *Alter_attribute_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_attribute_definitionContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserATTRIBUTE, 0)
}

func (s *Alter_attribute_definitionContext) ADD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserADD, 0)
}

func (s *Alter_attribute_definitionContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMODIFY, 0)
}

func (s *Alter_attribute_definitionContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Alter_attribute_definitionContext) AllAttribute_definition() []IAttribute_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_definitionContext)(nil)).Elem())
	var tst = make([]IAttribute_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_definitionContext)
		}
	}

	return tst
}

func (s *Alter_attribute_definitionContext) Attribute_definition(i int) IAttribute_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_definitionContext)
}

func (s *Alter_attribute_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_attribute_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_attribute_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_attribute_definition(s)
	}
}

func (s *Alter_attribute_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_attribute_definition(s)
	}
}

func (p *PlSqlParser) Alter_attribute_definition() (localctx IAlter_attribute_definitionContext) {
	localctx = NewAlter_attribute_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, PlSqlParserRULE_alter_attribute_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1570)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserADD || _la == PlSqlParserDROP || _la == PlSqlParserMODIFY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1571)
		p.Match(PlSqlParserATTRIBUTE)
	}
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(1572)
			p.Attribute_definition()
		}

	case PlSqlParserLEFT_PAREN:
		{
			p.SetState(1573)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(1574)
			p.Attribute_definition()
		}
		p.SetState(1579)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1575)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1576)
				p.Attribute_definition()
			}

			p.SetState(1581)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1582)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribute_definitionContext is an interface to support dynamic dispatch.
type IAttribute_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_definitionContext differentiates from other interfaces.
	IsAttribute_definitionContext()
}

type Attribute_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_definitionContext() *Attribute_definitionContext {
	var p = new(Attribute_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_attribute_definition
	return p
}

func (*Attribute_definitionContext) IsAttribute_definitionContext() {}

func NewAttribute_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_definitionContext {
	var p = new(Attribute_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_attribute_definition

	return p
}

func (s *Attribute_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_definitionContext) Attribute_name() IAttribute_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_nameContext)
}

func (s *Attribute_definitionContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Attribute_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAttribute_definition(s)
	}
}

func (s *Attribute_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAttribute_definition(s)
	}
}

func (p *PlSqlParser) Attribute_definition() (localctx IAttribute_definitionContext) {
	localctx = NewAttribute_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, PlSqlParserRULE_attribute_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1586)
		p.Attribute_name()
	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(1587)
			p.Type_spec()
		}

	}

	return localctx
}

// IAlter_collection_clausesContext is an interface to support dynamic dispatch.
type IAlter_collection_clausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_collection_clausesContext differentiates from other interfaces.
	IsAlter_collection_clausesContext()
}

type Alter_collection_clausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_collection_clausesContext() *Alter_collection_clausesContext {
	var p = new(Alter_collection_clausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_collection_clauses
	return p
}

func (*Alter_collection_clausesContext) IsAlter_collection_clausesContext() {}

func NewAlter_collection_clausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_collection_clausesContext {
	var p = new(Alter_collection_clausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_collection_clauses

	return p
}

func (s *Alter_collection_clausesContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_collection_clausesContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMODIFY, 0)
}

func (s *Alter_collection_clausesContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIMIT, 0)
}

func (s *Alter_collection_clausesContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Alter_collection_clausesContext) ELEMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserELEMENT, 0)
}

func (s *Alter_collection_clausesContext) TYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTYPE, 0)
}

func (s *Alter_collection_clausesContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Alter_collection_clausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_collection_clausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_collection_clausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_collection_clauses(s)
	}
}

func (s *Alter_collection_clausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_collection_clauses(s)
	}
}

func (p *PlSqlParser) Alter_collection_clauses() (localctx IAlter_collection_clausesContext) {
	localctx = NewAlter_collection_clausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, PlSqlParserRULE_alter_collection_clauses)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1590)
		p.Match(PlSqlParserMODIFY)
	}
	p.SetState(1596)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserLIMIT:
		{
			p.SetState(1591)
			p.Match(PlSqlParserLIMIT)
		}
		{
			p.SetState(1592)
			p.Expression()
		}

	case PlSqlParserELEMENT:
		{
			p.SetState(1593)
			p.Match(PlSqlParserELEMENT)
		}
		{
			p.SetState(1594)
			p.Match(PlSqlParserTYPE)
		}
		{
			p.SetState(1595)
			p.Type_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDependent_handling_clauseContext is an interface to support dynamic dispatch.
type IDependent_handling_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDependent_handling_clauseContext differentiates from other interfaces.
	IsDependent_handling_clauseContext()
}

type Dependent_handling_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDependent_handling_clauseContext() *Dependent_handling_clauseContext {
	var p = new(Dependent_handling_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_dependent_handling_clause
	return p
}

func (*Dependent_handling_clauseContext) IsDependent_handling_clauseContext() {}

func NewDependent_handling_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dependent_handling_clauseContext {
	var p = new(Dependent_handling_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_dependent_handling_clause

	return p
}

func (s *Dependent_handling_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Dependent_handling_clauseContext) INVALIDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINVALIDATE, 0)
}

func (s *Dependent_handling_clauseContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCASCADE, 0)
}

func (s *Dependent_handling_clauseContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONVERT, 0)
}

func (s *Dependent_handling_clauseContext) TO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO, 0)
}

func (s *Dependent_handling_clauseContext) SUBSTITUTABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBSTITUTABLE, 0)
}

func (s *Dependent_handling_clauseContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINCLUDING, 0)
}

func (s *Dependent_handling_clauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Dependent_handling_clauseContext) DATA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDATA, 0)
}

func (s *Dependent_handling_clauseContext) Dependent_exceptions_part() IDependent_exceptions_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDependent_exceptions_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDependent_exceptions_partContext)
}

func (s *Dependent_handling_clauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Dependent_handling_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dependent_handling_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dependent_handling_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDependent_handling_clause(s)
	}
}

func (s *Dependent_handling_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDependent_handling_clause(s)
	}
}

func (p *PlSqlParser) Dependent_handling_clause() (localctx IDependent_handling_clauseContext) {
	localctx = NewDependent_handling_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, PlSqlParserRULE_dependent_handling_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1614)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserINVALIDATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1598)
			p.Match(PlSqlParserINVALIDATE)
		}

	case PlSqlParserCASCADE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1599)
			p.Match(PlSqlParserCASCADE)
		}
		p.SetState(1609)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserCONVERT:
			{
				p.SetState(1600)
				p.Match(PlSqlParserCONVERT)
			}
			{
				p.SetState(1601)
				p.Match(PlSqlParserTO)
			}
			{
				p.SetState(1602)
				p.Match(PlSqlParserSUBSTITUTABLE)
			}

		case PlSqlParserINCLUDING, PlSqlParserNOT:
			p.SetState(1604)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserNOT {
				{
					p.SetState(1603)
					p.Match(PlSqlParserNOT)
				}

			}
			{
				p.SetState(1606)
				p.Match(PlSqlParserINCLUDING)
			}
			{
				p.SetState(1607)
				p.Match(PlSqlParserTABLE)
			}
			{
				p.SetState(1608)
				p.Match(PlSqlParserDATA)
			}

		case PlSqlParserEXCEPTIONS, PlSqlParserFORCE, PlSqlParserSEMICOLON:

		default:
		}
		p.SetState(1612)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserEXCEPTIONS || _la == PlSqlParserFORCE {
			{
				p.SetState(1611)
				p.Dependent_exceptions_part()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDependent_exceptions_partContext is an interface to support dynamic dispatch.
type IDependent_exceptions_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDependent_exceptions_partContext differentiates from other interfaces.
	IsDependent_exceptions_partContext()
}

type Dependent_exceptions_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDependent_exceptions_partContext() *Dependent_exceptions_partContext {
	var p = new(Dependent_exceptions_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_dependent_exceptions_part
	return p
}

func (*Dependent_exceptions_partContext) IsDependent_exceptions_partContext() {}

func NewDependent_exceptions_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dependent_exceptions_partContext {
	var p = new(Dependent_exceptions_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_dependent_exceptions_part

	return p
}

func (s *Dependent_exceptions_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Dependent_exceptions_partContext) EXCEPTIONS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCEPTIONS, 0)
}

func (s *Dependent_exceptions_partContext) INTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTO, 0)
}

func (s *Dependent_exceptions_partContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Dependent_exceptions_partContext) FORCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFORCE, 0)
}

func (s *Dependent_exceptions_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dependent_exceptions_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dependent_exceptions_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDependent_exceptions_part(s)
	}
}

func (s *Dependent_exceptions_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDependent_exceptions_part(s)
	}
}

func (p *PlSqlParser) Dependent_exceptions_part() (localctx IDependent_exceptions_partContext) {
	localctx = NewDependent_exceptions_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, PlSqlParserRULE_dependent_exceptions_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserFORCE {
		{
			p.SetState(1616)
			p.Match(PlSqlParserFORCE)
		}

	}
	{
		p.SetState(1619)
		p.Match(PlSqlParserEXCEPTIONS)
	}
	{
		p.SetState(1620)
		p.Match(PlSqlParserINTO)
	}
	{
		p.SetState(1621)
		p.Tableview_name()
	}

	return localctx
}

// ICreate_typeContext is an interface to support dynamic dispatch.
type ICreate_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_typeContext differentiates from other interfaces.
	IsCreate_typeContext()
}

type Create_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_typeContext() *Create_typeContext {
	var p = new(Create_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_type
	return p
}

func (*Create_typeContext) IsCreate_typeContext() {}

func NewCreate_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_typeContext {
	var p = new(Create_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_type

	return p
}

func (s *Create_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_typeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_typeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTYPE, 0)
}

func (s *Create_typeContext) Type_definition() IType_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_definitionContext)
}

func (s *Create_typeContext) Type_body() IType_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_bodyContext)
}

func (s *Create_typeContext) OR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, 0)
}

func (s *Create_typeContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREPLACE, 0)
}

func (s *Create_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_type(s)
	}
}

func (s *Create_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_type(s)
	}
}

func (p *PlSqlParser) Create_type() (localctx ICreate_typeContext) {
	localctx = NewCreate_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, PlSqlParserRULE_create_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1623)
		p.Match(PlSqlParserCREATE)
	}
	p.SetState(1626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOR {
		{
			p.SetState(1624)
			p.Match(PlSqlParserOR)
		}
		{
			p.SetState(1625)
			p.Match(PlSqlParserREPLACE)
		}

	}
	{
		p.SetState(1628)
		p.Match(PlSqlParserTYPE)
	}
	p.SetState(1631)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1629)
			p.Type_definition()
		}

	case 2:
		{
			p.SetState(1630)
			p.Type_body()
		}

	}
	{
		p.SetState(1633)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IType_definitionContext is an interface to support dynamic dispatch.
type IType_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_definitionContext differentiates from other interfaces.
	IsType_definitionContext()
}

type Type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_definitionContext() *Type_definitionContext {
	var p = new(Type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_type_definition
	return p
}

func (*Type_definitionContext) IsType_definitionContext() {}

func NewType_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_definitionContext {
	var p = new(Type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_type_definition

	return p
}

func (s *Type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_definitionContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Type_definitionContext) OID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOID, 0)
}

func (s *Type_definitionContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR_STRING, 0)
}

func (s *Type_definitionContext) Object_type_def() IObject_type_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_type_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_type_defContext)
}

func (s *Type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterType_definition(s)
	}
}

func (s *Type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitType_definition(s)
	}
}

func (p *PlSqlParser) Type_definition() (localctx IType_definitionContext) {
	localctx = NewType_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, PlSqlParserRULE_type_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1635)
		p.Type_name()
	}
	p.SetState(1638)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOID {
		{
			p.SetState(1636)
			p.Match(PlSqlParserOID)
		}
		{
			p.SetState(1637)
			p.Match(PlSqlParserCHAR_STRING)
		}

	}
	p.SetState(1641)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAS || _la == PlSqlParserAUTHID || _la == PlSqlParserIS || _la == PlSqlParserUNDER {
		{
			p.SetState(1640)
			p.Object_type_def()
		}

	}

	return localctx
}

// IObject_type_defContext is an interface to support dynamic dispatch.
type IObject_type_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_type_defContext differentiates from other interfaces.
	IsObject_type_defContext()
}

type Object_type_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_type_defContext() *Object_type_defContext {
	var p = new(Object_type_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_object_type_def
	return p
}

func (*Object_type_defContext) IsObject_type_defContext() {}

func NewObject_type_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_type_defContext {
	var p = new(Object_type_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_object_type_def

	return p
}

func (s *Object_type_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_type_defContext) Object_as_part() IObject_as_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_as_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_as_partContext)
}

func (s *Object_type_defContext) Object_under_part() IObject_under_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_under_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_under_partContext)
}

func (s *Object_type_defContext) Invoker_rights_clause() IInvoker_rights_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvoker_rights_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvoker_rights_clauseContext)
}

func (s *Object_type_defContext) Sqlj_object_type() ISqlj_object_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqlj_object_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqlj_object_typeContext)
}

func (s *Object_type_defContext) AllObject_member_spec() []IObject_member_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObject_member_specContext)(nil)).Elem())
	var tst = make([]IObject_member_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObject_member_specContext)
		}
	}

	return tst
}

func (s *Object_type_defContext) Object_member_spec(i int) IObject_member_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_member_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObject_member_specContext)
}

func (s *Object_type_defContext) AllModifier_clause() []IModifier_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifier_clauseContext)(nil)).Elem())
	var tst = make([]IModifier_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifier_clauseContext)
		}
	}

	return tst
}

func (s *Object_type_defContext) Modifier_clause(i int) IModifier_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifier_clauseContext)
}

func (s *Object_type_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_type_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_type_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterObject_type_def(s)
	}
}

func (s *Object_type_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitObject_type_def(s)
	}
}

func (p *PlSqlParser) Object_type_def() (localctx IObject_type_defContext) {
	localctx = NewObject_type_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, PlSqlParserRULE_object_type_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1644)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAUTHID {
		{
			p.SetState(1643)
			p.Invoker_rights_clause()
		}

	}
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserAS, PlSqlParserIS:
		{
			p.SetState(1646)
			p.Object_as_part()
		}

	case PlSqlParserUNDER:
		{
			p.SetState(1647)
			p.Object_under_part()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserEXTERNAL {
		{
			p.SetState(1650)
			p.Sqlj_object_type()
		}

	}
	p.SetState(1664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1653)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(1654)
			p.Object_member_spec()
		}
		p.SetState(1659)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1655)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1656)
				p.Object_member_spec()
			}

			p.SetState(1661)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1662)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	p.SetState(1669)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserFINAL || _la == PlSqlParserINSTANTIABLE || _la == PlSqlParserNOT || _la == PlSqlParserOVERRIDING {
		{
			p.SetState(1666)
			p.Modifier_clause()
		}

		p.SetState(1671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObject_as_partContext is an interface to support dynamic dispatch.
type IObject_as_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_as_partContext differentiates from other interfaces.
	IsObject_as_partContext()
}

type Object_as_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_as_partContext() *Object_as_partContext {
	var p = new(Object_as_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_object_as_part
	return p
}

func (*Object_as_partContext) IsObject_as_partContext() {}

func NewObject_as_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_as_partContext {
	var p = new(Object_as_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_object_as_part

	return p
}

func (s *Object_as_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_as_partContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Object_as_partContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Object_as_partContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOBJECT, 0)
}

func (s *Object_as_partContext) Varray_type_def() IVarray_type_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarray_type_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarray_type_defContext)
}

func (s *Object_as_partContext) Nested_table_type_def() INested_table_type_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_table_type_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_table_type_defContext)
}

func (s *Object_as_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_as_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_as_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterObject_as_part(s)
	}
}

func (s *Object_as_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitObject_as_part(s)
	}
}

func (p *PlSqlParser) Object_as_part() (localctx IObject_as_partContext) {
	localctx = NewObject_as_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, PlSqlParserRULE_object_as_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1672)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1676)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserOBJECT:
		{
			p.SetState(1673)
			p.Match(PlSqlParserOBJECT)
		}

	case PlSqlParserVARRAY, PlSqlParserVARYING:
		{
			p.SetState(1674)
			p.Varray_type_def()
		}

	case PlSqlParserTABLE:
		{
			p.SetState(1675)
			p.Nested_table_type_def()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObject_under_partContext is an interface to support dynamic dispatch.
type IObject_under_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_under_partContext differentiates from other interfaces.
	IsObject_under_partContext()
}

type Object_under_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_under_partContext() *Object_under_partContext {
	var p = new(Object_under_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_object_under_part
	return p
}

func (*Object_under_partContext) IsObject_under_partContext() {}

func NewObject_under_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_under_partContext {
	var p = new(Object_under_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_object_under_part

	return p
}

func (s *Object_under_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_under_partContext) UNDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNDER, 0)
}

func (s *Object_under_partContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Object_under_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_under_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_under_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterObject_under_part(s)
	}
}

func (s *Object_under_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitObject_under_part(s)
	}
}

func (p *PlSqlParser) Object_under_part() (localctx IObject_under_partContext) {
	localctx = NewObject_under_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, PlSqlParserRULE_object_under_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1678)
		p.Match(PlSqlParserUNDER)
	}
	{
		p.SetState(1679)
		p.Type_spec()
	}

	return localctx
}

// INested_table_type_defContext is an interface to support dynamic dispatch.
type INested_table_type_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNested_table_type_defContext differentiates from other interfaces.
	IsNested_table_type_defContext()
}

type Nested_table_type_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNested_table_type_defContext() *Nested_table_type_defContext {
	var p = new(Nested_table_type_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_nested_table_type_def
	return p
}

func (*Nested_table_type_defContext) IsNested_table_type_defContext() {}

func NewNested_table_type_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nested_table_type_defContext {
	var p = new(Nested_table_type_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_nested_table_type_def

	return p
}

func (s *Nested_table_type_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Nested_table_type_defContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Nested_table_type_defContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Nested_table_type_defContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Nested_table_type_defContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Nested_table_type_defContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *Nested_table_type_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nested_table_type_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nested_table_type_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNested_table_type_def(s)
	}
}

func (s *Nested_table_type_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNested_table_type_def(s)
	}
}

func (p *PlSqlParser) Nested_table_type_def() (localctx INested_table_type_defContext) {
	localctx = NewNested_table_type_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, PlSqlParserRULE_nested_table_type_def)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1681)
		p.Match(PlSqlParserTABLE)
	}
	{
		p.SetState(1682)
		p.Match(PlSqlParserOF)
	}
	{
		p.SetState(1683)
		p.Type_spec()
	}
	p.SetState(1686)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1684)
			p.Match(PlSqlParserNOT)
		}
		{
			p.SetState(1685)
			p.Match(PlSqlParserNULL)
		}

	}

	return localctx
}

// ISqlj_object_typeContext is an interface to support dynamic dispatch.
type ISqlj_object_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlj_object_typeContext differentiates from other interfaces.
	IsSqlj_object_typeContext()
}

type Sqlj_object_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlj_object_typeContext() *Sqlj_object_typeContext {
	var p = new(Sqlj_object_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_sqlj_object_type
	return p
}

func (*Sqlj_object_typeContext) IsSqlj_object_typeContext() {}

func NewSqlj_object_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sqlj_object_typeContext {
	var p = new(Sqlj_object_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_sqlj_object_type

	return p
}

func (s *Sqlj_object_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sqlj_object_typeContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXTERNAL, 0)
}

func (s *Sqlj_object_typeContext) NAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAME, 0)
}

func (s *Sqlj_object_typeContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Sqlj_object_typeContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLANGUAGE, 0)
}

func (s *Sqlj_object_typeContext) JAVA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserJAVA, 0)
}

func (s *Sqlj_object_typeContext) USING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSING, 0)
}

func (s *Sqlj_object_typeContext) SQLDATA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSQLDATA, 0)
}

func (s *Sqlj_object_typeContext) CUSTOMDATUM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCUSTOMDATUM, 0)
}

func (s *Sqlj_object_typeContext) ORADATA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORADATA, 0)
}

func (s *Sqlj_object_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sqlj_object_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sqlj_object_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSqlj_object_type(s)
	}
}

func (s *Sqlj_object_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSqlj_object_type(s)
	}
}

func (p *PlSqlParser) Sqlj_object_type() (localctx ISqlj_object_typeContext) {
	localctx = NewSqlj_object_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, PlSqlParserRULE_sqlj_object_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1688)
		p.Match(PlSqlParserEXTERNAL)
	}
	{
		p.SetState(1689)
		p.Match(PlSqlParserNAME)
	}
	{
		p.SetState(1690)
		p.Expression()
	}
	{
		p.SetState(1691)
		p.Match(PlSqlParserLANGUAGE)
	}
	{
		p.SetState(1692)
		p.Match(PlSqlParserJAVA)
	}
	{
		p.SetState(1693)
		p.Match(PlSqlParserUSING)
	}
	{
		p.SetState(1694)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserCUSTOMDATUM || _la == PlSqlParserORADATA || _la == PlSqlParserSQLDATA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IType_bodyContext is an interface to support dynamic dispatch.
type IType_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_bodyContext differentiates from other interfaces.
	IsType_bodyContext()
}

type Type_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_bodyContext() *Type_bodyContext {
	var p = new(Type_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_type_body
	return p
}

func (*Type_bodyContext) IsType_bodyContext() {}

func NewType_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_bodyContext {
	var p = new(Type_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_type_body

	return p
}

func (s *Type_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_bodyContext) BODY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBODY, 0)
}

func (s *Type_bodyContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Type_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *Type_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Type_bodyContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Type_bodyContext) AllType_body_elements() []IType_body_elementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_body_elementsContext)(nil)).Elem())
	var tst = make([]IType_body_elementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_body_elementsContext)
		}
	}

	return tst
}

func (s *Type_bodyContext) Type_body_elements(i int) IType_body_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_body_elementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_body_elementsContext)
}

func (s *Type_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterType_body(s)
	}
}

func (s *Type_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitType_body(s)
	}
}

func (p *PlSqlParser) Type_body() (localctx IType_bodyContext) {
	localctx = NewType_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, PlSqlParserRULE_type_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1696)
		p.Match(PlSqlParserBODY)
	}
	{
		p.SetState(1697)
		p.Type_name()
	}
	{
		p.SetState(1698)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1700)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PlSqlParserMAP || _la == PlSqlParserMEMBER || _la == PlSqlParserORDER || _la == PlSqlParserSTATIC {
		{
			p.SetState(1699)
			p.Type_body_elements()
		}

		p.SetState(1702)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1704)
		p.Match(PlSqlParserEND)
	}

	return localctx
}

// IType_body_elementsContext is an interface to support dynamic dispatch.
type IType_body_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_body_elementsContext differentiates from other interfaces.
	IsType_body_elementsContext()
}

type Type_body_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_body_elementsContext() *Type_body_elementsContext {
	var p = new(Type_body_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_type_body_elements
	return p
}

func (*Type_body_elementsContext) IsType_body_elementsContext() {}

func NewType_body_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_body_elementsContext {
	var p = new(Type_body_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_type_body_elements

	return p
}

func (s *Type_body_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_body_elementsContext) Map_order_func_declaration() IMap_order_func_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMap_order_func_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMap_order_func_declarationContext)
}

func (s *Type_body_elementsContext) Subprog_decl_in_type() ISubprog_decl_in_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprog_decl_in_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprog_decl_in_typeContext)
}

func (s *Type_body_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_body_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_body_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterType_body_elements(s)
	}
}

func (s *Type_body_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitType_body_elements(s)
	}
}

func (p *PlSqlParser) Type_body_elements() (localctx IType_body_elementsContext) {
	localctx = NewType_body_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, PlSqlParserRULE_type_body_elements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1708)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserMAP, PlSqlParserORDER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1706)
			p.Map_order_func_declaration()
		}

	case PlSqlParserMEMBER, PlSqlParserSTATIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1707)
			p.Subprog_decl_in_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMap_order_func_declarationContext is an interface to support dynamic dispatch.
type IMap_order_func_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMap_order_func_declarationContext differentiates from other interfaces.
	IsMap_order_func_declarationContext()
}

type Map_order_func_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMap_order_func_declarationContext() *Map_order_func_declarationContext {
	var p = new(Map_order_func_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_map_order_func_declaration
	return p
}

func (*Map_order_func_declarationContext) IsMap_order_func_declarationContext() {}

func NewMap_order_func_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Map_order_func_declarationContext {
	var p = new(Map_order_func_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_map_order_func_declaration

	return p
}

func (s *Map_order_func_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Map_order_func_declarationContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEMBER, 0)
}

func (s *Map_order_func_declarationContext) Func_decl_in_type() IFunc_decl_in_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_decl_in_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_decl_in_typeContext)
}

func (s *Map_order_func_declarationContext) MAP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAP, 0)
}

func (s *Map_order_func_declarationContext) ORDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORDER, 0)
}

func (s *Map_order_func_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Map_order_func_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Map_order_func_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMap_order_func_declaration(s)
	}
}

func (s *Map_order_func_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMap_order_func_declaration(s)
	}
}

func (p *PlSqlParser) Map_order_func_declaration() (localctx IMap_order_func_declarationContext) {
	localctx = NewMap_order_func_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, PlSqlParserRULE_map_order_func_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1710)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserMAP || _la == PlSqlParserORDER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1711)
		p.Match(PlSqlParserMEMBER)
	}
	{
		p.SetState(1712)
		p.Func_decl_in_type()
	}

	return localctx
}

// ISubprog_decl_in_typeContext is an interface to support dynamic dispatch.
type ISubprog_decl_in_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprog_decl_in_typeContext differentiates from other interfaces.
	IsSubprog_decl_in_typeContext()
}

type Subprog_decl_in_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprog_decl_in_typeContext() *Subprog_decl_in_typeContext {
	var p = new(Subprog_decl_in_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_subprog_decl_in_type
	return p
}

func (*Subprog_decl_in_typeContext) IsSubprog_decl_in_typeContext() {}

func NewSubprog_decl_in_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprog_decl_in_typeContext {
	var p = new(Subprog_decl_in_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_subprog_decl_in_type

	return p
}

func (s *Subprog_decl_in_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprog_decl_in_typeContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEMBER, 0)
}

func (s *Subprog_decl_in_typeContext) STATIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATIC, 0)
}

func (s *Subprog_decl_in_typeContext) Proc_decl_in_type() IProc_decl_in_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProc_decl_in_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProc_decl_in_typeContext)
}

func (s *Subprog_decl_in_typeContext) Func_decl_in_type() IFunc_decl_in_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_decl_in_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_decl_in_typeContext)
}

func (s *Subprog_decl_in_typeContext) Constructor_declaration() IConstructor_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructor_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructor_declarationContext)
}

func (s *Subprog_decl_in_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprog_decl_in_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprog_decl_in_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSubprog_decl_in_type(s)
	}
}

func (s *Subprog_decl_in_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSubprog_decl_in_type(s)
	}
}

func (p *PlSqlParser) Subprog_decl_in_type() (localctx ISubprog_decl_in_typeContext) {
	localctx = NewSubprog_decl_in_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, PlSqlParserRULE_subprog_decl_in_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1714)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserMEMBER || _la == PlSqlParserSTATIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1718)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserPROCEDURE:
		{
			p.SetState(1715)
			p.Proc_decl_in_type()
		}

	case PlSqlParserFUNCTION:
		{
			p.SetState(1716)
			p.Func_decl_in_type()
		}

	case PlSqlParserCONSTRUCTOR, PlSqlParserFINAL, PlSqlParserINSTANTIABLE:
		{
			p.SetState(1717)
			p.Constructor_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProc_decl_in_typeContext is an interface to support dynamic dispatch.
type IProc_decl_in_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProc_decl_in_typeContext differentiates from other interfaces.
	IsProc_decl_in_typeContext()
}

type Proc_decl_in_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProc_decl_in_typeContext() *Proc_decl_in_typeContext {
	var p = new(Proc_decl_in_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_proc_decl_in_type
	return p
}

func (*Proc_decl_in_typeContext) IsProc_decl_in_typeContext() {}

func NewProc_decl_in_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Proc_decl_in_typeContext {
	var p = new(Proc_decl_in_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_proc_decl_in_type

	return p
}

func (s *Proc_decl_in_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Proc_decl_in_typeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPROCEDURE, 0)
}

func (s *Proc_decl_in_typeContext) Procedure_name() IProcedure_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_nameContext)
}

func (s *Proc_decl_in_typeContext) AllType_elements_parameter() []IType_elements_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem())
	var tst = make([]IType_elements_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_elements_parameterContext)
		}
	}

	return tst
}

func (s *Proc_decl_in_typeContext) Type_elements_parameter(i int) IType_elements_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_elements_parameterContext)
}

func (s *Proc_decl_in_typeContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Proc_decl_in_typeContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Proc_decl_in_typeContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Proc_decl_in_typeContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Proc_decl_in_typeContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECLARE, 0)
}

func (s *Proc_decl_in_typeContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *Proc_decl_in_typeContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *Proc_decl_in_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Proc_decl_in_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Proc_decl_in_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterProc_decl_in_type(s)
	}
}

func (s *Proc_decl_in_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitProc_decl_in_type(s)
	}
}

func (p *PlSqlParser) Proc_decl_in_type() (localctx IProc_decl_in_typeContext) {
	localctx = NewProc_decl_in_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, PlSqlParserRULE_proc_decl_in_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1720)
		p.Match(PlSqlParserPROCEDURE)
	}
	{
		p.SetState(1721)
		p.Procedure_name()
	}
	{
		p.SetState(1722)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(1723)
		p.Type_elements_parameter()
	}
	p.SetState(1728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(1724)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(1725)
			p.Type_elements_parameter()
		}

		p.SetState(1730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1731)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	{
		p.SetState(1732)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1746)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1733)
			p.Call_spec()
		}

	case 2:
		p.SetState(1735)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserDECLARE {
			{
				p.SetState(1734)
				p.Match(PlSqlParserDECLARE)
			}

		}
		p.SetState(1740)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
			{
				p.SetState(1737)
				p.Declare_spec()
			}

			p.SetState(1742)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1743)
			p.Body()
		}
		{
			p.SetState(1744)
			p.Match(PlSqlParserSEMICOLON)
		}

	}

	return localctx
}

// IFunc_decl_in_typeContext is an interface to support dynamic dispatch.
type IFunc_decl_in_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_decl_in_typeContext differentiates from other interfaces.
	IsFunc_decl_in_typeContext()
}

type Func_decl_in_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_decl_in_typeContext() *Func_decl_in_typeContext {
	var p = new(Func_decl_in_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_func_decl_in_type
	return p
}

func (*Func_decl_in_typeContext) IsFunc_decl_in_typeContext() {}

func NewFunc_decl_in_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_decl_in_typeContext {
	var p = new(Func_decl_in_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_func_decl_in_type

	return p
}

func (s *Func_decl_in_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_decl_in_typeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Func_decl_in_typeContext) Function_name() IFunction_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Func_decl_in_typeContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Func_decl_in_typeContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Func_decl_in_typeContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Func_decl_in_typeContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Func_decl_in_typeContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Func_decl_in_typeContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Func_decl_in_typeContext) AllType_elements_parameter() []IType_elements_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem())
	var tst = make([]IType_elements_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_elements_parameterContext)
		}
	}

	return tst
}

func (s *Func_decl_in_typeContext) Type_elements_parameter(i int) IType_elements_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_elements_parameterContext)
}

func (s *Func_decl_in_typeContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECLARE, 0)
}

func (s *Func_decl_in_typeContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *Func_decl_in_typeContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *Func_decl_in_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_decl_in_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_decl_in_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFunc_decl_in_type(s)
	}
}

func (s *Func_decl_in_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFunc_decl_in_type(s)
	}
}

func (p *PlSqlParser) Func_decl_in_type() (localctx IFunc_decl_in_typeContext) {
	localctx = NewFunc_decl_in_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, PlSqlParserRULE_func_decl_in_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1748)
		p.Match(PlSqlParserFUNCTION)
	}
	{
		p.SetState(1749)
		p.Function_name()
	}
	p.SetState(1761)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1750)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(1751)
			p.Type_elements_parameter()
		}
		p.SetState(1756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1752)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1753)
				p.Type_elements_parameter()
			}

			p.SetState(1758)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1759)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(1763)
		p.Match(PlSqlParserRETURN)
	}
	{
		p.SetState(1764)
		p.Type_spec()
	}
	{
		p.SetState(1765)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1779)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1766)
			p.Call_spec()
		}

	case 2:
		p.SetState(1768)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserDECLARE {
			{
				p.SetState(1767)
				p.Match(PlSqlParserDECLARE)
			}

		}
		p.SetState(1773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
			{
				p.SetState(1770)
				p.Declare_spec()
			}

			p.SetState(1775)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1776)
			p.Body()
		}
		{
			p.SetState(1777)
			p.Match(PlSqlParserSEMICOLON)
		}

	}

	return localctx
}

// IConstructor_declarationContext is an interface to support dynamic dispatch.
type IConstructor_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructor_declarationContext differentiates from other interfaces.
	IsConstructor_declarationContext()
}

type Constructor_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructor_declarationContext() *Constructor_declarationContext {
	var p = new(Constructor_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_constructor_declaration
	return p
}

func (*Constructor_declarationContext) IsConstructor_declarationContext() {}

func NewConstructor_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constructor_declarationContext {
	var p = new(Constructor_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_constructor_declaration

	return p
}

func (s *Constructor_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constructor_declarationContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRUCTOR, 0)
}

func (s *Constructor_declarationContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Constructor_declarationContext) AllType_spec() []IType_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specContext)(nil)).Elem())
	var tst = make([]IType_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specContext)
		}
	}

	return tst
}

func (s *Constructor_declarationContext) Type_spec(i int) IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Constructor_declarationContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Constructor_declarationContext) AllSELF() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserSELF)
}

func (s *Constructor_declarationContext) SELF(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserSELF, i)
}

func (s *Constructor_declarationContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserAS)
}

func (s *Constructor_declarationContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, i)
}

func (s *Constructor_declarationContext) RESULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESULT, 0)
}

func (s *Constructor_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Constructor_declarationContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Constructor_declarationContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Constructor_declarationContext) FINAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFINAL, 0)
}

func (s *Constructor_declarationContext) INSTANTIABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINSTANTIABLE, 0)
}

func (s *Constructor_declarationContext) AllType_elements_parameter() []IType_elements_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem())
	var tst = make([]IType_elements_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_elements_parameterContext)
		}
	}

	return tst
}

func (s *Constructor_declarationContext) Type_elements_parameter(i int) IType_elements_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_elements_parameterContext)
}

func (s *Constructor_declarationContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Constructor_declarationContext) OUT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOUT, 0)
}

func (s *Constructor_declarationContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECLARE, 0)
}

func (s *Constructor_declarationContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *Constructor_declarationContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *Constructor_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constructor_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constructor_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterConstructor_declaration(s)
	}
}

func (s *Constructor_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitConstructor_declaration(s)
	}
}

func (p *PlSqlParser) Constructor_declaration() (localctx IConstructor_declarationContext) {
	localctx = NewConstructor_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, PlSqlParserRULE_constructor_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1782)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserFINAL {
		{
			p.SetState(1781)
			p.Match(PlSqlParserFINAL)
		}

	}
	p.SetState(1785)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserINSTANTIABLE {
		{
			p.SetState(1784)
			p.Match(PlSqlParserINSTANTIABLE)
		}

	}
	{
		p.SetState(1787)
		p.Match(PlSqlParserCONSTRUCTOR)
	}
	{
		p.SetState(1788)
		p.Match(PlSqlParserFUNCTION)
	}
	{
		p.SetState(1789)
		p.Type_spec()
	}
	p.SetState(1807)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1790)
			p.Match(PlSqlParserLEFT_PAREN)
		}

		{
			p.SetState(1791)
			p.Match(PlSqlParserSELF)
		}
		{
			p.SetState(1792)
			p.Match(PlSqlParserIN)
		}
		{
			p.SetState(1793)
			p.Match(PlSqlParserOUT)
		}
		{
			p.SetState(1794)
			p.Type_spec()
		}
		{
			p.SetState(1795)
			p.Match(PlSqlParserCOMMA)
		}

		{
			p.SetState(1797)
			p.Type_elements_parameter()
		}
		p.SetState(1802)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1798)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1799)
				p.Type_elements_parameter()
			}

			p.SetState(1804)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1805)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(1809)
		p.Match(PlSqlParserRETURN)
	}
	{
		p.SetState(1810)
		p.Match(PlSqlParserSELF)
	}
	{
		p.SetState(1811)
		p.Match(PlSqlParserAS)
	}
	{
		p.SetState(1812)
		p.Match(PlSqlParserRESULT)
	}
	{
		p.SetState(1813)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1814)
			p.Call_spec()
		}

	case 2:
		p.SetState(1816)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserDECLARE {
			{
				p.SetState(1815)
				p.Match(PlSqlParserDECLARE)
			}

		}
		p.SetState(1821)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
			{
				p.SetState(1818)
				p.Declare_spec()
			}

			p.SetState(1823)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1824)
			p.Body()
		}
		{
			p.SetState(1825)
			p.Match(PlSqlParserSEMICOLON)
		}

	}

	return localctx
}

// IModifier_clauseContext is an interface to support dynamic dispatch.
type IModifier_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifier_clauseContext differentiates from other interfaces.
	IsModifier_clauseContext()
}

type Modifier_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifier_clauseContext() *Modifier_clauseContext {
	var p = new(Modifier_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_modifier_clause
	return p
}

func (*Modifier_clauseContext) IsModifier_clauseContext() {}

func NewModifier_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modifier_clauseContext {
	var p = new(Modifier_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_modifier_clause

	return p
}

func (s *Modifier_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Modifier_clauseContext) INSTANTIABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINSTANTIABLE, 0)
}

func (s *Modifier_clauseContext) FINAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFINAL, 0)
}

func (s *Modifier_clauseContext) OVERRIDING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOVERRIDING, 0)
}

func (s *Modifier_clauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Modifier_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modifier_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modifier_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModifier_clause(s)
	}
}

func (s *Modifier_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModifier_clause(s)
	}
}

func (p *PlSqlParser) Modifier_clause() (localctx IModifier_clauseContext) {
	localctx = NewModifier_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, PlSqlParserRULE_modifier_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1830)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNOT {
		{
			p.SetState(1829)
			p.Match(PlSqlParserNOT)
		}

	}
	{
		p.SetState(1832)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserFINAL || _la == PlSqlParserINSTANTIABLE || _la == PlSqlParserOVERRIDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IObject_member_specContext is an interface to support dynamic dispatch.
type IObject_member_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_member_specContext differentiates from other interfaces.
	IsObject_member_specContext()
}

type Object_member_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_member_specContext() *Object_member_specContext {
	var p = new(Object_member_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_object_member_spec
	return p
}

func (*Object_member_specContext) IsObject_member_specContext() {}

func NewObject_member_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_member_specContext {
	var p = new(Object_member_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_object_member_spec

	return p
}

func (s *Object_member_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_member_specContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Object_member_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Object_member_specContext) Sqlj_object_type_attr() ISqlj_object_type_attrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqlj_object_type_attrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqlj_object_type_attrContext)
}

func (s *Object_member_specContext) Element_spec() IElement_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElement_specContext)
}

func (s *Object_member_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_member_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_member_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterObject_member_spec(s)
	}
}

func (s *Object_member_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitObject_member_spec(s)
	}
}

func (p *PlSqlParser) Object_member_spec() (localctx IObject_member_specContext) {
	localctx = NewObject_member_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, PlSqlParserRULE_object_member_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1840)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1834)
			p.Identifier()
		}
		{
			p.SetState(1835)
			p.Type_spec()
		}
		p.SetState(1837)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserEXTERNAL {
			{
				p.SetState(1836)
				p.Sqlj_object_type_attr()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1839)
			p.Element_spec()
		}

	}

	return localctx
}

// ISqlj_object_type_attrContext is an interface to support dynamic dispatch.
type ISqlj_object_type_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlj_object_type_attrContext differentiates from other interfaces.
	IsSqlj_object_type_attrContext()
}

type Sqlj_object_type_attrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlj_object_type_attrContext() *Sqlj_object_type_attrContext {
	var p = new(Sqlj_object_type_attrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_sqlj_object_type_attr
	return p
}

func (*Sqlj_object_type_attrContext) IsSqlj_object_type_attrContext() {}

func NewSqlj_object_type_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sqlj_object_type_attrContext {
	var p = new(Sqlj_object_type_attrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_sqlj_object_type_attr

	return p
}

func (s *Sqlj_object_type_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Sqlj_object_type_attrContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXTERNAL, 0)
}

func (s *Sqlj_object_type_attrContext) NAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAME, 0)
}

func (s *Sqlj_object_type_attrContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Sqlj_object_type_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sqlj_object_type_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sqlj_object_type_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSqlj_object_type_attr(s)
	}
}

func (s *Sqlj_object_type_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSqlj_object_type_attr(s)
	}
}

func (p *PlSqlParser) Sqlj_object_type_attr() (localctx ISqlj_object_type_attrContext) {
	localctx = NewSqlj_object_type_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, PlSqlParserRULE_sqlj_object_type_attr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1842)
		p.Match(PlSqlParserEXTERNAL)
	}
	{
		p.SetState(1843)
		p.Match(PlSqlParserNAME)
	}
	{
		p.SetState(1844)
		p.Expression()
	}

	return localctx
}

// IElement_specContext is an interface to support dynamic dispatch.
type IElement_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_specContext differentiates from other interfaces.
	IsElement_specContext()
}

type Element_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_specContext() *Element_specContext {
	var p = new(Element_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_element_spec
	return p
}

func (*Element_specContext) IsElement_specContext() {}

func NewElement_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_specContext {
	var p = new(Element_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_element_spec

	return p
}

func (s *Element_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_specContext) Modifier_clause() IModifier_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifier_clauseContext)
}

func (s *Element_specContext) AllElement_spec_options() []IElement_spec_optionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElement_spec_optionsContext)(nil)).Elem())
	var tst = make([]IElement_spec_optionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElement_spec_optionsContext)
		}
	}

	return tst
}

func (s *Element_specContext) Element_spec_options(i int) IElement_spec_optionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_spec_optionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElement_spec_optionsContext)
}

func (s *Element_specContext) Pragma_clause() IPragma_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPragma_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPragma_clauseContext)
}

func (s *Element_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterElement_spec(s)
	}
}

func (s *Element_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitElement_spec(s)
	}
}

func (p *PlSqlParser) Element_spec() (localctx IElement_specContext) {
	localctx = NewElement_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, PlSqlParserRULE_element_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1847)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1846)
			p.Modifier_clause()
		}

	}
	p.SetState(1850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PlSqlParserCONSTRUCTOR || _la == PlSqlParserFINAL || _la == PlSqlParserINSTANTIABLE || _la == PlSqlParserMAP || _la == PlSqlParserMEMBER || _la == PlSqlParserORDER || _la == PlSqlParserSTATIC {
		{
			p.SetState(1849)
			p.Element_spec_options()
		}

		p.SetState(1852)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1856)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1854)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(1855)
			p.Pragma_clause()
		}

	}

	return localctx
}

// IElement_spec_optionsContext is an interface to support dynamic dispatch.
type IElement_spec_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_spec_optionsContext differentiates from other interfaces.
	IsElement_spec_optionsContext()
}

type Element_spec_optionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_spec_optionsContext() *Element_spec_optionsContext {
	var p = new(Element_spec_optionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_element_spec_options
	return p
}

func (*Element_spec_optionsContext) IsElement_spec_optionsContext() {}

func NewElement_spec_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_spec_optionsContext {
	var p = new(Element_spec_optionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_element_spec_options

	return p
}

func (s *Element_spec_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_spec_optionsContext) Subprogram_spec() ISubprogram_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_specContext)
}

func (s *Element_spec_optionsContext) Constructor_spec() IConstructor_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructor_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructor_specContext)
}

func (s *Element_spec_optionsContext) Map_order_function_spec() IMap_order_function_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMap_order_function_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMap_order_function_specContext)
}

func (s *Element_spec_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_spec_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_spec_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterElement_spec_options(s)
	}
}

func (s *Element_spec_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitElement_spec_options(s)
	}
}

func (p *PlSqlParser) Element_spec_options() (localctx IElement_spec_optionsContext) {
	localctx = NewElement_spec_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, PlSqlParserRULE_element_spec_options)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1861)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserMEMBER, PlSqlParserSTATIC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1858)
			p.Subprogram_spec()
		}

	case PlSqlParserCONSTRUCTOR, PlSqlParserFINAL, PlSqlParserINSTANTIABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1859)
			p.Constructor_spec()
		}

	case PlSqlParserMAP, PlSqlParserORDER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1860)
			p.Map_order_function_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubprogram_specContext is an interface to support dynamic dispatch.
type ISubprogram_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_specContext differentiates from other interfaces.
	IsSubprogram_specContext()
}

type Subprogram_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_specContext() *Subprogram_specContext {
	var p = new(Subprogram_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_subprogram_spec
	return p
}

func (*Subprogram_specContext) IsSubprogram_specContext() {}

func NewSubprogram_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_specContext {
	var p = new(Subprogram_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_subprogram_spec

	return p
}

func (s *Subprogram_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_specContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEMBER, 0)
}

func (s *Subprogram_specContext) STATIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATIC, 0)
}

func (s *Subprogram_specContext) Type_procedure_spec() IType_procedure_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_procedure_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_procedure_specContext)
}

func (s *Subprogram_specContext) Type_function_spec() IType_function_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_function_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_function_specContext)
}

func (s *Subprogram_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSubprogram_spec(s)
	}
}

func (s *Subprogram_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSubprogram_spec(s)
	}
}

func (p *PlSqlParser) Subprogram_spec() (localctx ISubprogram_specContext) {
	localctx = NewSubprogram_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, PlSqlParserRULE_subprogram_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1863)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserMEMBER || _la == PlSqlParserSTATIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1866)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserPROCEDURE:
		{
			p.SetState(1864)
			p.Type_procedure_spec()
		}

	case PlSqlParserFUNCTION:
		{
			p.SetState(1865)
			p.Type_function_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_procedure_specContext is an interface to support dynamic dispatch.
type IType_procedure_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_procedure_specContext differentiates from other interfaces.
	IsType_procedure_specContext()
}

type Type_procedure_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_procedure_specContext() *Type_procedure_specContext {
	var p = new(Type_procedure_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_type_procedure_spec
	return p
}

func (*Type_procedure_specContext) IsType_procedure_specContext() {}

func NewType_procedure_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_procedure_specContext {
	var p = new(Type_procedure_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_type_procedure_spec

	return p
}

func (s *Type_procedure_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_procedure_specContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPROCEDURE, 0)
}

func (s *Type_procedure_specContext) Procedure_name() IProcedure_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_nameContext)
}

func (s *Type_procedure_specContext) AllType_elements_parameter() []IType_elements_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem())
	var tst = make([]IType_elements_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_elements_parameterContext)
		}
	}

	return tst
}

func (s *Type_procedure_specContext) Type_elements_parameter(i int) IType_elements_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_elements_parameterContext)
}

func (s *Type_procedure_specContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Type_procedure_specContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Type_procedure_specContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Type_procedure_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_procedure_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_procedure_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterType_procedure_spec(s)
	}
}

func (s *Type_procedure_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitType_procedure_spec(s)
	}
}

func (p *PlSqlParser) Type_procedure_spec() (localctx IType_procedure_specContext) {
	localctx = NewType_procedure_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, PlSqlParserRULE_type_procedure_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1868)
		p.Match(PlSqlParserPROCEDURE)
	}
	{
		p.SetState(1869)
		p.Procedure_name()
	}
	{
		p.SetState(1870)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(1871)
		p.Type_elements_parameter()
	}
	p.SetState(1876)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(1872)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(1873)
			p.Type_elements_parameter()
		}

		p.SetState(1878)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1879)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(1882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAS || _la == PlSqlParserIS {
		{
			p.SetState(1880)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1881)
			p.Call_spec()
		}

	}

	return localctx
}

// IType_function_specContext is an interface to support dynamic dispatch.
type IType_function_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_function_specContext differentiates from other interfaces.
	IsType_function_specContext()
}

type Type_function_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_function_specContext() *Type_function_specContext {
	var p = new(Type_function_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_type_function_spec
	return p
}

func (*Type_function_specContext) IsType_function_specContext() {}

func NewType_function_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_function_specContext {
	var p = new(Type_function_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_type_function_spec

	return p
}

func (s *Type_function_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_function_specContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Type_function_specContext) Function_name() IFunction_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Type_function_specContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Type_function_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Type_function_specContext) SELF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSELF, 0)
}

func (s *Type_function_specContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserAS)
}

func (s *Type_function_specContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, i)
}

func (s *Type_function_specContext) RESULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESULT, 0)
}

func (s *Type_function_specContext) AllType_elements_parameter() []IType_elements_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem())
	var tst = make([]IType_elements_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_elements_parameterContext)
		}
	}

	return tst
}

func (s *Type_function_specContext) Type_elements_parameter(i int) IType_elements_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_elements_parameterContext)
}

func (s *Type_function_specContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Type_function_specContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXTERNAL, 0)
}

func (s *Type_function_specContext) NAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAME, 0)
}

func (s *Type_function_specContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Type_function_specContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Type_function_specContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARIABLE, 0)
}

func (s *Type_function_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_function_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_function_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterType_function_spec(s)
	}
}

func (s *Type_function_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitType_function_spec(s)
	}
}

func (p *PlSqlParser) Type_function_spec() (localctx IType_function_specContext) {
	localctx = NewType_function_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, PlSqlParserRULE_type_function_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1884)
		p.Match(PlSqlParserFUNCTION)
	}
	{
		p.SetState(1885)
		p.Function_name()
	}
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1886)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(1887)
			p.Type_elements_parameter()
		}
		p.SetState(1892)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1888)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1889)
				p.Type_elements_parameter()
			}

			p.SetState(1894)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1895)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(1899)
		p.Match(PlSqlParserRETURN)
	}
	p.SetState(1904)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1900)
			p.Type_spec()
		}

	case 2:
		{
			p.SetState(1901)
			p.Match(PlSqlParserSELF)
		}
		{
			p.SetState(1902)
			p.Match(PlSqlParserAS)
		}
		{
			p.SetState(1903)
			p.Match(PlSqlParserRESULT)
		}

	}
	p.SetState(1914)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserAS, PlSqlParserIS:
		{
			p.SetState(1906)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1907)
			p.Call_spec()
		}

	case PlSqlParserEXTERNAL:
		{
			p.SetState(1908)
			p.Match(PlSqlParserEXTERNAL)
		}
		p.SetState(1910)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserVARIABLE {
			{
				p.SetState(1909)
				p.Match(PlSqlParserVARIABLE)
			}

		}
		{
			p.SetState(1912)
			p.Match(PlSqlParserNAME)
		}
		{
			p.SetState(1913)
			p.Expression()
		}

	case PlSqlParserCASCADE, PlSqlParserCONSTRUCTOR, PlSqlParserFINAL, PlSqlParserINSTANTIABLE, PlSqlParserINVALIDATE, PlSqlParserMAP, PlSqlParserMEMBER, PlSqlParserORDER, PlSqlParserSTATIC, PlSqlParserRIGHT_PAREN, PlSqlParserCOMMA, PlSqlParserSEMICOLON:

	default:
	}

	return localctx
}

// IConstructor_specContext is an interface to support dynamic dispatch.
type IConstructor_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructor_specContext differentiates from other interfaces.
	IsConstructor_specContext()
}

type Constructor_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructor_specContext() *Constructor_specContext {
	var p = new(Constructor_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_constructor_spec
	return p
}

func (*Constructor_specContext) IsConstructor_specContext() {}

func NewConstructor_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constructor_specContext {
	var p = new(Constructor_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_constructor_spec

	return p
}

func (s *Constructor_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Constructor_specContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRUCTOR, 0)
}

func (s *Constructor_specContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Constructor_specContext) AllType_spec() []IType_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specContext)(nil)).Elem())
	var tst = make([]IType_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specContext)
		}
	}

	return tst
}

func (s *Constructor_specContext) Type_spec(i int) IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Constructor_specContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Constructor_specContext) AllSELF() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserSELF)
}

func (s *Constructor_specContext) SELF(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserSELF, i)
}

func (s *Constructor_specContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserAS)
}

func (s *Constructor_specContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, i)
}

func (s *Constructor_specContext) RESULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESULT, 0)
}

func (s *Constructor_specContext) FINAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFINAL, 0)
}

func (s *Constructor_specContext) INSTANTIABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINSTANTIABLE, 0)
}

func (s *Constructor_specContext) AllType_elements_parameter() []IType_elements_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem())
	var tst = make([]IType_elements_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_elements_parameterContext)
		}
	}

	return tst
}

func (s *Constructor_specContext) Type_elements_parameter(i int) IType_elements_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_elements_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_elements_parameterContext)
}

func (s *Constructor_specContext) Call_spec() ICall_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_specContext)
}

func (s *Constructor_specContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Constructor_specContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Constructor_specContext) OUT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOUT, 0)
}

func (s *Constructor_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constructor_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constructor_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterConstructor_spec(s)
	}
}

func (s *Constructor_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitConstructor_spec(s)
	}
}

func (p *PlSqlParser) Constructor_spec() (localctx IConstructor_specContext) {
	localctx = NewConstructor_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, PlSqlParserRULE_constructor_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserFINAL {
		{
			p.SetState(1916)
			p.Match(PlSqlParserFINAL)
		}

	}
	p.SetState(1920)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserINSTANTIABLE {
		{
			p.SetState(1919)
			p.Match(PlSqlParserINSTANTIABLE)
		}

	}
	{
		p.SetState(1922)
		p.Match(PlSqlParserCONSTRUCTOR)
	}
	{
		p.SetState(1923)
		p.Match(PlSqlParserFUNCTION)
	}
	{
		p.SetState(1924)
		p.Type_spec()
	}
	p.SetState(1942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(1925)
			p.Match(PlSqlParserLEFT_PAREN)
		}

		{
			p.SetState(1926)
			p.Match(PlSqlParserSELF)
		}
		{
			p.SetState(1927)
			p.Match(PlSqlParserIN)
		}
		{
			p.SetState(1928)
			p.Match(PlSqlParserOUT)
		}
		{
			p.SetState(1929)
			p.Type_spec()
		}
		{
			p.SetState(1930)
			p.Match(PlSqlParserCOMMA)
		}

		{
			p.SetState(1932)
			p.Type_elements_parameter()
		}
		p.SetState(1937)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(1933)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(1934)
				p.Type_elements_parameter()
			}

			p.SetState(1939)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1940)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(1944)
		p.Match(PlSqlParserRETURN)
	}
	{
		p.SetState(1945)
		p.Match(PlSqlParserSELF)
	}
	{
		p.SetState(1946)
		p.Match(PlSqlParserAS)
	}
	{
		p.SetState(1947)
		p.Match(PlSqlParserRESULT)
	}
	p.SetState(1950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAS || _la == PlSqlParserIS {
		{
			p.SetState(1948)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserAS || _la == PlSqlParserIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1949)
			p.Call_spec()
		}

	}

	return localctx
}

// IMap_order_function_specContext is an interface to support dynamic dispatch.
type IMap_order_function_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMap_order_function_specContext differentiates from other interfaces.
	IsMap_order_function_specContext()
}

type Map_order_function_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMap_order_function_specContext() *Map_order_function_specContext {
	var p = new(Map_order_function_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_map_order_function_spec
	return p
}

func (*Map_order_function_specContext) IsMap_order_function_specContext() {}

func NewMap_order_function_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Map_order_function_specContext {
	var p = new(Map_order_function_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_map_order_function_spec

	return p
}

func (s *Map_order_function_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Map_order_function_specContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEMBER, 0)
}

func (s *Map_order_function_specContext) Type_function_spec() IType_function_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_function_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_function_specContext)
}

func (s *Map_order_function_specContext) MAP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAP, 0)
}

func (s *Map_order_function_specContext) ORDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORDER, 0)
}

func (s *Map_order_function_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Map_order_function_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Map_order_function_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMap_order_function_spec(s)
	}
}

func (s *Map_order_function_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMap_order_function_spec(s)
	}
}

func (p *PlSqlParser) Map_order_function_spec() (localctx IMap_order_function_specContext) {
	localctx = NewMap_order_function_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, PlSqlParserRULE_map_order_function_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1952)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserMAP || _la == PlSqlParserORDER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1953)
		p.Match(PlSqlParserMEMBER)
	}
	{
		p.SetState(1954)
		p.Type_function_spec()
	}

	return localctx
}

// IPragma_clauseContext is an interface to support dynamic dispatch.
type IPragma_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPragma_clauseContext differentiates from other interfaces.
	IsPragma_clauseContext()
}

type Pragma_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragma_clauseContext() *Pragma_clauseContext {
	var p = new(Pragma_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pragma_clause
	return p
}

func (*Pragma_clauseContext) IsPragma_clauseContext() {}

func NewPragma_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pragma_clauseContext {
	var p = new(Pragma_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pragma_clause

	return p
}

func (s *Pragma_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Pragma_clauseContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRAGMA, 0)
}

func (s *Pragma_clauseContext) RESTRICT_REFERENCES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESTRICT_REFERENCES, 0)
}

func (s *Pragma_clauseContext) AllPragma_elements() []IPragma_elementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPragma_elementsContext)(nil)).Elem())
	var tst = make([]IPragma_elementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPragma_elementsContext)
		}
	}

	return tst
}

func (s *Pragma_clauseContext) Pragma_elements(i int) IPragma_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPragma_elementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPragma_elementsContext)
}

func (s *Pragma_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pragma_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pragma_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPragma_clause(s)
	}
}

func (s *Pragma_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPragma_clause(s)
	}
}

func (p *PlSqlParser) Pragma_clause() (localctx IPragma_clauseContext) {
	localctx = NewPragma_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, PlSqlParserRULE_pragma_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1956)
		p.Match(PlSqlParserPRAGMA)
	}
	{
		p.SetState(1957)
		p.Match(PlSqlParserRESTRICT_REFERENCES)
	}
	{
		p.SetState(1958)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(1959)
		p.Pragma_elements()
	}
	p.SetState(1964)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(1960)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(1961)
			p.Pragma_elements()
		}

		p.SetState(1966)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1967)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IPragma_elementsContext is an interface to support dynamic dispatch.
type IPragma_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPragma_elementsContext differentiates from other interfaces.
	IsPragma_elementsContext()
}

type Pragma_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragma_elementsContext() *Pragma_elementsContext {
	var p = new(Pragma_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pragma_elements
	return p
}

func (*Pragma_elementsContext) IsPragma_elementsContext() {}

func NewPragma_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pragma_elementsContext {
	var p = new(Pragma_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pragma_elements

	return p
}

func (s *Pragma_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Pragma_elementsContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Pragma_elementsContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFAULT, 0)
}

func (s *Pragma_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pragma_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pragma_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPragma_elements(s)
	}
}

func (s *Pragma_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPragma_elements(s)
	}
}

func (p *PlSqlParser) Pragma_elements() (localctx IPragma_elementsContext) {
	localctx = NewPragma_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, PlSqlParserRULE_pragma_elements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1971)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1969)
			p.Identifier()
		}

	case PlSqlParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1970)
			p.Match(PlSqlParserDEFAULT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_elements_parameterContext is an interface to support dynamic dispatch.
type IType_elements_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_elements_parameterContext differentiates from other interfaces.
	IsType_elements_parameterContext()
}

type Type_elements_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_elements_parameterContext() *Type_elements_parameterContext {
	var p = new(Type_elements_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_type_elements_parameter
	return p
}

func (*Type_elements_parameterContext) IsType_elements_parameterContext() {}

func NewType_elements_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_elements_parameterContext {
	var p = new(Type_elements_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_type_elements_parameter

	return p
}

func (s *Type_elements_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_elements_parameterContext) Parameter_name() IParameter_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_nameContext)
}

func (s *Type_elements_parameterContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Type_elements_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_elements_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_elements_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterType_elements_parameter(s)
	}
}

func (s *Type_elements_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitType_elements_parameter(s)
	}
}

func (p *PlSqlParser) Type_elements_parameter() (localctx IType_elements_parameterContext) {
	localctx = NewType_elements_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, PlSqlParserRULE_type_elements_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1973)
		p.Parameter_name()
	}
	{
		p.SetState(1974)
		p.Type_spec()
	}

	return localctx
}

// IDrop_sequenceContext is an interface to support dynamic dispatch.
type IDrop_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_sequenceContext differentiates from other interfaces.
	IsDrop_sequenceContext()
}

type Drop_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_sequenceContext() *Drop_sequenceContext {
	var p = new(Drop_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_drop_sequence
	return p
}

func (*Drop_sequenceContext) IsDrop_sequenceContext() {}

func NewDrop_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_sequenceContext {
	var p = new(Drop_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_drop_sequence

	return p
}

func (s *Drop_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_sequenceContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Drop_sequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEQUENCE, 0)
}

func (s *Drop_sequenceContext) Sequence_name() ISequence_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_nameContext)
}

func (s *Drop_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDrop_sequence(s)
	}
}

func (s *Drop_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDrop_sequence(s)
	}
}

func (p *PlSqlParser) Drop_sequence() (localctx IDrop_sequenceContext) {
	localctx = NewDrop_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, PlSqlParserRULE_drop_sequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1976)
		p.Match(PlSqlParserDROP)
	}
	{
		p.SetState(1977)
		p.Match(PlSqlParserSEQUENCE)
	}
	{
		p.SetState(1978)
		p.Sequence_name()
	}
	{
		p.SetState(1979)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IAlter_sequenceContext is an interface to support dynamic dispatch.
type IAlter_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_sequenceContext differentiates from other interfaces.
	IsAlter_sequenceContext()
}

type Alter_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_sequenceContext() *Alter_sequenceContext {
	var p = new(Alter_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_sequence
	return p
}

func (*Alter_sequenceContext) IsAlter_sequenceContext() {}

func NewAlter_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_sequenceContext {
	var p = new(Alter_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_sequence

	return p
}

func (s *Alter_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_sequenceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *Alter_sequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEQUENCE, 0)
}

func (s *Alter_sequenceContext) Sequence_name() ISequence_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_nameContext)
}

func (s *Alter_sequenceContext) AllSequence_spec() []ISequence_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_specContext)(nil)).Elem())
	var tst = make([]ISequence_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_specContext)
		}
	}

	return tst
}

func (s *Alter_sequenceContext) Sequence_spec(i int) ISequence_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_specContext)
}

func (s *Alter_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_sequence(s)
	}
}

func (s *Alter_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_sequence(s)
	}
}

func (p *PlSqlParser) Alter_sequence() (localctx IAlter_sequenceContext) {
	localctx = NewAlter_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, PlSqlParserRULE_alter_sequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1981)
		p.Match(PlSqlParserALTER)
	}
	{
		p.SetState(1982)
		p.Match(PlSqlParserSEQUENCE)
	}
	{
		p.SetState(1983)
		p.Sequence_name()
	}
	p.SetState(1985)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PlSqlParserCACHE || _la == PlSqlParserCYCLE || _la == PlSqlParserINCREMENT || (((_la-237)&-(0x1f+1)) == 0 && ((1<<uint((_la-237)))&((1<<(PlSqlParserMAXVALUE-237))|(1<<(PlSqlParserMINVALUE-237))|(1<<(PlSqlParserNOCACHE-237))|(1<<(PlSqlParserNOCYCLE-237)))) != 0) || (((_la-269)&-(0x1f+1)) == 0 && ((1<<uint((_la-269)))&((1<<(PlSqlParserNOMAXVALUE-269))|(1<<(PlSqlParserNOMINVALUE-269))|(1<<(PlSqlParserNOORDER-269))|(1<<(PlSqlParserORDER-269)))) != 0) {
		{
			p.SetState(1984)
			p.Sequence_spec()
		}

		p.SetState(1987)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1989)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ICreate_sequenceContext is an interface to support dynamic dispatch.
type ICreate_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_sequenceContext differentiates from other interfaces.
	IsCreate_sequenceContext()
}

type Create_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_sequenceContext() *Create_sequenceContext {
	var p = new(Create_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_sequence
	return p
}

func (*Create_sequenceContext) IsCreate_sequenceContext() {}

func NewCreate_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_sequenceContext {
	var p = new(Create_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_sequence

	return p
}

func (s *Create_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_sequenceContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_sequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEQUENCE, 0)
}

func (s *Create_sequenceContext) Sequence_name() ISequence_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_nameContext)
}

func (s *Create_sequenceContext) AllSequence_start_clause() []ISequence_start_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_start_clauseContext)(nil)).Elem())
	var tst = make([]ISequence_start_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_start_clauseContext)
		}
	}

	return tst
}

func (s *Create_sequenceContext) Sequence_start_clause(i int) ISequence_start_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_start_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_start_clauseContext)
}

func (s *Create_sequenceContext) AllSequence_spec() []ISequence_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_specContext)(nil)).Elem())
	var tst = make([]ISequence_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_specContext)
		}
	}

	return tst
}

func (s *Create_sequenceContext) Sequence_spec(i int) ISequence_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_specContext)
}

func (s *Create_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_sequence(s)
	}
}

func (s *Create_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_sequence(s)
	}
}

func (p *PlSqlParser) Create_sequence() (localctx ICreate_sequenceContext) {
	localctx = NewCreate_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, PlSqlParserRULE_create_sequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1991)
		p.Match(PlSqlParserCREATE)
	}
	{
		p.SetState(1992)
		p.Match(PlSqlParserSEQUENCE)
	}
	{
		p.SetState(1993)
		p.Sequence_name()
	}
	p.SetState(1998)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCACHE || _la == PlSqlParserCYCLE || _la == PlSqlParserINCREMENT || (((_la-237)&-(0x1f+1)) == 0 && ((1<<uint((_la-237)))&((1<<(PlSqlParserMAXVALUE-237))|(1<<(PlSqlParserMINVALUE-237))|(1<<(PlSqlParserNOCACHE-237))|(1<<(PlSqlParserNOCYCLE-237)))) != 0) || (((_la-269)&-(0x1f+1)) == 0 && ((1<<uint((_la-269)))&((1<<(PlSqlParserNOMAXVALUE-269))|(1<<(PlSqlParserNOMINVALUE-269))|(1<<(PlSqlParserNOORDER-269))|(1<<(PlSqlParserORDER-269)))) != 0) || _la == PlSqlParserSTART {
		p.SetState(1996)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserSTART:
			{
				p.SetState(1994)
				p.Sequence_start_clause()
			}

		case PlSqlParserCACHE, PlSqlParserCYCLE, PlSqlParserINCREMENT, PlSqlParserMAXVALUE, PlSqlParserMINVALUE, PlSqlParserNOCACHE, PlSqlParserNOCYCLE, PlSqlParserNOMAXVALUE, PlSqlParserNOMINVALUE, PlSqlParserNOORDER, PlSqlParserORDER:
			{
				p.SetState(1995)
				p.Sequence_spec()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2000)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2001)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ISequence_specContext is an interface to support dynamic dispatch.
type ISequence_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_specContext differentiates from other interfaces.
	IsSequence_specContext()
}

type Sequence_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_specContext() *Sequence_specContext {
	var p = new(Sequence_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_sequence_spec
	return p
}

func (*Sequence_specContext) IsSequence_specContext() {}

func NewSequence_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_specContext {
	var p = new(Sequence_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_sequence_spec

	return p
}

func (s *Sequence_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_specContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINCREMENT, 0)
}

func (s *Sequence_specContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Sequence_specContext) UNSIGNED_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNSIGNED_INTEGER, 0)
}

func (s *Sequence_specContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAXVALUE, 0)
}

func (s *Sequence_specContext) NOMAXVALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOMAXVALUE, 0)
}

func (s *Sequence_specContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINVALUE, 0)
}

func (s *Sequence_specContext) NOMINVALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOMINVALUE, 0)
}

func (s *Sequence_specContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCYCLE, 0)
}

func (s *Sequence_specContext) NOCYCLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOCYCLE, 0)
}

func (s *Sequence_specContext) CACHE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCACHE, 0)
}

func (s *Sequence_specContext) NOCACHE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOCACHE, 0)
}

func (s *Sequence_specContext) ORDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORDER, 0)
}

func (s *Sequence_specContext) NOORDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOORDER, 0)
}

func (s *Sequence_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSequence_spec(s)
	}
}

func (s *Sequence_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSequence_spec(s)
	}
}

func (p *PlSqlParser) Sequence_spec() (localctx ISequence_specContext) {
	localctx = NewSequence_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, PlSqlParserRULE_sequence_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserINCREMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2003)
			p.Match(PlSqlParserINCREMENT)
		}
		{
			p.SetState(2004)
			p.Match(PlSqlParserBY)
		}
		{
			p.SetState(2005)
			p.Match(PlSqlParserUNSIGNED_INTEGER)
		}

	case PlSqlParserMAXVALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2006)
			p.Match(PlSqlParserMAXVALUE)
		}
		{
			p.SetState(2007)
			p.Match(PlSqlParserUNSIGNED_INTEGER)
		}

	case PlSqlParserNOMAXVALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2008)
			p.Match(PlSqlParserNOMAXVALUE)
		}

	case PlSqlParserMINVALUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2009)
			p.Match(PlSqlParserMINVALUE)
		}
		{
			p.SetState(2010)
			p.Match(PlSqlParserUNSIGNED_INTEGER)
		}

	case PlSqlParserNOMINVALUE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2011)
			p.Match(PlSqlParserNOMINVALUE)
		}

	case PlSqlParserCYCLE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2012)
			p.Match(PlSqlParserCYCLE)
		}

	case PlSqlParserNOCYCLE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2013)
			p.Match(PlSqlParserNOCYCLE)
		}

	case PlSqlParserCACHE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2014)
			p.Match(PlSqlParserCACHE)
		}
		{
			p.SetState(2015)
			p.Match(PlSqlParserUNSIGNED_INTEGER)
		}

	case PlSqlParserNOCACHE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2016)
			p.Match(PlSqlParserNOCACHE)
		}

	case PlSqlParserORDER:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2017)
			p.Match(PlSqlParserORDER)
		}

	case PlSqlParserNOORDER:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2018)
			p.Match(PlSqlParserNOORDER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISequence_start_clauseContext is an interface to support dynamic dispatch.
type ISequence_start_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_start_clauseContext differentiates from other interfaces.
	IsSequence_start_clauseContext()
}

type Sequence_start_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_start_clauseContext() *Sequence_start_clauseContext {
	var p = new(Sequence_start_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_sequence_start_clause
	return p
}

func (*Sequence_start_clauseContext) IsSequence_start_clauseContext() {}

func NewSequence_start_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_start_clauseContext {
	var p = new(Sequence_start_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_sequence_start_clause

	return p
}

func (s *Sequence_start_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_start_clauseContext) START() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTART, 0)
}

func (s *Sequence_start_clauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWITH, 0)
}

func (s *Sequence_start_clauseContext) UNSIGNED_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNSIGNED_INTEGER, 0)
}

func (s *Sequence_start_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_start_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_start_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSequence_start_clause(s)
	}
}

func (s *Sequence_start_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSequence_start_clause(s)
	}
}

func (p *PlSqlParser) Sequence_start_clause() (localctx ISequence_start_clauseContext) {
	localctx = NewSequence_start_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, PlSqlParserRULE_sequence_start_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2021)
		p.Match(PlSqlParserSTART)
	}
	{
		p.SetState(2022)
		p.Match(PlSqlParserWITH)
	}
	{
		p.SetState(2023)
		p.Match(PlSqlParserUNSIGNED_INTEGER)
	}

	return localctx
}

// ICreate_indexContext is an interface to support dynamic dispatch.
type ICreate_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_indexContext differentiates from other interfaces.
	IsCreate_indexContext()
}

type Create_indexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_indexContext() *Create_indexContext {
	var p = new(Create_indexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_index
	return p
}

func (*Create_indexContext) IsCreate_indexContext() {}

func NewCreate_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_indexContext {
	var p = new(Create_indexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_index

	return p
}

func (s *Create_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_indexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDEX, 0)
}

func (s *Create_indexContext) Index_name() IIndex_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_nameContext)
}

func (s *Create_indexContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Create_indexContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Create_indexContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Create_indexContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Create_indexContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNIQUE, 0)
}

func (s *Create_indexContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPUTE, 0)
}

func (s *Create_indexContext) STATISTICS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATISTICS, 0)
}

func (s *Create_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_index(s)
	}
}

func (s *Create_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_index(s)
	}
}

func (p *PlSqlParser) Create_index() (localctx ICreate_indexContext) {
	localctx = NewCreate_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, PlSqlParserRULE_create_index)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2025)
		p.Match(PlSqlParserCREATE)
	}
	p.SetState(2027)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserUNIQUE {
		{
			p.SetState(2026)
			p.Match(PlSqlParserUNIQUE)
		}

	}
	{
		p.SetState(2029)
		p.Match(PlSqlParserINDEX)
	}
	{
		p.SetState(2030)
		p.Index_name()
	}
	{
		p.SetState(2031)
		p.Match(PlSqlParserON)
	}
	{
		p.SetState(2032)
		p.Tableview_name()
	}
	{
		p.SetState(2033)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2034)
		p.Column_name()
	}
	p.SetState(2039)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(2035)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(2036)
			p.Column_name()
		}

		p.SetState(2041)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2042)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(2045)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserCOMPUTE {
		{
			p.SetState(2043)
			p.Match(PlSqlParserCOMPUTE)
		}
		{
			p.SetState(2044)
			p.Match(PlSqlParserSTATISTICS)
		}

	}
	{
		p.SetState(2047)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IAlter_indexContext is an interface to support dynamic dispatch.
type IAlter_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOld_index_name returns the old_index_name rule contexts.
	GetOld_index_name() IIndex_nameContext

	// GetNew_index_name returns the new_index_name rule contexts.
	GetNew_index_name() IIndex_nameContext

	// SetOld_index_name sets the old_index_name rule contexts.
	SetOld_index_name(IIndex_nameContext)

	// SetNew_index_name sets the new_index_name rule contexts.
	SetNew_index_name(IIndex_nameContext)

	// IsAlter_indexContext differentiates from other interfaces.
	IsAlter_indexContext()
}

type Alter_indexContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	old_index_name IIndex_nameContext
	new_index_name IIndex_nameContext
}

func NewEmptyAlter_indexContext() *Alter_indexContext {
	var p = new(Alter_indexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_index
	return p
}

func (*Alter_indexContext) IsAlter_indexContext() {}

func NewAlter_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_indexContext {
	var p = new(Alter_indexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_index

	return p
}

func (s *Alter_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_indexContext) GetOld_index_name() IIndex_nameContext { return s.old_index_name }

func (s *Alter_indexContext) GetNew_index_name() IIndex_nameContext { return s.new_index_name }

func (s *Alter_indexContext) SetOld_index_name(v IIndex_nameContext) { s.old_index_name = v }

func (s *Alter_indexContext) SetNew_index_name(v IIndex_nameContext) { s.new_index_name = v }

func (s *Alter_indexContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *Alter_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDEX, 0)
}

func (s *Alter_indexContext) RENAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRENAME, 0)
}

func (s *Alter_indexContext) TO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO, 0)
}

func (s *Alter_indexContext) AllIndex_name() []IIndex_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndex_nameContext)(nil)).Elem())
	var tst = make([]IIndex_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndex_nameContext)
		}
	}

	return tst
}

func (s *Alter_indexContext) Index_name(i int) IIndex_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndex_nameContext)
}

func (s *Alter_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_index(s)
	}
}

func (s *Alter_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_index(s)
	}
}

func (p *PlSqlParser) Alter_index() (localctx IAlter_indexContext) {
	localctx = NewAlter_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, PlSqlParserRULE_alter_index)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2049)
		p.Match(PlSqlParserALTER)
	}
	{
		p.SetState(2050)
		p.Match(PlSqlParserINDEX)
	}
	{
		p.SetState(2051)

		var _x = p.Index_name()

		localctx.(*Alter_indexContext).old_index_name = _x
	}
	{
		p.SetState(2052)
		p.Match(PlSqlParserRENAME)
	}
	{
		p.SetState(2053)
		p.Match(PlSqlParserTO)
	}
	{
		p.SetState(2054)

		var _x = p.Index_name()

		localctx.(*Alter_indexContext).new_index_name = _x
	}
	{
		p.SetState(2055)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IDrop_indexContext is an interface to support dynamic dispatch.
type IDrop_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_indexContext differentiates from other interfaces.
	IsDrop_indexContext()
}

type Drop_indexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_indexContext() *Drop_indexContext {
	var p = new(Drop_indexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_drop_index
	return p
}

func (*Drop_indexContext) IsDrop_indexContext() {}

func NewDrop_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_indexContext {
	var p = new(Drop_indexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_drop_index

	return p
}

func (s *Drop_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_indexContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Drop_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDEX, 0)
}

func (s *Drop_indexContext) Index_name() IIndex_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_nameContext)
}

func (s *Drop_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDrop_index(s)
	}
}

func (s *Drop_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDrop_index(s)
	}
}

func (p *PlSqlParser) Drop_index() (localctx IDrop_indexContext) {
	localctx = NewDrop_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, PlSqlParserRULE_drop_index)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2057)
		p.Match(PlSqlParserDROP)
	}
	{
		p.SetState(2058)
		p.Match(PlSqlParserINDEX)
	}
	{
		p.SetState(2059)
		p.Index_name()
	}
	{
		p.SetState(2060)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ICreate_tableContext is an interface to support dynamic dispatch.
type ICreate_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPctfree returns the pctfree token.
	GetPctfree() antlr.Token

	// GetPctused returns the pctused token.
	GetPctused() antlr.Token

	// GetInittrans returns the inittrans token.
	GetInittrans() antlr.Token

	// GetMinextents returns the minextents token.
	GetMinextents() antlr.Token

	// GetPctincrease returns the pctincrease token.
	GetPctincrease() antlr.Token

	// GetFreelists returns the freelists token.
	GetFreelists() antlr.Token

	// GetFreelist_groups returns the freelist_groups token.
	GetFreelist_groups() antlr.Token

	// GetTablespace_name returns the tablespace_name token.
	GetTablespace_name() antlr.Token

	// SetPctfree sets the pctfree token.
	SetPctfree(antlr.Token)

	// SetPctused sets the pctused token.
	SetPctused(antlr.Token)

	// SetInittrans sets the inittrans token.
	SetInittrans(antlr.Token)

	// SetMinextents sets the minextents token.
	SetMinextents(antlr.Token)

	// SetPctincrease sets the pctincrease token.
	SetPctincrease(antlr.Token)

	// SetFreelists sets the freelists token.
	SetFreelists(antlr.Token)

	// SetFreelist_groups sets the freelist_groups token.
	SetFreelist_groups(antlr.Token)

	// SetTablespace_name sets the tablespace_name token.
	SetTablespace_name(antlr.Token)

	// GetInitial returns the initial rule contexts.
	GetInitial() ISize_clauseContext

	// GetNext returns the next rule contexts.
	GetNext() ISize_clauseContext

	// SetInitial sets the initial rule contexts.
	SetInitial(ISize_clauseContext)

	// SetNext sets the next rule contexts.
	SetNext(ISize_clauseContext)

	// IsCreate_tableContext differentiates from other interfaces.
	IsCreate_tableContext()
}

type Create_tableContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	pctfree         antlr.Token
	pctused         antlr.Token
	inittrans       antlr.Token
	initial         ISize_clauseContext
	next            ISize_clauseContext
	minextents      antlr.Token
	pctincrease     antlr.Token
	freelists       antlr.Token
	freelist_groups antlr.Token
	tablespace_name antlr.Token
}

func NewEmptyCreate_tableContext() *Create_tableContext {
	var p = new(Create_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_table
	return p
}

func (*Create_tableContext) IsCreate_tableContext() {}

func NewCreate_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_tableContext {
	var p = new(Create_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_table

	return p
}

func (s *Create_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_tableContext) GetPctfree() antlr.Token { return s.pctfree }

func (s *Create_tableContext) GetPctused() antlr.Token { return s.pctused }

func (s *Create_tableContext) GetInittrans() antlr.Token { return s.inittrans }

func (s *Create_tableContext) GetMinextents() antlr.Token { return s.minextents }

func (s *Create_tableContext) GetPctincrease() antlr.Token { return s.pctincrease }

func (s *Create_tableContext) GetFreelists() antlr.Token { return s.freelists }

func (s *Create_tableContext) GetFreelist_groups() antlr.Token { return s.freelist_groups }

func (s *Create_tableContext) GetTablespace_name() antlr.Token { return s.tablespace_name }

func (s *Create_tableContext) SetPctfree(v antlr.Token) { s.pctfree = v }

func (s *Create_tableContext) SetPctused(v antlr.Token) { s.pctused = v }

func (s *Create_tableContext) SetInittrans(v antlr.Token) { s.inittrans = v }

func (s *Create_tableContext) SetMinextents(v antlr.Token) { s.minextents = v }

func (s *Create_tableContext) SetPctincrease(v antlr.Token) { s.pctincrease = v }

func (s *Create_tableContext) SetFreelists(v antlr.Token) { s.freelists = v }

func (s *Create_tableContext) SetFreelist_groups(v antlr.Token) { s.freelist_groups = v }

func (s *Create_tableContext) SetTablespace_name(v antlr.Token) { s.tablespace_name = v }

func (s *Create_tableContext) GetInitial() ISize_clauseContext { return s.initial }

func (s *Create_tableContext) GetNext() ISize_clauseContext { return s.next }

func (s *Create_tableContext) SetInitial(v ISize_clauseContext) { s.initial = v }

func (s *Create_tableContext) SetNext(v ISize_clauseContext) { s.next = v }

func (s *Create_tableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_tableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Create_tableContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Create_tableContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserLEFT_PAREN)
}

func (s *Create_tableContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEFT_PAREN, i)
}

func (s *Create_tableContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Create_tableContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Create_tableContext) AllDatatype() []IDatatypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatatypeContext)(nil)).Elem())
	var tst = make([]IDatatypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatatypeContext)
		}
	}

	return tst
}

func (s *Create_tableContext) Datatype(i int) IDatatypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatatypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatatypeContext)
}

func (s *Create_tableContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserRIGHT_PAREN)
}

func (s *Create_tableContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserRIGHT_PAREN, i)
}

func (s *Create_tableContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEMICOLON, 0)
}

func (s *Create_tableContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserGLOBAL, 0)
}

func (s *Create_tableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTEMPORARY, 0)
}

func (s *Create_tableContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Create_tableContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMIT, 0)
}

func (s *Create_tableContext) ROWS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROWS, 0)
}

func (s *Create_tableContext) SEGMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEGMENT, 0)
}

func (s *Create_tableContext) CREATION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATION, 0)
}

func (s *Create_tableContext) AllPCTFREE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserPCTFREE)
}

func (s *Create_tableContext) PCTFREE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserPCTFREE, i)
}

func (s *Create_tableContext) AllPCTUSED() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserPCTUSED)
}

func (s *Create_tableContext) PCTUSED(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserPCTUSED, i)
}

func (s *Create_tableContext) AllINITRANS() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserINITRANS)
}

func (s *Create_tableContext) INITRANS(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserINITRANS, i)
}

func (s *Create_tableContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTORAGE, 0)
}

func (s *Create_tableContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLESPACE, 0)
}

func (s *Create_tableContext) COMPRESS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPRESS, 0)
}

func (s *Create_tableContext) NOCOMPRESS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOCOMPRESS, 0)
}

func (s *Create_tableContext) DELETE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDELETE, 0)
}

func (s *Create_tableContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRESERVE, 0)
}

func (s *Create_tableContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIMMEDIATE, 0)
}

func (s *Create_tableContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFERRED, 0)
}

func (s *Create_tableContext) AllUNSIGNED_INTEGER() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserUNSIGNED_INTEGER)
}

func (s *Create_tableContext) UNSIGNED_INTEGER(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNSIGNED_INTEGER, i)
}

func (s *Create_tableContext) REGULAR_ID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREGULAR_ID, 0)
}

func (s *Create_tableContext) LOGGING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOGGING, 0)
}

func (s *Create_tableContext) NOLOGGING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOLOGGING, 0)
}

func (s *Create_tableContext) FILESYSTEM_LIKE_LOGGING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFILESYSTEM_LIKE_LOGGING, 0)
}

func (s *Create_tableContext) AllINITIAL() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserINITIAL)
}

func (s *Create_tableContext) INITIAL(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserINITIAL, i)
}

func (s *Create_tableContext) AllNEXT() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserNEXT)
}

func (s *Create_tableContext) NEXT(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserNEXT, i)
}

func (s *Create_tableContext) AllMINEXTENTS() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserMINEXTENTS)
}

func (s *Create_tableContext) MINEXTENTS(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINEXTENTS, i)
}

func (s *Create_tableContext) AllPCTINCREASE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserPCTINCREASE)
}

func (s *Create_tableContext) PCTINCREASE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserPCTINCREASE, i)
}

func (s *Create_tableContext) AllFREELISTS() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserFREELISTS)
}

func (s *Create_tableContext) FREELISTS(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserFREELISTS, i)
}

func (s *Create_tableContext) AllFREELIST() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserFREELIST)
}

func (s *Create_tableContext) FREELIST(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserFREELIST, i)
}

func (s *Create_tableContext) AllGROUPS() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserGROUPS)
}

func (s *Create_tableContext) GROUPS(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserGROUPS, i)
}

func (s *Create_tableContext) AllOPTIMAL() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserOPTIMAL)
}

func (s *Create_tableContext) OPTIMAL(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserOPTIMAL, i)
}

func (s *Create_tableContext) AllBUFFER_POOL() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserBUFFER_POOL)
}

func (s *Create_tableContext) BUFFER_POOL(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserBUFFER_POOL, i)
}

func (s *Create_tableContext) AllFLASH_CACHE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserFLASH_CACHE)
}

func (s *Create_tableContext) FLASH_CACHE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserFLASH_CACHE, i)
}

func (s *Create_tableContext) AllENCRYPT() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserENCRYPT)
}

func (s *Create_tableContext) ENCRYPT(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserENCRYPT, i)
}

func (s *Create_tableContext) BASIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBASIC, 0)
}

func (s *Create_tableContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Create_tableContext) AllSize_clause() []ISize_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISize_clauseContext)(nil)).Elem())
	var tst = make([]ISize_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISize_clauseContext)
		}
	}

	return tst
}

func (s *Create_tableContext) Size_clause(i int) ISize_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISize_clauseContext)
}

func (s *Create_tableContext) AllKEEP() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserKEEP)
}

func (s *Create_tableContext) KEEP(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserKEEP, i)
}

func (s *Create_tableContext) AllRECYCLE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserRECYCLE)
}

func (s *Create_tableContext) RECYCLE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserRECYCLE, i)
}

func (s *Create_tableContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserDEFAULT)
}

func (s *Create_tableContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFAULT, i)
}

func (s *Create_tableContext) AllNONE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserNONE)
}

func (s *Create_tableContext) NONE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserNONE, i)
}

func (s *Create_tableContext) AllUNLIMITED() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserUNLIMITED)
}

func (s *Create_tableContext) UNLIMITED(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNLIMITED, i)
}

func (s *Create_tableContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserNULL)
}

func (s *Create_tableContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, i)
}

func (s *Create_tableContext) OLTP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOLTP, 0)
}

func (s *Create_tableContext) QUERY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserQUERY, 0)
}

func (s *Create_tableContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserARCHIVE, 0)
}

func (s *Create_tableContext) LOW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOW, 0)
}

func (s *Create_tableContext) HIGH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserHIGH, 0)
}

func (s *Create_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_table(s)
	}
}

func (s *Create_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_table(s)
	}
}

func (p *PlSqlParser) Create_table() (localctx ICreate_tableContext) {
	localctx = NewCreate_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, PlSqlParserRULE_create_table)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2062)
		p.Match(PlSqlParserCREATE)
	}
	p.SetState(2065)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserGLOBAL {
		{
			p.SetState(2063)
			p.Match(PlSqlParserGLOBAL)
		}
		{
			p.SetState(2064)
			p.Match(PlSqlParserTEMPORARY)
		}

	}
	{
		p.SetState(2067)
		p.Match(PlSqlParserTABLE)
	}
	{
		p.SetState(2068)
		p.Tableview_name()
	}
	{
		p.SetState(2069)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2070)
		p.Column_name()
	}
	{
		p.SetState(2071)
		p.Datatype()
	}
	p.SetState(2078)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(2072)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(2073)
			p.Column_name()
		}
		{
			p.SetState(2074)
			p.Datatype()
		}

		p.SetState(2080)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2081)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(2086)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserON {
		{
			p.SetState(2082)
			p.Match(PlSqlParserON)
		}
		{
			p.SetState(2083)
			p.Match(PlSqlParserCOMMIT)
		}
		{
			p.SetState(2084)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserDELETE || _la == PlSqlParserPRESERVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2085)
			p.Match(PlSqlParserROWS)
		}

	}
	p.SetState(2091)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserSEGMENT {
		{
			p.SetState(2088)
			p.Match(PlSqlParserSEGMENT)
		}
		{
			p.SetState(2089)
			p.Match(PlSqlParserCREATION)
		}
		{
			p.SetState(2090)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserDEFERRED || _la == PlSqlParserIMMEDIATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2101)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserINITRANS || _la == PlSqlParserPCTFREE || _la == PlSqlParserPCTUSED {
		p.SetState(2099)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserPCTFREE:
			{
				p.SetState(2093)
				p.Match(PlSqlParserPCTFREE)
			}
			{
				p.SetState(2094)

				var _m = p.Match(PlSqlParserUNSIGNED_INTEGER)

				localctx.(*Create_tableContext).pctfree = _m
			}

		case PlSqlParserPCTUSED:
			{
				p.SetState(2095)
				p.Match(PlSqlParserPCTUSED)
			}
			{
				p.SetState(2096)

				var _m = p.Match(PlSqlParserUNSIGNED_INTEGER)

				localctx.(*Create_tableContext).pctused = _m
			}

		case PlSqlParserINITRANS:
			{
				p.SetState(2097)
				p.Match(PlSqlParserINITRANS)
			}
			{
				p.SetState(2098)

				var _m = p.Match(PlSqlParserUNSIGNED_INTEGER)

				localctx.(*Create_tableContext).inittrans = _m
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2103)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2134)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserSTORAGE {
		{
			p.SetState(2104)
			p.Match(PlSqlParserSTORAGE)
		}
		{
			p.SetState(2105)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(2129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PlSqlParserBUFFER_POOL || _la == PlSqlParserENCRYPT || _la == PlSqlParserFLASH_CACHE || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(PlSqlParserFREELIST-161))|(1<<(PlSqlParserFREELISTS-161))|(1<<(PlSqlParserINITIAL-161)))) != 0) || _la == PlSqlParserMINEXTENTS || _la == PlSqlParserNEXT || _la == PlSqlParserOPTIMAL || _la == PlSqlParserPCTINCREASE {
			p.SetState(2129)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PlSqlParserINITIAL:
				{
					p.SetState(2106)
					p.Match(PlSqlParserINITIAL)
				}
				{
					p.SetState(2107)

					var _x = p.Size_clause()

					localctx.(*Create_tableContext).initial = _x
				}

			case PlSqlParserNEXT:
				{
					p.SetState(2108)
					p.Match(PlSqlParserNEXT)
				}
				{
					p.SetState(2109)

					var _x = p.Size_clause()

					localctx.(*Create_tableContext).next = _x
				}

			case PlSqlParserMINEXTENTS:
				{
					p.SetState(2110)
					p.Match(PlSqlParserMINEXTENTS)
				}
				{
					p.SetState(2111)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Create_tableContext).minextents = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserUNLIMITED || _la == PlSqlParserUNSIGNED_INTEGER) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Create_tableContext).minextents = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case PlSqlParserPCTINCREASE:
				{
					p.SetState(2112)
					p.Match(PlSqlParserPCTINCREASE)
				}
				{
					p.SetState(2113)

					var _m = p.Match(PlSqlParserUNSIGNED_INTEGER)

					localctx.(*Create_tableContext).pctincrease = _m
				}

			case PlSqlParserFREELISTS:
				{
					p.SetState(2114)
					p.Match(PlSqlParserFREELISTS)
				}
				{
					p.SetState(2115)

					var _m = p.Match(PlSqlParserUNSIGNED_INTEGER)

					localctx.(*Create_tableContext).freelists = _m
				}

			case PlSqlParserFREELIST:
				{
					p.SetState(2116)
					p.Match(PlSqlParserFREELIST)
				}
				{
					p.SetState(2117)
					p.Match(PlSqlParserGROUPS)
				}
				{
					p.SetState(2118)

					var _m = p.Match(PlSqlParserUNSIGNED_INTEGER)

					localctx.(*Create_tableContext).freelist_groups = _m
				}

			case PlSqlParserOPTIMAL:
				{
					p.SetState(2119)
					p.Match(PlSqlParserOPTIMAL)
				}
				p.SetState(2122)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case PlSqlParserUNSIGNED_INTEGER:
					{
						p.SetState(2120)
						p.Size_clause()
					}

				case PlSqlParserNULL:
					{
						p.SetState(2121)
						p.Match(PlSqlParserNULL)
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			case PlSqlParserBUFFER_POOL:
				{
					p.SetState(2124)
					p.Match(PlSqlParserBUFFER_POOL)
				}
				{
					p.SetState(2125)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserDEFAULT || _la == PlSqlParserKEEP || _la == PlSqlParserRECYCLE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case PlSqlParserFLASH_CACHE:
				{
					p.SetState(2126)
					p.Match(PlSqlParserFLASH_CACHE)
				}
				{
					p.SetState(2127)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserDEFAULT || _la == PlSqlParserKEEP || _la == PlSqlParserNONE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case PlSqlParserENCRYPT:
				{
					p.SetState(2128)
					p.Match(PlSqlParserENCRYPT)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(2131)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2133)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	p.SetState(2138)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserTABLESPACE {
		{
			p.SetState(2136)
			p.Match(PlSqlParserTABLESPACE)
		}
		{
			p.SetState(2137)

			var _m = p.Match(PlSqlParserREGULAR_ID)

			localctx.(*Create_tableContext).tablespace_name = _m
		}

	}
	p.SetState(2141)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserFILESYSTEM_LIKE_LOGGING || _la == PlSqlParserLOGGING || _la == PlSqlParserNOLOGGING {
		{
			p.SetState(2140)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserFILESYSTEM_LIKE_LOGGING || _la == PlSqlParserLOGGING || _la == PlSqlParserNOLOGGING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2156)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserCOMPRESS:
		{
			p.SetState(2143)
			p.Match(PlSqlParserCOMPRESS)
		}
		p.SetState(2153)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserBASIC:
			{
				p.SetState(2144)
				p.Match(PlSqlParserBASIC)
			}

		case PlSqlParserFOR:
			{
				p.SetState(2145)
				p.Match(PlSqlParserFOR)
			}
			p.SetState(2151)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PlSqlParserOLTP:
				{
					p.SetState(2146)
					p.Match(PlSqlParserOLTP)
				}

			case PlSqlParserARCHIVE, PlSqlParserQUERY:
				{
					p.SetState(2147)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserARCHIVE || _la == PlSqlParserQUERY) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(2149)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == PlSqlParserHIGH || _la == PlSqlParserLOW {
					{
						p.SetState(2148)
						_la = p.GetTokenStream().LA(1)

						if !(_la == PlSqlParserHIGH || _la == PlSqlParserLOW) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case PlSqlParserSEMICOLON:

		default:
		}

	case PlSqlParserNOCOMPRESS:
		{
			p.SetState(2155)
			p.Match(PlSqlParserNOCOMPRESS)
		}

	case PlSqlParserSEMICOLON:

	default:
	}
	{
		p.SetState(2158)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ISize_clauseContext is an interface to support dynamic dispatch.
type ISize_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSize_clauseContext differentiates from other interfaces.
	IsSize_clauseContext()
}

type Size_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySize_clauseContext() *Size_clauseContext {
	var p = new(Size_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_size_clause
	return p
}

func (*Size_clauseContext) IsSize_clauseContext() {}

func NewSize_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Size_clauseContext {
	var p = new(Size_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_size_clause

	return p
}

func (s *Size_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Size_clauseContext) UNSIGNED_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNSIGNED_INTEGER, 0)
}

func (s *Size_clauseContext) REGULAR_ID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREGULAR_ID, 0)
}

func (s *Size_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Size_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Size_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSize_clause(s)
	}
}

func (s *Size_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSize_clause(s)
	}
}

func (p *PlSqlParser) Size_clause() (localctx ISize_clauseContext) {
	localctx = NewSize_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, PlSqlParserRULE_size_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2160)
		p.Match(PlSqlParserUNSIGNED_INTEGER)
	}
	{
		p.SetState(2161)
		p.Match(PlSqlParserREGULAR_ID)
	}

	return localctx
}

// IDrop_tableContext is an interface to support dynamic dispatch.
type IDrop_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_tableContext differentiates from other interfaces.
	IsDrop_tableContext()
}

type Drop_tableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_tableContext() *Drop_tableContext {
	var p = new(Drop_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_drop_table
	return p
}

func (*Drop_tableContext) IsDrop_tableContext() {}

func NewDrop_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_tableContext {
	var p = new(Drop_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_drop_table

	return p
}

func (s *Drop_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_tableContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Drop_tableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Drop_tableContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Drop_tableContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEMICOLON, 0)
}

func (s *Drop_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDrop_table(s)
	}
}

func (s *Drop_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDrop_table(s)
	}
}

func (p *PlSqlParser) Drop_table() (localctx IDrop_tableContext) {
	localctx = NewDrop_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, PlSqlParserRULE_drop_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2163)
		p.Match(PlSqlParserDROP)
	}
	{
		p.SetState(2164)
		p.Match(PlSqlParserTABLE)
	}
	{
		p.SetState(2165)
		p.Tableview_name()
	}
	{
		p.SetState(2166)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IComment_on_columnContext is an interface to support dynamic dispatch.
type IComment_on_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComment_on_columnContext differentiates from other interfaces.
	IsComment_on_columnContext()
}

type Comment_on_columnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComment_on_columnContext() *Comment_on_columnContext {
	var p = new(Comment_on_columnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_comment_on_column
	return p
}

func (*Comment_on_columnContext) IsComment_on_columnContext() {}

func NewComment_on_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comment_on_columnContext {
	var p = new(Comment_on_columnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_comment_on_column

	return p
}

func (s *Comment_on_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Comment_on_columnContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMENT, 0)
}

func (s *Comment_on_columnContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Comment_on_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOLUMN, 0)
}

func (s *Comment_on_columnContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Comment_on_columnContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERIOD, 0)
}

func (s *Comment_on_columnContext) Column_name() IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Comment_on_columnContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Comment_on_columnContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Comment_on_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comment_on_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comment_on_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterComment_on_column(s)
	}
}

func (s *Comment_on_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitComment_on_column(s)
	}
}

func (p *PlSqlParser) Comment_on_column() (localctx IComment_on_columnContext) {
	localctx = NewComment_on_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, PlSqlParserRULE_comment_on_column)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2168)
		p.Match(PlSqlParserCOMMENT)
	}
	{
		p.SetState(2169)
		p.Match(PlSqlParserON)
	}
	{
		p.SetState(2170)
		p.Match(PlSqlParserCOLUMN)
	}
	{
		p.SetState(2171)
		p.Tableview_name()
	}
	{
		p.SetState(2172)
		p.Match(PlSqlParserPERIOD)
	}
	{
		p.SetState(2173)
		p.Column_name()
	}
	{
		p.SetState(2174)
		p.Match(PlSqlParserIS)
	}
	{
		p.SetState(2175)
		p.Quoted_string()
	}

	return localctx
}

// ICreate_synonymContext is an interface to support dynamic dispatch.
type ICreate_synonymContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_synonymContext differentiates from other interfaces.
	IsCreate_synonymContext()
}

type Create_synonymContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_synonymContext() *Create_synonymContext {
	var p = new(Create_synonymContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_create_synonym
	return p
}

func (*Create_synonymContext) IsCreate_synonymContext() {}

func NewCreate_synonymContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_synonymContext {
	var p = new(Create_synonymContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_create_synonym

	return p
}

func (s *Create_synonymContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_synonymContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *Create_synonymContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPUBLIC, 0)
}

func (s *Create_synonymContext) SYNONYM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSYNONYM, 0)
}

func (s *Create_synonymContext) Synonym_name() ISynonym_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISynonym_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISynonym_nameContext)
}

func (s *Create_synonymContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Create_synonymContext) Schema_object_name() ISchema_object_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchema_object_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchema_object_nameContext)
}

func (s *Create_synonymContext) OR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, 0)
}

func (s *Create_synonymContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREPLACE, 0)
}

func (s *Create_synonymContext) AllSchema_name() []ISchema_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISchema_nameContext)(nil)).Elem())
	var tst = make([]ISchema_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISchema_nameContext)
		}
	}

	return tst
}

func (s *Create_synonymContext) Schema_name(i int) ISchema_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchema_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISchema_nameContext)
}

func (s *Create_synonymContext) AllPERIOD() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserPERIOD)
}

func (s *Create_synonymContext) PERIOD(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERIOD, i)
}

func (s *Create_synonymContext) AT_SIGN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAT_SIGN, 0)
}

func (s *Create_synonymContext) Link_name() ILink_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_nameContext)
}

func (s *Create_synonymContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_synonymContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_synonymContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCreate_synonym(s)
	}
}

func (s *Create_synonymContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCreate_synonym(s)
	}
}

func (p *PlSqlParser) Create_synonym() (localctx ICreate_synonymContext) {
	localctx = NewCreate_synonymContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, PlSqlParserRULE_create_synonym)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2219)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2177)
			p.Match(PlSqlParserCREATE)
		}
		p.SetState(2180)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserOR {
			{
				p.SetState(2178)
				p.Match(PlSqlParserOR)
			}
			{
				p.SetState(2179)
				p.Match(PlSqlParserREPLACE)
			}

		}
		{
			p.SetState(2182)
			p.Match(PlSqlParserPUBLIC)
		}
		{
			p.SetState(2183)
			p.Match(PlSqlParserSYNONYM)
		}
		{
			p.SetState(2184)
			p.Synonym_name()
		}
		{
			p.SetState(2185)
			p.Match(PlSqlParserFOR)
		}
		p.SetState(2189)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2186)
				p.Schema_name()
			}
			{
				p.SetState(2187)
				p.Match(PlSqlParserPERIOD)
			}

		}
		{
			p.SetState(2191)
			p.Schema_object_name()
		}
		p.SetState(2194)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserAT_SIGN {
			{
				p.SetState(2192)
				p.Match(PlSqlParserAT_SIGN)
			}
			{
				p.SetState(2193)
				p.Link_name()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2196)
			p.Match(PlSqlParserCREATE)
		}
		p.SetState(2199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserOR {
			{
				p.SetState(2197)
				p.Match(PlSqlParserOR)
			}
			{
				p.SetState(2198)
				p.Match(PlSqlParserREPLACE)
			}

		}
		{
			p.SetState(2201)
			p.Match(PlSqlParserSYNONYM)
		}
		p.SetState(2205)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2202)
				p.Schema_name()
			}
			{
				p.SetState(2203)
				p.Match(PlSqlParserPERIOD)
			}

		}
		{
			p.SetState(2207)
			p.Synonym_name()
		}
		{
			p.SetState(2208)
			p.Match(PlSqlParserFOR)
		}
		p.SetState(2212)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2209)
				p.Schema_name()
			}
			{
				p.SetState(2210)
				p.Match(PlSqlParserPERIOD)
			}

		}
		{
			p.SetState(2214)
			p.Schema_object_name()
		}
		p.SetState(2217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserAT_SIGN {
			{
				p.SetState(2215)
				p.Match(PlSqlParserAT_SIGN)
			}
			{
				p.SetState(2216)
				p.Link_name()
			}

		}

	}

	return localctx
}

// IComment_on_tableContext is an interface to support dynamic dispatch.
type IComment_on_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComment_on_tableContext differentiates from other interfaces.
	IsComment_on_tableContext()
}

type Comment_on_tableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComment_on_tableContext() *Comment_on_tableContext {
	var p = new(Comment_on_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_comment_on_table
	return p
}

func (*Comment_on_tableContext) IsComment_on_tableContext() {}

func NewComment_on_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comment_on_tableContext {
	var p = new(Comment_on_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_comment_on_table

	return p
}

func (s *Comment_on_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Comment_on_tableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMENT, 0)
}

func (s *Comment_on_tableContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Comment_on_tableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Comment_on_tableContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Comment_on_tableContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Comment_on_tableContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Comment_on_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comment_on_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comment_on_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterComment_on_table(s)
	}
}

func (s *Comment_on_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitComment_on_table(s)
	}
}

func (p *PlSqlParser) Comment_on_table() (localctx IComment_on_tableContext) {
	localctx = NewComment_on_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, PlSqlParserRULE_comment_on_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2221)
		p.Match(PlSqlParserCOMMENT)
	}
	{
		p.SetState(2222)
		p.Match(PlSqlParserON)
	}
	{
		p.SetState(2223)
		p.Match(PlSqlParserTABLE)
	}
	{
		p.SetState(2224)
		p.Tableview_name()
	}
	{
		p.SetState(2225)
		p.Match(PlSqlParserIS)
	}
	{
		p.SetState(2226)
		p.Quoted_string()
	}

	return localctx
}

// IAlter_tableContext is an interface to support dynamic dispatch.
type IAlter_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_tableContext differentiates from other interfaces.
	IsAlter_tableContext()
}

type Alter_tableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tableContext() *Alter_tableContext {
	var p = new(Alter_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_alter_table
	return p
}

func (*Alter_tableContext) IsAlter_tableContext() {}

func NewAlter_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tableContext {
	var p = new(Alter_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_alter_table

	return p
}

func (s *Alter_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *Alter_tableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Alter_tableContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Alter_tableContext) Add_constraint() IAdd_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdd_constraintContext)
}

func (s *Alter_tableContext) Drop_constraint() IDrop_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_constraintContext)
}

func (s *Alter_tableContext) Enable_constraint() IEnable_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_constraintContext)
}

func (s *Alter_tableContext) Disable_constraint() IDisable_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisable_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisable_constraintContext)
}

func (s *Alter_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAlter_table(s)
	}
}

func (s *Alter_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAlter_table(s)
	}
}

func (p *PlSqlParser) Alter_table() (localctx IAlter_tableContext) {
	localctx = NewAlter_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, PlSqlParserRULE_alter_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2228)
		p.Match(PlSqlParserALTER)
	}
	{
		p.SetState(2229)
		p.Match(PlSqlParserTABLE)
	}
	{
		p.SetState(2230)
		p.Tableview_name()
	}
	p.SetState(2235)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD:
		{
			p.SetState(2231)
			p.Add_constraint()
		}

	case PlSqlParserDROP:
		{
			p.SetState(2232)
			p.Drop_constraint()
		}

	case PlSqlParserENABLE:
		{
			p.SetState(2233)
			p.Enable_constraint()
		}

	case PlSqlParserDISABLE:
		{
			p.SetState(2234)
			p.Disable_constraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAdd_constraintContext is an interface to support dynamic dispatch.
type IAdd_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdd_constraintContext differentiates from other interfaces.
	IsAdd_constraintContext()
}

type Add_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_constraintContext() *Add_constraintContext {
	var p = new(Add_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_add_constraint
	return p
}

func (*Add_constraintContext) IsAdd_constraintContext() {}

func NewAdd_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_constraintContext {
	var p = new(Add_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_add_constraint

	return p
}

func (s *Add_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_constraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserADD, 0)
}

func (s *Add_constraintContext) Primary_key_clause() IPrimary_key_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_key_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_key_clauseContext)
}

func (s *Add_constraintContext) Foreign_key_clause() IForeign_key_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForeign_key_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForeign_key_clauseContext)
}

func (s *Add_constraintContext) Unique_key_clause() IUnique_key_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnique_key_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnique_key_clauseContext)
}

func (s *Add_constraintContext) Check_constraint() ICheck_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheck_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheck_constraintContext)
}

func (s *Add_constraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRAINT, 0)
}

func (s *Add_constraintContext) Constraint_name() IConstraint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Add_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAdd_constraint(s)
	}
}

func (s *Add_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAdd_constraint(s)
	}
}

func (p *PlSqlParser) Add_constraint() (localctx IAdd_constraintContext) {
	localctx = NewAdd_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, PlSqlParserRULE_add_constraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2237)
		p.Match(PlSqlParserADD)
	}
	p.SetState(2240)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserCONSTRAINT {
		{
			p.SetState(2238)
			p.Match(PlSqlParserCONSTRAINT)
		}
		{
			p.SetState(2239)
			p.Constraint_name()
		}

	}
	p.SetState(2246)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserPRIMARY:
		{
			p.SetState(2242)
			p.Primary_key_clause()
		}

	case PlSqlParserFOREIGN:
		{
			p.SetState(2243)
			p.Foreign_key_clause()
		}

	case PlSqlParserUNIQUE:
		{
			p.SetState(2244)
			p.Unique_key_clause()
		}

	case PlSqlParserCHECK:
		{
			p.SetState(2245)
			p.Check_constraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICheck_constraintContext is an interface to support dynamic dispatch.
type ICheck_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheck_constraintContext differentiates from other interfaces.
	IsCheck_constraintContext()
}

type Check_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheck_constraintContext() *Check_constraintContext {
	var p = new(Check_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_check_constraint
	return p
}

func (*Check_constraintContext) IsCheck_constraintContext() {}

func NewCheck_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Check_constraintContext {
	var p = new(Check_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_check_constraint

	return p
}

func (s *Check_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Check_constraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHECK, 0)
}

func (s *Check_constraintContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Check_constraintContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISABLE, 0)
}

func (s *Check_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Check_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Check_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCheck_constraint(s)
	}
}

func (s *Check_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCheck_constraint(s)
	}
}

func (p *PlSqlParser) Check_constraint() (localctx ICheck_constraintContext) {
	localctx = NewCheck_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, PlSqlParserRULE_check_constraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2248)
		p.Match(PlSqlParserCHECK)
	}
	{
		p.SetState(2249)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2250)
		p.Condition()
	}
	{
		p.SetState(2251)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(2253)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserDISABLE {
		{
			p.SetState(2252)
			p.Match(PlSqlParserDISABLE)
		}

	}

	return localctx
}

// IDrop_constraintContext is an interface to support dynamic dispatch.
type IDrop_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_constraintContext differentiates from other interfaces.
	IsDrop_constraintContext()
}

type Drop_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_constraintContext() *Drop_constraintContext {
	var p = new(Drop_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_drop_constraint
	return p
}

func (*Drop_constraintContext) IsDrop_constraintContext() {}

func NewDrop_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_constraintContext {
	var p = new(Drop_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_drop_constraint

	return p
}

func (s *Drop_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_constraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDROP, 0)
}

func (s *Drop_constraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRAINT, 0)
}

func (s *Drop_constraintContext) Constraint_name() IConstraint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Drop_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDrop_constraint(s)
	}
}

func (s *Drop_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDrop_constraint(s)
	}
}

func (p *PlSqlParser) Drop_constraint() (localctx IDrop_constraintContext) {
	localctx = NewDrop_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, PlSqlParserRULE_drop_constraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2255)
		p.Match(PlSqlParserDROP)
	}
	{
		p.SetState(2256)
		p.Match(PlSqlParserCONSTRAINT)
	}
	{
		p.SetState(2257)
		p.Constraint_name()
	}

	return localctx
}

// IEnable_constraintContext is an interface to support dynamic dispatch.
type IEnable_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_constraintContext differentiates from other interfaces.
	IsEnable_constraintContext()
}

type Enable_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_constraintContext() *Enable_constraintContext {
	var p = new(Enable_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_enable_constraint
	return p
}

func (*Enable_constraintContext) IsEnable_constraintContext() {}

func NewEnable_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_constraintContext {
	var p = new(Enable_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_enable_constraint

	return p
}

func (s *Enable_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_constraintContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserENABLE, 0)
}

func (s *Enable_constraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRAINT, 0)
}

func (s *Enable_constraintContext) Constraint_name() IConstraint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Enable_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterEnable_constraint(s)
	}
}

func (s *Enable_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitEnable_constraint(s)
	}
}

func (p *PlSqlParser) Enable_constraint() (localctx IEnable_constraintContext) {
	localctx = NewEnable_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, PlSqlParserRULE_enable_constraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2259)
		p.Match(PlSqlParserENABLE)
	}
	{
		p.SetState(2260)
		p.Match(PlSqlParserCONSTRAINT)
	}
	{
		p.SetState(2261)
		p.Constraint_name()
	}

	return localctx
}

// IDisable_constraintContext is an interface to support dynamic dispatch.
type IDisable_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisable_constraintContext differentiates from other interfaces.
	IsDisable_constraintContext()
}

type Disable_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisable_constraintContext() *Disable_constraintContext {
	var p = new(Disable_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_disable_constraint
	return p
}

func (*Disable_constraintContext) IsDisable_constraintContext() {}

func NewDisable_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Disable_constraintContext {
	var p = new(Disable_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_disable_constraint

	return p
}

func (s *Disable_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Disable_constraintContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISABLE, 0)
}

func (s *Disable_constraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRAINT, 0)
}

func (s *Disable_constraintContext) Constraint_name() IConstraint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Disable_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Disable_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Disable_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDisable_constraint(s)
	}
}

func (s *Disable_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDisable_constraint(s)
	}
}

func (p *PlSqlParser) Disable_constraint() (localctx IDisable_constraintContext) {
	localctx = NewDisable_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, PlSqlParserRULE_disable_constraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2263)
		p.Match(PlSqlParserDISABLE)
	}
	{
		p.SetState(2264)
		p.Match(PlSqlParserCONSTRAINT)
	}
	{
		p.SetState(2265)
		p.Constraint_name()
	}

	return localctx
}

// IForeign_key_clauseContext is an interface to support dynamic dispatch.
type IForeign_key_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForeign_key_clauseContext differentiates from other interfaces.
	IsForeign_key_clauseContext()
}

type Foreign_key_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeign_key_clauseContext() *Foreign_key_clauseContext {
	var p = new(Foreign_key_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_foreign_key_clause
	return p
}

func (*Foreign_key_clauseContext) IsForeign_key_clauseContext() {}

func NewForeign_key_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Foreign_key_clauseContext {
	var p = new(Foreign_key_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_foreign_key_clause

	return p
}

func (s *Foreign_key_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Foreign_key_clauseContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOREIGN, 0)
}

func (s *Foreign_key_clauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserKEY, 0)
}

func (s *Foreign_key_clauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEFT_PAREN, 0)
}

func (s *Foreign_key_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Foreign_key_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Foreign_key_clauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRIGHT_PAREN, 0)
}

func (s *Foreign_key_clauseContext) References_clause() IReferences_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferences_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferences_clauseContext)
}

func (s *Foreign_key_clauseContext) On_delete_clause() IOn_delete_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOn_delete_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOn_delete_clauseContext)
}

func (s *Foreign_key_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Foreign_key_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Foreign_key_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterForeign_key_clause(s)
	}
}

func (s *Foreign_key_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitForeign_key_clause(s)
	}
}

func (p *PlSqlParser) Foreign_key_clause() (localctx IForeign_key_clauseContext) {
	localctx = NewForeign_key_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, PlSqlParserRULE_foreign_key_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2267)
		p.Match(PlSqlParserFOREIGN)
	}
	{
		p.SetState(2268)
		p.Match(PlSqlParserKEY)
	}
	{
		p.SetState(2269)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2270)
		p.Column_name()
	}
	p.SetState(2275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(2271)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(2272)
			p.Column_name()
		}

		p.SetState(2277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2278)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	{
		p.SetState(2279)
		p.References_clause()
	}
	p.SetState(2281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserON {
		{
			p.SetState(2280)
			p.On_delete_clause()
		}

	}

	return localctx
}

// IReferences_clauseContext is an interface to support dynamic dispatch.
type IReferences_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferences_clauseContext differentiates from other interfaces.
	IsReferences_clauseContext()
}

type References_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferences_clauseContext() *References_clauseContext {
	var p = new(References_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_references_clause
	return p
}

func (*References_clauseContext) IsReferences_clauseContext() {}

func NewReferences_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *References_clauseContext {
	var p = new(References_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_references_clause

	return p
}

func (s *References_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *References_clauseContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREFERENCES, 0)
}

func (s *References_clauseContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *References_clauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEFT_PAREN, 0)
}

func (s *References_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *References_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *References_clauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRIGHT_PAREN, 0)
}

func (s *References_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *References_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *References_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterReferences_clause(s)
	}
}

func (s *References_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitReferences_clause(s)
	}
}

func (p *PlSqlParser) References_clause() (localctx IReferences_clauseContext) {
	localctx = NewReferences_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, PlSqlParserRULE_references_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2283)
		p.Match(PlSqlParserREFERENCES)
	}
	{
		p.SetState(2284)
		p.Tableview_name()
	}
	{
		p.SetState(2285)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2286)
		p.Column_name()
	}
	p.SetState(2291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(2287)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(2288)
			p.Column_name()
		}

		p.SetState(2293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2294)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IOn_delete_clauseContext is an interface to support dynamic dispatch.
type IOn_delete_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOn_delete_clauseContext differentiates from other interfaces.
	IsOn_delete_clauseContext()
}

type On_delete_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOn_delete_clauseContext() *On_delete_clauseContext {
	var p = new(On_delete_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_on_delete_clause
	return p
}

func (*On_delete_clauseContext) IsOn_delete_clauseContext() {}

func NewOn_delete_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *On_delete_clauseContext {
	var p = new(On_delete_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_on_delete_clause

	return p
}

func (s *On_delete_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *On_delete_clauseContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *On_delete_clauseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDELETE, 0)
}

func (s *On_delete_clauseContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCASCADE, 0)
}

func (s *On_delete_clauseContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *On_delete_clauseContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *On_delete_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *On_delete_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *On_delete_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOn_delete_clause(s)
	}
}

func (s *On_delete_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOn_delete_clause(s)
	}
}

func (p *PlSqlParser) On_delete_clause() (localctx IOn_delete_clauseContext) {
	localctx = NewOn_delete_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, PlSqlParserRULE_on_delete_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2296)
		p.Match(PlSqlParserON)
	}
	{
		p.SetState(2297)
		p.Match(PlSqlParserDELETE)
	}
	p.SetState(2301)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserCASCADE:
		{
			p.SetState(2298)
			p.Match(PlSqlParserCASCADE)
		}

	case PlSqlParserSET:
		{
			p.SetState(2299)
			p.Match(PlSqlParserSET)
		}
		{
			p.SetState(2300)
			p.Match(PlSqlParserNULL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnique_key_clauseContext is an interface to support dynamic dispatch.
type IUnique_key_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnique_key_clauseContext differentiates from other interfaces.
	IsUnique_key_clauseContext()
}

type Unique_key_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnique_key_clauseContext() *Unique_key_clauseContext {
	var p = new(Unique_key_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_unique_key_clause
	return p
}

func (*Unique_key_clauseContext) IsUnique_key_clauseContext() {}

func NewUnique_key_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unique_key_clauseContext {
	var p = new(Unique_key_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_unique_key_clause

	return p
}

func (s *Unique_key_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Unique_key_clauseContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNIQUE, 0)
}

func (s *Unique_key_clauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEFT_PAREN, 0)
}

func (s *Unique_key_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Unique_key_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Unique_key_clauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRIGHT_PAREN, 0)
}

func (s *Unique_key_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unique_key_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unique_key_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUnique_key_clause(s)
	}
}

func (s *Unique_key_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUnique_key_clause(s)
	}
}

func (p *PlSqlParser) Unique_key_clause() (localctx IUnique_key_clauseContext) {
	localctx = NewUnique_key_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, PlSqlParserRULE_unique_key_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2303)
		p.Match(PlSqlParserUNIQUE)
	}
	{
		p.SetState(2304)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2305)
		p.Column_name()
	}
	p.SetState(2310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(2306)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(2307)
			p.Column_name()
		}

		p.SetState(2312)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2313)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IPrimary_key_clauseContext is an interface to support dynamic dispatch.
type IPrimary_key_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_key_clauseContext differentiates from other interfaces.
	IsPrimary_key_clauseContext()
}

type Primary_key_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_key_clauseContext() *Primary_key_clauseContext {
	var p = new(Primary_key_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_primary_key_clause
	return p
}

func (*Primary_key_clauseContext) IsPrimary_key_clauseContext() {}

func NewPrimary_key_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_key_clauseContext {
	var p = new(Primary_key_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_primary_key_clause

	return p
}

func (s *Primary_key_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_key_clauseContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRIMARY, 0)
}

func (s *Primary_key_clauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserKEY, 0)
}

func (s *Primary_key_clauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEFT_PAREN, 0)
}

func (s *Primary_key_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Primary_key_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Primary_key_clauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRIGHT_PAREN, 0)
}

func (s *Primary_key_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_key_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_key_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPrimary_key_clause(s)
	}
}

func (s *Primary_key_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPrimary_key_clause(s)
	}
}

func (p *PlSqlParser) Primary_key_clause() (localctx IPrimary_key_clauseContext) {
	localctx = NewPrimary_key_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, PlSqlParserRULE_primary_key_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2315)
		p.Match(PlSqlParserPRIMARY)
	}
	{
		p.SetState(2316)
		p.Match(PlSqlParserKEY)
	}
	{
		p.SetState(2317)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2318)
		p.Column_name()
	}
	p.SetState(2323)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(2319)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(2320)
			p.Column_name()
		}

		p.SetState(2325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2326)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IAnonymous_blockContext is an interface to support dynamic dispatch.
type IAnonymous_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymous_blockContext differentiates from other interfaces.
	IsAnonymous_blockContext()
}

type Anonymous_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymous_blockContext() *Anonymous_blockContext {
	var p = new(Anonymous_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_anonymous_block
	return p
}

func (*Anonymous_blockContext) IsAnonymous_blockContext() {}

func NewAnonymous_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Anonymous_blockContext {
	var p = new(Anonymous_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_anonymous_block

	return p
}

func (s *Anonymous_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Anonymous_blockContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBEGIN, 0)
}

func (s *Anonymous_blockContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *Anonymous_blockContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *Anonymous_blockContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEMICOLON, 0)
}

func (s *Anonymous_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Anonymous_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Anonymous_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAnonymous_block(s)
	}
}

func (s *Anonymous_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAnonymous_block(s)
	}
}

func (p *PlSqlParser) Anonymous_block() (localctx IAnonymous_blockContext) {
	localctx = NewAnonymous_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, PlSqlParserRULE_anonymous_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2328)
		p.Match(PlSqlParserBEGIN)
	}
	{
		p.SetState(2329)
		p.Seq_of_statements()
	}
	{
		p.SetState(2330)
		p.Match(PlSqlParserEND)
	}
	{
		p.SetState(2331)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IInvoker_rights_clauseContext is an interface to support dynamic dispatch.
type IInvoker_rights_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInvoker_rights_clauseContext differentiates from other interfaces.
	IsInvoker_rights_clauseContext()
}

type Invoker_rights_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvoker_rights_clauseContext() *Invoker_rights_clauseContext {
	var p = new(Invoker_rights_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_invoker_rights_clause
	return p
}

func (*Invoker_rights_clauseContext) IsInvoker_rights_clauseContext() {}

func NewInvoker_rights_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Invoker_rights_clauseContext {
	var p = new(Invoker_rights_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_invoker_rights_clause

	return p
}

func (s *Invoker_rights_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Invoker_rights_clauseContext) AUTHID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUTHID, 0)
}

func (s *Invoker_rights_clauseContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCURRENT_USER, 0)
}

func (s *Invoker_rights_clauseContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFINER, 0)
}

func (s *Invoker_rights_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Invoker_rights_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Invoker_rights_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterInvoker_rights_clause(s)
	}
}

func (s *Invoker_rights_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitInvoker_rights_clause(s)
	}
}

func (p *PlSqlParser) Invoker_rights_clause() (localctx IInvoker_rights_clauseContext) {
	localctx = NewInvoker_rights_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, PlSqlParserRULE_invoker_rights_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2333)
		p.Match(PlSqlParserAUTHID)
	}
	{
		p.SetState(2334)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserCURRENT_USER || _la == PlSqlParserDEFINER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICompiler_parameters_clauseContext is an interface to support dynamic dispatch.
type ICompiler_parameters_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompiler_parameters_clauseContext differentiates from other interfaces.
	IsCompiler_parameters_clauseContext()
}

type Compiler_parameters_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompiler_parameters_clauseContext() *Compiler_parameters_clauseContext {
	var p = new(Compiler_parameters_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_compiler_parameters_clause
	return p
}

func (*Compiler_parameters_clauseContext) IsCompiler_parameters_clauseContext() {}

func NewCompiler_parameters_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compiler_parameters_clauseContext {
	var p = new(Compiler_parameters_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_compiler_parameters_clause

	return p
}

func (s *Compiler_parameters_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Compiler_parameters_clauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Compiler_parameters_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Compiler_parameters_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compiler_parameters_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compiler_parameters_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCompiler_parameters_clause(s)
	}
}

func (s *Compiler_parameters_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCompiler_parameters_clause(s)
	}
}

func (p *PlSqlParser) Compiler_parameters_clause() (localctx ICompiler_parameters_clauseContext) {
	localctx = NewCompiler_parameters_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, PlSqlParserRULE_compiler_parameters_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2336)
		p.Identifier()
	}
	{
		p.SetState(2337)
		p.Match(PlSqlParserEQUALS_OP)
	}
	{
		p.SetState(2338)
		p.Expression()
	}

	return localctx
}

// ICall_specContext is an interface to support dynamic dispatch.
type ICall_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_specContext differentiates from other interfaces.
	IsCall_specContext()
}

type Call_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_specContext() *Call_specContext {
	var p = new(Call_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_call_spec
	return p
}

func (*Call_specContext) IsCall_specContext() {}

func NewCall_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_specContext {
	var p = new(Call_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_call_spec

	return p
}

func (s *Call_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_specContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLANGUAGE, 0)
}

func (s *Call_specContext) Java_spec() IJava_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJava_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJava_specContext)
}

func (s *Call_specContext) C_spec() IC_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_specContext)
}

func (s *Call_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCall_spec(s)
	}
}

func (s *Call_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCall_spec(s)
	}
}

func (p *PlSqlParser) Call_spec() (localctx ICall_specContext) {
	localctx = NewCall_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, PlSqlParserRULE_call_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2340)
		p.Match(PlSqlParserLANGUAGE)
	}
	p.SetState(2343)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserJAVA:
		{
			p.SetState(2341)
			p.Java_spec()
		}

	case PlSqlParserC_LETTER:
		{
			p.SetState(2342)
			p.C_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJava_specContext is an interface to support dynamic dispatch.
type IJava_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJava_specContext differentiates from other interfaces.
	IsJava_specContext()
}

type Java_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJava_specContext() *Java_specContext {
	var p = new(Java_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_java_spec
	return p
}

func (*Java_specContext) IsJava_specContext() {}

func NewJava_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Java_specContext {
	var p = new(Java_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_java_spec

	return p
}

func (s *Java_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Java_specContext) JAVA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserJAVA, 0)
}

func (s *Java_specContext) NAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAME, 0)
}

func (s *Java_specContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR_STRING, 0)
}

func (s *Java_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Java_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Java_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterJava_spec(s)
	}
}

func (s *Java_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitJava_spec(s)
	}
}

func (p *PlSqlParser) Java_spec() (localctx IJava_specContext) {
	localctx = NewJava_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, PlSqlParserRULE_java_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2345)
		p.Match(PlSqlParserJAVA)
	}
	{
		p.SetState(2346)
		p.Match(PlSqlParserNAME)
	}
	{
		p.SetState(2347)
		p.Match(PlSqlParserCHAR_STRING)
	}

	return localctx
}

// IC_specContext is an interface to support dynamic dispatch.
type IC_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsC_specContext differentiates from other interfaces.
	IsC_specContext()
}

type C_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyC_specContext() *C_specContext {
	var p = new(C_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_c_spec
	return p
}

func (*C_specContext) IsC_specContext() {}

func NewC_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *C_specContext {
	var p = new(C_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_c_spec

	return p
}

func (s *C_specContext) GetParser() antlr.Parser { return s.parser }

func (s *C_specContext) C_LETTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserC_LETTER, 0)
}

func (s *C_specContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIBRARY, 0)
}

func (s *C_specContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *C_specContext) NAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAME, 0)
}

func (s *C_specContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR_STRING, 0)
}

func (s *C_specContext) C_agent_in_clause() IC_agent_in_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_agent_in_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_agent_in_clauseContext)
}

func (s *C_specContext) WITH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWITH, 0)
}

func (s *C_specContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONTEXT, 0)
}

func (s *C_specContext) C_parameters_clause() IC_parameters_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_parameters_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_parameters_clauseContext)
}

func (s *C_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *C_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *C_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterC_spec(s)
	}
}

func (s *C_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitC_spec(s)
	}
}

func (p *PlSqlParser) C_spec() (localctx IC_specContext) {
	localctx = NewC_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, PlSqlParserRULE_c_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2349)
		p.Match(PlSqlParserC_LETTER)
	}
	p.SetState(2352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNAME {
		{
			p.SetState(2350)
			p.Match(PlSqlParserNAME)
		}
		{
			p.SetState(2351)
			p.Match(PlSqlParserCHAR_STRING)
		}

	}
	{
		p.SetState(2354)
		p.Match(PlSqlParserLIBRARY)
	}
	{
		p.SetState(2355)
		p.Identifier()
	}
	p.SetState(2357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAGENT {
		{
			p.SetState(2356)
			p.C_agent_in_clause()
		}

	}
	p.SetState(2361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWITH {
		{
			p.SetState(2359)
			p.Match(PlSqlParserWITH)
		}
		{
			p.SetState(2360)
			p.Match(PlSqlParserCONTEXT)
		}

	}
	p.SetState(2364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPARAMETERS {
		{
			p.SetState(2363)
			p.C_parameters_clause()
		}

	}

	return localctx
}

// IC_agent_in_clauseContext is an interface to support dynamic dispatch.
type IC_agent_in_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsC_agent_in_clauseContext differentiates from other interfaces.
	IsC_agent_in_clauseContext()
}

type C_agent_in_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyC_agent_in_clauseContext() *C_agent_in_clauseContext {
	var p = new(C_agent_in_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_c_agent_in_clause
	return p
}

func (*C_agent_in_clauseContext) IsC_agent_in_clauseContext() {}

func NewC_agent_in_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *C_agent_in_clauseContext {
	var p = new(C_agent_in_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_c_agent_in_clause

	return p
}

func (s *C_agent_in_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *C_agent_in_clauseContext) AGENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAGENT, 0)
}

func (s *C_agent_in_clauseContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *C_agent_in_clauseContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *C_agent_in_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *C_agent_in_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *C_agent_in_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterC_agent_in_clause(s)
	}
}

func (s *C_agent_in_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitC_agent_in_clause(s)
	}
}

func (p *PlSqlParser) C_agent_in_clause() (localctx IC_agent_in_clauseContext) {
	localctx = NewC_agent_in_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, PlSqlParserRULE_c_agent_in_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2366)
		p.Match(PlSqlParserAGENT)
	}
	{
		p.SetState(2367)
		p.Match(PlSqlParserIN)
	}
	{
		p.SetState(2368)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2369)
		p.Expressions()
	}
	{
		p.SetState(2370)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IC_parameters_clauseContext is an interface to support dynamic dispatch.
type IC_parameters_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsC_parameters_clauseContext differentiates from other interfaces.
	IsC_parameters_clauseContext()
}

type C_parameters_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyC_parameters_clauseContext() *C_parameters_clauseContext {
	var p = new(C_parameters_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_c_parameters_clause
	return p
}

func (*C_parameters_clauseContext) IsC_parameters_clauseContext() {}

func NewC_parameters_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *C_parameters_clauseContext {
	var p = new(C_parameters_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_c_parameters_clause

	return p
}

func (s *C_parameters_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *C_parameters_clauseContext) PARAMETERS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARAMETERS, 0)
}

func (s *C_parameters_clauseContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *C_parameters_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *C_parameters_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *C_parameters_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterC_parameters_clause(s)
	}
}

func (s *C_parameters_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitC_parameters_clause(s)
	}
}

func (p *PlSqlParser) C_parameters_clause() (localctx IC_parameters_clauseContext) {
	localctx = NewC_parameters_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, PlSqlParserRULE_c_parameters_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2372)
		p.Match(PlSqlParserPARAMETERS)
	}
	{
		p.SetState(2373)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(2378)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALL, PlSqlParserANALYZE, PlSqlParserANY, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOALESCE, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONNECT_BY_ROOT, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDISTINCT, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXISTS, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFALSE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNOT, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPRIOR, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUE, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserDECODE, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserNVL, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROUND, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTO_CHAR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserLEAST, PlSqlParserGREATEST, PlSqlParserTO_DATE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserPLUS_SIGN, PlSqlParserMINUS_SIGN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(2374)
			p.Expressions()
		}

	case PlSqlParserPERIOD:
		{
			p.SetState(2375)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(2376)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(2377)
			p.Match(PlSqlParserPERIOD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2380)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) Parameter_name() IParameter_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_nameContext)
}

func (s *ParameterContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *ParameterContext) Default_value_part() IDefault_value_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_value_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_value_partContext)
}

func (s *ParameterContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserIN)
}

func (s *ParameterContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, i)
}

func (s *ParameterContext) AllOUT() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserOUT)
}

func (s *ParameterContext) OUT(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserOUT, i)
}

func (s *ParameterContext) AllINOUT() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserINOUT)
}

func (s *ParameterContext) INOUT(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserINOUT, i)
}

func (s *ParameterContext) AllNOCOPY() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserNOCOPY)
}

func (s *ParameterContext) NOCOPY(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOCOPY, i)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *PlSqlParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, PlSqlParserRULE_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2382)
		p.Parameter_name()
	}
	p.SetState(2386)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2383)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserIN || _la == PlSqlParserINOUT || _la == PlSqlParserNOCOPY || _la == PlSqlParserOUT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2388)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext())
	}
	p.SetState(2390)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(2389)
			p.Type_spec()
		}

	}
	p.SetState(2393)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserDEFAULT || _la == PlSqlParserASSIGN_OP {
		{
			p.SetState(2392)
			p.Default_value_part()
		}

	}

	return localctx
}

// IDefault_value_partContext is an interface to support dynamic dispatch.
type IDefault_value_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_value_partContext differentiates from other interfaces.
	IsDefault_value_partContext()
}

type Default_value_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_value_partContext() *Default_value_partContext {
	var p = new(Default_value_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_default_value_part
	return p
}

func (*Default_value_partContext) IsDefault_value_partContext() {}

func NewDefault_value_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_value_partContext {
	var p = new(Default_value_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_default_value_part

	return p
}

func (s *Default_value_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Default_value_partContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Default_value_partContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserASSIGN_OP, 0)
}

func (s *Default_value_partContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFAULT, 0)
}

func (s *Default_value_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_value_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_value_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDefault_value_part(s)
	}
}

func (s *Default_value_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDefault_value_part(s)
	}
}

func (p *PlSqlParser) Default_value_part() (localctx IDefault_value_partContext) {
	localctx = NewDefault_value_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, PlSqlParserRULE_default_value_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2395)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserDEFAULT || _la == PlSqlParserASSIGN_OP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2396)
		p.Expression()
	}

	return localctx
}

// IDeclare_specContext is an interface to support dynamic dispatch.
type IDeclare_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclare_specContext differentiates from other interfaces.
	IsDeclare_specContext()
}

type Declare_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_specContext() *Declare_specContext {
	var p = new(Declare_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_declare_spec
	return p
}

func (*Declare_specContext) IsDeclare_specContext() {}

func NewDeclare_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_specContext {
	var p = new(Declare_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_declare_spec

	return p
}

func (s *Declare_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_specContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Declare_specContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Declare_specContext) Cursor_declaration() ICursor_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_declarationContext)
}

func (s *Declare_specContext) Exception_declaration() IException_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_declarationContext)
}

func (s *Declare_specContext) Pragma_declaration() IPragma_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPragma_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPragma_declarationContext)
}

func (s *Declare_specContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Declare_specContext) Procedure_spec() IProcedure_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_specContext)
}

func (s *Declare_specContext) Function_spec() IFunction_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_specContext)
}

func (s *Declare_specContext) Procedure_body() IProcedure_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_bodyContext)
}

func (s *Declare_specContext) Function_body() IFunction_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_bodyContext)
}

func (s *Declare_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDeclare_spec(s)
	}
}

func (s *Declare_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDeclare_spec(s)
	}
}

func (p *PlSqlParser) Declare_spec() (localctx IDeclare_specContext) {
	localctx = NewDeclare_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, PlSqlParserRULE_declare_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2408)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2398)
			p.Variable_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2399)
			p.Subtype_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2400)
			p.Cursor_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2401)
			p.Exception_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2402)
			p.Pragma_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2403)
			p.Type_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2404)
			p.Procedure_spec()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2405)
			p.Function_spec()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2406)
			p.Procedure_body()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2407)
			p.Function_body()
		}

	}

	return localctx
}

// IVariable_declarationContext is an interface to support dynamic dispatch.
type IVariable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_declarationContext differentiates from other interfaces.
	IsVariable_declarationContext()
}

type Variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_declarationContext() *Variable_declarationContext {
	var p = new(Variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_variable_declaration
	return p
}

func (*Variable_declarationContext) IsVariable_declarationContext() {}

func NewVariable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_declarationContext {
	var p = new(Variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_variable_declaration

	return p
}

func (s *Variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Variable_declarationContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Variable_declarationContext) CONSTANT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTANT, 0)
}

func (s *Variable_declarationContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Variable_declarationContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *Variable_declarationContext) Default_value_part() IDefault_value_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_value_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_value_partContext)
}

func (s *Variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterVariable_declaration(s)
	}
}

func (s *Variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitVariable_declaration(s)
	}
}

func (p *PlSqlParser) Variable_declaration() (localctx IVariable_declarationContext) {
	localctx = NewVariable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, PlSqlParserRULE_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2410)
		p.Identifier()
	}
	p.SetState(2412)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2411)
			p.Match(PlSqlParserCONSTANT)
		}

	}
	{
		p.SetState(2414)
		p.Type_spec()
	}
	p.SetState(2417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNOT {
		{
			p.SetState(2415)
			p.Match(PlSqlParserNOT)
		}
		{
			p.SetState(2416)
			p.Match(PlSqlParserNULL)
		}

	}
	p.SetState(2420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserDEFAULT || _la == PlSqlParserASSIGN_OP {
		{
			p.SetState(2419)
			p.Default_value_part()
		}

	}
	{
		p.SetState(2422)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ISubtype_declarationContext is an interface to support dynamic dispatch.
type ISubtype_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtype_declarationContext differentiates from other interfaces.
	IsSubtype_declarationContext()
}

type Subtype_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtype_declarationContext() *Subtype_declarationContext {
	var p = new(Subtype_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_subtype_declaration
	return p
}

func (*Subtype_declarationContext) IsSubtype_declarationContext() {}

func NewSubtype_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subtype_declarationContext {
	var p = new(Subtype_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_subtype_declaration

	return p
}

func (s *Subtype_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subtype_declarationContext) SUBTYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBTYPE, 0)
}

func (s *Subtype_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Subtype_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Subtype_declarationContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Subtype_declarationContext) RANGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRANGE, 0)
}

func (s *Subtype_declarationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Subtype_declarationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Subtype_declarationContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Subtype_declarationContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *Subtype_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subtype_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subtype_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSubtype_declaration(s)
	}
}

func (s *Subtype_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSubtype_declaration(s)
	}
}

func (p *PlSqlParser) Subtype_declaration() (localctx ISubtype_declarationContext) {
	localctx = NewSubtype_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, PlSqlParserRULE_subtype_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2424)
		p.Match(PlSqlParserSUBTYPE)
	}
	{
		p.SetState(2425)
		p.Identifier()
	}
	{
		p.SetState(2426)
		p.Match(PlSqlParserIS)
	}
	{
		p.SetState(2427)
		p.Type_spec()
	}
	p.SetState(2433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserRANGE {
		{
			p.SetState(2428)
			p.Match(PlSqlParserRANGE)
		}
		{
			p.SetState(2429)
			p.Expression()
		}
		{
			p.SetState(2430)
			p.Match(PlSqlParserDOUBLE_PERIOD)
		}
		{
			p.SetState(2431)
			p.Expression()
		}

	}
	p.SetState(2437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNOT {
		{
			p.SetState(2435)
			p.Match(PlSqlParserNOT)
		}
		{
			p.SetState(2436)
			p.Match(PlSqlParserNULL)
		}

	}
	{
		p.SetState(2439)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ICursor_declarationContext is an interface to support dynamic dispatch.
type ICursor_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCursor_declarationContext differentiates from other interfaces.
	IsCursor_declarationContext()
}

type Cursor_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_declarationContext() *Cursor_declarationContext {
	var p = new(Cursor_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cursor_declaration
	return p
}

func (*Cursor_declarationContext) IsCursor_declarationContext() {}

func NewCursor_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_declarationContext {
	var p = new(Cursor_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cursor_declaration

	return p
}

func (s *Cursor_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_declarationContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCURSOR, 0)
}

func (s *Cursor_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cursor_declarationContext) AllParameter_spec() []IParameter_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameter_specContext)(nil)).Elem())
	var tst = make([]IParameter_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameter_specContext)
		}
	}

	return tst
}

func (s *Cursor_declarationContext) Parameter_spec(i int) IParameter_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameter_specContext)
}

func (s *Cursor_declarationContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Cursor_declarationContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Cursor_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Cursor_declarationContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Cursor_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cursor_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCursor_declaration(s)
	}
}

func (s *Cursor_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCursor_declaration(s)
	}
}

func (p *PlSqlParser) Cursor_declaration() (localctx ICursor_declarationContext) {
	localctx = NewCursor_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, PlSqlParserRULE_cursor_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2441)
		p.Match(PlSqlParserCURSOR)
	}
	{
		p.SetState(2442)
		p.Identifier()
	}
	p.SetState(2454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(2443)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(2444)
			p.Parameter_spec()
		}
		p.SetState(2449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(2445)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(2446)
				p.Parameter_spec()
			}

			p.SetState(2451)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2452)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	p.SetState(2458)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserRETURN {
		{
			p.SetState(2456)
			p.Match(PlSqlParserRETURN)
		}
		{
			p.SetState(2457)
			p.Type_spec()
		}

	}
	p.SetState(2462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserIS {
		{
			p.SetState(2460)
			p.Match(PlSqlParserIS)
		}
		{
			p.SetState(2461)
			p.Select_statement()
		}

	}
	{
		p.SetState(2464)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IParameter_specContext is an interface to support dynamic dispatch.
type IParameter_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_specContext differentiates from other interfaces.
	IsParameter_specContext()
}

type Parameter_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_specContext() *Parameter_specContext {
	var p = new(Parameter_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_parameter_spec
	return p
}

func (*Parameter_specContext) IsParameter_specContext() {}

func NewParameter_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_specContext {
	var p = new(Parameter_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_parameter_spec

	return p
}

func (s *Parameter_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_specContext) Parameter_name() IParameter_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_nameContext)
}

func (s *Parameter_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Parameter_specContext) Default_value_part() IDefault_value_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_value_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_value_partContext)
}

func (s *Parameter_specContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Parameter_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterParameter_spec(s)
	}
}

func (s *Parameter_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitParameter_spec(s)
	}
}

func (p *PlSqlParser) Parameter_spec() (localctx IParameter_specContext) {
	localctx = NewParameter_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, PlSqlParserRULE_parameter_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2466)
		p.Parameter_name()
	}
	p.SetState(2471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserIN-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserREGULAR_ID {
		p.SetState(2468)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserIN {
			{
				p.SetState(2467)
				p.Match(PlSqlParserIN)
			}

		}
		{
			p.SetState(2470)
			p.Type_spec()
		}

	}
	p.SetState(2474)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserDEFAULT || _la == PlSqlParserASSIGN_OP {
		{
			p.SetState(2473)
			p.Default_value_part()
		}

	}

	return localctx
}

// IException_declarationContext is an interface to support dynamic dispatch.
type IException_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_declarationContext differentiates from other interfaces.
	IsException_declarationContext()
}

type Exception_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_declarationContext() *Exception_declarationContext {
	var p = new(Exception_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_exception_declaration
	return p
}

func (*Exception_declarationContext) IsException_declarationContext() {}

func NewException_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_declarationContext {
	var p = new(Exception_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_exception_declaration

	return p
}

func (s *Exception_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Exception_declarationContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCEPTION, 0)
}

func (s *Exception_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterException_declaration(s)
	}
}

func (s *Exception_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitException_declaration(s)
	}
}

func (p *PlSqlParser) Exception_declaration() (localctx IException_declarationContext) {
	localctx = NewException_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, PlSqlParserRULE_exception_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2476)
		p.Identifier()
	}
	{
		p.SetState(2477)
		p.Match(PlSqlParserEXCEPTION)
	}
	{
		p.SetState(2478)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IPragma_declarationContext is an interface to support dynamic dispatch.
type IPragma_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId1 returns the id1 rule contexts.
	GetId1() IIdentifierContext

	// SetId1 sets the id1 rule contexts.
	SetId1(IIdentifierContext)

	// IsPragma_declarationContext differentiates from other interfaces.
	IsPragma_declarationContext()
}

type Pragma_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	id1    IIdentifierContext
}

func NewEmptyPragma_declarationContext() *Pragma_declarationContext {
	var p = new(Pragma_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pragma_declaration
	return p
}

func (*Pragma_declarationContext) IsPragma_declarationContext() {}

func NewPragma_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pragma_declarationContext {
	var p = new(Pragma_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pragma_declaration

	return p
}

func (s *Pragma_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Pragma_declarationContext) GetId1() IIdentifierContext { return s.id1 }

func (s *Pragma_declarationContext) SetId1(v IIdentifierContext) { s.id1 = v }

func (s *Pragma_declarationContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRAGMA, 0)
}

func (s *Pragma_declarationContext) SERIALLY_REUSABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSERIALLY_REUSABLE, 0)
}

func (s *Pragma_declarationContext) AUTONOMOUS_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUTONOMOUS_TRANSACTION, 0)
}

func (s *Pragma_declarationContext) EXCEPTION_INIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCEPTION_INIT, 0)
}

func (s *Pragma_declarationContext) Exception_name() IException_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_nameContext)
}

func (s *Pragma_declarationContext) Numeric_negative() INumeric_negativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeric_negativeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeric_negativeContext)
}

func (s *Pragma_declarationContext) INLINE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINLINE, 0)
}

func (s *Pragma_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pragma_declarationContext) RESTRICT_REFERENCES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESTRICT_REFERENCES, 0)
}

func (s *Pragma_declarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Pragma_declarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Pragma_declarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFAULT, 0)
}

func (s *Pragma_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pragma_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pragma_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPragma_declaration(s)
	}
}

func (s *Pragma_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPragma_declaration(s)
	}
}

func (p *PlSqlParser) Pragma_declaration() (localctx IPragma_declarationContext) {
	localctx = NewPragma_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, PlSqlParserRULE_pragma_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2480)
		p.Match(PlSqlParserPRAGMA)
	}
	p.SetState(2511)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserSERIALLY_REUSABLE:
		{
			p.SetState(2481)
			p.Match(PlSqlParserSERIALLY_REUSABLE)
		}

	case PlSqlParserAUTONOMOUS_TRANSACTION:
		{
			p.SetState(2482)
			p.Match(PlSqlParserAUTONOMOUS_TRANSACTION)
		}

	case PlSqlParserEXCEPTION_INIT:
		{
			p.SetState(2483)
			p.Match(PlSqlParserEXCEPTION_INIT)
		}
		{
			p.SetState(2484)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(2485)
			p.Exception_name()
		}
		{
			p.SetState(2486)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(2487)
			p.Numeric_negative()
		}
		{
			p.SetState(2488)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserINLINE:
		{
			p.SetState(2490)
			p.Match(PlSqlParserINLINE)
		}
		{
			p.SetState(2491)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(2492)

			var _x = p.Identifier()

			localctx.(*Pragma_declarationContext).id1 = _x
		}
		{
			p.SetState(2493)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(2494)
			p.Expression()
		}
		{
			p.SetState(2495)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserRESTRICT_REFERENCES:
		{
			p.SetState(2497)
			p.Match(PlSqlParserRESTRICT_REFERENCES)
		}
		{
			p.SetState(2498)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(2501)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
			{
				p.SetState(2499)
				p.Identifier()
			}

		case PlSqlParserDEFAULT:
			{
				p.SetState(2500)
				p.Match(PlSqlParserDEFAULT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(2505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PlSqlParserCOMMA {
			{
				p.SetState(2503)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(2504)
				p.Identifier()
			}

			p.SetState(2507)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2509)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2513)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// IRecord_type_defContext is an interface to support dynamic dispatch.
type IRecord_type_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecord_type_defContext differentiates from other interfaces.
	IsRecord_type_defContext()
}

type Record_type_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecord_type_defContext() *Record_type_defContext {
	var p = new(Record_type_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_record_type_def
	return p
}

func (*Record_type_defContext) IsRecord_type_defContext() {}

func NewRecord_type_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Record_type_defContext {
	var p = new(Record_type_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_record_type_def

	return p
}

func (s *Record_type_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Record_type_defContext) RECORD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRECORD, 0)
}

func (s *Record_type_defContext) AllField_spec() []IField_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IField_specContext)(nil)).Elem())
	var tst = make([]IField_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IField_specContext)
		}
	}

	return tst
}

func (s *Record_type_defContext) Field_spec(i int) IField_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IField_specContext)
}

func (s *Record_type_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Record_type_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Record_type_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRecord_type_def(s)
	}
}

func (s *Record_type_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRecord_type_def(s)
	}
}

func (p *PlSqlParser) Record_type_def() (localctx IRecord_type_defContext) {
	localctx = NewRecord_type_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, PlSqlParserRULE_record_type_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2515)
		p.Match(PlSqlParserRECORD)
	}
	{
		p.SetState(2516)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2517)
		p.Field_spec()
	}
	p.SetState(2522)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(2518)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(2519)
			p.Field_spec()
		}

		p.SetState(2524)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2525)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IField_specContext is an interface to support dynamic dispatch.
type IField_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_specContext differentiates from other interfaces.
	IsField_specContext()
}

type Field_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_specContext() *Field_specContext {
	var p = new(Field_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_field_spec
	return p
}

func (*Field_specContext) IsField_specContext() {}

func NewField_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_specContext {
	var p = new(Field_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_field_spec

	return p
}

func (s *Field_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_specContext) Column_name() IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Field_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Field_specContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Field_specContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *Field_specContext) Default_value_part() IDefault_value_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_value_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_value_partContext)
}

func (s *Field_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterField_spec(s)
	}
}

func (s *Field_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitField_spec(s)
	}
}

func (p *PlSqlParser) Field_spec() (localctx IField_specContext) {
	localctx = NewField_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, PlSqlParserRULE_field_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2527)
		p.Column_name()
	}
	p.SetState(2529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(2528)
			p.Type_spec()
		}

	}
	p.SetState(2533)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNOT {
		{
			p.SetState(2531)
			p.Match(PlSqlParserNOT)
		}
		{
			p.SetState(2532)
			p.Match(PlSqlParserNULL)
		}

	}
	p.SetState(2536)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserDEFAULT || _la == PlSqlParserASSIGN_OP {
		{
			p.SetState(2535)
			p.Default_value_part()
		}

	}

	return localctx
}

// IRef_cursor_type_defContext is an interface to support dynamic dispatch.
type IRef_cursor_type_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRef_cursor_type_defContext differentiates from other interfaces.
	IsRef_cursor_type_defContext()
}

type Ref_cursor_type_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRef_cursor_type_defContext() *Ref_cursor_type_defContext {
	var p = new(Ref_cursor_type_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_ref_cursor_type_def
	return p
}

func (*Ref_cursor_type_defContext) IsRef_cursor_type_defContext() {}

func NewRef_cursor_type_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ref_cursor_type_defContext {
	var p = new(Ref_cursor_type_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_ref_cursor_type_def

	return p
}

func (s *Ref_cursor_type_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Ref_cursor_type_defContext) REF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREF, 0)
}

func (s *Ref_cursor_type_defContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCURSOR, 0)
}

func (s *Ref_cursor_type_defContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Ref_cursor_type_defContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Ref_cursor_type_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ref_cursor_type_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ref_cursor_type_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRef_cursor_type_def(s)
	}
}

func (s *Ref_cursor_type_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRef_cursor_type_def(s)
	}
}

func (p *PlSqlParser) Ref_cursor_type_def() (localctx IRef_cursor_type_defContext) {
	localctx = NewRef_cursor_type_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, PlSqlParserRULE_ref_cursor_type_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2538)
		p.Match(PlSqlParserREF)
	}
	{
		p.SetState(2539)
		p.Match(PlSqlParserCURSOR)
	}
	p.SetState(2542)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserRETURN {
		{
			p.SetState(2540)
			p.Match(PlSqlParserRETURN)
		}
		{
			p.SetState(2541)
			p.Type_spec()
		}

	}

	return localctx
}

// IType_declarationContext is an interface to support dynamic dispatch.
type IType_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_declarationContext differentiates from other interfaces.
	IsType_declarationContext()
}

type Type_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declarationContext() *Type_declarationContext {
	var p = new(Type_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_type_declaration
	return p
}

func (*Type_declarationContext) IsType_declarationContext() {}

func NewType_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declarationContext {
	var p = new(Type_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_type_declaration

	return p
}

func (s *Type_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTYPE, 0)
}

func (s *Type_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Type_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, 0)
}

func (s *Type_declarationContext) Table_type_def() ITable_type_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_type_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_type_defContext)
}

func (s *Type_declarationContext) Varray_type_def() IVarray_type_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarray_type_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarray_type_defContext)
}

func (s *Type_declarationContext) Record_type_def() IRecord_type_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecord_type_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecord_type_defContext)
}

func (s *Type_declarationContext) Ref_cursor_type_def() IRef_cursor_type_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRef_cursor_type_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRef_cursor_type_defContext)
}

func (s *Type_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterType_declaration(s)
	}
}

func (s *Type_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitType_declaration(s)
	}
}

func (p *PlSqlParser) Type_declaration() (localctx IType_declarationContext) {
	localctx = NewType_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, PlSqlParserRULE_type_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2544)
		p.Match(PlSqlParserTYPE)
	}
	{
		p.SetState(2545)
		p.Identifier()
	}
	{
		p.SetState(2546)
		p.Match(PlSqlParserIS)
	}
	p.SetState(2551)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserTABLE:
		{
			p.SetState(2547)
			p.Table_type_def()
		}

	case PlSqlParserVARRAY, PlSqlParserVARYING:
		{
			p.SetState(2548)
			p.Varray_type_def()
		}

	case PlSqlParserRECORD:
		{
			p.SetState(2549)
			p.Record_type_def()
		}

	case PlSqlParserREF:
		{
			p.SetState(2550)
			p.Ref_cursor_type_def()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2553)
		p.Match(PlSqlParserSEMICOLON)
	}

	return localctx
}

// ITable_type_defContext is an interface to support dynamic dispatch.
type ITable_type_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_type_defContext differentiates from other interfaces.
	IsTable_type_defContext()
}

type Table_type_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_type_defContext() *Table_type_defContext {
	var p = new(Table_type_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_type_def
	return p
}

func (*Table_type_defContext) IsTable_type_defContext() {}

func NewTable_type_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_type_defContext {
	var p = new(Table_type_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_type_def

	return p
}

func (s *Table_type_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_type_defContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Table_type_defContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Table_type_defContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Table_type_defContext) Table_indexed_by_part() ITable_indexed_by_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_indexed_by_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_indexed_by_partContext)
}

func (s *Table_type_defContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Table_type_defContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *Table_type_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_type_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_type_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_type_def(s)
	}
}

func (s *Table_type_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_type_def(s)
	}
}

func (p *PlSqlParser) Table_type_def() (localctx ITable_type_defContext) {
	localctx = NewTable_type_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, PlSqlParserRULE_table_type_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2555)
		p.Match(PlSqlParserTABLE)
	}
	{
		p.SetState(2556)
		p.Match(PlSqlParserOF)
	}
	{
		p.SetState(2557)
		p.Type_spec()
	}
	p.SetState(2559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserINDEXED || _la == PlSqlParserINDEX {
		{
			p.SetState(2558)
			p.Table_indexed_by_part()
		}

	}
	p.SetState(2563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNOT {
		{
			p.SetState(2561)
			p.Match(PlSqlParserNOT)
		}
		{
			p.SetState(2562)
			p.Match(PlSqlParserNULL)
		}

	}

	return localctx
}

// ITable_indexed_by_partContext is an interface to support dynamic dispatch.
type ITable_indexed_by_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIdx1 returns the idx1 token.
	GetIdx1() antlr.Token

	// GetIdx2 returns the idx2 token.
	GetIdx2() antlr.Token

	// SetIdx1 sets the idx1 token.
	SetIdx1(antlr.Token)

	// SetIdx2 sets the idx2 token.
	SetIdx2(antlr.Token)

	// IsTable_indexed_by_partContext differentiates from other interfaces.
	IsTable_indexed_by_partContext()
}

type Table_indexed_by_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	idx1   antlr.Token
	idx2   antlr.Token
}

func NewEmptyTable_indexed_by_partContext() *Table_indexed_by_partContext {
	var p = new(Table_indexed_by_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_indexed_by_part
	return p
}

func (*Table_indexed_by_partContext) IsTable_indexed_by_partContext() {}

func NewTable_indexed_by_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_indexed_by_partContext {
	var p = new(Table_indexed_by_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_indexed_by_part

	return p
}

func (s *Table_indexed_by_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_indexed_by_partContext) GetIdx1() antlr.Token { return s.idx1 }

func (s *Table_indexed_by_partContext) GetIdx2() antlr.Token { return s.idx2 }

func (s *Table_indexed_by_partContext) SetIdx1(v antlr.Token) { s.idx1 = v }

func (s *Table_indexed_by_partContext) SetIdx2(v antlr.Token) { s.idx2 = v }

func (s *Table_indexed_by_partContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Table_indexed_by_partContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Table_indexed_by_partContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDEXED, 0)
}

func (s *Table_indexed_by_partContext) INDEX() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDEX, 0)
}

func (s *Table_indexed_by_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_indexed_by_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_indexed_by_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_indexed_by_part(s)
	}
}

func (s *Table_indexed_by_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_indexed_by_part(s)
	}
}

func (p *PlSqlParser) Table_indexed_by_part() (localctx ITable_indexed_by_partContext) {
	localctx = NewTable_indexed_by_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, PlSqlParserRULE_table_indexed_by_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2567)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserINDEXED:
		{
			p.SetState(2565)

			var _m = p.Match(PlSqlParserINDEXED)

			localctx.(*Table_indexed_by_partContext).idx1 = _m
		}

	case PlSqlParserINDEX:
		{
			p.SetState(2566)

			var _m = p.Match(PlSqlParserINDEX)

			localctx.(*Table_indexed_by_partContext).idx2 = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2569)
		p.Match(PlSqlParserBY)
	}
	{
		p.SetState(2570)
		p.Type_spec()
	}

	return localctx
}

// IVarray_type_defContext is an interface to support dynamic dispatch.
type IVarray_type_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarray_type_defContext differentiates from other interfaces.
	IsVarray_type_defContext()
}

type Varray_type_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarray_type_defContext() *Varray_type_defContext {
	var p = new(Varray_type_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_varray_type_def
	return p
}

func (*Varray_type_defContext) IsVarray_type_defContext() {}

func NewVarray_type_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Varray_type_defContext {
	var p = new(Varray_type_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_varray_type_def

	return p
}

func (s *Varray_type_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Varray_type_defContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Varray_type_defContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Varray_type_defContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Varray_type_defContext) VARRAY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARRAY, 0)
}

func (s *Varray_type_defContext) VARYING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARYING, 0)
}

func (s *Varray_type_defContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserARRAY, 0)
}

func (s *Varray_type_defContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Varray_type_defContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *Varray_type_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Varray_type_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Varray_type_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterVarray_type_def(s)
	}
}

func (s *Varray_type_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitVarray_type_def(s)
	}
}

func (p *PlSqlParser) Varray_type_def() (localctx IVarray_type_defContext) {
	localctx = NewVarray_type_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, PlSqlParserRULE_varray_type_def)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2575)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserVARRAY:
		{
			p.SetState(2572)
			p.Match(PlSqlParserVARRAY)
		}

	case PlSqlParserVARYING:
		{
			p.SetState(2573)
			p.Match(PlSqlParserVARYING)
		}
		{
			p.SetState(2574)
			p.Match(PlSqlParserARRAY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2577)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2578)
		p.Expression()
	}
	{
		p.SetState(2579)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	{
		p.SetState(2580)
		p.Match(PlSqlParserOF)
	}
	{
		p.SetState(2581)
		p.Type_spec()
	}
	p.SetState(2584)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 250, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2582)
			p.Match(PlSqlParserNOT)
		}
		{
			p.SetState(2583)
			p.Match(PlSqlParserNULL)
		}

	}

	return localctx
}

// ISeq_of_statementsContext is an interface to support dynamic dispatch.
type ISeq_of_statementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeq_of_statementsContext differentiates from other interfaces.
	IsSeq_of_statementsContext()
}

type Seq_of_statementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeq_of_statementsContext() *Seq_of_statementsContext {
	var p = new(Seq_of_statementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_seq_of_statements
	return p
}

func (*Seq_of_statementsContext) IsSeq_of_statementsContext() {}

func NewSeq_of_statementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seq_of_statementsContext {
	var p = new(Seq_of_statementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_seq_of_statements

	return p
}

func (s *Seq_of_statementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Seq_of_statementsContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Seq_of_statementsContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Seq_of_statementsContext) AllLabel_declaration() []ILabel_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILabel_declarationContext)(nil)).Elem())
	var tst = make([]ILabel_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILabel_declarationContext)
		}
	}

	return tst
}

func (s *Seq_of_statementsContext) Label_declaration(i int) ILabel_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILabel_declarationContext)
}

func (s *Seq_of_statementsContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserEOF)
}

func (s *Seq_of_statementsContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserEOF, i)
}

func (s *Seq_of_statementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seq_of_statementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seq_of_statementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSeq_of_statements(s)
	}
}

func (s *Seq_of_statementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSeq_of_statements(s)
	}
}

func (p *PlSqlParser) Seq_of_statements() (localctx ISeq_of_statementsContext) {
	localctx = NewSeq_of_statementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, PlSqlParserRULE_seq_of_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2590)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(2590)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBEGIN, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCREATE, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECLARE, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFETCH, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFOR, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGOTO, PlSqlParserGRANT, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIF, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSERT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOCK, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPIPE, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPROCEDURE, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELECT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPDATE, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWITH, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
				{
					p.SetState(2586)
					p.Statement()
				}
				{
					p.SetState(2587)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserEOF || _la == PlSqlParserSEMICOLON) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case PlSqlParserLESS_THAN_OP:
				{
					p.SetState(2589)
					p.Label_declaration()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2592)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 252, p.GetParserRuleContext())
	}

	return localctx
}

// ILabel_declarationContext is an interface to support dynamic dispatch.
type ILabel_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLtp1 returns the ltp1 token.
	GetLtp1() antlr.Token

	// SetLtp1 sets the ltp1 token.
	SetLtp1(antlr.Token)

	// IsLabel_declarationContext differentiates from other interfaces.
	IsLabel_declarationContext()
}

type Label_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	ltp1   antlr.Token
}

func NewEmptyLabel_declarationContext() *Label_declarationContext {
	var p = new(Label_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_label_declaration
	return p
}

func (*Label_declarationContext) IsLabel_declarationContext() {}

func NewLabel_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Label_declarationContext {
	var p = new(Label_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_label_declaration

	return p
}

func (s *Label_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Label_declarationContext) GetLtp1() antlr.Token { return s.ltp1 }

func (s *Label_declarationContext) SetLtp1(v antlr.Token) { s.ltp1 = v }

func (s *Label_declarationContext) Label_name() ILabel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_nameContext)
}

func (s *Label_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Label_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Label_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterLabel_declaration(s)
	}
}

func (s *Label_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitLabel_declaration(s)
	}
}

func (p *PlSqlParser) Label_declaration() (localctx ILabel_declarationContext) {
	localctx = NewLabel_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, PlSqlParserRULE_label_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2594)

		var _m = p.Match(PlSqlParserLESS_THAN_OP)

		localctx.(*Label_declarationContext).ltp1 = _m
	}
	{
		p.SetState(2595)
		p.Match(PlSqlParserLESS_THAN_OP)
	}
	{
		p.SetState(2596)
		p.Label_name()
	}
	{
		p.SetState(2597)
		p.Match(PlSqlParserGREATER_THAN_OP)
	}
	{
		p.SetState(2598)
		p.Match(PlSqlParserGREATER_THAN_OP)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCREATE, 0)
}

func (s *StatementContext) Swallow_to_semi() ISwallow_to_semiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwallow_to_semiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwallow_to_semiContext)
}

func (s *StatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALTER, 0)
}

func (s *StatementContext) GRANT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserGRANT, 0)
}

func (s *StatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *StatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRUNCATE, 0)
}

func (s *StatementContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *StatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) Assignment_statement() IAssignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_statementContext)
}

func (s *StatementContext) Continue_statement() IContinue_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinue_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinue_statementContext)
}

func (s *StatementContext) Exit_statement() IExit_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExit_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExit_statementContext)
}

func (s *StatementContext) Goto_statement() IGoto_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoto_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoto_statementContext)
}

func (s *StatementContext) If_statement() IIf_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_statementContext)
}

func (s *StatementContext) Loop_statement() ILoop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_statementContext)
}

func (s *StatementContext) Forall_statement() IForall_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForall_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForall_statementContext)
}

func (s *StatementContext) Null_statement() INull_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_statementContext)
}

func (s *StatementContext) Raise_statement() IRaise_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaise_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaise_statementContext)
}

func (s *StatementContext) Return_statement() IReturn_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_statementContext)
}

func (s *StatementContext) Case_statement() ICase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_statementContext)
}

func (s *StatementContext) Sql_statement() ISql_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISql_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *StatementContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *StatementContext) Pipe_row_statement() IPipe_row_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPipe_row_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPipe_row_statementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *PlSqlParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, PlSqlParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2627)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2600)
			p.Match(PlSqlParserCREATE)
		}
		{
			p.SetState(2601)
			p.Swallow_to_semi()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2602)
			p.Match(PlSqlParserALTER)
		}
		{
			p.SetState(2603)
			p.Swallow_to_semi()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2604)
			p.Match(PlSqlParserGRANT)
		}
		p.SetState(2606)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2605)
				p.Match(PlSqlParserALL)
			}

		}
		{
			p.SetState(2608)
			p.Swallow_to_semi()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2609)
			p.Match(PlSqlParserTRUNCATE)
		}
		{
			p.SetState(2610)
			p.Swallow_to_semi()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2611)
			p.Body()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2612)
			p.Block()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2613)
			p.Assignment_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2614)
			p.Continue_statement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2615)
			p.Exit_statement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2616)
			p.Goto_statement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2617)
			p.If_statement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2618)
			p.Loop_statement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2619)
			p.Forall_statement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2620)
			p.Null_statement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2621)
			p.Raise_statement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2622)
			p.Return_statement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2623)
			p.Case_statement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2624)
			p.Sql_statement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2625)
			p.Function_call()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2626)
			p.Pipe_row_statement()
		}

	}

	return localctx
}

// ISwallow_to_semiContext is an interface to support dynamic dispatch.
type ISwallow_to_semiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwallow_to_semiContext differentiates from other interfaces.
	IsSwallow_to_semiContext()
}

type Swallow_to_semiContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwallow_to_semiContext() *Swallow_to_semiContext {
	var p = new(Swallow_to_semiContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_swallow_to_semi
	return p
}

func (*Swallow_to_semiContext) IsSwallow_to_semiContext() {}

func NewSwallow_to_semiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Swallow_to_semiContext {
	var p = new(Swallow_to_semiContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_swallow_to_semi

	return p
}

func (s *Swallow_to_semiContext) GetParser() antlr.Parser { return s.parser }
func (s *Swallow_to_semiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Swallow_to_semiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Swallow_to_semiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSwallow_to_semi(s)
	}
}

func (s *Swallow_to_semiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSwallow_to_semi(s)
	}
}

func (p *PlSqlParser) Swallow_to_semi() (localctx ISwallow_to_semiContext) {
	localctx = NewSwallow_to_semiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, PlSqlParserRULE_swallow_to_semi)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2630)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserALTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserAND)|(1<<PlSqlParserANY)|(1<<PlSqlParserARCHIVE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserAS)|(1<<PlSqlParserASC)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBASIC)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBEGIN)|(1<<PlSqlParserBETWEEN)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBREADTH-32))|(1<<(PlSqlParserBUFFER_POOL-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBY-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCACHE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHECK-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMN-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCOMPRESS-64))|(1<<(PlSqlParserCOMPUTE-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONNECT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCREATE-64))|(1<<(PlSqlParserCREATION-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECLARE-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDEPTH-96))|(1<<(PlSqlParserDESC-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDROP-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserELSE-96))|(1<<(PlSqlParserELSIF-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(PlSqlParserENCRYPT-128))|(1<<(PlSqlParserEND-128))|(1<<(PlSqlParserENTITYESCAPING-128))|(1<<(PlSqlParserERR-128))|(1<<(PlSqlParserERRORS-128))|(1<<(PlSqlParserESCAPE-128))|(1<<(PlSqlParserEVALNAME-128))|(1<<(PlSqlParserEXCEPTION-128))|(1<<(PlSqlParserEXCEPTION_INIT-128))|(1<<(PlSqlParserEXCEPTIONS-128))|(1<<(PlSqlParserEXCLUDE-128))|(1<<(PlSqlParserEXCLUSIVE-128))|(1<<(PlSqlParserEXECUTE-128))|(1<<(PlSqlParserEXISTS-128))|(1<<(PlSqlParserEXIT-128))|(1<<(PlSqlParserEXPLAIN-128))|(1<<(PlSqlParserEXTERNAL-128))|(1<<(PlSqlParserEXTRACT-128))|(1<<(PlSqlParserFAILURE-128))|(1<<(PlSqlParserFALSE-128))|(1<<(PlSqlParserFETCH-128))|(1<<(PlSqlParserFILESYSTEM_LIKE_LOGGING-128))|(1<<(PlSqlParserFINAL-128))|(1<<(PlSqlParserFIRST-128))|(1<<(PlSqlParserFIRST_VALUE-128))|(1<<(PlSqlParserFLASH_CACHE-128))|(1<<(PlSqlParserFLOAT-128))|(1<<(PlSqlParserFOLLOWING-128))|(1<<(PlSqlParserFOLLOWS-128))|(1<<(PlSqlParserFORALL-128))|(1<<(PlSqlParserFORCE-128))|(1<<(PlSqlParserFOREIGN-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(PlSqlParserFOR-160))|(1<<(PlSqlParserFREELIST-160))|(1<<(PlSqlParserFREELISTS-160))|(1<<(PlSqlParserFROM-160))|(1<<(PlSqlParserFULL-160))|(1<<(PlSqlParserFUNCTION-160))|(1<<(PlSqlParserGLOBAL-160))|(1<<(PlSqlParserGOTO-160))|(1<<(PlSqlParserGRANT-160))|(1<<(PlSqlParserGROUP-160))|(1<<(PlSqlParserGROUPING-160))|(1<<(PlSqlParserGROUPS-160))|(1<<(PlSqlParserHASH-160))|(1<<(PlSqlParserHAVING-160))|(1<<(PlSqlParserHIDE-160))|(1<<(PlSqlParserHIGH-160))|(1<<(PlSqlParserHOUR-160))|(1<<(PlSqlParserIF-160))|(1<<(PlSqlParserIGNORE-160))|(1<<(PlSqlParserIMMEDIATE-160))|(1<<(PlSqlParserINCLUDE-160))|(1<<(PlSqlParserINCLUDING-160))|(1<<(PlSqlParserINCREMENT-160))|(1<<(PlSqlParserINDENT-160))|(1<<(PlSqlParserINDEXED-160))|(1<<(PlSqlParserINDEX-160))|(1<<(PlSqlParserINDICATOR-160))|(1<<(PlSqlParserINDICES-160))|(1<<(PlSqlParserINFINITE-160))|(1<<(PlSqlParserIN-160))|(1<<(PlSqlParserINITIAL-160))|(1<<(PlSqlParserINITRANS-160)))) != 0) || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(PlSqlParserINLINE-192))|(1<<(PlSqlParserINNER-192))|(1<<(PlSqlParserINOUT-192))|(1<<(PlSqlParserINSERT-192))|(1<<(PlSqlParserINSTANTIABLE-192))|(1<<(PlSqlParserINSTEAD-192))|(1<<(PlSqlParserINTEGER-192))|(1<<(PlSqlParserINTERSECT-192))|(1<<(PlSqlParserINTERVAL-192))|(1<<(PlSqlParserINT-192))|(1<<(PlSqlParserINTO-192))|(1<<(PlSqlParserINVALIDATE-192))|(1<<(PlSqlParserIS-192))|(1<<(PlSqlParserISOLATION-192))|(1<<(PlSqlParserITERATE-192))|(1<<(PlSqlParserJAVA-192))|(1<<(PlSqlParserJOIN-192))|(1<<(PlSqlParserKEEP-192))|(1<<(PlSqlParserKEY-192))|(1<<(PlSqlParserLANGUAGE-192))|(1<<(PlSqlParserLAST-192))|(1<<(PlSqlParserLAST_VALUE-192))|(1<<(PlSqlParserLEADING-192))|(1<<(PlSqlParserLEFT-192))|(1<<(PlSqlParserLEVEL-192))|(1<<(PlSqlParserLIBRARY-192))|(1<<(PlSqlParserLIKE2-192))|(1<<(PlSqlParserLIKE4-192))|(1<<(PlSqlParserLIKEC-192))|(1<<(PlSqlParserLIKE-192))|(1<<(PlSqlParserLIMIT-192))|(1<<(PlSqlParserLIST-192)))) != 0) || (((_la-224)&-(0x1f+1)) == 0 && ((1<<uint((_la-224)))&((1<<(PlSqlParserLOCAL-224))|(1<<(PlSqlParserLOCKED-224))|(1<<(PlSqlParserLOCK-224))|(1<<(PlSqlParserLOGGING-224))|(1<<(PlSqlParserLOG-224))|(1<<(PlSqlParserLOGOFF-224))|(1<<(PlSqlParserLOGON-224))|(1<<(PlSqlParserLONG-224))|(1<<(PlSqlParserLOOP-224))|(1<<(PlSqlParserLOW-224))|(1<<(PlSqlParserMAIN-224))|(1<<(PlSqlParserMAP-224))|(1<<(PlSqlParserMATCHED-224))|(1<<(PlSqlParserMAXVALUE-224))|(1<<(PlSqlParserMEASURES-224))|(1<<(PlSqlParserMEMBER-224))|(1<<(PlSqlParserMERGE-224))|(1<<(PlSqlParserMINEXTENTS-224))|(1<<(PlSqlParserMINUS-224))|(1<<(PlSqlParserMINUTE-224))|(1<<(PlSqlParserMINVALUE-224))|(1<<(PlSqlParserMLSLABEL-224))|(1<<(PlSqlParserMODEL-224))|(1<<(PlSqlParserMODE-224))|(1<<(PlSqlParserMODIFY-224))|(1<<(PlSqlParserMONTH-224))|(1<<(PlSqlParserMULTISET-224))|(1<<(PlSqlParserNAME-224))|(1<<(PlSqlParserNAN-224))|(1<<(PlSqlParserNATURAL-224))|(1<<(PlSqlParserNATURALN-224))|(1<<(PlSqlParserNAV-224)))) != 0) || (((_la-256)&-(0x1f+1)) == 0 && ((1<<uint((_la-256)))&((1<<(PlSqlParserNCHAR_CS-256))|(1<<(PlSqlParserNCHAR-256))|(1<<(PlSqlParserNCLOB-256))|(1<<(PlSqlParserNESTED-256))|(1<<(PlSqlParserNEW-256))|(1<<(PlSqlParserNEXT-256))|(1<<(PlSqlParserNOAUDIT-256))|(1<<(PlSqlParserNOCACHE-256))|(1<<(PlSqlParserNOCOMPRESS-256))|(1<<(PlSqlParserNOCOPY-256))|(1<<(PlSqlParserNOCYCLE-256))|(1<<(PlSqlParserNOENTITYESCAPING-256))|(1<<(PlSqlParserNOLOGGING-256))|(1<<(PlSqlParserNOMAXVALUE-256))|(1<<(PlSqlParserNOMINVALUE-256))|(1<<(PlSqlParserNONE-256))|(1<<(PlSqlParserNO-256))|(1<<(PlSqlParserNOORDER-256))|(1<<(PlSqlParserNOSCHEMACHECK-256))|(1<<(PlSqlParserNOT-256))|(1<<(PlSqlParserNOWAIT-256))|(1<<(PlSqlParserNULL-256))|(1<<(PlSqlParserNULLS-256))|(1<<(PlSqlParserNUMBER-256))|(1<<(PlSqlParserNUMERIC-256))|(1<<(PlSqlParserNVARCHAR2-256))|(1<<(PlSqlParserOBJECT-256))|(1<<(PlSqlParserOFF-256))|(1<<(PlSqlParserOF-256))|(1<<(PlSqlParserOID-256))|(1<<(PlSqlParserOLD-256))|(1<<(PlSqlParserOLTP-256)))) != 0) || (((_la-288)&-(0x1f+1)) == 0 && ((1<<uint((_la-288)))&((1<<(PlSqlParserONLY-288))|(1<<(PlSqlParserON-288))|(1<<(PlSqlParserOPEN-288))|(1<<(PlSqlParserOPTIMAL-288))|(1<<(PlSqlParserOPTION-288))|(1<<(PlSqlParserORADATA-288))|(1<<(PlSqlParserORDER-288))|(1<<(PlSqlParserORDINALITY-288))|(1<<(PlSqlParserOR-288))|(1<<(PlSqlParserOSERROR-288))|(1<<(PlSqlParserOUTER-288))|(1<<(PlSqlParserOUT-288))|(1<<(PlSqlParserOVER-288))|(1<<(PlSqlParserOVERRIDING-288))|(1<<(PlSqlParserPACKAGE-288))|(1<<(PlSqlParserPARALLEL_ENABLE-288))|(1<<(PlSqlParserPARAMETERS-288))|(1<<(PlSqlParserPARENT-288))|(1<<(PlSqlParserPARTITION-288))|(1<<(PlSqlParserPASSING-288))|(1<<(PlSqlParserPATH-288))|(1<<(PlSqlParserPCTFREE-288))|(1<<(PlSqlParserPCTINCREASE-288))|(1<<(PlSqlParserPCTUSED-288))|(1<<(PlSqlParserPERCENT_FOUND-288))|(1<<(PlSqlParserPERCENT_ISOPEN-288))|(1<<(PlSqlParserPERCENT_NOTFOUND-288))|(1<<(PlSqlParserPERCENT_ROWCOUNT-288))|(1<<(PlSqlParserPERCENT_ROWTYPE-288))|(1<<(PlSqlParserPERCENT_TYPE-288))|(1<<(PlSqlParserPIPELINED-288))|(1<<(PlSqlParserPIPE-288)))) != 0) || (((_la-320)&-(0x1f+1)) == 0 && ((1<<uint((_la-320)))&((1<<(PlSqlParserPIVOT-320))|(1<<(PlSqlParserPLAN-320))|(1<<(PlSqlParserPLS_INTEGER-320))|(1<<(PlSqlParserPOSITIVEN-320))|(1<<(PlSqlParserPOSITIVE-320))|(1<<(PlSqlParserPRAGMA-320))|(1<<(PlSqlParserPRECEDING-320))|(1<<(PlSqlParserPRECISION-320))|(1<<(PlSqlParserPRESENT-320))|(1<<(PlSqlParserPRESERVE-320))|(1<<(PlSqlParserPRIMARY-320))|(1<<(PlSqlParserPRIOR-320))|(1<<(PlSqlParserPROCEDURE-320))|(1<<(PlSqlParserPUBLIC-320))|(1<<(PlSqlParserQUERY-320))|(1<<(PlSqlParserRAISE-320))|(1<<(PlSqlParserRANGE-320))|(1<<(PlSqlParserRAW-320))|(1<<(PlSqlParserREAD-320))|(1<<(PlSqlParserREAL-320))|(1<<(PlSqlParserRECORD-320))|(1<<(PlSqlParserRECYCLE-320))|(1<<(PlSqlParserREFERENCE-320))|(1<<(PlSqlParserREFERENCES-320))|(1<<(PlSqlParserREFERENCING-320))|(1<<(PlSqlParserREF-320))|(1<<(PlSqlParserREJECT-320))|(1<<(PlSqlParserRELIES_ON-320))|(1<<(PlSqlParserRENAME-320))|(1<<(PlSqlParserREPLACE-320))|(1<<(PlSqlParserRESPECT-320))|(1<<(PlSqlParserRESTRICT_REFERENCES-320)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(PlSqlParserRESULT_CACHE-352))|(1<<(PlSqlParserRESULT-352))|(1<<(PlSqlParserRETURNING-352))|(1<<(PlSqlParserRETURN-352))|(1<<(PlSqlParserREUSE-352))|(1<<(PlSqlParserREVERSE-352))|(1<<(PlSqlParserREVOKE-352))|(1<<(PlSqlParserRIGHT-352))|(1<<(PlSqlParserROLLBACK-352))|(1<<(PlSqlParserROLLUP-352))|(1<<(PlSqlParserROWID-352))|(1<<(PlSqlParserROW-352))|(1<<(PlSqlParserROWS-352))|(1<<(PlSqlParserRULES-352))|(1<<(PlSqlParserSAMPLE-352))|(1<<(PlSqlParserSAVEPOINT-352))|(1<<(PlSqlParserSAVE-352))|(1<<(PlSqlParserSCHEMACHECK-352))|(1<<(PlSqlParserSCHEMA-352))|(1<<(PlSqlParserSCN-352))|(1<<(PlSqlParserSEARCH-352))|(1<<(PlSqlParserSECOND-352))|(1<<(PlSqlParserSEED-352))|(1<<(PlSqlParserSEGMENT-352))|(1<<(PlSqlParserSELECT-352))|(1<<(PlSqlParserSELF-352))|(1<<(PlSqlParserSEQUENCE-352))|(1<<(PlSqlParserSEQUENTIAL-352))|(1<<(PlSqlParserSERIALIZABLE-352))|(1<<(PlSqlParserSERIALLY_REUSABLE-352))|(1<<(PlSqlParserSERVERERROR-352))|(1<<(PlSqlParserSESSIONTIMEZONE-352)))) != 0) || (((_la-384)&-(0x1f+1)) == 0 && ((1<<uint((_la-384)))&((1<<(PlSqlParserSET-384))|(1<<(PlSqlParserSETS-384))|(1<<(PlSqlParserSETTINGS-384))|(1<<(PlSqlParserSHARE-384))|(1<<(PlSqlParserSHOW-384))|(1<<(PlSqlParserSHUTDOWN-384))|(1<<(PlSqlParserSIBLINGS-384))|(1<<(PlSqlParserSIGNTYPE-384))|(1<<(PlSqlParserSIMPLE_INTEGER-384))|(1<<(PlSqlParserSINGLE-384))|(1<<(PlSqlParserSIZE-384))|(1<<(PlSqlParserSKIP_-384))|(1<<(PlSqlParserSMALLINT-384))|(1<<(PlSqlParserSNAPSHOT-384))|(1<<(PlSqlParserSOME-384))|(1<<(PlSqlParserSPECIFICATION-384))|(1<<(PlSqlParserSQLDATA-384))|(1<<(PlSqlParserSQLERROR-384))|(1<<(PlSqlParserSTANDALONE-384))|(1<<(PlSqlParserSTART-384))|(1<<(PlSqlParserSTARTUP-384))|(1<<(PlSqlParserSTATEMENT_ID-384))|(1<<(PlSqlParserSTATEMENT-384))|(1<<(PlSqlParserSTATIC-384))|(1<<(PlSqlParserSTATISTICS-384))|(1<<(PlSqlParserSTORAGE-384))|(1<<(PlSqlParserSTRING-384))|(1<<(PlSqlParserSUBMULTISET-384))|(1<<(PlSqlParserSUBPARTITION-384))|(1<<(PlSqlParserSUBSTITUTABLE-384))|(1<<(PlSqlParserSUBTYPE-384))|(1<<(PlSqlParserSUCCESS-384)))) != 0) || (((_la-416)&-(0x1f+1)) == 0 && ((1<<uint((_la-416)))&((1<<(PlSqlParserSUSPEND-416))|(1<<(PlSqlParserSYNONYM-416))|(1<<(PlSqlParserTABLESPACE-416))|(1<<(PlSqlParserTABLE-416))|(1<<(PlSqlParserTEMPORARY-416))|(1<<(PlSqlParserTHEN-416))|(1<<(PlSqlParserTHE-416))|(1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-416))|(1<<(PlSqlParserTIMESTAMP-416))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-416))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-416))|(1<<(PlSqlParserTIME-416))|(1<<(PlSqlParserTIMEZONE_ABBR-416))|(1<<(PlSqlParserTIMEZONE_HOUR-416))|(1<<(PlSqlParserTIMEZONE_MINUTE-416))|(1<<(PlSqlParserTIMEZONE_REGION-416))|(1<<(PlSqlParserTO-416))|(1<<(PlSqlParserTRAILING-416))|(1<<(PlSqlParserTRANSACTION-416))|(1<<(PlSqlParserTRANSLATE-416))|(1<<(PlSqlParserTREAT-416))|(1<<(PlSqlParserTRIGGER-416))|(1<<(PlSqlParserTRUE-416))|(1<<(PlSqlParserTRUNCATE-416))|(1<<(PlSqlParserTYPE-416))|(1<<(PlSqlParserUNBOUNDED-416))|(1<<(PlSqlParserUNDER-416))|(1<<(PlSqlParserUNION-416))|(1<<(PlSqlParserUNIQUE-416))|(1<<(PlSqlParserUNLIMITED-416))|(1<<(PlSqlParserUNPIVOT-416))|(1<<(PlSqlParserUNTIL-416)))) != 0) || (((_la-448)&-(0x1f+1)) == 0 && ((1<<uint((_la-448)))&((1<<(PlSqlParserUPDATED-448))|(1<<(PlSqlParserUPDATE-448))|(1<<(PlSqlParserUPSERT-448))|(1<<(PlSqlParserUROWID-448))|(1<<(PlSqlParserUSE-448))|(1<<(PlSqlParserUSING-448))|(1<<(PlSqlParserVALIDATE-448))|(1<<(PlSqlParserVALUES-448))|(1<<(PlSqlParserVALUE-448))|(1<<(PlSqlParserVARCHAR2-448))|(1<<(PlSqlParserVARCHAR-448))|(1<<(PlSqlParserVARIABLE-448))|(1<<(PlSqlParserVARRAY-448))|(1<<(PlSqlParserVARYING-448))|(1<<(PlSqlParserVERSIONS-448))|(1<<(PlSqlParserVERSION-448))|(1<<(PlSqlParserWAIT-448))|(1<<(PlSqlParserWARNING-448))|(1<<(PlSqlParserWELLFORMED-448))|(1<<(PlSqlParserWHENEVER-448))|(1<<(PlSqlParserWHEN-448))|(1<<(PlSqlParserWHERE-448))|(1<<(PlSqlParserWHILE-448))|(1<<(PlSqlParserWITHIN-448))|(1<<(PlSqlParserWITH-448))|(1<<(PlSqlParserWORK-448))|(1<<(PlSqlParserWRITE-448))|(1<<(PlSqlParserXMLAGG-448))|(1<<(PlSqlParserXMLATTRIBUTES-448))|(1<<(PlSqlParserXMLCAST-448))|(1<<(PlSqlParserXMLCOLATTVAL-448))|(1<<(PlSqlParserXMLELEMENT-448)))) != 0) || (((_la-480)&-(0x1f+1)) == 0 && ((1<<uint((_la-480)))&((1<<(PlSqlParserXMLEXISTS-480))|(1<<(PlSqlParserXMLFOREST-480))|(1<<(PlSqlParserXMLNAMESPACES-480))|(1<<(PlSqlParserXMLPARSE-480))|(1<<(PlSqlParserXMLPI-480))|(1<<(PlSqlParserXMLQUERY-480))|(1<<(PlSqlParserXMLROOT-480))|(1<<(PlSqlParserXMLSERIALIZE-480))|(1<<(PlSqlParserXMLTABLE-480))|(1<<(PlSqlParserXML-480))|(1<<(PlSqlParserYEAR-480))|(1<<(PlSqlParserYES-480))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-480))|(1<<(PlSqlParserZONE-480))|(1<<(PlSqlParserPREDICTION-480))|(1<<(PlSqlParserPREDICTION_BOUNDS-480))|(1<<(PlSqlParserPREDICTION_COST-480))|(1<<(PlSqlParserPREDICTION_DETAILS-480))|(1<<(PlSqlParserPREDICTION_PROBABILITY-480))|(1<<(PlSqlParserPREDICTION_SET-480))|(1<<(PlSqlParserCUME_DIST-480))|(1<<(PlSqlParserDENSE_RANK-480))|(1<<(PlSqlParserLISTAGG-480))|(1<<(PlSqlParserPERCENT_RANK-480))|(1<<(PlSqlParserPERCENTILE_CONT-480))|(1<<(PlSqlParserPERCENTILE_DISC-480))|(1<<(PlSqlParserRANK-480))|(1<<(PlSqlParserAVG-480))|(1<<(PlSqlParserCORR-480))|(1<<(PlSqlParserCOVAR_-480))|(1<<(PlSqlParserDECODE-480))|(1<<(PlSqlParserLAG-480)))) != 0) || (((_la-512)&-(0x1f+1)) == 0 && ((1<<uint((_la-512)))&((1<<(PlSqlParserLEAD-512))|(1<<(PlSqlParserMAX-512))|(1<<(PlSqlParserMEDIAN-512))|(1<<(PlSqlParserMIN-512))|(1<<(PlSqlParserNTILE-512))|(1<<(PlSqlParserNVL-512))|(1<<(PlSqlParserRATIO_TO_REPORT-512))|(1<<(PlSqlParserREGR_-512))|(1<<(PlSqlParserROUND-512))|(1<<(PlSqlParserROW_NUMBER-512))|(1<<(PlSqlParserSUBSTR-512))|(1<<(PlSqlParserTO_CHAR-512))|(1<<(PlSqlParserTRIM-512))|(1<<(PlSqlParserSUM-512))|(1<<(PlSqlParserSTDDEV-512))|(1<<(PlSqlParserVAR_-512))|(1<<(PlSqlParserVARIANCE-512))|(1<<(PlSqlParserLEAST-512))|(1<<(PlSqlParserGREATEST-512))|(1<<(PlSqlParserTO_DATE-512))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-512))|(1<<(PlSqlParserBIT_STRING_LIT-512))|(1<<(PlSqlParserHEX_STRING_LIT-512))|(1<<(PlSqlParserDOUBLE_PERIOD-512))|(1<<(PlSqlParserPERIOD-512))|(1<<(PlSqlParserUNSIGNED_INTEGER-512))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-512))|(1<<(PlSqlParserCHAR_STRING-512))|(1<<(PlSqlParserDELIMITED_ID-512))|(1<<(PlSqlParserPERCENT-512))|(1<<(PlSqlParserAMPERSAND-512))|(1<<(PlSqlParserLEFT_PAREN-512)))) != 0) || (((_la-544)&-(0x1f+1)) == 0 && ((1<<uint((_la-544)))&((1<<(PlSqlParserRIGHT_PAREN-544))|(1<<(PlSqlParserDOUBLE_ASTERISK-544))|(1<<(PlSqlParserASTERISK-544))|(1<<(PlSqlParserPLUS_SIGN-544))|(1<<(PlSqlParserMINUS_SIGN-544))|(1<<(PlSqlParserCOMMA-544))|(1<<(PlSqlParserSOLIDUS-544))|(1<<(PlSqlParserAT_SIGN-544))|(1<<(PlSqlParserASSIGN_OP-544))|(1<<(PlSqlParserBINDVAR-544))|(1<<(PlSqlParserNOT_EQUAL_OP-544))|(1<<(PlSqlParserCARRET_OPERATOR_PART-544))|(1<<(PlSqlParserTILDE_OPERATOR_PART-544))|(1<<(PlSqlParserEXCLAMATION_OPERATOR_PART-544))|(1<<(PlSqlParserGREATER_THAN_OP-544))|(1<<(PlSqlParserLESS_THAN_OP-544))|(1<<(PlSqlParserCOLON-544))|(1<<(PlSqlParserBAR-544))|(1<<(PlSqlParserEQUALS_OP-544))|(1<<(PlSqlParserLEFT_BRACKET-544))|(1<<(PlSqlParserRIGHT_BRACKET-544))|(1<<(PlSqlParserINTRODUCER-544))|(1<<(PlSqlParserSPACES-544))|(1<<(PlSqlParserSINGLE_LINE_COMMENT-544))|(1<<(PlSqlParserMULTI_LINE_COMMENT-544))|(1<<(PlSqlParserPROMPT-544))|(1<<(PlSqlParserSTART_CMD-544))|(1<<(PlSqlParserREGULAR_ID-544))|(1<<(PlSqlParserZV-544)))) != 0) {
		{
			p.SetState(2629)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == PlSqlParserSEMICOLON {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(2632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignment_statementContext is an interface to support dynamic dispatch.
type IAssignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_statementContext differentiates from other interfaces.
	IsAssignment_statementContext()
}

type Assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_statementContext() *Assignment_statementContext {
	var p = new(Assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_assignment_statement
	return p
}

func (*Assignment_statementContext) IsAssignment_statementContext() {}

func NewAssignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_statementContext {
	var p = new(Assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_assignment_statement

	return p
}

func (s *Assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_statementContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserASSIGN_OP, 0)
}

func (s *Assignment_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Assignment_statementContext) General_element() IGeneral_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_elementContext)
}

func (s *Assignment_statementContext) Bind_variable() IBind_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_variableContext)
}

func (s *Assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAssignment_statement(s)
	}
}

func (s *Assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAssignment_statement(s)
	}
}

func (p *PlSqlParser) Assignment_statement() (localctx IAssignment_statementContext) {
	localctx = NewAssignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, PlSqlParserRULE_assignment_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2636)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(2634)
			p.General_element()
		}

	case PlSqlParserBINDVAR, PlSqlParserCOLON:
		{
			p.SetState(2635)
			p.Bind_variable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2638)
		p.Match(PlSqlParserASSIGN_OP)
	}
	{
		p.SetState(2639)
		p.Expression()
	}

	return localctx
}

// IContinue_statementContext is an interface to support dynamic dispatch.
type IContinue_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinue_statementContext differentiates from other interfaces.
	IsContinue_statementContext()
}

type Continue_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinue_statementContext() *Continue_statementContext {
	var p = new(Continue_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_continue_statement
	return p
}

func (*Continue_statementContext) IsContinue_statementContext() {}

func NewContinue_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_statementContext {
	var p = new(Continue_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_continue_statement

	return p
}

func (s *Continue_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Continue_statementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONTINUE, 0)
}

func (s *Continue_statementContext) Label_name() ILabel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_nameContext)
}

func (s *Continue_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHEN, 0)
}

func (s *Continue_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Continue_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continue_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterContinue_statement(s)
	}
}

func (s *Continue_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitContinue_statement(s)
	}
}

func (p *PlSqlParser) Continue_statement() (localctx IContinue_statementContext) {
	localctx = NewContinue_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, PlSqlParserRULE_continue_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2641)
		p.Match(PlSqlParserCONTINUE)
	}
	p.SetState(2643)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(2642)
			p.Label_name()
		}

	}
	p.SetState(2647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWHEN {
		{
			p.SetState(2645)
			p.Match(PlSqlParserWHEN)
		}
		{
			p.SetState(2646)
			p.Condition()
		}

	}

	return localctx
}

// IExit_statementContext is an interface to support dynamic dispatch.
type IExit_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExit_statementContext differentiates from other interfaces.
	IsExit_statementContext()
}

type Exit_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExit_statementContext() *Exit_statementContext {
	var p = new(Exit_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_exit_statement
	return p
}

func (*Exit_statementContext) IsExit_statementContext() {}

func NewExit_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exit_statementContext {
	var p = new(Exit_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_exit_statement

	return p
}

func (s *Exit_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Exit_statementContext) EXIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXIT, 0)
}

func (s *Exit_statementContext) Label_name() ILabel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_nameContext)
}

func (s *Exit_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHEN, 0)
}

func (s *Exit_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Exit_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exit_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exit_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterExit_statement(s)
	}
}

func (s *Exit_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitExit_statement(s)
	}
}

func (p *PlSqlParser) Exit_statement() (localctx IExit_statementContext) {
	localctx = NewExit_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, PlSqlParserRULE_exit_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2649)
		p.Match(PlSqlParserEXIT)
	}
	p.SetState(2651)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(2650)
			p.Label_name()
		}

	}
	p.SetState(2655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWHEN {
		{
			p.SetState(2653)
			p.Match(PlSqlParserWHEN)
		}
		{
			p.SetState(2654)
			p.Condition()
		}

	}

	return localctx
}

// IGoto_statementContext is an interface to support dynamic dispatch.
type IGoto_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoto_statementContext differentiates from other interfaces.
	IsGoto_statementContext()
}

type Goto_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoto_statementContext() *Goto_statementContext {
	var p = new(Goto_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_goto_statement
	return p
}

func (*Goto_statementContext) IsGoto_statementContext() {}

func NewGoto_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Goto_statementContext {
	var p = new(Goto_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_goto_statement

	return p
}

func (s *Goto_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Goto_statementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserGOTO, 0)
}

func (s *Goto_statementContext) Label_name() ILabel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_nameContext)
}

func (s *Goto_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Goto_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Goto_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterGoto_statement(s)
	}
}

func (s *Goto_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitGoto_statement(s)
	}
}

func (p *PlSqlParser) Goto_statement() (localctx IGoto_statementContext) {
	localctx = NewGoto_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, PlSqlParserRULE_goto_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2657)
		p.Match(PlSqlParserGOTO)
	}
	{
		p.SetState(2658)
		p.Label_name()
	}

	return localctx
}

// IIf_statementContext is an interface to support dynamic dispatch.
type IIf_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_statementContext differentiates from other interfaces.
	IsIf_statementContext()
}

type If_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_statementContext() *If_statementContext {
	var p = new(If_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_if_statement
	return p
}

func (*If_statementContext) IsIf_statementContext() {}

func NewIf_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_statementContext {
	var p = new(If_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_if_statement

	return p
}

func (s *If_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_statementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserIF)
}

func (s *If_statementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserIF, i)
}

func (s *If_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *If_statementContext) THEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTHEN, 0)
}

func (s *If_statementContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *If_statementContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *If_statementContext) AllElsif_part() []IElsif_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElsif_partContext)(nil)).Elem())
	var tst = make([]IElsif_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElsif_partContext)
		}
	}

	return tst
}

func (s *If_statementContext) Elsif_part(i int) IElsif_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElsif_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElsif_partContext)
}

func (s *If_statementContext) Else_part() IElse_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_partContext)
}

func (s *If_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterIf_statement(s)
	}
}

func (s *If_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitIf_statement(s)
	}
}

func (p *PlSqlParser) If_statement() (localctx IIf_statementContext) {
	localctx = NewIf_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, PlSqlParserRULE_if_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2660)
		p.Match(PlSqlParserIF)
	}
	{
		p.SetState(2661)
		p.Condition()
	}
	{
		p.SetState(2662)
		p.Match(PlSqlParserTHEN)
	}
	{
		p.SetState(2663)
		p.Seq_of_statements()
	}
	p.SetState(2667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserELSIF {
		{
			p.SetState(2664)
			p.Elsif_part()
		}

		p.SetState(2669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserELSE {
		{
			p.SetState(2670)
			p.Else_part()
		}

	}
	{
		p.SetState(2673)
		p.Match(PlSqlParserEND)
	}
	{
		p.SetState(2674)
		p.Match(PlSqlParserIF)
	}

	return localctx
}

// IElsif_partContext is an interface to support dynamic dispatch.
type IElsif_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElsif_partContext differentiates from other interfaces.
	IsElsif_partContext()
}

type Elsif_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElsif_partContext() *Elsif_partContext {
	var p = new(Elsif_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_elsif_part
	return p
}

func (*Elsif_partContext) IsElsif_partContext() {}

func NewElsif_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elsif_partContext {
	var p = new(Elsif_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_elsif_part

	return p
}

func (s *Elsif_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Elsif_partContext) ELSIF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserELSIF, 0)
}

func (s *Elsif_partContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Elsif_partContext) THEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTHEN, 0)
}

func (s *Elsif_partContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *Elsif_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elsif_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Elsif_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterElsif_part(s)
	}
}

func (s *Elsif_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitElsif_part(s)
	}
}

func (p *PlSqlParser) Elsif_part() (localctx IElsif_partContext) {
	localctx = NewElsif_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, PlSqlParserRULE_elsif_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2676)
		p.Match(PlSqlParserELSIF)
	}
	{
		p.SetState(2677)
		p.Condition()
	}
	{
		p.SetState(2678)
		p.Match(PlSqlParserTHEN)
	}
	{
		p.SetState(2679)
		p.Seq_of_statements()
	}

	return localctx
}

// IElse_partContext is an interface to support dynamic dispatch.
type IElse_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_partContext differentiates from other interfaces.
	IsElse_partContext()
}

type Else_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_partContext() *Else_partContext {
	var p = new(Else_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_else_part
	return p
}

func (*Else_partContext) IsElse_partContext() {}

func NewElse_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_partContext {
	var p = new(Else_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_else_part

	return p
}

func (s *Else_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_partContext) ELSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserELSE, 0)
}

func (s *Else_partContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *Else_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterElse_part(s)
	}
}

func (s *Else_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitElse_part(s)
	}
}

func (p *PlSqlParser) Else_part() (localctx IElse_partContext) {
	localctx = NewElse_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, PlSqlParserRULE_else_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2681)
		p.Match(PlSqlParserELSE)
	}
	{
		p.SetState(2682)
		p.Seq_of_statements()
	}

	return localctx
}

// ILoop_statementContext is an interface to support dynamic dispatch.
type ILoop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_statementContext differentiates from other interfaces.
	IsLoop_statementContext()
}

type Loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_statementContext() *Loop_statementContext {
	var p = new(Loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_loop_statement
	return p
}

func (*Loop_statementContext) IsLoop_statementContext() {}

func NewLoop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_statementContext {
	var p = new(Loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_loop_statement

	return p
}

func (s *Loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_statementContext) AllLOOP() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserLOOP)
}

func (s *Loop_statementContext) LOOP(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOOP, i)
}

func (s *Loop_statementContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *Loop_statementContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *Loop_statementContext) AllLabel_name() []ILabel_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem())
	var tst = make([]ILabel_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILabel_nameContext)
		}
	}

	return tst
}

func (s *Loop_statementContext) Label_name(i int) ILabel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILabel_nameContext)
}

func (s *Loop_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHILE, 0)
}

func (s *Loop_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Loop_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Loop_statementContext) Cursor_loop_param() ICursor_loop_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_loop_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_loop_paramContext)
}

func (s *Loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterLoop_statement(s)
	}
}

func (s *Loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitLoop_statement(s)
	}
}

func (p *PlSqlParser) Loop_statement() (localctx ILoop_statementContext) {
	localctx = NewLoop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, PlSqlParserRULE_loop_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2685)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2684)
			p.Label_name()
		}

	}
	p.SetState(2691)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserWHILE:
		{
			p.SetState(2687)
			p.Match(PlSqlParserWHILE)
		}
		{
			p.SetState(2688)
			p.Condition()
		}

	case PlSqlParserFOR:
		{
			p.SetState(2689)
			p.Match(PlSqlParserFOR)
		}
		{
			p.SetState(2690)
			p.Cursor_loop_param()
		}

	case PlSqlParserLOOP:

	default:
	}
	{
		p.SetState(2693)
		p.Match(PlSqlParserLOOP)
	}
	{
		p.SetState(2694)
		p.Seq_of_statements()
	}
	{
		p.SetState(2695)
		p.Match(PlSqlParserEND)
	}
	{
		p.SetState(2696)
		p.Match(PlSqlParserLOOP)
	}
	p.SetState(2698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(2697)
			p.Label_name()
		}

	}

	return localctx
}

// ICursor_loop_paramContext is an interface to support dynamic dispatch.
type ICursor_loop_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRange_ returns the range_ token.
	GetRange_() antlr.Token

	// SetRange_ sets the range_ token.
	SetRange_(antlr.Token)

	// IsCursor_loop_paramContext differentiates from other interfaces.
	IsCursor_loop_paramContext()
}

type Cursor_loop_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	range_ antlr.Token
}

func NewEmptyCursor_loop_paramContext() *Cursor_loop_paramContext {
	var p = new(Cursor_loop_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cursor_loop_param
	return p
}

func (*Cursor_loop_paramContext) IsCursor_loop_paramContext() {}

func NewCursor_loop_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_loop_paramContext {
	var p = new(Cursor_loop_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cursor_loop_param

	return p
}

func (s *Cursor_loop_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_loop_paramContext) GetRange_() antlr.Token { return s.range_ }

func (s *Cursor_loop_paramContext) SetRange_(v antlr.Token) { s.range_ = v }

func (s *Cursor_loop_paramContext) Index_name() IIndex_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_nameContext)
}

func (s *Cursor_loop_paramContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Cursor_loop_paramContext) Lower_bound() ILower_boundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILower_boundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILower_boundContext)
}

func (s *Cursor_loop_paramContext) Upper_bound() IUpper_boundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpper_boundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpper_boundContext)
}

func (s *Cursor_loop_paramContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREVERSE, 0)
}

func (s *Cursor_loop_paramContext) Record_name() IRecord_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecord_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecord_nameContext)
}

func (s *Cursor_loop_paramContext) Cursor_name() ICursor_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_nameContext)
}

func (s *Cursor_loop_paramContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Cursor_loop_paramContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Cursor_loop_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_loop_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cursor_loop_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCursor_loop_param(s)
	}
}

func (s *Cursor_loop_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCursor_loop_param(s)
	}
}

func (p *PlSqlParser) Cursor_loop_param() (localctx ICursor_loop_paramContext) {
	localctx = NewCursor_loop_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, PlSqlParserRULE_cursor_loop_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2725)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 270, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2700)
			p.Index_name()
		}
		{
			p.SetState(2701)
			p.Match(PlSqlParserIN)
		}
		p.SetState(2703)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2702)
				p.Match(PlSqlParserREVERSE)
			}

		}
		{
			p.SetState(2705)
			p.Lower_bound()
		}
		{
			p.SetState(2706)

			var _m = p.Match(PlSqlParserDOUBLE_PERIOD)

			localctx.(*Cursor_loop_paramContext).range_ = _m
		}
		{
			p.SetState(2707)
			p.Upper_bound()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2709)
			p.Record_name()
		}
		{
			p.SetState(2710)
			p.Match(PlSqlParserIN)
		}
		p.SetState(2723)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
			{
				p.SetState(2711)
				p.Cursor_name()
			}
			p.SetState(2717)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserLEFT_PAREN {
				{
					p.SetState(2712)
					p.Match(PlSqlParserLEFT_PAREN)
				}
				p.SetState(2714)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
					{
						p.SetState(2713)
						p.Expressions()
					}

				}
				{
					p.SetState(2716)
					p.Match(PlSqlParserRIGHT_PAREN)
				}

			}

		case PlSqlParserLEFT_PAREN:
			{
				p.SetState(2719)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			{
				p.SetState(2720)
				p.Select_statement()
			}
			{
				p.SetState(2721)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IForall_statementContext is an interface to support dynamic dispatch.
type IForall_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForall_statementContext differentiates from other interfaces.
	IsForall_statementContext()
}

type Forall_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForall_statementContext() *Forall_statementContext {
	var p = new(Forall_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_forall_statement
	return p
}

func (*Forall_statementContext) IsForall_statementContext() {}

func NewForall_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forall_statementContext {
	var p = new(Forall_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_forall_statement

	return p
}

func (s *Forall_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Forall_statementContext) FORALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFORALL, 0)
}

func (s *Forall_statementContext) Index_name() IIndex_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_nameContext)
}

func (s *Forall_statementContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Forall_statementContext) Bounds_clause() IBounds_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBounds_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBounds_clauseContext)
}

func (s *Forall_statementContext) Sql_statement() ISql_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISql_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *Forall_statementContext) SAVE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSAVE, 0)
}

func (s *Forall_statementContext) EXCEPTIONS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCEPTIONS, 0)
}

func (s *Forall_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forall_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forall_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterForall_statement(s)
	}
}

func (s *Forall_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitForall_statement(s)
	}
}

func (p *PlSqlParser) Forall_statement() (localctx IForall_statementContext) {
	localctx = NewForall_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, PlSqlParserRULE_forall_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2727)
		p.Match(PlSqlParserFORALL)
	}
	{
		p.SetState(2728)
		p.Index_name()
	}
	{
		p.SetState(2729)
		p.Match(PlSqlParserIN)
	}
	{
		p.SetState(2730)
		p.Bounds_clause()
	}
	{
		p.SetState(2731)
		p.Sql_statement()
	}
	p.SetState(2734)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserSAVE {
		{
			p.SetState(2732)
			p.Match(PlSqlParserSAVE)
		}
		{
			p.SetState(2733)
			p.Match(PlSqlParserEXCEPTIONS)
		}

	}

	return localctx
}

// IBounds_clauseContext is an interface to support dynamic dispatch.
type IBounds_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBounds_clauseContext differentiates from other interfaces.
	IsBounds_clauseContext()
}

type Bounds_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBounds_clauseContext() *Bounds_clauseContext {
	var p = new(Bounds_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_bounds_clause
	return p
}

func (*Bounds_clauseContext) IsBounds_clauseContext() {}

func NewBounds_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bounds_clauseContext {
	var p = new(Bounds_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_bounds_clause

	return p
}

func (s *Bounds_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Bounds_clauseContext) Lower_bound() ILower_boundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILower_boundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILower_boundContext)
}

func (s *Bounds_clauseContext) Upper_bound() IUpper_boundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpper_boundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpper_boundContext)
}

func (s *Bounds_clauseContext) INDICES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDICES, 0)
}

func (s *Bounds_clauseContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Bounds_clauseContext) Collection_name() ICollection_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_nameContext)
}

func (s *Bounds_clauseContext) Between_bound() IBetween_boundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBetween_boundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBetween_boundContext)
}

func (s *Bounds_clauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALUES, 0)
}

func (s *Bounds_clauseContext) Index_name() IIndex_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_nameContext)
}

func (s *Bounds_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bounds_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bounds_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterBounds_clause(s)
	}
}

func (s *Bounds_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitBounds_clause(s)
	}
}

func (p *PlSqlParser) Bounds_clause() (localctx IBounds_clauseContext) {
	localctx = NewBounds_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, PlSqlParserRULE_bounds_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2749)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 273, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2736)
			p.Lower_bound()
		}
		{
			p.SetState(2737)
			p.Match(PlSqlParserDOUBLE_PERIOD)
		}
		{
			p.SetState(2738)
			p.Upper_bound()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2740)
			p.Match(PlSqlParserINDICES)
		}
		{
			p.SetState(2741)
			p.Match(PlSqlParserOF)
		}
		{
			p.SetState(2742)
			p.Collection_name()
		}
		p.SetState(2744)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserBETWEEN {
			{
				p.SetState(2743)
				p.Between_bound()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2746)
			p.Match(PlSqlParserVALUES)
		}
		{
			p.SetState(2747)
			p.Match(PlSqlParserOF)
		}
		{
			p.SetState(2748)
			p.Index_name()
		}

	}

	return localctx
}

// IBetween_boundContext is an interface to support dynamic dispatch.
type IBetween_boundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBetween_boundContext differentiates from other interfaces.
	IsBetween_boundContext()
}

type Between_boundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBetween_boundContext() *Between_boundContext {
	var p = new(Between_boundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_between_bound
	return p
}

func (*Between_boundContext) IsBetween_boundContext() {}

func NewBetween_boundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Between_boundContext {
	var p = new(Between_boundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_between_bound

	return p
}

func (s *Between_boundContext) GetParser() antlr.Parser { return s.parser }

func (s *Between_boundContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBETWEEN, 0)
}

func (s *Between_boundContext) Lower_bound() ILower_boundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILower_boundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILower_boundContext)
}

func (s *Between_boundContext) AND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAND, 0)
}

func (s *Between_boundContext) Upper_bound() IUpper_boundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpper_boundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpper_boundContext)
}

func (s *Between_boundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Between_boundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Between_boundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterBetween_bound(s)
	}
}

func (s *Between_boundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitBetween_bound(s)
	}
}

func (p *PlSqlParser) Between_bound() (localctx IBetween_boundContext) {
	localctx = NewBetween_boundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, PlSqlParserRULE_between_bound)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2751)
		p.Match(PlSqlParserBETWEEN)
	}
	{
		p.SetState(2752)
		p.Lower_bound()
	}
	{
		p.SetState(2753)
		p.Match(PlSqlParserAND)
	}
	{
		p.SetState(2754)
		p.Upper_bound()
	}

	return localctx
}

// ILower_boundContext is an interface to support dynamic dispatch.
type ILower_boundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLower_boundContext differentiates from other interfaces.
	IsLower_boundContext()
}

type Lower_boundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLower_boundContext() *Lower_boundContext {
	var p = new(Lower_boundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_lower_bound
	return p
}

func (*Lower_boundContext) IsLower_boundContext() {}

func NewLower_boundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lower_boundContext {
	var p = new(Lower_boundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_lower_bound

	return p
}

func (s *Lower_boundContext) GetParser() antlr.Parser { return s.parser }

func (s *Lower_boundContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Lower_boundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lower_boundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lower_boundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterLower_bound(s)
	}
}

func (s *Lower_boundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitLower_bound(s)
	}
}

func (p *PlSqlParser) Lower_bound() (localctx ILower_boundContext) {
	localctx = NewLower_boundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, PlSqlParserRULE_lower_bound)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2756)
		p.concatenation(0)
	}

	return localctx
}

// IUpper_boundContext is an interface to support dynamic dispatch.
type IUpper_boundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpper_boundContext differentiates from other interfaces.
	IsUpper_boundContext()
}

type Upper_boundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpper_boundContext() *Upper_boundContext {
	var p = new(Upper_boundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_upper_bound
	return p
}

func (*Upper_boundContext) IsUpper_boundContext() {}

func NewUpper_boundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Upper_boundContext {
	var p = new(Upper_boundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_upper_bound

	return p
}

func (s *Upper_boundContext) GetParser() antlr.Parser { return s.parser }

func (s *Upper_boundContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Upper_boundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Upper_boundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Upper_boundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUpper_bound(s)
	}
}

func (s *Upper_boundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUpper_bound(s)
	}
}

func (p *PlSqlParser) Upper_bound() (localctx IUpper_boundContext) {
	localctx = NewUpper_boundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, PlSqlParserRULE_upper_bound)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2758)
		p.concatenation(0)
	}

	return localctx
}

// INull_statementContext is an interface to support dynamic dispatch.
type INull_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNull_statementContext differentiates from other interfaces.
	IsNull_statementContext()
}

type Null_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_statementContext() *Null_statementContext {
	var p = new(Null_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_null_statement
	return p
}

func (*Null_statementContext) IsNull_statementContext() {}

func NewNull_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_statementContext {
	var p = new(Null_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_null_statement

	return p
}

func (s *Null_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_statementContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *Null_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNull_statement(s)
	}
}

func (s *Null_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNull_statement(s)
	}
}

func (p *PlSqlParser) Null_statement() (localctx INull_statementContext) {
	localctx = NewNull_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, PlSqlParserRULE_null_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2760)
		p.Match(PlSqlParserNULL)
	}

	return localctx
}

// IRaise_statementContext is an interface to support dynamic dispatch.
type IRaise_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRaise_statementContext differentiates from other interfaces.
	IsRaise_statementContext()
}

type Raise_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_statementContext() *Raise_statementContext {
	var p = new(Raise_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_raise_statement
	return p
}

func (*Raise_statementContext) IsRaise_statementContext() {}

func NewRaise_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_statementContext {
	var p = new(Raise_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_raise_statement

	return p
}

func (s *Raise_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_statementContext) RAISE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRAISE, 0)
}

func (s *Raise_statementContext) Exception_name() IException_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_nameContext)
}

func (s *Raise_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raise_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRaise_statement(s)
	}
}

func (s *Raise_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRaise_statement(s)
	}
}

func (p *PlSqlParser) Raise_statement() (localctx IRaise_statementContext) {
	localctx = NewRaise_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, PlSqlParserRULE_raise_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2762)
		p.Match(PlSqlParserRAISE)
	}
	p.SetState(2764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(2763)
			p.Exception_name()
		}

	}

	return localctx
}

// IReturn_statementContext is an interface to support dynamic dispatch.
type IReturn_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_statementContext differentiates from other interfaces.
	IsReturn_statementContext()
}

type Return_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_statementContext() *Return_statementContext {
	var p = new(Return_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_return_statement
	return p
}

func (*Return_statementContext) IsReturn_statementContext() {}

func NewReturn_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_statementContext {
	var p = new(Return_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_return_statement

	return p
}

func (s *Return_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_statementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Return_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Return_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterReturn_statement(s)
	}
}

func (s *Return_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitReturn_statement(s)
	}
}

func (p *PlSqlParser) Return_statement() (localctx IReturn_statementContext) {
	localctx = NewReturn_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, PlSqlParserRULE_return_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2766)
		p.Match(PlSqlParserRETURN)
	}
	p.SetState(2768)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
		{
			p.SetState(2767)
			p.Expression()
		}

	}

	return localctx
}

// IFunction_callContext is an interface to support dynamic dispatch.
type IFunction_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_callContext differentiates from other interfaces.
	IsFunction_callContext()
}

type Function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_callContext() *Function_callContext {
	var p = new(Function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_function_call
	return p
}

func (*Function_callContext) IsFunction_callContext() {}

func NewFunction_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_callContext {
	var p = new(Function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_function_call

	return p
}

func (s *Function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_callContext) Routine_name() IRoutine_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutine_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutine_nameContext)
}

func (s *Function_callContext) CALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCALL, 0)
}

func (s *Function_callContext) Function_argument() IFunction_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_argumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_argumentContext)
}

func (s *Function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFunction_call(s)
	}
}

func (s *Function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFunction_call(s)
	}
}

func (p *PlSqlParser) Function_call() (localctx IFunction_callContext) {
	localctx = NewFunction_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, PlSqlParserRULE_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2771)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2770)
			p.Match(PlSqlParserCALL)
		}

	}
	{
		p.SetState(2773)
		p.Routine_name()
	}
	p.SetState(2775)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(2774)
			p.Function_argument()
		}

	}

	return localctx
}

// IPipe_row_statementContext is an interface to support dynamic dispatch.
type IPipe_row_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPipe_row_statementContext differentiates from other interfaces.
	IsPipe_row_statementContext()
}

type Pipe_row_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPipe_row_statementContext() *Pipe_row_statementContext {
	var p = new(Pipe_row_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pipe_row_statement
	return p
}

func (*Pipe_row_statementContext) IsPipe_row_statementContext() {}

func NewPipe_row_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pipe_row_statementContext {
	var p = new(Pipe_row_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pipe_row_statement

	return p
}

func (s *Pipe_row_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Pipe_row_statementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPIPE, 0)
}

func (s *Pipe_row_statementContext) ROW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROW, 0)
}

func (s *Pipe_row_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pipe_row_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pipe_row_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pipe_row_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPipe_row_statement(s)
	}
}

func (s *Pipe_row_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPipe_row_statement(s)
	}
}

func (p *PlSqlParser) Pipe_row_statement() (localctx IPipe_row_statementContext) {
	localctx = NewPipe_row_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, PlSqlParserRULE_pipe_row_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2777)
		p.Match(PlSqlParserPIPE)
	}
	{
		p.SetState(2778)
		p.Match(PlSqlParserROW)
	}
	{
		p.SetState(2779)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(2780)
		p.Expression()
	}
	{
		p.SetState(2781)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IBodyContext is an interface to support dynamic dispatch.
type IBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBodyContext differentiates from other interfaces.
	IsBodyContext()
}

type BodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBodyContext() *BodyContext {
	var p = new(BodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_body
	return p
}

func (*BodyContext) IsBodyContext() {}

func NewBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BodyContext {
	var p = new(BodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_body

	return p
}

func (s *BodyContext) GetParser() antlr.Parser { return s.parser }

func (s *BodyContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBEGIN, 0)
}

func (s *BodyContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *BodyContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *BodyContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCEPTION, 0)
}

func (s *BodyContext) Label_name() ILabel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_nameContext)
}

func (s *BodyContext) AllException_handler() []IException_handlerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IException_handlerContext)(nil)).Elem())
	var tst = make([]IException_handlerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IException_handlerContext)
		}
	}

	return tst
}

func (s *BodyContext) Exception_handler(i int) IException_handlerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_handlerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IException_handlerContext)
}

func (s *BodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterBody(s)
	}
}

func (s *BodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitBody(s)
	}
}

func (p *PlSqlParser) Body() (localctx IBodyContext) {
	localctx = NewBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, PlSqlParserRULE_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2783)
		p.Match(PlSqlParserBEGIN)
	}
	{
		p.SetState(2784)
		p.Seq_of_statements()
	}
	p.SetState(2791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserEXCEPTION {
		{
			p.SetState(2785)
			p.Match(PlSqlParserEXCEPTION)
		}
		p.SetState(2787)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PlSqlParserWHEN {
			{
				p.SetState(2786)
				p.Exception_handler()
			}

			p.SetState(2789)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2793)
		p.Match(PlSqlParserEND)
	}
	p.SetState(2795)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2794)
			p.Label_name()
		}

	}

	return localctx
}

// IException_handlerContext is an interface to support dynamic dispatch.
type IException_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_handlerContext differentiates from other interfaces.
	IsException_handlerContext()
}

type Exception_handlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_handlerContext() *Exception_handlerContext {
	var p = new(Exception_handlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_exception_handler
	return p
}

func (*Exception_handlerContext) IsException_handlerContext() {}

func NewException_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_handlerContext {
	var p = new(Exception_handlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_exception_handler

	return p
}

func (s *Exception_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_handlerContext) WHEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHEN, 0)
}

func (s *Exception_handlerContext) AllException_name() []IException_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IException_nameContext)(nil)).Elem())
	var tst = make([]IException_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IException_nameContext)
		}
	}

	return tst
}

func (s *Exception_handlerContext) Exception_name(i int) IException_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IException_nameContext)
}

func (s *Exception_handlerContext) THEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTHEN, 0)
}

func (s *Exception_handlerContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *Exception_handlerContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserOR)
}

func (s *Exception_handlerContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, i)
}

func (s *Exception_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterException_handler(s)
	}
}

func (s *Exception_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitException_handler(s)
	}
}

func (p *PlSqlParser) Exception_handler() (localctx IException_handlerContext) {
	localctx = NewException_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, PlSqlParserRULE_exception_handler)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2797)
		p.Match(PlSqlParserWHEN)
	}
	{
		p.SetState(2798)
		p.Exception_name()
	}
	p.SetState(2803)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserOR {
		{
			p.SetState(2799)
			p.Match(PlSqlParserOR)
		}
		{
			p.SetState(2800)
			p.Exception_name()
		}

		p.SetState(2805)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2806)
		p.Match(PlSqlParserTHEN)
	}
	{
		p.SetState(2807)
		p.Seq_of_statements()
	}

	return localctx
}

// ITrigger_blockContext is an interface to support dynamic dispatch.
type ITrigger_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrigger_blockContext differentiates from other interfaces.
	IsTrigger_blockContext()
}

type Trigger_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrigger_blockContext() *Trigger_blockContext {
	var p = new(Trigger_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_trigger_block
	return p
}

func (*Trigger_blockContext) IsTrigger_blockContext() {}

func NewTrigger_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trigger_blockContext {
	var p = new(Trigger_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_trigger_block

	return p
}

func (s *Trigger_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Trigger_blockContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Trigger_blockContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECLARE, 0)
}

func (s *Trigger_blockContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *Trigger_blockContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *Trigger_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trigger_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trigger_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTrigger_block(s)
	}
}

func (s *Trigger_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTrigger_block(s)
	}
}

func (p *PlSqlParser) Trigger_block() (localctx ITrigger_blockContext) {
	localctx = NewTrigger_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, PlSqlParserRULE_trigger_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2817)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECLARE-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		p.SetState(2810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserDECLARE {
			{
				p.SetState(2809)
				p.Match(PlSqlParserDECLARE)
			}

		}
		p.SetState(2813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
			{
				p.SetState(2812)
				p.Declare_spec()
			}

			p.SetState(2815)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2819)
		p.Body()
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *BlockContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECLARE, 0)
}

func (s *BlockContext) AllDeclare_spec() []IDeclare_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem())
	var tst = make([]IDeclare_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclare_specContext)
		}
	}

	return tst
}

func (s *BlockContext) Declare_spec(i int) IDeclare_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclare_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclare_specContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *PlSqlParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, PlSqlParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2822)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserDECLARE {
		{
			p.SetState(2821)
			p.Match(PlSqlParserDECLARE)
		}

	}
	p.SetState(2825)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPROCEDURE-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(2824)
			p.Declare_spec()
		}

		p.SetState(2827)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2829)
		p.Body()
	}

	return localctx
}

// ISql_statementContext is an interface to support dynamic dispatch.
type ISql_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSql_statementContext differentiates from other interfaces.
	IsSql_statementContext()
}

type Sql_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_statementContext() *Sql_statementContext {
	var p = new(Sql_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_sql_statement
	return p
}

func (*Sql_statementContext) IsSql_statementContext() {}

func NewSql_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_statementContext {
	var p = new(Sql_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_sql_statement

	return p
}

func (s *Sql_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_statementContext) Execute_immediate() IExecute_immediateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecute_immediateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecute_immediateContext)
}

func (s *Sql_statementContext) Data_manipulation_language_statements() IData_manipulation_language_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_manipulation_language_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_manipulation_language_statementsContext)
}

func (s *Sql_statementContext) Cursor_manipulation_statements() ICursor_manipulation_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_manipulation_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_manipulation_statementsContext)
}

func (s *Sql_statementContext) Transaction_control_statements() ITransaction_control_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransaction_control_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransaction_control_statementsContext)
}

func (s *Sql_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSql_statement(s)
	}
}

func (s *Sql_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSql_statement(s)
	}
}

func (p *PlSqlParser) Sql_statement() (localctx ISql_statementContext) {
	localctx = NewSql_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, PlSqlParserRULE_sql_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2835)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserEXECUTE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2831)
			p.Execute_immediate()
		}

	case PlSqlParserDELETE, PlSqlParserEXPLAIN, PlSqlParserINSERT, PlSqlParserLOCK, PlSqlParserMERGE, PlSqlParserSELECT, PlSqlParserUPDATE, PlSqlParserWITH, PlSqlParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2832)
			p.Data_manipulation_language_statements()
		}

	case PlSqlParserCLOSE, PlSqlParserFETCH, PlSqlParserOPEN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2833)
			p.Cursor_manipulation_statements()
		}

	case PlSqlParserCOMMIT, PlSqlParserROLLBACK, PlSqlParserSAVEPOINT, PlSqlParserSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2834)
			p.Transaction_control_statements()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExecute_immediateContext is an interface to support dynamic dispatch.
type IExecute_immediateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecute_immediateContext differentiates from other interfaces.
	IsExecute_immediateContext()
}

type Execute_immediateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecute_immediateContext() *Execute_immediateContext {
	var p = new(Execute_immediateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_execute_immediate
	return p
}

func (*Execute_immediateContext) IsExecute_immediateContext() {}

func NewExecute_immediateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Execute_immediateContext {
	var p = new(Execute_immediateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_execute_immediate

	return p
}

func (s *Execute_immediateContext) GetParser() antlr.Parser { return s.parser }

func (s *Execute_immediateContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXECUTE, 0)
}

func (s *Execute_immediateContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIMMEDIATE, 0)
}

func (s *Execute_immediateContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Execute_immediateContext) Into_clause() IInto_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInto_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInto_clauseContext)
}

func (s *Execute_immediateContext) Using_clause() IUsing_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsing_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *Execute_immediateContext) Dynamic_returning_clause() IDynamic_returning_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_returning_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_returning_clauseContext)
}

func (s *Execute_immediateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Execute_immediateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Execute_immediateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterExecute_immediate(s)
	}
}

func (s *Execute_immediateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitExecute_immediate(s)
	}
}

func (p *PlSqlParser) Execute_immediate() (localctx IExecute_immediateContext) {
	localctx = NewExecute_immediateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, PlSqlParserRULE_execute_immediate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2837)
		p.Match(PlSqlParserEXECUTE)
	}
	{
		p.SetState(2838)
		p.Match(PlSqlParserIMMEDIATE)
	}
	{
		p.SetState(2839)
		p.Expression()
	}
	p.SetState(2849)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserBULK, PlSqlParserINTO:
		{
			p.SetState(2840)
			p.Into_clause()
		}
		p.SetState(2842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserUSING {
			{
				p.SetState(2841)
				p.Using_clause()
			}

		}

	case PlSqlParserUSING:
		{
			p.SetState(2844)
			p.Using_clause()
		}
		p.SetState(2846)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserRETURNING || _la == PlSqlParserRETURN {
			{
				p.SetState(2845)
				p.Dynamic_returning_clause()
			}

		}

	case PlSqlParserRETURNING, PlSqlParserRETURN:
		{
			p.SetState(2848)
			p.Dynamic_returning_clause()
		}

	case PlSqlParserEOF, PlSqlParserSAVE, PlSqlParserSEMICOLON:

	default:
	}

	return localctx
}

// IDynamic_returning_clauseContext is an interface to support dynamic dispatch.
type IDynamic_returning_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDynamic_returning_clauseContext differentiates from other interfaces.
	IsDynamic_returning_clauseContext()
}

type Dynamic_returning_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamic_returning_clauseContext() *Dynamic_returning_clauseContext {
	var p = new(Dynamic_returning_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_dynamic_returning_clause
	return p
}

func (*Dynamic_returning_clauseContext) IsDynamic_returning_clauseContext() {}

func NewDynamic_returning_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dynamic_returning_clauseContext {
	var p = new(Dynamic_returning_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_dynamic_returning_clause

	return p
}

func (s *Dynamic_returning_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Dynamic_returning_clauseContext) Into_clause() IInto_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInto_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInto_clauseContext)
}

func (s *Dynamic_returning_clauseContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURNING, 0)
}

func (s *Dynamic_returning_clauseContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Dynamic_returning_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dynamic_returning_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dynamic_returning_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDynamic_returning_clause(s)
	}
}

func (s *Dynamic_returning_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDynamic_returning_clause(s)
	}
}

func (p *PlSqlParser) Dynamic_returning_clause() (localctx IDynamic_returning_clauseContext) {
	localctx = NewDynamic_returning_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, PlSqlParserRULE_dynamic_returning_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2851)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserRETURNING || _la == PlSqlParserRETURN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2852)
		p.Into_clause()
	}

	return localctx
}

// IData_manipulation_language_statementsContext is an interface to support dynamic dispatch.
type IData_manipulation_language_statementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_manipulation_language_statementsContext differentiates from other interfaces.
	IsData_manipulation_language_statementsContext()
}

type Data_manipulation_language_statementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_manipulation_language_statementsContext() *Data_manipulation_language_statementsContext {
	var p = new(Data_manipulation_language_statementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_data_manipulation_language_statements
	return p
}

func (*Data_manipulation_language_statementsContext) IsData_manipulation_language_statementsContext() {
}

func NewData_manipulation_language_statementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_manipulation_language_statementsContext {
	var p = new(Data_manipulation_language_statementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_data_manipulation_language_statements

	return p
}

func (s *Data_manipulation_language_statementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_manipulation_language_statementsContext) Merge_statement() IMerge_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMerge_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMerge_statementContext)
}

func (s *Data_manipulation_language_statementsContext) Lock_table_statement() ILock_table_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILock_table_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILock_table_statementContext)
}

func (s *Data_manipulation_language_statementsContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Data_manipulation_language_statementsContext) Update_statement() IUpdate_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdate_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdate_statementContext)
}

func (s *Data_manipulation_language_statementsContext) Delete_statement() IDelete_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelete_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelete_statementContext)
}

func (s *Data_manipulation_language_statementsContext) Insert_statement() IInsert_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsert_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsert_statementContext)
}

func (s *Data_manipulation_language_statementsContext) Explain_statement() IExplain_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplain_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplain_statementContext)
}

func (s *Data_manipulation_language_statementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_manipulation_language_statementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_manipulation_language_statementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterData_manipulation_language_statements(s)
	}
}

func (s *Data_manipulation_language_statementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitData_manipulation_language_statements(s)
	}
}

func (p *PlSqlParser) Data_manipulation_language_statements() (localctx IData_manipulation_language_statementsContext) {
	localctx = NewData_manipulation_language_statementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, PlSqlParserRULE_data_manipulation_language_statements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2861)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserMERGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2854)
			p.Merge_statement()
		}

	case PlSqlParserLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2855)
			p.Lock_table_statement()
		}

	case PlSqlParserSELECT, PlSqlParserWITH, PlSqlParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2856)
			p.Select_statement()
		}

	case PlSqlParserUPDATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2857)
			p.Update_statement()
		}

	case PlSqlParserDELETE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2858)
			p.Delete_statement()
		}

	case PlSqlParserINSERT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2859)
			p.Insert_statement()
		}

	case PlSqlParserEXPLAIN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2860)
			p.Explain_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICursor_manipulation_statementsContext is an interface to support dynamic dispatch.
type ICursor_manipulation_statementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCursor_manipulation_statementsContext differentiates from other interfaces.
	IsCursor_manipulation_statementsContext()
}

type Cursor_manipulation_statementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_manipulation_statementsContext() *Cursor_manipulation_statementsContext {
	var p = new(Cursor_manipulation_statementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cursor_manipulation_statements
	return p
}

func (*Cursor_manipulation_statementsContext) IsCursor_manipulation_statementsContext() {}

func NewCursor_manipulation_statementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_manipulation_statementsContext {
	var p = new(Cursor_manipulation_statementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cursor_manipulation_statements

	return p
}

func (s *Cursor_manipulation_statementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_manipulation_statementsContext) Close_statement() IClose_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClose_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClose_statementContext)
}

func (s *Cursor_manipulation_statementsContext) Open_statement() IOpen_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpen_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOpen_statementContext)
}

func (s *Cursor_manipulation_statementsContext) Fetch_statement() IFetch_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFetch_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFetch_statementContext)
}

func (s *Cursor_manipulation_statementsContext) Open_for_statement() IOpen_for_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpen_for_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOpen_for_statementContext)
}

func (s *Cursor_manipulation_statementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_manipulation_statementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cursor_manipulation_statementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCursor_manipulation_statements(s)
	}
}

func (s *Cursor_manipulation_statementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCursor_manipulation_statements(s)
	}
}

func (p *PlSqlParser) Cursor_manipulation_statements() (localctx ICursor_manipulation_statementsContext) {
	localctx = NewCursor_manipulation_statementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, PlSqlParserRULE_cursor_manipulation_statements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2867)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2863)
			p.Close_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2864)
			p.Open_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2865)
			p.Fetch_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2866)
			p.Open_for_statement()
		}

	}

	return localctx
}

// IClose_statementContext is an interface to support dynamic dispatch.
type IClose_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClose_statementContext differentiates from other interfaces.
	IsClose_statementContext()
}

type Close_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClose_statementContext() *Close_statementContext {
	var p = new(Close_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_close_statement
	return p
}

func (*Close_statementContext) IsClose_statementContext() {}

func NewClose_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Close_statementContext {
	var p = new(Close_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_close_statement

	return p
}

func (s *Close_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Close_statementContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCLOSE, 0)
}

func (s *Close_statementContext) Cursor_name() ICursor_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_nameContext)
}

func (s *Close_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Close_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Close_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterClose_statement(s)
	}
}

func (s *Close_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitClose_statement(s)
	}
}

func (p *PlSqlParser) Close_statement() (localctx IClose_statementContext) {
	localctx = NewClose_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, PlSqlParserRULE_close_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2869)
		p.Match(PlSqlParserCLOSE)
	}
	{
		p.SetState(2870)
		p.Cursor_name()
	}

	return localctx
}

// IOpen_statementContext is an interface to support dynamic dispatch.
type IOpen_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpen_statementContext differentiates from other interfaces.
	IsOpen_statementContext()
}

type Open_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpen_statementContext() *Open_statementContext {
	var p = new(Open_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_open_statement
	return p
}

func (*Open_statementContext) IsOpen_statementContext() {}

func NewOpen_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Open_statementContext {
	var p = new(Open_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_open_statement

	return p
}

func (s *Open_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Open_statementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOPEN, 0)
}

func (s *Open_statementContext) Cursor_name() ICursor_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_nameContext)
}

func (s *Open_statementContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Open_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Open_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Open_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOpen_statement(s)
	}
}

func (s *Open_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOpen_statement(s)
	}
}

func (p *PlSqlParser) Open_statement() (localctx IOpen_statementContext) {
	localctx = NewOpen_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, PlSqlParserRULE_open_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2872)
		p.Match(PlSqlParserOPEN)
	}
	{
		p.SetState(2873)
		p.Cursor_name()
	}
	p.SetState(2879)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(2874)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(2876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
			{
				p.SetState(2875)
				p.Expressions()
			}

		}
		{
			p.SetState(2878)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}

	return localctx
}

// IFetch_statementContext is an interface to support dynamic dispatch.
type IFetch_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIt1 returns the it1 token.
	GetIt1() antlr.Token

	// SetIt1 sets the it1 token.
	SetIt1(antlr.Token)

	// IsFetch_statementContext differentiates from other interfaces.
	IsFetch_statementContext()
}

type Fetch_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	it1    antlr.Token
}

func NewEmptyFetch_statementContext() *Fetch_statementContext {
	var p = new(Fetch_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_fetch_statement
	return p
}

func (*Fetch_statementContext) IsFetch_statementContext() {}

func NewFetch_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fetch_statementContext {
	var p = new(Fetch_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_fetch_statement

	return p
}

func (s *Fetch_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Fetch_statementContext) GetIt1() antlr.Token { return s.it1 }

func (s *Fetch_statementContext) SetIt1(v antlr.Token) { s.it1 = v }

func (s *Fetch_statementContext) FETCH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFETCH, 0)
}

func (s *Fetch_statementContext) Cursor_name() ICursor_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_nameContext)
}

func (s *Fetch_statementContext) AllVariable_name() []IVariable_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_nameContext)(nil)).Elem())
	var tst = make([]IVariable_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_nameContext)
		}
	}

	return tst
}

func (s *Fetch_statementContext) Variable_name(i int) IVariable_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_nameContext)
}

func (s *Fetch_statementContext) BULK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBULK, 0)
}

func (s *Fetch_statementContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOLLECT, 0)
}

func (s *Fetch_statementContext) INTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTO, 0)
}

func (s *Fetch_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fetch_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fetch_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFetch_statement(s)
	}
}

func (s *Fetch_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFetch_statement(s)
	}
}

func (p *PlSqlParser) Fetch_statement() (localctx IFetch_statementContext) {
	localctx = NewFetch_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, PlSqlParserRULE_fetch_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2881)
		p.Match(PlSqlParserFETCH)
	}
	{
		p.SetState(2882)
		p.Cursor_name()
	}
	p.SetState(2903)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserINTO:
		{
			p.SetState(2883)

			var _m = p.Match(PlSqlParserINTO)

			localctx.(*Fetch_statementContext).it1 = _m
		}
		{
			p.SetState(2884)
			p.Variable_name()
		}
		p.SetState(2889)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(2885)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(2886)
				p.Variable_name()
			}

			p.SetState(2891)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case PlSqlParserBULK:
		{
			p.SetState(2892)
			p.Match(PlSqlParserBULK)
		}
		{
			p.SetState(2893)
			p.Match(PlSqlParserCOLLECT)
		}
		{
			p.SetState(2894)
			p.Match(PlSqlParserINTO)
		}
		{
			p.SetState(2895)
			p.Variable_name()
		}
		p.SetState(2900)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(2896)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(2897)
				p.Variable_name()
			}

			p.SetState(2902)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOpen_for_statementContext is an interface to support dynamic dispatch.
type IOpen_for_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpen_for_statementContext differentiates from other interfaces.
	IsOpen_for_statementContext()
}

type Open_for_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpen_for_statementContext() *Open_for_statementContext {
	var p = new(Open_for_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_open_for_statement
	return p
}

func (*Open_for_statementContext) IsOpen_for_statementContext() {}

func NewOpen_for_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Open_for_statementContext {
	var p = new(Open_for_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_open_for_statement

	return p
}

func (s *Open_for_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Open_for_statementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOPEN, 0)
}

func (s *Open_for_statementContext) Variable_name() IVariable_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_nameContext)
}

func (s *Open_for_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Open_for_statementContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Open_for_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Open_for_statementContext) Using_clause() IUsing_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsing_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *Open_for_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Open_for_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Open_for_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOpen_for_statement(s)
	}
}

func (s *Open_for_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOpen_for_statement(s)
	}
}

func (p *PlSqlParser) Open_for_statement() (localctx IOpen_for_statementContext) {
	localctx = NewOpen_for_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, PlSqlParserRULE_open_for_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2905)
		p.Match(PlSqlParserOPEN)
	}
	{
		p.SetState(2906)
		p.Variable_name()
	}
	{
		p.SetState(2907)
		p.Match(PlSqlParserFOR)
	}
	p.SetState(2910)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 298, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2908)
			p.Select_statement()
		}

	case 2:
		{
			p.SetState(2909)
			p.Expression()
		}

	}
	p.SetState(2913)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserUSING {
		{
			p.SetState(2912)
			p.Using_clause()
		}

	}

	return localctx
}

// ITransaction_control_statementsContext is an interface to support dynamic dispatch.
type ITransaction_control_statementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransaction_control_statementsContext differentiates from other interfaces.
	IsTransaction_control_statementsContext()
}

type Transaction_control_statementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_control_statementsContext() *Transaction_control_statementsContext {
	var p = new(Transaction_control_statementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_transaction_control_statements
	return p
}

func (*Transaction_control_statementsContext) IsTransaction_control_statementsContext() {}

func NewTransaction_control_statementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_control_statementsContext {
	var p = new(Transaction_control_statementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_transaction_control_statements

	return p
}

func (s *Transaction_control_statementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_control_statementsContext) Set_transaction_command() ISet_transaction_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_transaction_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_transaction_commandContext)
}

func (s *Transaction_control_statementsContext) Set_constraint_command() ISet_constraint_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_constraint_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_constraint_commandContext)
}

func (s *Transaction_control_statementsContext) Commit_statement() ICommit_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommit_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommit_statementContext)
}

func (s *Transaction_control_statementsContext) Rollback_statement() IRollback_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRollback_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRollback_statementContext)
}

func (s *Transaction_control_statementsContext) Savepoint_statement() ISavepoint_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISavepoint_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISavepoint_statementContext)
}

func (s *Transaction_control_statementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_control_statementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_control_statementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTransaction_control_statements(s)
	}
}

func (s *Transaction_control_statementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTransaction_control_statements(s)
	}
}

func (p *PlSqlParser) Transaction_control_statements() (localctx ITransaction_control_statementsContext) {
	localctx = NewTransaction_control_statementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, PlSqlParserRULE_transaction_control_statements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2920)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 300, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2915)
			p.Set_transaction_command()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2916)
			p.Set_constraint_command()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2917)
			p.Commit_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2918)
			p.Rollback_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2919)
			p.Savepoint_statement()
		}

	}

	return localctx
}

// ISet_transaction_commandContext is an interface to support dynamic dispatch.
type ISet_transaction_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_transaction_commandContext differentiates from other interfaces.
	IsSet_transaction_commandContext()
}

type Set_transaction_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_transaction_commandContext() *Set_transaction_commandContext {
	var p = new(Set_transaction_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_set_transaction_command
	return p
}

func (*Set_transaction_commandContext) IsSet_transaction_commandContext() {}

func NewSet_transaction_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_transaction_commandContext {
	var p = new(Set_transaction_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_set_transaction_command

	return p
}

func (s *Set_transaction_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_transaction_commandContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *Set_transaction_commandContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRANSACTION, 0)
}

func (s *Set_transaction_commandContext) READ() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREAD, 0)
}

func (s *Set_transaction_commandContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserISOLATION, 0)
}

func (s *Set_transaction_commandContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEVEL, 0)
}

func (s *Set_transaction_commandContext) USE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSE, 0)
}

func (s *Set_transaction_commandContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROLLBACK, 0)
}

func (s *Set_transaction_commandContext) SEGMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEGMENT, 0)
}

func (s *Set_transaction_commandContext) Rollback_segment_name() IRollback_segment_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRollback_segment_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRollback_segment_nameContext)
}

func (s *Set_transaction_commandContext) NAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAME, 0)
}

func (s *Set_transaction_commandContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Set_transaction_commandContext) ONLY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserONLY, 0)
}

func (s *Set_transaction_commandContext) WRITE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWRITE, 0)
}

func (s *Set_transaction_commandContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSERIALIZABLE, 0)
}

func (s *Set_transaction_commandContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMITTED, 0)
}

func (s *Set_transaction_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_transaction_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_transaction_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSet_transaction_command(s)
	}
}

func (s *Set_transaction_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSet_transaction_command(s)
	}
}

func (p *PlSqlParser) Set_transaction_command() (localctx ISet_transaction_commandContext) {
	localctx = NewSet_transaction_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, PlSqlParserRULE_set_transaction_command)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2922)
		p.Match(PlSqlParserSET)
	}
	{
		p.SetState(2923)
		p.Match(PlSqlParserTRANSACTION)
	}
	p.SetState(2937)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserREAD:
		{
			p.SetState(2924)
			p.Match(PlSqlParserREAD)
		}
		{
			p.SetState(2925)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserONLY || _la == PlSqlParserWRITE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case PlSqlParserISOLATION:
		{
			p.SetState(2926)
			p.Match(PlSqlParserISOLATION)
		}
		{
			p.SetState(2927)
			p.Match(PlSqlParserLEVEL)
		}
		p.SetState(2931)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserSERIALIZABLE:
			{
				p.SetState(2928)
				p.Match(PlSqlParserSERIALIZABLE)
			}

		case PlSqlParserREAD:
			{
				p.SetState(2929)
				p.Match(PlSqlParserREAD)
			}
			{
				p.SetState(2930)
				p.Match(PlSqlParserCOMMITTED)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case PlSqlParserUSE:
		{
			p.SetState(2933)
			p.Match(PlSqlParserUSE)
		}
		{
			p.SetState(2934)
			p.Match(PlSqlParserROLLBACK)
		}
		{
			p.SetState(2935)
			p.Match(PlSqlParserSEGMENT)
		}
		{
			p.SetState(2936)
			p.Rollback_segment_name()
		}

	case PlSqlParserEOF, PlSqlParserNAME, PlSqlParserSAVE, PlSqlParserSEMICOLON:

	default:
	}
	p.SetState(2941)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNAME {
		{
			p.SetState(2939)
			p.Match(PlSqlParserNAME)
		}
		{
			p.SetState(2940)
			p.Quoted_string()
		}

	}

	return localctx
}

// ISet_constraint_commandContext is an interface to support dynamic dispatch.
type ISet_constraint_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_constraint_commandContext differentiates from other interfaces.
	IsSet_constraint_commandContext()
}

type Set_constraint_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_constraint_commandContext() *Set_constraint_commandContext {
	var p = new(Set_constraint_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_set_constraint_command
	return p
}

func (*Set_constraint_commandContext) IsSet_constraint_commandContext() {}

func NewSet_constraint_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_constraint_commandContext {
	var p = new(Set_constraint_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_set_constraint_command

	return p
}

func (s *Set_constraint_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_constraint_commandContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *Set_constraint_commandContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRAINT, 0)
}

func (s *Set_constraint_commandContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRAINTS, 0)
}

func (s *Set_constraint_commandContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIMMEDIATE, 0)
}

func (s *Set_constraint_commandContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFERRED, 0)
}

func (s *Set_constraint_commandContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Set_constraint_commandContext) AllConstraint_name() []IConstraint_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstraint_nameContext)(nil)).Elem())
	var tst = make([]IConstraint_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstraint_nameContext)
		}
	}

	return tst
}

func (s *Set_constraint_commandContext) Constraint_name(i int) IConstraint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Set_constraint_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_constraint_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_constraint_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSet_constraint_command(s)
	}
}

func (s *Set_constraint_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSet_constraint_command(s)
	}
}

func (p *PlSqlParser) Set_constraint_command() (localctx ISet_constraint_commandContext) {
	localctx = NewSet_constraint_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, PlSqlParserRULE_set_constraint_command)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2943)
		p.Match(PlSqlParserSET)
	}
	{
		p.SetState(2944)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserCONSTRAINT || _la == PlSqlParserCONSTRAINTS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2954)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserALL:
		{
			p.SetState(2945)
			p.Match(PlSqlParserALL)
		}

	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(2946)
			p.Constraint_name()
		}
		p.SetState(2951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(2947)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(2948)
				p.Constraint_name()
			}

			p.SetState(2953)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2956)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserDEFERRED || _la == PlSqlParserIMMEDIATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICommit_statementContext is an interface to support dynamic dispatch.
type ICommit_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommit_statementContext differentiates from other interfaces.
	IsCommit_statementContext()
}

type Commit_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommit_statementContext() *Commit_statementContext {
	var p = new(Commit_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_commit_statement
	return p
}

func (*Commit_statementContext) IsCommit_statementContext() {}

func NewCommit_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Commit_statementContext {
	var p = new(Commit_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_commit_statement

	return p
}

func (s *Commit_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Commit_statementContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMIT, 0)
}

func (s *Commit_statementContext) WORK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWORK, 0)
}

func (s *Commit_statementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMENT, 0)
}

func (s *Commit_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Commit_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Commit_statementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFORCE, 0)
}

func (s *Commit_statementContext) Write_clause() IWrite_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWrite_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWrite_clauseContext)
}

func (s *Commit_statementContext) CORRUPT_XID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCORRUPT_XID, 0)
}

func (s *Commit_statementContext) CORRUPT_XID_ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCORRUPT_XID_ALL, 0)
}

func (s *Commit_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Commit_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Commit_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCommit_statement(s)
	}
}

func (s *Commit_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCommit_statement(s)
	}
}

func (p *PlSqlParser) Commit_statement() (localctx ICommit_statementContext) {
	localctx = NewCommit_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, PlSqlParserRULE_commit_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2958)
		p.Match(PlSqlParserCOMMIT)
	}
	p.SetState(2960)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWORK {
		{
			p.SetState(2959)
			p.Match(PlSqlParserWORK)
		}

	}
	p.SetState(2975)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserCOMMENT:
		{
			p.SetState(2962)
			p.Match(PlSqlParserCOMMENT)
		}
		{
			p.SetState(2963)
			p.Expression()
		}

	case PlSqlParserFORCE:
		{
			p.SetState(2964)
			p.Match(PlSqlParserFORCE)
		}
		p.SetState(2973)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 308, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2965)
				p.Match(PlSqlParserCORRUPT_XID)
			}
			{
				p.SetState(2966)
				p.Expression()
			}

		case 2:
			{
				p.SetState(2967)
				p.Match(PlSqlParserCORRUPT_XID_ALL)
			}

		case 3:
			{
				p.SetState(2968)
				p.Expression()
			}
			p.SetState(2971)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserCOMMA {
				{
					p.SetState(2969)
					p.Match(PlSqlParserCOMMA)
				}
				{
					p.SetState(2970)
					p.Expression()
				}

			}

		}

	case PlSqlParserEOF, PlSqlParserSAVE, PlSqlParserWRITE, PlSqlParserSEMICOLON:

	default:
	}
	p.SetState(2978)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWRITE {
		{
			p.SetState(2977)
			p.Write_clause()
		}

	}

	return localctx
}

// IWrite_clauseContext is an interface to support dynamic dispatch.
type IWrite_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWrite_clauseContext differentiates from other interfaces.
	IsWrite_clauseContext()
}

type Write_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWrite_clauseContext() *Write_clauseContext {
	var p = new(Write_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_write_clause
	return p
}

func (*Write_clauseContext) IsWrite_clauseContext() {}

func NewWrite_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Write_clauseContext {
	var p = new(Write_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_write_clause

	return p
}

func (s *Write_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Write_clauseContext) WRITE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWRITE, 0)
}

func (s *Write_clauseContext) WAIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWAIT, 0)
}

func (s *Write_clauseContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOWAIT, 0)
}

func (s *Write_clauseContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIMMEDIATE, 0)
}

func (s *Write_clauseContext) BATCH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBATCH, 0)
}

func (s *Write_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Write_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Write_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterWrite_clause(s)
	}
}

func (s *Write_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitWrite_clause(s)
	}
}

func (p *PlSqlParser) Write_clause() (localctx IWrite_clauseContext) {
	localctx = NewWrite_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, PlSqlParserRULE_write_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2980)
		p.Match(PlSqlParserWRITE)
	}
	p.SetState(2982)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNOWAIT || _la == PlSqlParserWAIT {
		{
			p.SetState(2981)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserNOWAIT || _la == PlSqlParserWAIT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2985)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserBATCH || _la == PlSqlParserIMMEDIATE {
		{
			p.SetState(2984)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserBATCH || _la == PlSqlParserIMMEDIATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IRollback_statementContext is an interface to support dynamic dispatch.
type IRollback_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRollback_statementContext differentiates from other interfaces.
	IsRollback_statementContext()
}

type Rollback_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollback_statementContext() *Rollback_statementContext {
	var p = new(Rollback_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_rollback_statement
	return p
}

func (*Rollback_statementContext) IsRollback_statementContext() {}

func NewRollback_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollback_statementContext {
	var p = new(Rollback_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_rollback_statement

	return p
}

func (s *Rollback_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollback_statementContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROLLBACK, 0)
}

func (s *Rollback_statementContext) WORK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWORK, 0)
}

func (s *Rollback_statementContext) TO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO, 0)
}

func (s *Rollback_statementContext) Savepoint_name() ISavepoint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISavepoint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISavepoint_nameContext)
}

func (s *Rollback_statementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFORCE, 0)
}

func (s *Rollback_statementContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Rollback_statementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSAVEPOINT, 0)
}

func (s *Rollback_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollback_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rollback_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRollback_statement(s)
	}
}

func (s *Rollback_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRollback_statement(s)
	}
}

func (p *PlSqlParser) Rollback_statement() (localctx IRollback_statementContext) {
	localctx = NewRollback_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, PlSqlParserRULE_rollback_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2987)
		p.Match(PlSqlParserROLLBACK)
	}
	p.SetState(2989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWORK {
		{
			p.SetState(2988)
			p.Match(PlSqlParserWORK)
		}

	}
	p.SetState(2998)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserTO:
		{
			p.SetState(2991)
			p.Match(PlSqlParserTO)
		}
		p.SetState(2993)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 314, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2992)
				p.Match(PlSqlParserSAVEPOINT)
			}

		}
		{
			p.SetState(2995)
			p.Savepoint_name()
		}

	case PlSqlParserFORCE:
		{
			p.SetState(2996)
			p.Match(PlSqlParserFORCE)
		}
		{
			p.SetState(2997)
			p.Quoted_string()
		}

	case PlSqlParserEOF, PlSqlParserSAVE, PlSqlParserSEMICOLON:

	default:
	}

	return localctx
}

// ISavepoint_statementContext is an interface to support dynamic dispatch.
type ISavepoint_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSavepoint_statementContext differentiates from other interfaces.
	IsSavepoint_statementContext()
}

type Savepoint_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepoint_statementContext() *Savepoint_statementContext {
	var p = new(Savepoint_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_savepoint_statement
	return p
}

func (*Savepoint_statementContext) IsSavepoint_statementContext() {}

func NewSavepoint_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Savepoint_statementContext {
	var p = new(Savepoint_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_savepoint_statement

	return p
}

func (s *Savepoint_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Savepoint_statementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSAVEPOINT, 0)
}

func (s *Savepoint_statementContext) Savepoint_name() ISavepoint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISavepoint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISavepoint_nameContext)
}

func (s *Savepoint_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Savepoint_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Savepoint_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSavepoint_statement(s)
	}
}

func (s *Savepoint_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSavepoint_statement(s)
	}
}

func (p *PlSqlParser) Savepoint_statement() (localctx ISavepoint_statementContext) {
	localctx = NewSavepoint_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, PlSqlParserRULE_savepoint_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3000)
		p.Match(PlSqlParserSAVEPOINT)
	}
	{
		p.SetState(3001)
		p.Savepoint_name()
	}

	return localctx
}

// IExplain_statementContext is an interface to support dynamic dispatch.
type IExplain_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplain_statementContext differentiates from other interfaces.
	IsExplain_statementContext()
}

type Explain_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplain_statementContext() *Explain_statementContext {
	var p = new(Explain_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_explain_statement
	return p
}

func (*Explain_statementContext) IsExplain_statementContext() {}

func NewExplain_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Explain_statementContext {
	var p = new(Explain_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_explain_statement

	return p
}

func (s *Explain_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Explain_statementContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXPLAIN, 0)
}

func (s *Explain_statementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPLAN, 0)
}

func (s *Explain_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Explain_statementContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Explain_statementContext) Update_statement() IUpdate_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdate_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdate_statementContext)
}

func (s *Explain_statementContext) Delete_statement() IDelete_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelete_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelete_statementContext)
}

func (s *Explain_statementContext) Insert_statement() IInsert_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsert_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsert_statementContext)
}

func (s *Explain_statementContext) Merge_statement() IMerge_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMerge_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMerge_statementContext)
}

func (s *Explain_statementContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *Explain_statementContext) STATEMENT_ID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATEMENT_ID, 0)
}

func (s *Explain_statementContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Explain_statementContext) INTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTO, 0)
}

func (s *Explain_statementContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Explain_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Explain_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Explain_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterExplain_statement(s)
	}
}

func (s *Explain_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitExplain_statement(s)
	}
}

func (p *PlSqlParser) Explain_statement() (localctx IExplain_statementContext) {
	localctx = NewExplain_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, PlSqlParserRULE_explain_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3003)
		p.Match(PlSqlParserEXPLAIN)
	}
	{
		p.SetState(3004)
		p.Match(PlSqlParserPLAN)
	}
	p.SetState(3009)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserSET {
		{
			p.SetState(3005)
			p.Match(PlSqlParserSET)
		}
		{
			p.SetState(3006)
			p.Match(PlSqlParserSTATEMENT_ID)
		}
		{
			p.SetState(3007)
			p.Match(PlSqlParserEQUALS_OP)
		}
		{
			p.SetState(3008)
			p.Quoted_string()
		}

	}
	p.SetState(3013)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserINTO {
		{
			p.SetState(3011)
			p.Match(PlSqlParserINTO)
		}
		{
			p.SetState(3012)
			p.Tableview_name()
		}

	}
	{
		p.SetState(3015)
		p.Match(PlSqlParserFOR)
	}
	p.SetState(3021)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserSELECT, PlSqlParserWITH, PlSqlParserLEFT_PAREN:
		{
			p.SetState(3016)
			p.Select_statement()
		}

	case PlSqlParserUPDATE:
		{
			p.SetState(3017)
			p.Update_statement()
		}

	case PlSqlParserDELETE:
		{
			p.SetState(3018)
			p.Delete_statement()
		}

	case PlSqlParserINSERT:
		{
			p.SetState(3019)
			p.Insert_statement()
		}

	case PlSqlParserMERGE:
		{
			p.SetState(3020)
			p.Merge_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelect_statementContext is an interface to support dynamic dispatch.
type ISelect_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_statementContext differentiates from other interfaces.
	IsSelect_statementContext()
}

type Select_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_statementContext() *Select_statementContext {
	var p = new(Select_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_select_statement
	return p
}

func (*Select_statementContext) IsSelect_statementContext() {}

func NewSelect_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_statementContext {
	var p = new(Select_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_select_statement

	return p
}

func (s *Select_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_statementContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Select_statementContext) Subquery_factoring_clause() ISubquery_factoring_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubquery_factoring_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubquery_factoring_clauseContext)
}

func (s *Select_statementContext) AllFor_update_clause() []IFor_update_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFor_update_clauseContext)(nil)).Elem())
	var tst = make([]IFor_update_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFor_update_clauseContext)
		}
	}

	return tst
}

func (s *Select_statementContext) For_update_clause(i int) IFor_update_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_update_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFor_update_clauseContext)
}

func (s *Select_statementContext) AllOrder_by_clause() []IOrder_by_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrder_by_clauseContext)(nil)).Elem())
	var tst = make([]IOrder_by_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrder_by_clauseContext)
		}
	}

	return tst
}

func (s *Select_statementContext) Order_by_clause(i int) IOrder_by_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Select_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSelect_statement(s)
	}
}

func (s *Select_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSelect_statement(s)
	}
}

func (p *PlSqlParser) Select_statement() (localctx ISelect_statementContext) {
	localctx = NewSelect_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, PlSqlParserRULE_select_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWITH {
		{
			p.SetState(3023)
			p.Subquery_factoring_clause()
		}

	}
	{
		p.SetState(3026)
		p.Subquery()
	}
	p.SetState(3031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserFOR || _la == PlSqlParserORDER {
		p.SetState(3029)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserFOR:
			{
				p.SetState(3027)
				p.For_update_clause()
			}

		case PlSqlParserORDER:
			{
				p.SetState(3028)
				p.Order_by_clause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3033)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubquery_factoring_clauseContext is an interface to support dynamic dispatch.
type ISubquery_factoring_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubquery_factoring_clauseContext differentiates from other interfaces.
	IsSubquery_factoring_clauseContext()
}

type Subquery_factoring_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubquery_factoring_clauseContext() *Subquery_factoring_clauseContext {
	var p = new(Subquery_factoring_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_subquery_factoring_clause
	return p
}

func (*Subquery_factoring_clauseContext) IsSubquery_factoring_clauseContext() {}

func NewSubquery_factoring_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subquery_factoring_clauseContext {
	var p = new(Subquery_factoring_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_subquery_factoring_clause

	return p
}

func (s *Subquery_factoring_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Subquery_factoring_clauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWITH, 0)
}

func (s *Subquery_factoring_clauseContext) AllFactoring_element() []IFactoring_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFactoring_elementContext)(nil)).Elem())
	var tst = make([]IFactoring_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFactoring_elementContext)
		}
	}

	return tst
}

func (s *Subquery_factoring_clauseContext) Factoring_element(i int) IFactoring_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactoring_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFactoring_elementContext)
}

func (s *Subquery_factoring_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subquery_factoring_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subquery_factoring_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSubquery_factoring_clause(s)
	}
}

func (s *Subquery_factoring_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSubquery_factoring_clause(s)
	}
}

func (p *PlSqlParser) Subquery_factoring_clause() (localctx ISubquery_factoring_clauseContext) {
	localctx = NewSubquery_factoring_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, PlSqlParserRULE_subquery_factoring_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3034)
		p.Match(PlSqlParserWITH)
	}
	{
		p.SetState(3035)
		p.Factoring_element()
	}
	p.SetState(3040)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3036)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3037)
			p.Factoring_element()
		}

		p.SetState(3042)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFactoring_elementContext is an interface to support dynamic dispatch.
type IFactoring_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactoring_elementContext differentiates from other interfaces.
	IsFactoring_elementContext()
}

type Factoring_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactoring_elementContext() *Factoring_elementContext {
	var p = new(Factoring_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_factoring_element
	return p
}

func (*Factoring_elementContext) IsFactoring_elementContext() {}

func NewFactoring_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Factoring_elementContext {
	var p = new(Factoring_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_factoring_element

	return p
}

func (s *Factoring_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Factoring_elementContext) Query_name() IQuery_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_nameContext)
}

func (s *Factoring_elementContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Factoring_elementContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Factoring_elementContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Factoring_elementContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Factoring_elementContext) Order_by_clause() IOrder_by_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Factoring_elementContext) Search_clause() ISearch_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISearch_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISearch_clauseContext)
}

func (s *Factoring_elementContext) Cycle_clause() ICycle_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICycle_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICycle_clauseContext)
}

func (s *Factoring_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Factoring_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Factoring_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFactoring_element(s)
	}
}

func (s *Factoring_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFactoring_element(s)
	}
}

func (p *PlSqlParser) Factoring_element() (localctx IFactoring_elementContext) {
	localctx = NewFactoring_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, PlSqlParserRULE_factoring_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3043)
		p.Query_name()
	}
	p.SetState(3055)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(3044)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3045)
			p.Column_name()
		}
		p.SetState(3050)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3046)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3047)
				p.Column_name()
			}

			p.SetState(3052)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3053)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(3057)
		p.Match(PlSqlParserAS)
	}
	{
		p.SetState(3058)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3059)
		p.Subquery()
	}
	p.SetState(3061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserORDER {
		{
			p.SetState(3060)
			p.Order_by_clause()
		}

	}
	{
		p.SetState(3063)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(3065)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserSEARCH {
		{
			p.SetState(3064)
			p.Search_clause()
		}

	}
	p.SetState(3068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserCYCLE {
		{
			p.SetState(3067)
			p.Cycle_clause()
		}

	}

	return localctx
}

// ISearch_clauseContext is an interface to support dynamic dispatch.
type ISearch_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearch_clauseContext differentiates from other interfaces.
	IsSearch_clauseContext()
}

type Search_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearch_clauseContext() *Search_clauseContext {
	var p = new(Search_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_search_clause
	return p
}

func (*Search_clauseContext) IsSearch_clauseContext() {}

func NewSearch_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Search_clauseContext {
	var p = new(Search_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_search_clause

	return p
}

func (s *Search_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Search_clauseContext) SEARCH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEARCH, 0)
}

func (s *Search_clauseContext) AllFIRST() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserFIRST)
}

func (s *Search_clauseContext) FIRST(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserFIRST, i)
}

func (s *Search_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Search_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Search_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Search_clauseContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *Search_clauseContext) DEPTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEPTH, 0)
}

func (s *Search_clauseContext) BREADTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBREADTH, 0)
}

func (s *Search_clauseContext) AllASC() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserASC)
}

func (s *Search_clauseContext) ASC(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserASC, i)
}

func (s *Search_clauseContext) AllDESC() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserDESC)
}

func (s *Search_clauseContext) DESC(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserDESC, i)
}

func (s *Search_clauseContext) AllNULLS() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserNULLS)
}

func (s *Search_clauseContext) NULLS(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULLS, i)
}

func (s *Search_clauseContext) AllLAST() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserLAST)
}

func (s *Search_clauseContext) LAST(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserLAST, i)
}

func (s *Search_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Search_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Search_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSearch_clause(s)
	}
}

func (s *Search_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSearch_clause(s)
	}
}

func (p *PlSqlParser) Search_clause() (localctx ISearch_clauseContext) {
	localctx = NewSearch_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, PlSqlParserRULE_search_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3070)
		p.Match(PlSqlParserSEARCH)
	}
	{
		p.SetState(3071)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserBREADTH || _la == PlSqlParserDEPTH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3072)
		p.Match(PlSqlParserFIRST)
	}
	{
		p.SetState(3073)
		p.Match(PlSqlParserBY)
	}
	{
		p.SetState(3074)
		p.Column_name()
	}
	p.SetState(3076)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserASC {
		{
			p.SetState(3075)
			p.Match(PlSqlParserASC)
		}

	}
	p.SetState(3079)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserDESC {
		{
			p.SetState(3078)
			p.Match(PlSqlParserDESC)
		}

	}
	p.SetState(3083)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3081)
			p.Match(PlSqlParserNULLS)
		}
		{
			p.SetState(3082)
			p.Match(PlSqlParserFIRST)
		}

	}
	p.SetState(3087)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNULLS {
		{
			p.SetState(3085)
			p.Match(PlSqlParserNULLS)
		}
		{
			p.SetState(3086)
			p.Match(PlSqlParserLAST)
		}

	}
	p.SetState(3107)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3089)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3090)
			p.Column_name()
		}
		p.SetState(3092)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserASC {
			{
				p.SetState(3091)
				p.Match(PlSqlParserASC)
			}

		}
		p.SetState(3095)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserDESC {
			{
				p.SetState(3094)
				p.Match(PlSqlParserDESC)
			}

		}
		p.SetState(3099)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 334, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3097)
				p.Match(PlSqlParserNULLS)
			}
			{
				p.SetState(3098)
				p.Match(PlSqlParserFIRST)
			}

		}
		p.SetState(3103)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserNULLS {
			{
				p.SetState(3101)
				p.Match(PlSqlParserNULLS)
			}
			{
				p.SetState(3102)
				p.Match(PlSqlParserLAST)
			}

		}

		p.SetState(3109)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3110)
		p.Match(PlSqlParserSET)
	}
	{
		p.SetState(3111)
		p.Column_name()
	}

	return localctx
}

// ICycle_clauseContext is an interface to support dynamic dispatch.
type ICycle_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCycle_clauseContext differentiates from other interfaces.
	IsCycle_clauseContext()
}

type Cycle_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCycle_clauseContext() *Cycle_clauseContext {
	var p = new(Cycle_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cycle_clause
	return p
}

func (*Cycle_clauseContext) IsCycle_clauseContext() {}

func NewCycle_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cycle_clauseContext {
	var p = new(Cycle_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cycle_clause

	return p
}

func (s *Cycle_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Cycle_clauseContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCYCLE, 0)
}

func (s *Cycle_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Cycle_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Cycle_clauseContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *Cycle_clauseContext) TO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO, 0)
}

func (s *Cycle_clauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Cycle_clauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Cycle_clauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFAULT, 0)
}

func (s *Cycle_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cycle_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cycle_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCycle_clause(s)
	}
}

func (s *Cycle_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCycle_clause(s)
	}
}

func (p *PlSqlParser) Cycle_clause() (localctx ICycle_clauseContext) {
	localctx = NewCycle_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, PlSqlParserRULE_cycle_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3113)
		p.Match(PlSqlParserCYCLE)
	}
	{
		p.SetState(3114)
		p.Column_name()
	}
	p.SetState(3119)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3115)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3116)
			p.Column_name()
		}

		p.SetState(3121)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3122)
		p.Match(PlSqlParserSET)
	}
	{
		p.SetState(3123)
		p.Column_name()
	}
	{
		p.SetState(3124)
		p.Match(PlSqlParserTO)
	}
	{
		p.SetState(3125)
		p.Expression()
	}
	{
		p.SetState(3126)
		p.Match(PlSqlParserDEFAULT)
	}
	{
		p.SetState(3127)
		p.Expression()
	}

	return localctx
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_subquery
	return p
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) Subquery_basic_elements() ISubquery_basic_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubquery_basic_elementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubquery_basic_elementsContext)
}

func (s *SubqueryContext) AllSubquery_operation_part() []ISubquery_operation_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubquery_operation_partContext)(nil)).Elem())
	var tst = make([]ISubquery_operation_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubquery_operation_partContext)
		}
	}

	return tst
}

func (s *SubqueryContext) Subquery_operation_part(i int) ISubquery_operation_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubquery_operation_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubquery_operation_partContext)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (p *PlSqlParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, PlSqlParserRULE_subquery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3129)
		p.Subquery_basic_elements()
	}
	p.SetState(3133)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserINTERSECT || _la == PlSqlParserMINUS || _la == PlSqlParserUNION {
		{
			p.SetState(3130)
			p.Subquery_operation_part()
		}

		p.SetState(3135)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubquery_basic_elementsContext is an interface to support dynamic dispatch.
type ISubquery_basic_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubquery_basic_elementsContext differentiates from other interfaces.
	IsSubquery_basic_elementsContext()
}

type Subquery_basic_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubquery_basic_elementsContext() *Subquery_basic_elementsContext {
	var p = new(Subquery_basic_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_subquery_basic_elements
	return p
}

func (*Subquery_basic_elementsContext) IsSubquery_basic_elementsContext() {}

func NewSubquery_basic_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subquery_basic_elementsContext {
	var p = new(Subquery_basic_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_subquery_basic_elements

	return p
}

func (s *Subquery_basic_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Subquery_basic_elementsContext) Query_block() IQuery_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_blockContext)
}

func (s *Subquery_basic_elementsContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Subquery_basic_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subquery_basic_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subquery_basic_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSubquery_basic_elements(s)
	}
}

func (s *Subquery_basic_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSubquery_basic_elements(s)
	}
}

func (p *PlSqlParser) Subquery_basic_elements() (localctx ISubquery_basic_elementsContext) {
	localctx = NewSubquery_basic_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, PlSqlParserRULE_subquery_basic_elements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3141)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserSELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3136)
			p.Query_block()
		}

	case PlSqlParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3137)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3138)
			p.Subquery()
		}
		{
			p.SetState(3139)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubquery_operation_partContext is an interface to support dynamic dispatch.
type ISubquery_operation_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubquery_operation_partContext differentiates from other interfaces.
	IsSubquery_operation_partContext()
}

type Subquery_operation_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubquery_operation_partContext() *Subquery_operation_partContext {
	var p = new(Subquery_operation_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_subquery_operation_part
	return p
}

func (*Subquery_operation_partContext) IsSubquery_operation_partContext() {}

func NewSubquery_operation_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subquery_operation_partContext {
	var p = new(Subquery_operation_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_subquery_operation_part

	return p
}

func (s *Subquery_operation_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Subquery_operation_partContext) Subquery_basic_elements() ISubquery_basic_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubquery_basic_elementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubquery_basic_elementsContext)
}

func (s *Subquery_operation_partContext) UNION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNION, 0)
}

func (s *Subquery_operation_partContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTERSECT, 0)
}

func (s *Subquery_operation_partContext) MINUS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINUS, 0)
}

func (s *Subquery_operation_partContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Subquery_operation_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subquery_operation_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subquery_operation_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSubquery_operation_part(s)
	}
}

func (s *Subquery_operation_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSubquery_operation_part(s)
	}
}

func (p *PlSqlParser) Subquery_operation_part() (localctx ISubquery_operation_partContext) {
	localctx = NewSubquery_operation_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, PlSqlParserRULE_subquery_operation_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3149)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserUNION:
		{
			p.SetState(3143)
			p.Match(PlSqlParserUNION)
		}
		p.SetState(3145)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserALL {
			{
				p.SetState(3144)
				p.Match(PlSqlParserALL)
			}

		}

	case PlSqlParserINTERSECT:
		{
			p.SetState(3147)
			p.Match(PlSqlParserINTERSECT)
		}

	case PlSqlParserMINUS:
		{
			p.SetState(3148)
			p.Match(PlSqlParserMINUS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(3151)
		p.Subquery_basic_elements()
	}

	return localctx
}

// IQuery_blockContext is an interface to support dynamic dispatch.
type IQuery_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_blockContext differentiates from other interfaces.
	IsQuery_blockContext()
}

type Query_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_blockContext() *Query_blockContext {
	var p = new(Query_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_query_block
	return p
}

func (*Query_blockContext) IsQuery_blockContext() {}

func NewQuery_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_blockContext {
	var p = new(Query_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_query_block

	return p
}

func (s *Query_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_blockContext) SELECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSELECT, 0)
}

func (s *Query_blockContext) From_clause() IFrom_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFrom_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *Query_blockContext) AllSelected_element() []ISelected_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelected_elementContext)(nil)).Elem())
	var tst = make([]ISelected_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelected_elementContext)
		}
	}

	return tst
}

func (s *Query_blockContext) Selected_element(i int) ISelected_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelected_elementContext)
}

func (s *Query_blockContext) Into_clause() IInto_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInto_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInto_clauseContext)
}

func (s *Query_blockContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Query_blockContext) Hierarchical_query_clause() IHierarchical_query_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_query_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_query_clauseContext)
}

func (s *Query_blockContext) Group_by_clause() IGroup_by_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_by_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clauseContext)
}

func (s *Query_blockContext) Model_clause() IModel_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_clauseContext)
}

func (s *Query_blockContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISTINCT, 0)
}

func (s *Query_blockContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNIQUE, 0)
}

func (s *Query_blockContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Query_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterQuery_block(s)
	}
}

func (s *Query_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitQuery_block(s)
	}
}

func (p *PlSqlParser) Query_block() (localctx IQuery_blockContext) {
	localctx = NewQuery_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, PlSqlParserRULE_query_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3153)
		p.Match(PlSqlParserSELECT)
	}
	p.SetState(3155)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 342, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3154)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserALL || _la == PlSqlParserDISTINCT || _la == PlSqlParserUNIQUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3166)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserASTERISK:
		{
			p.SetState(3157)
			p.Match(PlSqlParserASTERISK)
		}

	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALL, PlSqlParserANALYZE, PlSqlParserANY, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOALESCE, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONNECT_BY_ROOT, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDISTINCT, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXISTS, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFALSE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNOT, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPRIOR, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUE, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserDECODE, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserNVL, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROUND, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTO_CHAR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserLEAST, PlSqlParserGREATEST, PlSqlParserTO_DATE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserPLUS_SIGN, PlSqlParserMINUS_SIGN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(3158)
			p.Selected_element()
		}
		p.SetState(3163)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3159)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3160)
				p.Selected_element()
			}

			p.SetState(3165)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserBULK || _la == PlSqlParserINTO {
		{
			p.SetState(3168)
			p.Into_clause()
		}

	}
	{
		p.SetState(3171)
		p.From_clause()
	}
	p.SetState(3173)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 346, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3172)
			p.Where_clause()
		}

	}
	p.SetState(3176)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 347, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3175)
			p.Hierarchical_query_clause()
		}

	}
	p.SetState(3179)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 348, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3178)
			p.Group_by_clause()
		}

	}
	p.SetState(3182)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 349, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3181)
			p.Model_clause()
		}

	}

	return localctx
}

// ISelected_elementContext is an interface to support dynamic dispatch.
type ISelected_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelected_elementContext differentiates from other interfaces.
	IsSelected_elementContext()
}

type Selected_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelected_elementContext() *Selected_elementContext {
	var p = new(Selected_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_selected_element
	return p
}

func (*Selected_elementContext) IsSelected_elementContext() {}

func NewSelected_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selected_elementContext {
	var p = new(Selected_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_selected_element

	return p
}

func (s *Selected_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Selected_elementContext) Select_list_elements() ISelect_list_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_list_elementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_list_elementsContext)
}

func (s *Selected_elementContext) Column_alias() IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Selected_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selected_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selected_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSelected_element(s)
	}
}

func (s *Selected_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSelected_element(s)
	}
}

func (p *PlSqlParser) Selected_element() (localctx ISelected_elementContext) {
	localctx = NewSelected_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, PlSqlParserRULE_selected_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3184)
		p.Select_list_elements()
	}
	p.SetState(3186)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 350, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3185)
			p.Column_alias()
		}

	}

	return localctx
}

// IFrom_clauseContext is an interface to support dynamic dispatch.
type IFrom_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFrom_clauseContext differentiates from other interfaces.
	IsFrom_clauseContext()
}

type From_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_clauseContext() *From_clauseContext {
	var p = new(From_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_from_clause
	return p
}

func (*From_clauseContext) IsFrom_clauseContext() {}

func NewFrom_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_clauseContext {
	var p = new(From_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_from_clause

	return p
}

func (s *From_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_clauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFROM, 0)
}

func (s *From_clauseContext) Table_ref_list() ITable_ref_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_ref_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_ref_listContext)
}

func (s *From_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFrom_clause(s)
	}
}

func (s *From_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFrom_clause(s)
	}
}

func (p *PlSqlParser) From_clause() (localctx IFrom_clauseContext) {
	localctx = NewFrom_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, PlSqlParserRULE_from_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3188)
		p.Match(PlSqlParserFROM)
	}
	{
		p.SetState(3189)
		p.Table_ref_list()
	}

	return localctx
}

// ISelect_list_elementsContext is an interface to support dynamic dispatch.
type ISelect_list_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_list_elementsContext differentiates from other interfaces.
	IsSelect_list_elementsContext()
}

type Select_list_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_elementsContext() *Select_list_elementsContext {
	var p = new(Select_list_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_select_list_elements
	return p
}

func (*Select_list_elementsContext) IsSelect_list_elementsContext() {}

func NewSelect_list_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_elementsContext {
	var p = new(Select_list_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_select_list_elements

	return p
}

func (s *Select_list_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_elementsContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Select_list_elementsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Select_list_elementsContext) Regular_id() IRegular_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegular_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegular_idContext)
}

func (s *Select_list_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSelect_list_elements(s)
	}
}

func (s *Select_list_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSelect_list_elements(s)
	}
}

func (p *PlSqlParser) Select_list_elements() (localctx ISelect_list_elementsContext) {
	localctx = NewSelect_list_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, PlSqlParserRULE_select_list_elements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3201)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 352, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3191)
			p.Tableview_name()
		}
		{
			p.SetState(3192)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(3193)
			p.Match(PlSqlParserASTERISK)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3198)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 351, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3195)
				p.Regular_id()
			}
			{
				p.SetState(3196)
				p.Match(PlSqlParserPERIOD)
			}

		}
		{
			p.SetState(3200)
			p.Expression()
		}

	}

	return localctx
}

// ITable_ref_listContext is an interface to support dynamic dispatch.
type ITable_ref_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_ref_listContext differentiates from other interfaces.
	IsTable_ref_listContext()
}

type Table_ref_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_ref_listContext() *Table_ref_listContext {
	var p = new(Table_ref_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_ref_list
	return p
}

func (*Table_ref_listContext) IsTable_ref_listContext() {}

func NewTable_ref_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_ref_listContext {
	var p = new(Table_ref_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_ref_list

	return p
}

func (s *Table_ref_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_ref_listContext) AllTable_ref() []ITable_refContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_refContext)(nil)).Elem())
	var tst = make([]ITable_refContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_refContext)
		}
	}

	return tst
}

func (s *Table_ref_listContext) Table_ref(i int) ITable_refContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_refContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_refContext)
}

func (s *Table_ref_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_ref_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_ref_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_ref_list(s)
	}
}

func (s *Table_ref_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_ref_list(s)
	}
}

func (p *PlSqlParser) Table_ref_list() (localctx ITable_ref_listContext) {
	localctx = NewTable_ref_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, PlSqlParserRULE_table_ref_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3203)
		p.Table_ref()
	}
	p.SetState(3208)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 353, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3204)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3205)
				p.Table_ref()
			}

		}
		p.SetState(3210)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 353, p.GetParserRuleContext())
	}

	return localctx
}

// ITable_refContext is an interface to support dynamic dispatch.
type ITable_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_refContext differentiates from other interfaces.
	IsTable_refContext()
}

type Table_refContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_refContext() *Table_refContext {
	var p = new(Table_refContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_ref
	return p
}

func (*Table_refContext) IsTable_refContext() {}

func NewTable_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_refContext {
	var p = new(Table_refContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_ref

	return p
}

func (s *Table_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_refContext) Table_ref_aux() ITable_ref_auxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_ref_auxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_ref_auxContext)
}

func (s *Table_refContext) AllJoin_clause() []IJoin_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoin_clauseContext)(nil)).Elem())
	var tst = make([]IJoin_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoin_clauseContext)
		}
	}

	return tst
}

func (s *Table_refContext) Join_clause(i int) IJoin_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoin_clauseContext)
}

func (s *Table_refContext) Pivot_clause() IPivot_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPivot_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPivot_clauseContext)
}

func (s *Table_refContext) Unpivot_clause() IUnpivot_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpivot_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnpivot_clauseContext)
}

func (s *Table_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_ref(s)
	}
}

func (s *Table_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_ref(s)
	}
}

func (p *PlSqlParser) Table_ref() (localctx ITable_refContext) {
	localctx = NewTable_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, PlSqlParserRULE_table_ref)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3211)
		p.Table_ref_aux()
	}
	p.SetState(3215)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3212)
				p.Join_clause()
			}

		}
		p.SetState(3217)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext())
	}
	p.SetState(3220)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 355, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3218)
			p.Pivot_clause()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 355, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3219)
			p.Unpivot_clause()
		}

	}

	return localctx
}

// ITable_ref_auxContext is an interface to support dynamic dispatch.
type ITable_ref_auxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_ref_auxContext differentiates from other interfaces.
	IsTable_ref_auxContext()
}

type Table_ref_auxContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_ref_auxContext() *Table_ref_auxContext {
	var p = new(Table_ref_auxContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_ref_aux
	return p
}

func (*Table_ref_auxContext) IsTable_ref_auxContext() {}

func NewTable_ref_auxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_ref_auxContext {
	var p = new(Table_ref_auxContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_ref_aux

	return p
}

func (s *Table_ref_auxContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_ref_auxContext) Table_ref_aux_internal() ITable_ref_aux_internalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_ref_aux_internalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_ref_aux_internalContext)
}

func (s *Table_ref_auxContext) AllFlashback_query_clause() []IFlashback_query_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFlashback_query_clauseContext)(nil)).Elem())
	var tst = make([]IFlashback_query_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFlashback_query_clauseContext)
		}
	}

	return tst
}

func (s *Table_ref_auxContext) Flashback_query_clause(i int) IFlashback_query_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlashback_query_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFlashback_query_clauseContext)
}

func (s *Table_ref_auxContext) Table_alias() ITable_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_aliasContext)
}

func (s *Table_ref_auxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_ref_auxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_ref_auxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_ref_aux(s)
	}
}

func (s *Table_ref_auxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_ref_aux(s)
	}
}

func (p *PlSqlParser) Table_ref_aux() (localctx ITable_ref_auxContext) {
	localctx = NewTable_ref_auxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, PlSqlParserRULE_table_ref_aux)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3222)
		p.Table_ref_aux_internal()
	}
	p.SetState(3226)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 356, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3223)
				p.Flashback_query_clause()
			}

		}
		p.SetState(3228)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 356, p.GetParserRuleContext())
	}
	p.SetState(3230)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 357, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3229)
			p.Table_alias()
		}

	}

	return localctx
}

// ITable_ref_aux_internalContext is an interface to support dynamic dispatch.
type ITable_ref_aux_internalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_ref_aux_internalContext differentiates from other interfaces.
	IsTable_ref_aux_internalContext()
}

type Table_ref_aux_internalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_ref_aux_internalContext() *Table_ref_aux_internalContext {
	var p = new(Table_ref_aux_internalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_ref_aux_internal
	return p
}

func (*Table_ref_aux_internalContext) IsTable_ref_aux_internalContext() {}

func NewTable_ref_aux_internalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_ref_aux_internalContext {
	var p = new(Table_ref_aux_internalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_ref_aux_internal

	return p
}

func (s *Table_ref_aux_internalContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_ref_aux_internalContext) CopyFrom(ctx *Table_ref_aux_internalContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *Table_ref_aux_internalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_ref_aux_internalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Table_ref_aux_internal_threeContext struct {
	*Table_ref_aux_internalContext
}

func NewTable_ref_aux_internal_threeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Table_ref_aux_internal_threeContext {
	var p = new(Table_ref_aux_internal_threeContext)

	p.Table_ref_aux_internalContext = NewEmptyTable_ref_aux_internalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Table_ref_aux_internalContext))

	return p
}

func (s *Table_ref_aux_internal_threeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_ref_aux_internal_threeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserONLY, 0)
}

func (s *Table_ref_aux_internal_threeContext) Dml_table_expression_clause() IDml_table_expression_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDml_table_expression_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDml_table_expression_clauseContext)
}

func (s *Table_ref_aux_internal_threeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_ref_aux_internal_three(s)
	}
}

func (s *Table_ref_aux_internal_threeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_ref_aux_internal_three(s)
	}
}

type Table_ref_aux_internal_oneContext struct {
	*Table_ref_aux_internalContext
}

func NewTable_ref_aux_internal_oneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Table_ref_aux_internal_oneContext {
	var p = new(Table_ref_aux_internal_oneContext)

	p.Table_ref_aux_internalContext = NewEmptyTable_ref_aux_internalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Table_ref_aux_internalContext))

	return p
}

func (s *Table_ref_aux_internal_oneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_ref_aux_internal_oneContext) Dml_table_expression_clause() IDml_table_expression_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDml_table_expression_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDml_table_expression_clauseContext)
}

func (s *Table_ref_aux_internal_oneContext) Pivot_clause() IPivot_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPivot_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPivot_clauseContext)
}

func (s *Table_ref_aux_internal_oneContext) Unpivot_clause() IUnpivot_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpivot_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnpivot_clauseContext)
}

func (s *Table_ref_aux_internal_oneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_ref_aux_internal_one(s)
	}
}

func (s *Table_ref_aux_internal_oneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_ref_aux_internal_one(s)
	}
}

type Table_ref_aux_internal_twoContext struct {
	*Table_ref_aux_internalContext
}

func NewTable_ref_aux_internal_twoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Table_ref_aux_internal_twoContext {
	var p = new(Table_ref_aux_internal_twoContext)

	p.Table_ref_aux_internalContext = NewEmptyTable_ref_aux_internalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Table_ref_aux_internalContext))

	return p
}

func (s *Table_ref_aux_internal_twoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_ref_aux_internal_twoContext) Table_ref() ITable_refContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_refContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_refContext)
}

func (s *Table_ref_aux_internal_twoContext) AllSubquery_operation_part() []ISubquery_operation_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubquery_operation_partContext)(nil)).Elem())
	var tst = make([]ISubquery_operation_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubquery_operation_partContext)
		}
	}

	return tst
}

func (s *Table_ref_aux_internal_twoContext) Subquery_operation_part(i int) ISubquery_operation_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubquery_operation_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubquery_operation_partContext)
}

func (s *Table_ref_aux_internal_twoContext) Pivot_clause() IPivot_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPivot_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPivot_clauseContext)
}

func (s *Table_ref_aux_internal_twoContext) Unpivot_clause() IUnpivot_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpivot_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnpivot_clauseContext)
}

func (s *Table_ref_aux_internal_twoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_ref_aux_internal_two(s)
	}
}

func (s *Table_ref_aux_internal_twoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_ref_aux_internal_two(s)
	}
}

func (p *PlSqlParser) Table_ref_aux_internal() (localctx ITable_ref_aux_internalContext) {
	localctx = NewTable_ref_aux_internalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, PlSqlParserRULE_table_ref_aux_internal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3255)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 361, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTable_ref_aux_internal_oneContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3232)
			p.Dml_table_expression_clause()
		}
		p.SetState(3235)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 358, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3233)
				p.Pivot_clause()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 358, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3234)
				p.Unpivot_clause()
			}

		}

	case 2:
		localctx = NewTable_ref_aux_internal_twoContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3237)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3238)
			p.Table_ref()
		}
		p.SetState(3242)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserINTERSECT || _la == PlSqlParserMINUS || _la == PlSqlParserUNION {
			{
				p.SetState(3239)
				p.Subquery_operation_part()
			}

			p.SetState(3244)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3245)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(3248)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 360, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3246)
				p.Pivot_clause()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 360, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3247)
				p.Unpivot_clause()
			}

		}

	case 3:
		localctx = NewTable_ref_aux_internal_threeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3250)
			p.Match(PlSqlParserONLY)
		}
		{
			p.SetState(3251)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3252)
			p.Dml_table_expression_clause()
		}
		{
			p.SetState(3253)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}

	return localctx
}

// IJoin_clauseContext is an interface to support dynamic dispatch.
type IJoin_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoin_clauseContext differentiates from other interfaces.
	IsJoin_clauseContext()
}

type Join_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_clauseContext() *Join_clauseContext {
	var p = new(Join_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_join_clause
	return p
}

func (*Join_clauseContext) IsJoin_clauseContext() {}

func NewJoin_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_clauseContext {
	var p = new(Join_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_join_clause

	return p
}

func (s *Join_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_clauseContext) JOIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserJOIN, 0)
}

func (s *Join_clauseContext) Table_ref_aux() ITable_ref_auxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_ref_auxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_ref_auxContext)
}

func (s *Join_clauseContext) AllQuery_partition_clause() []IQuery_partition_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuery_partition_clauseContext)(nil)).Elem())
	var tst = make([]IQuery_partition_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuery_partition_clauseContext)
		}
	}

	return tst
}

func (s *Join_clauseContext) Query_partition_clause(i int) IQuery_partition_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_partition_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuery_partition_clauseContext)
}

func (s *Join_clauseContext) INNER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINNER, 0)
}

func (s *Join_clauseContext) Outer_join_type() IOuter_join_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOuter_join_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOuter_join_typeContext)
}

func (s *Join_clauseContext) AllJoin_on_part() []IJoin_on_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoin_on_partContext)(nil)).Elem())
	var tst = make([]IJoin_on_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoin_on_partContext)
		}
	}

	return tst
}

func (s *Join_clauseContext) Join_on_part(i int) IJoin_on_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_on_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoin_on_partContext)
}

func (s *Join_clauseContext) AllJoin_using_part() []IJoin_using_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoin_using_partContext)(nil)).Elem())
	var tst = make([]IJoin_using_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoin_using_partContext)
		}
	}

	return tst
}

func (s *Join_clauseContext) Join_using_part(i int) IJoin_using_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_using_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoin_using_partContext)
}

func (s *Join_clauseContext) CROSS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCROSS, 0)
}

func (s *Join_clauseContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNATURAL, 0)
}

func (s *Join_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterJoin_clause(s)
	}
}

func (s *Join_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitJoin_clause(s)
	}
}

func (p *PlSqlParser) Join_clause() (localctx IJoin_clauseContext) {
	localctx = NewJoin_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, PlSqlParserRULE_join_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPARTITION {
		{
			p.SetState(3257)
			p.Query_partition_clause()
		}

	}
	p.SetState(3261)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserCROSS || _la == PlSqlParserNATURAL {
		{
			p.SetState(3260)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserCROSS || _la == PlSqlParserNATURAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3265)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserINNER:
		{
			p.SetState(3263)
			p.Match(PlSqlParserINNER)
		}

	case PlSqlParserFULL, PlSqlParserLEFT, PlSqlParserRIGHT:
		{
			p.SetState(3264)
			p.Outer_join_type()
		}

	case PlSqlParserJOIN:

	default:
	}
	{
		p.SetState(3267)
		p.Match(PlSqlParserJOIN)
	}
	{
		p.SetState(3268)
		p.Table_ref_aux()
	}
	p.SetState(3270)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 365, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3269)
			p.Query_partition_clause()
		}

	}
	p.SetState(3276)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 367, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3274)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PlSqlParserON:
				{
					p.SetState(3272)
					p.Join_on_part()
				}

			case PlSqlParserUSING:
				{
					p.SetState(3273)
					p.Join_using_part()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(3278)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 367, p.GetParserRuleContext())
	}

	return localctx
}

// IJoin_on_partContext is an interface to support dynamic dispatch.
type IJoin_on_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoin_on_partContext differentiates from other interfaces.
	IsJoin_on_partContext()
}

type Join_on_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_on_partContext() *Join_on_partContext {
	var p = new(Join_on_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_join_on_part
	return p
}

func (*Join_on_partContext) IsJoin_on_partContext() {}

func NewJoin_on_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_on_partContext {
	var p = new(Join_on_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_join_on_part

	return p
}

func (s *Join_on_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_on_partContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Join_on_partContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Join_on_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_on_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_on_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterJoin_on_part(s)
	}
}

func (s *Join_on_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitJoin_on_part(s)
	}
}

func (p *PlSqlParser) Join_on_part() (localctx IJoin_on_partContext) {
	localctx = NewJoin_on_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, PlSqlParserRULE_join_on_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3279)
		p.Match(PlSqlParserON)
	}
	{
		p.SetState(3280)
		p.Condition()
	}

	return localctx
}

// IJoin_using_partContext is an interface to support dynamic dispatch.
type IJoin_using_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoin_using_partContext differentiates from other interfaces.
	IsJoin_using_partContext()
}

type Join_using_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_using_partContext() *Join_using_partContext {
	var p = new(Join_using_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_join_using_part
	return p
}

func (*Join_using_partContext) IsJoin_using_partContext() {}

func NewJoin_using_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_using_partContext {
	var p = new(Join_using_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_join_using_part

	return p
}

func (s *Join_using_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_using_partContext) USING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSING, 0)
}

func (s *Join_using_partContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Join_using_partContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Join_using_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_using_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_using_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterJoin_using_part(s)
	}
}

func (s *Join_using_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitJoin_using_part(s)
	}
}

func (p *PlSqlParser) Join_using_part() (localctx IJoin_using_partContext) {
	localctx = NewJoin_using_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, PlSqlParserRULE_join_using_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3282)
		p.Match(PlSqlParserUSING)
	}
	{
		p.SetState(3283)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3284)
		p.Column_name()
	}
	p.SetState(3289)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3285)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3286)
			p.Column_name()
		}

		p.SetState(3291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3292)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IOuter_join_typeContext is an interface to support dynamic dispatch.
type IOuter_join_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOuter_join_typeContext differentiates from other interfaces.
	IsOuter_join_typeContext()
}

type Outer_join_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOuter_join_typeContext() *Outer_join_typeContext {
	var p = new(Outer_join_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_outer_join_type
	return p
}

func (*Outer_join_typeContext) IsOuter_join_typeContext() {}

func NewOuter_join_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Outer_join_typeContext {
	var p = new(Outer_join_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_outer_join_type

	return p
}

func (s *Outer_join_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Outer_join_typeContext) FULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFULL, 0)
}

func (s *Outer_join_typeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEFT, 0)
}

func (s *Outer_join_typeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRIGHT, 0)
}

func (s *Outer_join_typeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOUTER, 0)
}

func (s *Outer_join_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Outer_join_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Outer_join_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOuter_join_type(s)
	}
}

func (s *Outer_join_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOuter_join_type(s)
	}
}

func (p *PlSqlParser) Outer_join_type() (localctx IOuter_join_typeContext) {
	localctx = NewOuter_join_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, PlSqlParserRULE_outer_join_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3294)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserFULL || _la == PlSqlParserLEFT || _la == PlSqlParserRIGHT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3296)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOUTER {
		{
			p.SetState(3295)
			p.Match(PlSqlParserOUTER)
		}

	}

	return localctx
}

// IQuery_partition_clauseContext is an interface to support dynamic dispatch.
type IQuery_partition_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_partition_clauseContext differentiates from other interfaces.
	IsQuery_partition_clauseContext()
}

type Query_partition_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_partition_clauseContext() *Query_partition_clauseContext {
	var p = new(Query_partition_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_query_partition_clause
	return p
}

func (*Query_partition_clauseContext) IsQuery_partition_clauseContext() {}

func NewQuery_partition_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_partition_clauseContext {
	var p = new(Query_partition_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_query_partition_clause

	return p
}

func (s *Query_partition_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_partition_clauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARTITION, 0)
}

func (s *Query_partition_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Query_partition_clauseContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Query_partition_clauseContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Query_partition_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_partition_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_partition_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterQuery_partition_clause(s)
	}
}

func (s *Query_partition_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitQuery_partition_clause(s)
	}
}

func (p *PlSqlParser) Query_partition_clause() (localctx IQuery_partition_clauseContext) {
	localctx = NewQuery_partition_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, PlSqlParserRULE_query_partition_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3298)
		p.Match(PlSqlParserPARTITION)
	}
	{
		p.SetState(3299)
		p.Match(PlSqlParserBY)
	}
	p.SetState(3307)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 371, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3300)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(3303)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 370, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3301)
				p.Subquery()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 370, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3302)
				p.Expressions()
			}

		}
		{
			p.SetState(3305)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 2:
		{
			p.SetState(3306)
			p.Expressions()
		}

	}

	return localctx
}

// IFlashback_query_clauseContext is an interface to support dynamic dispatch.
type IFlashback_query_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlashback_query_clauseContext differentiates from other interfaces.
	IsFlashback_query_clauseContext()
}

type Flashback_query_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlashback_query_clauseContext() *Flashback_query_clauseContext {
	var p = new(Flashback_query_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_flashback_query_clause
	return p
}

func (*Flashback_query_clauseContext) IsFlashback_query_clauseContext() {}

func NewFlashback_query_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flashback_query_clauseContext {
	var p = new(Flashback_query_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_flashback_query_clause

	return p
}

func (s *Flashback_query_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Flashback_query_clauseContext) VERSIONS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVERSIONS, 0)
}

func (s *Flashback_query_clauseContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBETWEEN, 0)
}

func (s *Flashback_query_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Flashback_query_clauseContext) SCN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSCN, 0)
}

func (s *Flashback_query_clauseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP, 0)
}

func (s *Flashback_query_clauseContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Flashback_query_clauseContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Flashback_query_clauseContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSNAPSHOT, 0)
}

func (s *Flashback_query_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flashback_query_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flashback_query_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFlashback_query_clause(s)
	}
}

func (s *Flashback_query_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFlashback_query_clause(s)
	}
}

func (p *PlSqlParser) Flashback_query_clause() (localctx IFlashback_query_clauseContext) {
	localctx = NewFlashback_query_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, PlSqlParserRULE_flashback_query_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3317)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserVERSIONS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3309)
			p.Match(PlSqlParserVERSIONS)
		}
		{
			p.SetState(3310)
			p.Match(PlSqlParserBETWEEN)
		}
		{
			p.SetState(3311)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserSCN || _la == PlSqlParserTIMESTAMP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3312)
			p.Expression()
		}

	case PlSqlParserAS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3313)
			p.Match(PlSqlParserAS)
		}
		{
			p.SetState(3314)
			p.Match(PlSqlParserOF)
		}
		{
			p.SetState(3315)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserSCN || _la == PlSqlParserSNAPSHOT || _la == PlSqlParserTIMESTAMP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3316)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPivot_clauseContext is an interface to support dynamic dispatch.
type IPivot_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPivot_clauseContext differentiates from other interfaces.
	IsPivot_clauseContext()
}

type Pivot_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_clauseContext() *Pivot_clauseContext {
	var p = new(Pivot_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pivot_clause
	return p
}

func (*Pivot_clauseContext) IsPivot_clauseContext() {}

func NewPivot_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_clauseContext {
	var p = new(Pivot_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pivot_clause

	return p
}

func (s *Pivot_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_clauseContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPIVOT, 0)
}

func (s *Pivot_clauseContext) AllPivot_element() []IPivot_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPivot_elementContext)(nil)).Elem())
	var tst = make([]IPivot_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPivot_elementContext)
		}
	}

	return tst
}

func (s *Pivot_clauseContext) Pivot_element(i int) IPivot_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPivot_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPivot_elementContext)
}

func (s *Pivot_clauseContext) Pivot_for_clause() IPivot_for_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPivot_for_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPivot_for_clauseContext)
}

func (s *Pivot_clauseContext) Pivot_in_clause() IPivot_in_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPivot_in_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPivot_in_clauseContext)
}

func (s *Pivot_clauseContext) XML() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXML, 0)
}

func (s *Pivot_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pivot_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPivot_clause(s)
	}
}

func (s *Pivot_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPivot_clause(s)
	}
}

func (p *PlSqlParser) Pivot_clause() (localctx IPivot_clauseContext) {
	localctx = NewPivot_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, PlSqlParserRULE_pivot_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3319)
		p.Match(PlSqlParserPIVOT)
	}
	p.SetState(3321)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserXML {
		{
			p.SetState(3320)
			p.Match(PlSqlParserXML)
		}

	}
	{
		p.SetState(3323)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3324)
		p.Pivot_element()
	}
	p.SetState(3329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3325)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3326)
			p.Pivot_element()
		}

		p.SetState(3331)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3332)
		p.Pivot_for_clause()
	}
	{
		p.SetState(3333)
		p.Pivot_in_clause()
	}
	{
		p.SetState(3334)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IPivot_elementContext is an interface to support dynamic dispatch.
type IPivot_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPivot_elementContext differentiates from other interfaces.
	IsPivot_elementContext()
}

type Pivot_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_elementContext() *Pivot_elementContext {
	var p = new(Pivot_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pivot_element
	return p
}

func (*Pivot_elementContext) IsPivot_elementContext() {}

func NewPivot_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_elementContext {
	var p = new(Pivot_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pivot_element

	return p
}

func (s *Pivot_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_elementContext) Aggregate_function_name() IAggregate_function_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregate_function_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregate_function_nameContext)
}

func (s *Pivot_elementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pivot_elementContext) Column_alias() IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Pivot_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pivot_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPivot_element(s)
	}
}

func (s *Pivot_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPivot_element(s)
	}
}

func (p *PlSqlParser) Pivot_element() (localctx IPivot_elementContext) {
	localctx = NewPivot_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, PlSqlParserRULE_pivot_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3336)
		p.Aggregate_function_name()
	}
	{
		p.SetState(3337)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3338)
		p.Expression()
	}
	{
		p.SetState(3339)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(3341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserAS)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-521))|(1<<(PlSqlParserCHAR_STRING-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(3340)
			p.Column_alias()
		}

	}

	return localctx
}

// IPivot_for_clauseContext is an interface to support dynamic dispatch.
type IPivot_for_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPivot_for_clauseContext differentiates from other interfaces.
	IsPivot_for_clauseContext()
}

type Pivot_for_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_for_clauseContext() *Pivot_for_clauseContext {
	var p = new(Pivot_for_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pivot_for_clause
	return p
}

func (*Pivot_for_clauseContext) IsPivot_for_clauseContext() {}

func NewPivot_for_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_for_clauseContext {
	var p = new(Pivot_for_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pivot_for_clause

	return p
}

func (s *Pivot_for_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_for_clauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Pivot_for_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Pivot_for_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Pivot_for_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_for_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pivot_for_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPivot_for_clause(s)
	}
}

func (s *Pivot_for_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPivot_for_clause(s)
	}
}

func (p *PlSqlParser) Pivot_for_clause() (localctx IPivot_for_clauseContext) {
	localctx = NewPivot_for_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, PlSqlParserRULE_pivot_for_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3343)
		p.Match(PlSqlParserFOR)
	}
	p.SetState(3356)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(3344)
			p.Column_name()
		}

	case PlSqlParserLEFT_PAREN:
		{
			p.SetState(3345)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3346)
			p.Column_name()
		}
		p.SetState(3351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3347)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3348)
				p.Column_name()
			}

			p.SetState(3353)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3354)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPivot_in_clauseContext is an interface to support dynamic dispatch.
type IPivot_in_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPivot_in_clauseContext differentiates from other interfaces.
	IsPivot_in_clauseContext()
}

type Pivot_in_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_in_clauseContext() *Pivot_in_clauseContext {
	var p = new(Pivot_in_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pivot_in_clause
	return p
}

func (*Pivot_in_clauseContext) IsPivot_in_clauseContext() {}

func NewPivot_in_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_in_clauseContext {
	var p = new(Pivot_in_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pivot_in_clause

	return p
}

func (s *Pivot_in_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_in_clauseContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Pivot_in_clauseContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Pivot_in_clauseContext) AllANY() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserANY)
}

func (s *Pivot_in_clauseContext) ANY(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserANY, i)
}

func (s *Pivot_in_clauseContext) AllPivot_in_clause_element() []IPivot_in_clause_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPivot_in_clause_elementContext)(nil)).Elem())
	var tst = make([]IPivot_in_clause_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPivot_in_clause_elementContext)
		}
	}

	return tst
}

func (s *Pivot_in_clauseContext) Pivot_in_clause_element(i int) IPivot_in_clause_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPivot_in_clause_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPivot_in_clause_elementContext)
}

func (s *Pivot_in_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_in_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pivot_in_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPivot_in_clause(s)
	}
}

func (s *Pivot_in_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPivot_in_clause(s)
	}
}

func (p *PlSqlParser) Pivot_in_clause() (localctx IPivot_in_clauseContext) {
	localctx = NewPivot_in_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, PlSqlParserRULE_pivot_in_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3358)
		p.Match(PlSqlParserIN)
	}
	{
		p.SetState(3359)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(3377)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 380, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3360)
			p.Subquery()
		}

	case 2:
		{
			p.SetState(3361)
			p.Match(PlSqlParserANY)
		}
		p.SetState(3366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3362)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3363)
				p.Match(PlSqlParserANY)
			}

			p.SetState(3368)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		{
			p.SetState(3369)
			p.Pivot_in_clause_element()
		}
		p.SetState(3374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3370)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3371)
				p.Pivot_in_clause_element()
			}

			p.SetState(3376)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3379)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IPivot_in_clause_elementContext is an interface to support dynamic dispatch.
type IPivot_in_clause_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPivot_in_clause_elementContext differentiates from other interfaces.
	IsPivot_in_clause_elementContext()
}

type Pivot_in_clause_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_in_clause_elementContext() *Pivot_in_clause_elementContext {
	var p = new(Pivot_in_clause_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pivot_in_clause_element
	return p
}

func (*Pivot_in_clause_elementContext) IsPivot_in_clause_elementContext() {}

func NewPivot_in_clause_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_in_clause_elementContext {
	var p = new(Pivot_in_clause_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pivot_in_clause_element

	return p
}

func (s *Pivot_in_clause_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_in_clause_elementContext) Pivot_in_clause_elements() IPivot_in_clause_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPivot_in_clause_elementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPivot_in_clause_elementsContext)
}

func (s *Pivot_in_clause_elementContext) Column_alias() IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Pivot_in_clause_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_in_clause_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pivot_in_clause_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPivot_in_clause_element(s)
	}
}

func (s *Pivot_in_clause_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPivot_in_clause_element(s)
	}
}

func (p *PlSqlParser) Pivot_in_clause_element() (localctx IPivot_in_clause_elementContext) {
	localctx = NewPivot_in_clause_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, PlSqlParserRULE_pivot_in_clause_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3381)
		p.Pivot_in_clause_elements()
	}
	p.SetState(3383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserAS)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-521))|(1<<(PlSqlParserCHAR_STRING-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(3382)
			p.Column_alias()
		}

	}

	return localctx
}

// IPivot_in_clause_elementsContext is an interface to support dynamic dispatch.
type IPivot_in_clause_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPivot_in_clause_elementsContext differentiates from other interfaces.
	IsPivot_in_clause_elementsContext()
}

type Pivot_in_clause_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivot_in_clause_elementsContext() *Pivot_in_clause_elementsContext {
	var p = new(Pivot_in_clause_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_pivot_in_clause_elements
	return p
}

func (*Pivot_in_clause_elementsContext) IsPivot_in_clause_elementsContext() {}

func NewPivot_in_clause_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pivot_in_clause_elementsContext {
	var p = new(Pivot_in_clause_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_pivot_in_clause_elements

	return p
}

func (s *Pivot_in_clause_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Pivot_in_clause_elementsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pivot_in_clause_elementsContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Pivot_in_clause_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pivot_in_clause_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pivot_in_clause_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPivot_in_clause_elements(s)
	}
}

func (s *Pivot_in_clause_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPivot_in_clause_elements(s)
	}
}

func (p *PlSqlParser) Pivot_in_clause_elements() (localctx IPivot_in_clause_elementsContext) {
	localctx = NewPivot_in_clause_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, PlSqlParserRULE_pivot_in_clause_elements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3391)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 383, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3385)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3386)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(3388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
			{
				p.SetState(3387)
				p.Expressions()
			}

		}
		{
			p.SetState(3390)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}

	return localctx
}

// IUnpivot_clauseContext is an interface to support dynamic dispatch.
type IUnpivot_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnpivot_clauseContext differentiates from other interfaces.
	IsUnpivot_clauseContext()
}

type Unpivot_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivot_clauseContext() *Unpivot_clauseContext {
	var p = new(Unpivot_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_unpivot_clause
	return p
}

func (*Unpivot_clauseContext) IsUnpivot_clauseContext() {}

func NewUnpivot_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpivot_clauseContext {
	var p = new(Unpivot_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_unpivot_clause

	return p
}

func (s *Unpivot_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpivot_clauseContext) UNPIVOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNPIVOT, 0)
}

func (s *Unpivot_clauseContext) Pivot_for_clause() IPivot_for_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPivot_for_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPivot_for_clauseContext)
}

func (s *Unpivot_clauseContext) Unpivot_in_clause() IUnpivot_in_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpivot_in_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnpivot_in_clauseContext)
}

func (s *Unpivot_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Unpivot_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Unpivot_clauseContext) NULLS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULLS, 0)
}

func (s *Unpivot_clauseContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINCLUDE, 0)
}

func (s *Unpivot_clauseContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCLUDE, 0)
}

func (s *Unpivot_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpivot_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unpivot_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUnpivot_clause(s)
	}
}

func (s *Unpivot_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUnpivot_clause(s)
	}
}

func (p *PlSqlParser) Unpivot_clause() (localctx IUnpivot_clauseContext) {
	localctx = NewUnpivot_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, PlSqlParserRULE_unpivot_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3393)
		p.Match(PlSqlParserUNPIVOT)
	}
	p.SetState(3396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserEXCLUDE || _la == PlSqlParserINCLUDE {
		{
			p.SetState(3394)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserEXCLUDE || _la == PlSqlParserINCLUDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3395)
			p.Match(PlSqlParserNULLS)
		}

	}
	{
		p.SetState(3398)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(3411)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(3399)
			p.Column_name()
		}

	case PlSqlParserLEFT_PAREN:
		{
			p.SetState(3400)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3401)
			p.Column_name()
		}
		p.SetState(3406)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3402)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3403)
				p.Column_name()
			}

			p.SetState(3408)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3409)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(3413)
		p.Pivot_for_clause()
	}
	{
		p.SetState(3414)
		p.Unpivot_in_clause()
	}
	{
		p.SetState(3415)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IUnpivot_in_clauseContext is an interface to support dynamic dispatch.
type IUnpivot_in_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnpivot_in_clauseContext differentiates from other interfaces.
	IsUnpivot_in_clauseContext()
}

type Unpivot_in_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivot_in_clauseContext() *Unpivot_in_clauseContext {
	var p = new(Unpivot_in_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_unpivot_in_clause
	return p
}

func (*Unpivot_in_clauseContext) IsUnpivot_in_clauseContext() {}

func NewUnpivot_in_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpivot_in_clauseContext {
	var p = new(Unpivot_in_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_unpivot_in_clause

	return p
}

func (s *Unpivot_in_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpivot_in_clauseContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Unpivot_in_clauseContext) AllUnpivot_in_elements() []IUnpivot_in_elementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnpivot_in_elementsContext)(nil)).Elem())
	var tst = make([]IUnpivot_in_elementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnpivot_in_elementsContext)
		}
	}

	return tst
}

func (s *Unpivot_in_clauseContext) Unpivot_in_elements(i int) IUnpivot_in_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpivot_in_elementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnpivot_in_elementsContext)
}

func (s *Unpivot_in_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpivot_in_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unpivot_in_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUnpivot_in_clause(s)
	}
}

func (s *Unpivot_in_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUnpivot_in_clause(s)
	}
}

func (p *PlSqlParser) Unpivot_in_clause() (localctx IUnpivot_in_clauseContext) {
	localctx = NewUnpivot_in_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, PlSqlParserRULE_unpivot_in_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3417)
		p.Match(PlSqlParserIN)
	}
	{
		p.SetState(3418)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3419)
		p.Unpivot_in_elements()
	}
	p.SetState(3424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3420)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3421)
			p.Unpivot_in_elements()
		}

		p.SetState(3426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3427)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IUnpivot_in_elementsContext is an interface to support dynamic dispatch.
type IUnpivot_in_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnpivot_in_elementsContext differentiates from other interfaces.
	IsUnpivot_in_elementsContext()
}

type Unpivot_in_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivot_in_elementsContext() *Unpivot_in_elementsContext {
	var p = new(Unpivot_in_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_unpivot_in_elements
	return p
}

func (*Unpivot_in_elementsContext) IsUnpivot_in_elementsContext() {}

func NewUnpivot_in_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpivot_in_elementsContext {
	var p = new(Unpivot_in_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_unpivot_in_elements

	return p
}

func (s *Unpivot_in_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpivot_in_elementsContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Unpivot_in_elementsContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Unpivot_in_elementsContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Unpivot_in_elementsContext) AllConstant() []IConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantContext)(nil)).Elem())
	var tst = make([]IConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantContext)
		}
	}

	return tst
}

func (s *Unpivot_in_elementsContext) Constant(i int) IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Unpivot_in_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpivot_in_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unpivot_in_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUnpivot_in_elements(s)
	}
}

func (s *Unpivot_in_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUnpivot_in_elements(s)
	}
}

func (p *PlSqlParser) Unpivot_in_elements() (localctx IUnpivot_in_elementsContext) {
	localctx = NewUnpivot_in_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, PlSqlParserRULE_unpivot_in_elements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3441)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(3429)
			p.Column_name()
		}

	case PlSqlParserLEFT_PAREN:
		{
			p.SetState(3430)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3431)
			p.Column_name()
		}
		p.SetState(3436)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3432)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3433)
				p.Column_name()
			}

			p.SetState(3438)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3439)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3458)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAS {
		{
			p.SetState(3443)
			p.Match(PlSqlParserAS)
		}
		p.SetState(3456)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserDATE, PlSqlParserDBTIMEZONE, PlSqlParserDEFAULT, PlSqlParserFALSE, PlSqlParserINTERVAL, PlSqlParserMAXVALUE, PlSqlParserMINVALUE, PlSqlParserNULL, PlSqlParserSESSIONTIMEZONE, PlSqlParserTIMESTAMP, PlSqlParserTRUE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING:
			{
				p.SetState(3444)
				p.Constant()
			}

		case PlSqlParserLEFT_PAREN:
			{
				p.SetState(3445)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			{
				p.SetState(3446)
				p.Constant()
			}
			p.SetState(3451)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == PlSqlParserCOMMA {
				{
					p.SetState(3447)
					p.Match(PlSqlParserCOMMA)
				}
				{
					p.SetState(3448)
					p.Constant()
				}

				p.SetState(3453)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3454)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IHierarchical_query_clauseContext is an interface to support dynamic dispatch.
type IHierarchical_query_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_query_clauseContext differentiates from other interfaces.
	IsHierarchical_query_clauseContext()
}

type Hierarchical_query_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_query_clauseContext() *Hierarchical_query_clauseContext {
	var p = new(Hierarchical_query_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_hierarchical_query_clause
	return p
}

func (*Hierarchical_query_clauseContext) IsHierarchical_query_clauseContext() {}

func NewHierarchical_query_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_query_clauseContext {
	var p = new(Hierarchical_query_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_hierarchical_query_clause

	return p
}

func (s *Hierarchical_query_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_query_clauseContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONNECT, 0)
}

func (s *Hierarchical_query_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Hierarchical_query_clauseContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Hierarchical_query_clauseContext) NOCYCLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOCYCLE, 0)
}

func (s *Hierarchical_query_clauseContext) Start_part() IStart_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStart_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStart_partContext)
}

func (s *Hierarchical_query_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_query_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_query_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterHierarchical_query_clause(s)
	}
}

func (s *Hierarchical_query_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitHierarchical_query_clause(s)
	}
}

func (p *PlSqlParser) Hierarchical_query_clause() (localctx IHierarchical_query_clauseContext) {
	localctx = NewHierarchical_query_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, PlSqlParserRULE_hierarchical_query_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3477)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserCONNECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3460)
			p.Match(PlSqlParserCONNECT)
		}
		{
			p.SetState(3461)
			p.Match(PlSqlParserBY)
		}
		p.SetState(3463)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 393, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3462)
				p.Match(PlSqlParserNOCYCLE)
			}

		}
		{
			p.SetState(3465)
			p.Condition()
		}
		p.SetState(3467)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 394, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3466)
				p.Start_part()
			}

		}

	case PlSqlParserSTART:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3469)
			p.Start_part()
		}
		{
			p.SetState(3470)
			p.Match(PlSqlParserCONNECT)
		}
		{
			p.SetState(3471)
			p.Match(PlSqlParserBY)
		}
		p.SetState(3473)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 395, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3472)
				p.Match(PlSqlParserNOCYCLE)
			}

		}
		{
			p.SetState(3475)
			p.Condition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStart_partContext is an interface to support dynamic dispatch.
type IStart_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStart_partContext differentiates from other interfaces.
	IsStart_partContext()
}

type Start_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStart_partContext() *Start_partContext {
	var p = new(Start_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_start_part
	return p
}

func (*Start_partContext) IsStart_partContext() {}

func NewStart_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Start_partContext {
	var p = new(Start_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_start_part

	return p
}

func (s *Start_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Start_partContext) START() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTART, 0)
}

func (s *Start_partContext) WITH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWITH, 0)
}

func (s *Start_partContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Start_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Start_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Start_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterStart_part(s)
	}
}

func (s *Start_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitStart_part(s)
	}
}

func (p *PlSqlParser) Start_part() (localctx IStart_partContext) {
	localctx = NewStart_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, PlSqlParserRULE_start_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3479)
		p.Match(PlSqlParserSTART)
	}
	{
		p.SetState(3480)
		p.Match(PlSqlParserWITH)
	}
	{
		p.SetState(3481)
		p.Condition()
	}

	return localctx
}

// IGroup_by_clauseContext is an interface to support dynamic dispatch.
type IGroup_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_by_clauseContext differentiates from other interfaces.
	IsGroup_by_clauseContext()
}

type Group_by_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_clauseContext() *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_group_by_clause
	return p
}

func (*Group_by_clauseContext) IsGroup_by_clauseContext() {}

func NewGroup_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_group_by_clause

	return p
}

func (s *Group_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_clauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserGROUP, 0)
}

func (s *Group_by_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Group_by_clauseContext) AllGroup_by_elements() []IGroup_by_elementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroup_by_elementsContext)(nil)).Elem())
	var tst = make([]IGroup_by_elementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroup_by_elementsContext)
		}
	}

	return tst
}

func (s *Group_by_clauseContext) Group_by_elements(i int) IGroup_by_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_by_elementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroup_by_elementsContext)
}

func (s *Group_by_clauseContext) Having_clause() IHaving_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHaving_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHaving_clauseContext)
}

func (s *Group_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterGroup_by_clause(s)
	}
}

func (s *Group_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitGroup_by_clause(s)
	}
}

func (p *PlSqlParser) Group_by_clause() (localctx IGroup_by_clauseContext) {
	localctx = NewGroup_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, PlSqlParserRULE_group_by_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3509)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserGROUP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3483)
			p.Match(PlSqlParserGROUP)
		}
		{
			p.SetState(3484)
			p.Match(PlSqlParserBY)
		}
		{
			p.SetState(3485)
			p.Group_by_elements()
		}
		p.SetState(3490)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3486)
					p.Match(PlSqlParserCOMMA)
				}
				{
					p.SetState(3487)
					p.Group_by_elements()
				}

			}
			p.SetState(3492)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext())
		}
		p.SetState(3494)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 398, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3493)
				p.Having_clause()
			}

		}

	case PlSqlParserHAVING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3496)
			p.Having_clause()
		}
		p.SetState(3507)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3497)
				p.Match(PlSqlParserGROUP)
			}
			{
				p.SetState(3498)
				p.Match(PlSqlParserBY)
			}
			{
				p.SetState(3499)
				p.Group_by_elements()
			}
			p.SetState(3504)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 399, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3500)
						p.Match(PlSqlParserCOMMA)
					}
					{
						p.SetState(3501)
						p.Group_by_elements()
					}

				}
				p.SetState(3506)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 399, p.GetParserRuleContext())
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGroup_by_elementsContext is an interface to support dynamic dispatch.
type IGroup_by_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_by_elementsContext differentiates from other interfaces.
	IsGroup_by_elementsContext()
}

type Group_by_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_elementsContext() *Group_by_elementsContext {
	var p = new(Group_by_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_group_by_elements
	return p
}

func (*Group_by_elementsContext) IsGroup_by_elementsContext() {}

func NewGroup_by_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_elementsContext {
	var p = new(Group_by_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_group_by_elements

	return p
}

func (s *Group_by_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_elementsContext) Grouping_sets_clause() IGrouping_sets_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrouping_sets_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrouping_sets_clauseContext)
}

func (s *Group_by_elementsContext) Rollup_cube_clause() IRollup_cube_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRollup_cube_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRollup_cube_clauseContext)
}

func (s *Group_by_elementsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Group_by_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_by_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterGroup_by_elements(s)
	}
}

func (s *Group_by_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitGroup_by_elements(s)
	}
}

func (p *PlSqlParser) Group_by_elements() (localctx IGroup_by_elementsContext) {
	localctx = NewGroup_by_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, PlSqlParserRULE_group_by_elements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3514)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 402, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3511)
			p.Grouping_sets_clause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3512)
			p.Rollup_cube_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3513)
			p.Expression()
		}

	}

	return localctx
}

// IRollup_cube_clauseContext is an interface to support dynamic dispatch.
type IRollup_cube_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRollup_cube_clauseContext differentiates from other interfaces.
	IsRollup_cube_clauseContext()
}

type Rollup_cube_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollup_cube_clauseContext() *Rollup_cube_clauseContext {
	var p = new(Rollup_cube_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_rollup_cube_clause
	return p
}

func (*Rollup_cube_clauseContext) IsRollup_cube_clauseContext() {}

func NewRollup_cube_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollup_cube_clauseContext {
	var p = new(Rollup_cube_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_rollup_cube_clause

	return p
}

func (s *Rollup_cube_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollup_cube_clauseContext) AllGrouping_sets_elements() []IGrouping_sets_elementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGrouping_sets_elementsContext)(nil)).Elem())
	var tst = make([]IGrouping_sets_elementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGrouping_sets_elementsContext)
		}
	}

	return tst
}

func (s *Rollup_cube_clauseContext) Grouping_sets_elements(i int) IGrouping_sets_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrouping_sets_elementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGrouping_sets_elementsContext)
}

func (s *Rollup_cube_clauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROLLUP, 0)
}

func (s *Rollup_cube_clauseContext) CUBE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCUBE, 0)
}

func (s *Rollup_cube_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollup_cube_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rollup_cube_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRollup_cube_clause(s)
	}
}

func (s *Rollup_cube_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRollup_cube_clause(s)
	}
}

func (p *PlSqlParser) Rollup_cube_clause() (localctx IRollup_cube_clauseContext) {
	localctx = NewRollup_cube_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, PlSqlParserRULE_rollup_cube_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3516)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserCUBE || _la == PlSqlParserROLLUP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3517)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3518)
		p.Grouping_sets_elements()
	}
	p.SetState(3523)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3519)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3520)
			p.Grouping_sets_elements()
		}

		p.SetState(3525)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3526)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IGrouping_sets_clauseContext is an interface to support dynamic dispatch.
type IGrouping_sets_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGrouping_sets_clauseContext differentiates from other interfaces.
	IsGrouping_sets_clauseContext()
}

type Grouping_sets_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_sets_clauseContext() *Grouping_sets_clauseContext {
	var p = new(Grouping_sets_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_grouping_sets_clause
	return p
}

func (*Grouping_sets_clauseContext) IsGrouping_sets_clauseContext() {}

func NewGrouping_sets_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_sets_clauseContext {
	var p = new(Grouping_sets_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_grouping_sets_clause

	return p
}

func (s *Grouping_sets_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_sets_clauseContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserGROUPING, 0)
}

func (s *Grouping_sets_clauseContext) SETS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSETS, 0)
}

func (s *Grouping_sets_clauseContext) AllGrouping_sets_elements() []IGrouping_sets_elementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGrouping_sets_elementsContext)(nil)).Elem())
	var tst = make([]IGrouping_sets_elementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGrouping_sets_elementsContext)
		}
	}

	return tst
}

func (s *Grouping_sets_clauseContext) Grouping_sets_elements(i int) IGrouping_sets_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrouping_sets_elementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGrouping_sets_elementsContext)
}

func (s *Grouping_sets_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_sets_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grouping_sets_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterGrouping_sets_clause(s)
	}
}

func (s *Grouping_sets_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitGrouping_sets_clause(s)
	}
}

func (p *PlSqlParser) Grouping_sets_clause() (localctx IGrouping_sets_clauseContext) {
	localctx = NewGrouping_sets_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, PlSqlParserRULE_grouping_sets_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3528)
		p.Match(PlSqlParserGROUPING)
	}
	{
		p.SetState(3529)
		p.Match(PlSqlParserSETS)
	}
	{
		p.SetState(3530)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3531)
		p.Grouping_sets_elements()
	}
	p.SetState(3536)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3532)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3533)
			p.Grouping_sets_elements()
		}

		p.SetState(3538)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3539)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IGrouping_sets_elementsContext is an interface to support dynamic dispatch.
type IGrouping_sets_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGrouping_sets_elementsContext differentiates from other interfaces.
	IsGrouping_sets_elementsContext()
}

type Grouping_sets_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_sets_elementsContext() *Grouping_sets_elementsContext {
	var p = new(Grouping_sets_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_grouping_sets_elements
	return p
}

func (*Grouping_sets_elementsContext) IsGrouping_sets_elementsContext() {}

func NewGrouping_sets_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_sets_elementsContext {
	var p = new(Grouping_sets_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_grouping_sets_elements

	return p
}

func (s *Grouping_sets_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_sets_elementsContext) Rollup_cube_clause() IRollup_cube_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRollup_cube_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRollup_cube_clauseContext)
}

func (s *Grouping_sets_elementsContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Grouping_sets_elementsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Grouping_sets_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_sets_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grouping_sets_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterGrouping_sets_elements(s)
	}
}

func (s *Grouping_sets_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitGrouping_sets_elements(s)
	}
}

func (p *PlSqlParser) Grouping_sets_elements() (localctx IGrouping_sets_elementsContext) {
	localctx = NewGrouping_sets_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, PlSqlParserRULE_grouping_sets_elements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3548)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 406, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3541)
			p.Rollup_cube_clause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3542)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(3544)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
			{
				p.SetState(3543)
				p.Expressions()
			}

		}
		{
			p.SetState(3546)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3547)
			p.Expression()
		}

	}

	return localctx
}

// IHaving_clauseContext is an interface to support dynamic dispatch.
type IHaving_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHaving_clauseContext differentiates from other interfaces.
	IsHaving_clauseContext()
}

type Having_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHaving_clauseContext() *Having_clauseContext {
	var p = new(Having_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_having_clause
	return p
}

func (*Having_clauseContext) IsHaving_clauseContext() {}

func NewHaving_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Having_clauseContext {
	var p = new(Having_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_having_clause

	return p
}

func (s *Having_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Having_clauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserHAVING, 0)
}

func (s *Having_clauseContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Having_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Having_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Having_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterHaving_clause(s)
	}
}

func (s *Having_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitHaving_clause(s)
	}
}

func (p *PlSqlParser) Having_clause() (localctx IHaving_clauseContext) {
	localctx = NewHaving_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, PlSqlParserRULE_having_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3550)
		p.Match(PlSqlParserHAVING)
	}
	{
		p.SetState(3551)
		p.Condition()
	}

	return localctx
}

// IModel_clauseContext is an interface to support dynamic dispatch.
type IModel_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_clauseContext differentiates from other interfaces.
	IsModel_clauseContext()
}

type Model_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_clauseContext() *Model_clauseContext {
	var p = new(Model_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_clause
	return p
}

func (*Model_clauseContext) IsModel_clauseContext() {}

func NewModel_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_clauseContext {
	var p = new(Model_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_clause

	return p
}

func (s *Model_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_clauseContext) MODEL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMODEL, 0)
}

func (s *Model_clauseContext) Main_model() IMain_modelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMain_modelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMain_modelContext)
}

func (s *Model_clauseContext) AllCell_reference_options() []ICell_reference_optionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICell_reference_optionsContext)(nil)).Elem())
	var tst = make([]ICell_reference_optionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICell_reference_optionsContext)
		}
	}

	return tst
}

func (s *Model_clauseContext) Cell_reference_options(i int) ICell_reference_optionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_reference_optionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICell_reference_optionsContext)
}

func (s *Model_clauseContext) Return_rows_clause() IReturn_rows_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_rows_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_rows_clauseContext)
}

func (s *Model_clauseContext) AllReference_model() []IReference_modelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReference_modelContext)(nil)).Elem())
	var tst = make([]IReference_modelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReference_modelContext)
		}
	}

	return tst
}

func (s *Model_clauseContext) Reference_model(i int) IReference_modelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_modelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReference_modelContext)
}

func (s *Model_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_clause(s)
	}
}

func (s *Model_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_clause(s)
	}
}

func (p *PlSqlParser) Model_clause() (localctx IModel_clauseContext) {
	localctx = NewModel_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, PlSqlParserRULE_model_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3553)
		p.Match(PlSqlParserMODEL)
	}
	p.SetState(3557)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserIGNORE || _la == PlSqlParserKEEP || _la == PlSqlParserUNIQUE {
		{
			p.SetState(3554)
			p.Cell_reference_options()
		}

		p.SetState(3559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3561)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserRETURN {
		{
			p.SetState(3560)
			p.Return_rows_clause()
		}

	}
	p.SetState(3566)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserREFERENCE {
		{
			p.SetState(3563)
			p.Reference_model()
		}

		p.SetState(3568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3569)
		p.Main_model()
	}

	return localctx
}

// ICell_reference_optionsContext is an interface to support dynamic dispatch.
type ICell_reference_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_reference_optionsContext differentiates from other interfaces.
	IsCell_reference_optionsContext()
}

type Cell_reference_optionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_reference_optionsContext() *Cell_reference_optionsContext {
	var p = new(Cell_reference_optionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cell_reference_options
	return p
}

func (*Cell_reference_optionsContext) IsCell_reference_optionsContext() {}

func NewCell_reference_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_reference_optionsContext {
	var p = new(Cell_reference_optionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cell_reference_options

	return p
}

func (s *Cell_reference_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_reference_optionsContext) NAV() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAV, 0)
}

func (s *Cell_reference_optionsContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIGNORE, 0)
}

func (s *Cell_reference_optionsContext) KEEP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserKEEP, 0)
}

func (s *Cell_reference_optionsContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNIQUE, 0)
}

func (s *Cell_reference_optionsContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDIMENSION, 0)
}

func (s *Cell_reference_optionsContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSINGLE, 0)
}

func (s *Cell_reference_optionsContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREFERENCE, 0)
}

func (s *Cell_reference_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_reference_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_reference_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCell_reference_options(s)
	}
}

func (s *Cell_reference_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCell_reference_options(s)
	}
}

func (p *PlSqlParser) Cell_reference_options() (localctx ICell_reference_optionsContext) {
	localctx = NewCell_reference_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, PlSqlParserRULE_cell_reference_options)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3579)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserIGNORE, PlSqlParserKEEP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3571)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserIGNORE || _la == PlSqlParserKEEP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3572)
			p.Match(PlSqlParserNAV)
		}

	case PlSqlParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3573)
			p.Match(PlSqlParserUNIQUE)
		}
		p.SetState(3577)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserDIMENSION:
			{
				p.SetState(3574)
				p.Match(PlSqlParserDIMENSION)
			}

		case PlSqlParserSINGLE:
			{
				p.SetState(3575)
				p.Match(PlSqlParserSINGLE)
			}
			{
				p.SetState(3576)
				p.Match(PlSqlParserREFERENCE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReturn_rows_clauseContext is an interface to support dynamic dispatch.
type IReturn_rows_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_rows_clauseContext differentiates from other interfaces.
	IsReturn_rows_clauseContext()
}

type Return_rows_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_rows_clauseContext() *Return_rows_clauseContext {
	var p = new(Return_rows_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_return_rows_clause
	return p
}

func (*Return_rows_clauseContext) IsReturn_rows_clauseContext() {}

func NewReturn_rows_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_rows_clauseContext {
	var p = new(Return_rows_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_return_rows_clause

	return p
}

func (s *Return_rows_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_rows_clauseContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Return_rows_clauseContext) ROWS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROWS, 0)
}

func (s *Return_rows_clauseContext) UPDATED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPDATED, 0)
}

func (s *Return_rows_clauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Return_rows_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_rows_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_rows_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterReturn_rows_clause(s)
	}
}

func (s *Return_rows_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitReturn_rows_clause(s)
	}
}

func (p *PlSqlParser) Return_rows_clause() (localctx IReturn_rows_clauseContext) {
	localctx = NewReturn_rows_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, PlSqlParserRULE_return_rows_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3581)
		p.Match(PlSqlParserRETURN)
	}
	{
		p.SetState(3582)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserALL || _la == PlSqlParserUPDATED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3583)
		p.Match(PlSqlParserROWS)
	}

	return localctx
}

// IReference_modelContext is an interface to support dynamic dispatch.
type IReference_modelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReference_modelContext differentiates from other interfaces.
	IsReference_modelContext()
}

type Reference_modelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReference_modelContext() *Reference_modelContext {
	var p = new(Reference_modelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_reference_model
	return p
}

func (*Reference_modelContext) IsReference_modelContext() {}

func NewReference_modelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reference_modelContext {
	var p = new(Reference_modelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_reference_model

	return p
}

func (s *Reference_modelContext) GetParser() antlr.Parser { return s.parser }

func (s *Reference_modelContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREFERENCE, 0)
}

func (s *Reference_modelContext) Reference_model_name() IReference_model_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_model_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_model_nameContext)
}

func (s *Reference_modelContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Reference_modelContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Reference_modelContext) Model_column_clauses() IModel_column_clausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_column_clausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_column_clausesContext)
}

func (s *Reference_modelContext) AllCell_reference_options() []ICell_reference_optionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICell_reference_optionsContext)(nil)).Elem())
	var tst = make([]ICell_reference_optionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICell_reference_optionsContext)
		}
	}

	return tst
}

func (s *Reference_modelContext) Cell_reference_options(i int) ICell_reference_optionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_reference_optionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICell_reference_optionsContext)
}

func (s *Reference_modelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reference_modelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reference_modelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterReference_model(s)
	}
}

func (s *Reference_modelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitReference_model(s)
	}
}

func (p *PlSqlParser) Reference_model() (localctx IReference_modelContext) {
	localctx = NewReference_modelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, PlSqlParserRULE_reference_model)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3585)
		p.Match(PlSqlParserREFERENCE)
	}
	{
		p.SetState(3586)
		p.Reference_model_name()
	}
	{
		p.SetState(3587)
		p.Match(PlSqlParserON)
	}
	{
		p.SetState(3588)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3589)
		p.Subquery()
	}
	{
		p.SetState(3590)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	{
		p.SetState(3591)
		p.Model_column_clauses()
	}
	p.SetState(3595)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserIGNORE || _la == PlSqlParserKEEP || _la == PlSqlParserUNIQUE {
		{
			p.SetState(3592)
			p.Cell_reference_options()
		}

		p.SetState(3597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMain_modelContext is an interface to support dynamic dispatch.
type IMain_modelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMain_modelContext differentiates from other interfaces.
	IsMain_modelContext()
}

type Main_modelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMain_modelContext() *Main_modelContext {
	var p = new(Main_modelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_main_model
	return p
}

func (*Main_modelContext) IsMain_modelContext() {}

func NewMain_modelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Main_modelContext {
	var p = new(Main_modelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_main_model

	return p
}

func (s *Main_modelContext) GetParser() antlr.Parser { return s.parser }

func (s *Main_modelContext) Model_column_clauses() IModel_column_clausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_column_clausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_column_clausesContext)
}

func (s *Main_modelContext) Model_rules_clause() IModel_rules_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_rules_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_rules_clauseContext)
}

func (s *Main_modelContext) MAIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAIN, 0)
}

func (s *Main_modelContext) Main_model_name() IMain_model_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMain_model_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMain_model_nameContext)
}

func (s *Main_modelContext) AllCell_reference_options() []ICell_reference_optionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICell_reference_optionsContext)(nil)).Elem())
	var tst = make([]ICell_reference_optionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICell_reference_optionsContext)
		}
	}

	return tst
}

func (s *Main_modelContext) Cell_reference_options(i int) ICell_reference_optionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_reference_optionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICell_reference_optionsContext)
}

func (s *Main_modelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Main_modelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Main_modelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMain_model(s)
	}
}

func (s *Main_modelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMain_model(s)
	}
}

func (p *PlSqlParser) Main_model() (localctx IMain_modelContext) {
	localctx = NewMain_modelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, PlSqlParserRULE_main_model)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3600)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserMAIN {
		{
			p.SetState(3598)
			p.Match(PlSqlParserMAIN)
		}
		{
			p.SetState(3599)
			p.Main_model_name()
		}

	}
	{
		p.SetState(3602)
		p.Model_column_clauses()
	}
	p.SetState(3606)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserIGNORE || _la == PlSqlParserKEEP || _la == PlSqlParserUNIQUE {
		{
			p.SetState(3603)
			p.Cell_reference_options()
		}

		p.SetState(3608)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3609)
		p.Model_rules_clause()
	}

	return localctx
}

// IModel_column_clausesContext is an interface to support dynamic dispatch.
type IModel_column_clausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_column_clausesContext differentiates from other interfaces.
	IsModel_column_clausesContext()
}

type Model_column_clausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_column_clausesContext() *Model_column_clausesContext {
	var p = new(Model_column_clausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_column_clauses
	return p
}

func (*Model_column_clausesContext) IsModel_column_clausesContext() {}

func NewModel_column_clausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_column_clausesContext {
	var p = new(Model_column_clausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_column_clauses

	return p
}

func (s *Model_column_clausesContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_column_clausesContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDIMENSION, 0)
}

func (s *Model_column_clausesContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Model_column_clausesContext) AllModel_column_list() []IModel_column_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModel_column_listContext)(nil)).Elem())
	var tst = make([]IModel_column_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModel_column_listContext)
		}
	}

	return tst
}

func (s *Model_column_clausesContext) Model_column_list(i int) IModel_column_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_column_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModel_column_listContext)
}

func (s *Model_column_clausesContext) MEASURES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEASURES, 0)
}

func (s *Model_column_clausesContext) Model_column_partition_part() IModel_column_partition_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_column_partition_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_column_partition_partContext)
}

func (s *Model_column_clausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_column_clausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_column_clausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_column_clauses(s)
	}
}

func (s *Model_column_clausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_column_clauses(s)
	}
}

func (p *PlSqlParser) Model_column_clauses() (localctx IModel_column_clausesContext) {
	localctx = NewModel_column_clausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, PlSqlParserRULE_model_column_clauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3612)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPARTITION {
		{
			p.SetState(3611)
			p.Model_column_partition_part()
		}

	}
	{
		p.SetState(3614)
		p.Match(PlSqlParserDIMENSION)
	}
	{
		p.SetState(3615)
		p.Match(PlSqlParserBY)
	}
	{
		p.SetState(3616)
		p.Model_column_list()
	}
	{
		p.SetState(3617)
		p.Match(PlSqlParserMEASURES)
	}
	{
		p.SetState(3618)
		p.Model_column_list()
	}

	return localctx
}

// IModel_column_partition_partContext is an interface to support dynamic dispatch.
type IModel_column_partition_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_column_partition_partContext differentiates from other interfaces.
	IsModel_column_partition_partContext()
}

type Model_column_partition_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_column_partition_partContext() *Model_column_partition_partContext {
	var p = new(Model_column_partition_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_column_partition_part
	return p
}

func (*Model_column_partition_partContext) IsModel_column_partition_partContext() {}

func NewModel_column_partition_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_column_partition_partContext {
	var p = new(Model_column_partition_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_column_partition_part

	return p
}

func (s *Model_column_partition_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_column_partition_partContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARTITION, 0)
}

func (s *Model_column_partition_partContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Model_column_partition_partContext) Model_column_list() IModel_column_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_column_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_column_listContext)
}

func (s *Model_column_partition_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_column_partition_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_column_partition_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_column_partition_part(s)
	}
}

func (s *Model_column_partition_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_column_partition_part(s)
	}
}

func (p *PlSqlParser) Model_column_partition_part() (localctx IModel_column_partition_partContext) {
	localctx = NewModel_column_partition_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, PlSqlParserRULE_model_column_partition_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3620)
		p.Match(PlSqlParserPARTITION)
	}
	{
		p.SetState(3621)
		p.Match(PlSqlParserBY)
	}
	{
		p.SetState(3622)
		p.Model_column_list()
	}

	return localctx
}

// IModel_column_listContext is an interface to support dynamic dispatch.
type IModel_column_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_column_listContext differentiates from other interfaces.
	IsModel_column_listContext()
}

type Model_column_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_column_listContext() *Model_column_listContext {
	var p = new(Model_column_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_column_list
	return p
}

func (*Model_column_listContext) IsModel_column_listContext() {}

func NewModel_column_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_column_listContext {
	var p = new(Model_column_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_column_list

	return p
}

func (s *Model_column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_column_listContext) AllModel_column() []IModel_columnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModel_columnContext)(nil)).Elem())
	var tst = make([]IModel_columnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModel_columnContext)
		}
	}

	return tst
}

func (s *Model_column_listContext) Model_column(i int) IModel_columnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_columnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModel_columnContext)
}

func (s *Model_column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_column_list(s)
	}
}

func (s *Model_column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_column_list(s)
	}
}

func (p *PlSqlParser) Model_column_list() (localctx IModel_column_listContext) {
	localctx = NewModel_column_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, PlSqlParserRULE_model_column_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3624)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3625)
		p.Model_column()
	}
	p.SetState(3630)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3626)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3627)
			p.Model_column()
		}

		p.SetState(3632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3633)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IModel_columnContext is an interface to support dynamic dispatch.
type IModel_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_columnContext differentiates from other interfaces.
	IsModel_columnContext()
}

type Model_columnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_columnContext() *Model_columnContext {
	var p = new(Model_columnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_column
	return p
}

func (*Model_columnContext) IsModel_columnContext() {}

func NewModel_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_columnContext {
	var p = new(Model_columnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_column

	return p
}

func (s *Model_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_columnContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Model_columnContext) Query_block() IQuery_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_blockContext)
}

func (s *Model_columnContext) Column_alias() IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Model_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_column(s)
	}
}

func (s *Model_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_column(s)
	}
}

func (p *PlSqlParser) Model_column() (localctx IModel_columnContext) {
	localctx = NewModel_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, PlSqlParserRULE_model_column)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3637)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALL, PlSqlParserANALYZE, PlSqlParserANY, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOALESCE, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONNECT_BY_ROOT, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDISTINCT, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXISTS, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFALSE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNOT, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPRIOR, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUE, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserDECODE, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserNVL, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROUND, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTO_CHAR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserLEAST, PlSqlParserGREATEST, PlSqlParserTO_DATE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserPLUS_SIGN, PlSqlParserMINUS_SIGN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(3635)
			p.Expression()
		}

	case PlSqlParserSELECT:
		{
			p.SetState(3636)
			p.Query_block()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserAS)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-521))|(1<<(PlSqlParserCHAR_STRING-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(3639)
			p.Column_alias()
		}

	}

	return localctx
}

// IModel_rules_clauseContext is an interface to support dynamic dispatch.
type IModel_rules_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_rules_clauseContext differentiates from other interfaces.
	IsModel_rules_clauseContext()
}

type Model_rules_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_rules_clauseContext() *Model_rules_clauseContext {
	var p = new(Model_rules_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_rules_clause
	return p
}

func (*Model_rules_clauseContext) IsModel_rules_clauseContext() {}

func NewModel_rules_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_rules_clauseContext {
	var p = new(Model_rules_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_rules_clause

	return p
}

func (s *Model_rules_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_rules_clauseContext) Model_rules_part() IModel_rules_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_rules_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_rules_partContext)
}

func (s *Model_rules_clauseContext) AllModel_rules_element() []IModel_rules_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModel_rules_elementContext)(nil)).Elem())
	var tst = make([]IModel_rules_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModel_rules_elementContext)
		}
	}

	return tst
}

func (s *Model_rules_clauseContext) Model_rules_element(i int) IModel_rules_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_rules_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModel_rules_elementContext)
}

func (s *Model_rules_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_rules_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_rules_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_rules_clause(s)
	}
}

func (s *Model_rules_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_rules_clause(s)
	}
}

func (p *PlSqlParser) Model_rules_clause() (localctx IModel_rules_clauseContext) {
	localctx = NewModel_rules_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, PlSqlParserRULE_model_rules_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3643)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserRULES {
		{
			p.SetState(3642)
			p.Model_rules_part()
		}

	}
	{
		p.SetState(3645)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(3654)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPDATE-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
		{
			p.SetState(3646)
			p.Model_rules_element()
		}
		p.SetState(3651)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3647)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3648)
				p.Model_rules_element()
			}

			p.SetState(3653)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3656)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IModel_rules_partContext is an interface to support dynamic dispatch.
type IModel_rules_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_rules_partContext differentiates from other interfaces.
	IsModel_rules_partContext()
}

type Model_rules_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_rules_partContext() *Model_rules_partContext {
	var p = new(Model_rules_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_rules_part
	return p
}

func (*Model_rules_partContext) IsModel_rules_partContext() {}

func NewModel_rules_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_rules_partContext {
	var p = new(Model_rules_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_rules_part

	return p
}

func (s *Model_rules_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_rules_partContext) RULES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRULES, 0)
}

func (s *Model_rules_partContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPDATE, 0)
}

func (s *Model_rules_partContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPSERT, 0)
}

func (s *Model_rules_partContext) ORDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORDER, 0)
}

func (s *Model_rules_partContext) Model_iterate_clause() IModel_iterate_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_iterate_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_iterate_clauseContext)
}

func (s *Model_rules_partContext) AUTOMATIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUTOMATIC, 0)
}

func (s *Model_rules_partContext) SEQUENTIAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEQUENTIAL, 0)
}

func (s *Model_rules_partContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Model_rules_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_rules_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_rules_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_rules_part(s)
	}
}

func (s *Model_rules_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_rules_part(s)
	}
}

func (p *PlSqlParser) Model_rules_part() (localctx IModel_rules_partContext) {
	localctx = NewModel_rules_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, PlSqlParserRULE_model_rules_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3658)
		p.Match(PlSqlParserRULES)
	}
	p.SetState(3664)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserUPDATE:
		{
			p.SetState(3659)
			p.Match(PlSqlParserUPDATE)
		}

	case PlSqlParserUPSERT:
		{
			p.SetState(3660)
			p.Match(PlSqlParserUPSERT)
		}
		p.SetState(3662)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserALL {
			{
				p.SetState(3661)
				p.Match(PlSqlParserALL)
			}

		}

	case PlSqlParserAUTOMATIC, PlSqlParserITERATE, PlSqlParserSEQUENTIAL, PlSqlParserLEFT_PAREN:

	default:
	}
	p.SetState(3668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAUTOMATIC || _la == PlSqlParserSEQUENTIAL {
		{
			p.SetState(3666)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserAUTOMATIC || _la == PlSqlParserSEQUENTIAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3667)
			p.Match(PlSqlParserORDER)
		}

	}
	p.SetState(3671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserITERATE {
		{
			p.SetState(3670)
			p.Model_iterate_clause()
		}

	}

	return localctx
}

// IModel_rules_elementContext is an interface to support dynamic dispatch.
type IModel_rules_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_rules_elementContext differentiates from other interfaces.
	IsModel_rules_elementContext()
}

type Model_rules_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_rules_elementContext() *Model_rules_elementContext {
	var p = new(Model_rules_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_rules_element
	return p
}

func (*Model_rules_elementContext) IsModel_rules_elementContext() {}

func NewModel_rules_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_rules_elementContext {
	var p = new(Model_rules_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_rules_element

	return p
}

func (s *Model_rules_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_rules_elementContext) Cell_assignment() ICell_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_assignmentContext)
}

func (s *Model_rules_elementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Model_rules_elementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPDATE, 0)
}

func (s *Model_rules_elementContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPSERT, 0)
}

func (s *Model_rules_elementContext) Order_by_clause() IOrder_by_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Model_rules_elementContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Model_rules_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_rules_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_rules_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_rules_element(s)
	}
}

func (s *Model_rules_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_rules_element(s)
	}
}

func (p *PlSqlParser) Model_rules_element() (localctx IModel_rules_elementContext) {
	localctx = NewModel_rules_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, PlSqlParserRULE_model_rules_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3678)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 427, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3673)
			p.Match(PlSqlParserUPDATE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 427, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3674)
			p.Match(PlSqlParserUPSERT)
		}
		p.SetState(3676)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 426, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3675)
				p.Match(PlSqlParserALL)
			}

		}

	}
	{
		p.SetState(3680)
		p.Cell_assignment()
	}
	p.SetState(3682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserORDER {
		{
			p.SetState(3681)
			p.Order_by_clause()
		}

	}
	{
		p.SetState(3684)
		p.Match(PlSqlParserEQUALS_OP)
	}
	{
		p.SetState(3685)
		p.Expression()
	}

	return localctx
}

// ICell_assignmentContext is an interface to support dynamic dispatch.
type ICell_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_assignmentContext differentiates from other interfaces.
	IsCell_assignmentContext()
}

type Cell_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_assignmentContext() *Cell_assignmentContext {
	var p = new(Cell_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cell_assignment
	return p
}

func (*Cell_assignmentContext) IsCell_assignmentContext() {}

func NewCell_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_assignmentContext {
	var p = new(Cell_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cell_assignment

	return p
}

func (s *Cell_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_assignmentContext) Model_expression() IModel_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_expressionContext)
}

func (s *Cell_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCell_assignment(s)
	}
}

func (s *Cell_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCell_assignment(s)
	}
}

func (p *PlSqlParser) Cell_assignment() (localctx ICell_assignmentContext) {
	localctx = NewCell_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, PlSqlParserRULE_cell_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3687)
		p.Model_expression()
	}

	return localctx
}

// IModel_iterate_clauseContext is an interface to support dynamic dispatch.
type IModel_iterate_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_iterate_clauseContext differentiates from other interfaces.
	IsModel_iterate_clauseContext()
}

type Model_iterate_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_iterate_clauseContext() *Model_iterate_clauseContext {
	var p = new(Model_iterate_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_iterate_clause
	return p
}

func (*Model_iterate_clauseContext) IsModel_iterate_clauseContext() {}

func NewModel_iterate_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_iterate_clauseContext {
	var p = new(Model_iterate_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_iterate_clause

	return p
}

func (s *Model_iterate_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_iterate_clauseContext) ITERATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserITERATE, 0)
}

func (s *Model_iterate_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Model_iterate_clauseContext) Until_part() IUntil_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUntil_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUntil_partContext)
}

func (s *Model_iterate_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_iterate_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_iterate_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_iterate_clause(s)
	}
}

func (s *Model_iterate_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_iterate_clause(s)
	}
}

func (p *PlSqlParser) Model_iterate_clause() (localctx IModel_iterate_clauseContext) {
	localctx = NewModel_iterate_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, PlSqlParserRULE_model_iterate_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3689)
		p.Match(PlSqlParserITERATE)
	}
	{
		p.SetState(3690)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3691)
		p.Expression()
	}
	{
		p.SetState(3692)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(3694)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserUNTIL {
		{
			p.SetState(3693)
			p.Until_part()
		}

	}

	return localctx
}

// IUntil_partContext is an interface to support dynamic dispatch.
type IUntil_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUntil_partContext differentiates from other interfaces.
	IsUntil_partContext()
}

type Until_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUntil_partContext() *Until_partContext {
	var p = new(Until_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_until_part
	return p
}

func (*Until_partContext) IsUntil_partContext() {}

func NewUntil_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Until_partContext {
	var p = new(Until_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_until_part

	return p
}

func (s *Until_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Until_partContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNTIL, 0)
}

func (s *Until_partContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Until_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Until_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Until_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUntil_part(s)
	}
}

func (s *Until_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUntil_part(s)
	}
}

func (p *PlSqlParser) Until_part() (localctx IUntil_partContext) {
	localctx = NewUntil_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, PlSqlParserRULE_until_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3696)
		p.Match(PlSqlParserUNTIL)
	}
	{
		p.SetState(3697)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3698)
		p.Condition()
	}
	{
		p.SetState(3699)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IOrder_by_clauseContext is an interface to support dynamic dispatch.
type IOrder_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrder_by_clauseContext differentiates from other interfaces.
	IsOrder_by_clauseContext()
}

type Order_by_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_clauseContext() *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_order_by_clause
	return p
}

func (*Order_by_clauseContext) IsOrder_by_clauseContext() {}

func NewOrder_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_order_by_clause

	return p
}

func (s *Order_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_clauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORDER, 0)
}

func (s *Order_by_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Order_by_clauseContext) AllOrder_by_elements() []IOrder_by_elementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrder_by_elementsContext)(nil)).Elem())
	var tst = make([]IOrder_by_elementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrder_by_elementsContext)
		}
	}

	return tst
}

func (s *Order_by_clauseContext) Order_by_elements(i int) IOrder_by_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_elementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_elementsContext)
}

func (s *Order_by_clauseContext) SIBLINGS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSIBLINGS, 0)
}

func (s *Order_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Order_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOrder_by_clause(s)
	}
}

func (s *Order_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOrder_by_clause(s)
	}
}

func (p *PlSqlParser) Order_by_clause() (localctx IOrder_by_clauseContext) {
	localctx = NewOrder_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, PlSqlParserRULE_order_by_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3701)
		p.Match(PlSqlParserORDER)
	}
	p.SetState(3703)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserSIBLINGS {
		{
			p.SetState(3702)
			p.Match(PlSqlParserSIBLINGS)
		}

	}
	{
		p.SetState(3705)
		p.Match(PlSqlParserBY)
	}
	{
		p.SetState(3706)
		p.Order_by_elements()
	}
	p.SetState(3711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3707)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3708)
			p.Order_by_elements()
		}

		p.SetState(3713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOrder_by_elementsContext is an interface to support dynamic dispatch.
type IOrder_by_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrder_by_elementsContext differentiates from other interfaces.
	IsOrder_by_elementsContext()
}

type Order_by_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_elementsContext() *Order_by_elementsContext {
	var p = new(Order_by_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_order_by_elements
	return p
}

func (*Order_by_elementsContext) IsOrder_by_elementsContext() {}

func NewOrder_by_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_elementsContext {
	var p = new(Order_by_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_order_by_elements

	return p
}

func (s *Order_by_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_elementsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Order_by_elementsContext) NULLS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULLS, 0)
}

func (s *Order_by_elementsContext) ASC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserASC, 0)
}

func (s *Order_by_elementsContext) DESC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDESC, 0)
}

func (s *Order_by_elementsContext) FIRST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFIRST, 0)
}

func (s *Order_by_elementsContext) LAST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLAST, 0)
}

func (s *Order_by_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Order_by_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOrder_by_elements(s)
	}
}

func (s *Order_by_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOrder_by_elements(s)
	}
}

func (p *PlSqlParser) Order_by_elements() (localctx IOrder_by_elementsContext) {
	localctx = NewOrder_by_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, PlSqlParserRULE_order_by_elements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3714)
		p.Expression()
	}
	p.SetState(3716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserASC || _la == PlSqlParserDESC {
		{
			p.SetState(3715)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserASC || _la == PlSqlParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNULLS {
		{
			p.SetState(3718)
			p.Match(PlSqlParserNULLS)
		}
		{
			p.SetState(3719)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserFIRST || _la == PlSqlParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IFor_update_clauseContext is an interface to support dynamic dispatch.
type IFor_update_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_update_clauseContext differentiates from other interfaces.
	IsFor_update_clauseContext()
}

type For_update_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_update_clauseContext() *For_update_clauseContext {
	var p = new(For_update_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_for_update_clause
	return p
}

func (*For_update_clauseContext) IsFor_update_clauseContext() {}

func NewFor_update_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_update_clauseContext {
	var p = new(For_update_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_for_update_clause

	return p
}

func (s *For_update_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *For_update_clauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *For_update_clauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPDATE, 0)
}

func (s *For_update_clauseContext) For_update_of_part() IFor_update_of_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_update_of_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_update_of_partContext)
}

func (s *For_update_clauseContext) For_update_options() IFor_update_optionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_update_optionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_update_optionsContext)
}

func (s *For_update_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_update_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_update_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFor_update_clause(s)
	}
}

func (s *For_update_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFor_update_clause(s)
	}
}

func (p *PlSqlParser) For_update_clause() (localctx IFor_update_clauseContext) {
	localctx = NewFor_update_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, PlSqlParserRULE_for_update_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3722)
		p.Match(PlSqlParserFOR)
	}
	{
		p.SetState(3723)
		p.Match(PlSqlParserUPDATE)
	}
	p.SetState(3725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserOF {
		{
			p.SetState(3724)
			p.For_update_of_part()
		}

	}
	p.SetState(3728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNOWAIT || _la == PlSqlParserSKIP_ || _la == PlSqlParserWAIT {
		{
			p.SetState(3727)
			p.For_update_options()
		}

	}

	return localctx
}

// IFor_update_of_partContext is an interface to support dynamic dispatch.
type IFor_update_of_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_update_of_partContext differentiates from other interfaces.
	IsFor_update_of_partContext()
}

type For_update_of_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_update_of_partContext() *For_update_of_partContext {
	var p = new(For_update_of_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_for_update_of_part
	return p
}

func (*For_update_of_partContext) IsFor_update_of_partContext() {}

func NewFor_update_of_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_update_of_partContext {
	var p = new(For_update_of_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_for_update_of_part

	return p
}

func (s *For_update_of_partContext) GetParser() antlr.Parser { return s.parser }

func (s *For_update_of_partContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *For_update_of_partContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *For_update_of_partContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *For_update_of_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_update_of_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_update_of_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFor_update_of_part(s)
	}
}

func (s *For_update_of_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFor_update_of_part(s)
	}
}

func (p *PlSqlParser) For_update_of_part() (localctx IFor_update_of_partContext) {
	localctx = NewFor_update_of_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, PlSqlParserRULE_for_update_of_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3730)
		p.Match(PlSqlParserOF)
	}
	{
		p.SetState(3731)
		p.Column_name()
	}
	p.SetState(3736)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3732)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3733)
			p.Column_name()
		}

		p.SetState(3738)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFor_update_optionsContext is an interface to support dynamic dispatch.
type IFor_update_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_update_optionsContext differentiates from other interfaces.
	IsFor_update_optionsContext()
}

type For_update_optionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_update_optionsContext() *For_update_optionsContext {
	var p = new(For_update_optionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_for_update_options
	return p
}

func (*For_update_optionsContext) IsFor_update_optionsContext() {}

func NewFor_update_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_update_optionsContext {
	var p = new(For_update_optionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_for_update_options

	return p
}

func (s *For_update_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *For_update_optionsContext) SKIP_() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSKIP_, 0)
}

func (s *For_update_optionsContext) LOCKED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOCKED, 0)
}

func (s *For_update_optionsContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOWAIT, 0)
}

func (s *For_update_optionsContext) WAIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWAIT, 0)
}

func (s *For_update_optionsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *For_update_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_update_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_update_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFor_update_options(s)
	}
}

func (s *For_update_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFor_update_options(s)
	}
}

func (p *PlSqlParser) For_update_options() (localctx IFor_update_optionsContext) {
	localctx = NewFor_update_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, PlSqlParserRULE_for_update_options)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3744)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserSKIP_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3739)
			p.Match(PlSqlParserSKIP_)
		}
		{
			p.SetState(3740)
			p.Match(PlSqlParserLOCKED)
		}

	case PlSqlParserNOWAIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3741)
			p.Match(PlSqlParserNOWAIT)
		}

	case PlSqlParserWAIT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3742)
			p.Match(PlSqlParserWAIT)
		}
		{
			p.SetState(3743)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUpdate_statementContext is an interface to support dynamic dispatch.
type IUpdate_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdate_statementContext differentiates from other interfaces.
	IsUpdate_statementContext()
}

type Update_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_statementContext() *Update_statementContext {
	var p = new(Update_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_update_statement
	return p
}

func (*Update_statementContext) IsUpdate_statementContext() {}

func NewUpdate_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_statementContext {
	var p = new(Update_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_update_statement

	return p
}

func (s *Update_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_statementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPDATE, 0)
}

func (s *Update_statementContext) General_table_ref() IGeneral_table_refContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_table_refContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_table_refContext)
}

func (s *Update_statementContext) Update_set_clause() IUpdate_set_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdate_set_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdate_set_clauseContext)
}

func (s *Update_statementContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Update_statementContext) Static_returning_clause() IStatic_returning_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatic_returning_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatic_returning_clauseContext)
}

func (s *Update_statementContext) Error_logging_clause() IError_logging_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_logging_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_logging_clauseContext)
}

func (s *Update_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUpdate_statement(s)
	}
}

func (s *Update_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUpdate_statement(s)
	}
}

func (p *PlSqlParser) Update_statement() (localctx IUpdate_statementContext) {
	localctx = NewUpdate_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, PlSqlParserRULE_update_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3746)
		p.Match(PlSqlParserUPDATE)
	}
	{
		p.SetState(3747)
		p.General_table_ref()
	}
	{
		p.SetState(3748)
		p.Update_set_clause()
	}
	p.SetState(3750)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWHERE {
		{
			p.SetState(3749)
			p.Where_clause()
		}

	}
	p.SetState(3753)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserRETURNING || _la == PlSqlParserRETURN {
		{
			p.SetState(3752)
			p.Static_returning_clause()
		}

	}
	p.SetState(3756)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLOG {
		{
			p.SetState(3755)
			p.Error_logging_clause()
		}

	}

	return localctx
}

// IUpdate_set_clauseContext is an interface to support dynamic dispatch.
type IUpdate_set_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdate_set_clauseContext differentiates from other interfaces.
	IsUpdate_set_clauseContext()
}

type Update_set_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_set_clauseContext() *Update_set_clauseContext {
	var p = new(Update_set_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_update_set_clause
	return p
}

func (*Update_set_clauseContext) IsUpdate_set_clauseContext() {}

func NewUpdate_set_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_set_clauseContext {
	var p = new(Update_set_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_update_set_clause

	return p
}

func (s *Update_set_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_set_clauseContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *Update_set_clauseContext) AllColumn_based_update_set_clause() []IColumn_based_update_set_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_based_update_set_clauseContext)(nil)).Elem())
	var tst = make([]IColumn_based_update_set_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_based_update_set_clauseContext)
		}
	}

	return tst
}

func (s *Update_set_clauseContext) Column_based_update_set_clause(i int) IColumn_based_update_set_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_based_update_set_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_based_update_set_clauseContext)
}

func (s *Update_set_clauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALUE, 0)
}

func (s *Update_set_clauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Update_set_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Update_set_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_set_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_set_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUpdate_set_clause(s)
	}
}

func (s *Update_set_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUpdate_set_clause(s)
	}
}

func (p *PlSqlParser) Update_set_clause() (localctx IUpdate_set_clauseContext) {
	localctx = NewUpdate_set_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, PlSqlParserRULE_update_set_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3758)
		p.Match(PlSqlParserSET)
	}
	p.SetState(3774)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 442, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3759)
			p.Column_based_update_set_clause()
		}
		p.SetState(3764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3760)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3761)
				p.Column_based_update_set_clause()
			}

			p.SetState(3766)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(3767)
			p.Match(PlSqlParserVALUE)
		}
		{
			p.SetState(3768)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3769)
			p.Identifier()
		}
		{
			p.SetState(3770)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		{
			p.SetState(3771)
			p.Match(PlSqlParserEQUALS_OP)
		}
		{
			p.SetState(3772)
			p.Expression()
		}

	}

	return localctx
}

// IColumn_based_update_set_clauseContext is an interface to support dynamic dispatch.
type IColumn_based_update_set_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumn_based_update_set_clauseContext differentiates from other interfaces.
	IsColumn_based_update_set_clauseContext()
}

type Column_based_update_set_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_based_update_set_clauseContext() *Column_based_update_set_clauseContext {
	var p = new(Column_based_update_set_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_column_based_update_set_clause
	return p
}

func (*Column_based_update_set_clauseContext) IsColumn_based_update_set_clauseContext() {}

func NewColumn_based_update_set_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_based_update_set_clauseContext {
	var p = new(Column_based_update_set_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_column_based_update_set_clause

	return p
}

func (s *Column_based_update_set_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_based_update_set_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Column_based_update_set_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_based_update_set_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Column_based_update_set_clauseContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Column_based_update_set_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_based_update_set_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_based_update_set_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterColumn_based_update_set_clause(s)
	}
}

func (s *Column_based_update_set_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitColumn_based_update_set_clause(s)
	}
}

func (p *PlSqlParser) Column_based_update_set_clause() (localctx IColumn_based_update_set_clauseContext) {
	localctx = NewColumn_based_update_set_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, PlSqlParserRULE_column_based_update_set_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3793)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3776)
			p.Column_name()
		}
		{
			p.SetState(3777)
			p.Match(PlSqlParserEQUALS_OP)
		}
		{
			p.SetState(3778)
			p.Expression()
		}

	case PlSqlParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3780)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3781)
			p.Column_name()
		}
		p.SetState(3786)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3782)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3783)
				p.Column_name()
			}

			p.SetState(3788)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3789)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		{
			p.SetState(3790)
			p.Match(PlSqlParserEQUALS_OP)
		}
		{
			p.SetState(3791)
			p.Subquery()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDelete_statementContext is an interface to support dynamic dispatch.
type IDelete_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelete_statementContext differentiates from other interfaces.
	IsDelete_statementContext()
}

type Delete_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_statementContext() *Delete_statementContext {
	var p = new(Delete_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_delete_statement
	return p
}

func (*Delete_statementContext) IsDelete_statementContext() {}

func NewDelete_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_statementContext {
	var p = new(Delete_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_delete_statement

	return p
}

func (s *Delete_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_statementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDELETE, 0)
}

func (s *Delete_statementContext) General_table_ref() IGeneral_table_refContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_table_refContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_table_refContext)
}

func (s *Delete_statementContext) FROM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFROM, 0)
}

func (s *Delete_statementContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Delete_statementContext) Static_returning_clause() IStatic_returning_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatic_returning_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatic_returning_clauseContext)
}

func (s *Delete_statementContext) Error_logging_clause() IError_logging_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_logging_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_logging_clauseContext)
}

func (s *Delete_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDelete_statement(s)
	}
}

func (s *Delete_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDelete_statement(s)
	}
}

func (p *PlSqlParser) Delete_statement() (localctx IDelete_statementContext) {
	localctx = NewDelete_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, PlSqlParserRULE_delete_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3795)
		p.Match(PlSqlParserDELETE)
	}
	p.SetState(3797)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserFROM {
		{
			p.SetState(3796)
			p.Match(PlSqlParserFROM)
		}

	}
	{
		p.SetState(3799)
		p.General_table_ref()
	}
	p.SetState(3801)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWHERE {
		{
			p.SetState(3800)
			p.Where_clause()
		}

	}
	p.SetState(3804)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserRETURNING || _la == PlSqlParserRETURN {
		{
			p.SetState(3803)
			p.Static_returning_clause()
		}

	}
	p.SetState(3807)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLOG {
		{
			p.SetState(3806)
			p.Error_logging_clause()
		}

	}

	return localctx
}

// IInsert_statementContext is an interface to support dynamic dispatch.
type IInsert_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsert_statementContext differentiates from other interfaces.
	IsInsert_statementContext()
}

type Insert_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_statementContext() *Insert_statementContext {
	var p = new(Insert_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_insert_statement
	return p
}

func (*Insert_statementContext) IsInsert_statementContext() {}

func NewInsert_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_statementContext {
	var p = new(Insert_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_insert_statement

	return p
}

func (s *Insert_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_statementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINSERT, 0)
}

func (s *Insert_statementContext) Single_table_insert() ISingle_table_insertContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_table_insertContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_table_insertContext)
}

func (s *Insert_statementContext) Multi_table_insert() IMulti_table_insertContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_table_insertContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_table_insertContext)
}

func (s *Insert_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterInsert_statement(s)
	}
}

func (s *Insert_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitInsert_statement(s)
	}
}

func (p *PlSqlParser) Insert_statement() (localctx IInsert_statementContext) {
	localctx = NewInsert_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, PlSqlParserRULE_insert_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3809)
		p.Match(PlSqlParserINSERT)
	}
	p.SetState(3812)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserINTO:
		{
			p.SetState(3810)
			p.Single_table_insert()
		}

	case PlSqlParserALL, PlSqlParserFIRST, PlSqlParserWHEN:
		{
			p.SetState(3811)
			p.Multi_table_insert()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISingle_table_insertContext is an interface to support dynamic dispatch.
type ISingle_table_insertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_table_insertContext differentiates from other interfaces.
	IsSingle_table_insertContext()
}

type Single_table_insertContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_table_insertContext() *Single_table_insertContext {
	var p = new(Single_table_insertContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_single_table_insert
	return p
}

func (*Single_table_insertContext) IsSingle_table_insertContext() {}

func NewSingle_table_insertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_table_insertContext {
	var p = new(Single_table_insertContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_single_table_insert

	return p
}

func (s *Single_table_insertContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_table_insertContext) Insert_into_clause() IInsert_into_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsert_into_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsert_into_clauseContext)
}

func (s *Single_table_insertContext) Values_clause() IValues_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValues_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValues_clauseContext)
}

func (s *Single_table_insertContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Single_table_insertContext) Error_logging_clause() IError_logging_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_logging_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_logging_clauseContext)
}

func (s *Single_table_insertContext) Static_returning_clause() IStatic_returning_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatic_returning_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatic_returning_clauseContext)
}

func (s *Single_table_insertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_table_insertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_table_insertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSingle_table_insert(s)
	}
}

func (s *Single_table_insertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSingle_table_insert(s)
	}
}

func (p *PlSqlParser) Single_table_insert() (localctx ISingle_table_insertContext) {
	localctx = NewSingle_table_insertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, PlSqlParserRULE_single_table_insert)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3814)
		p.Insert_into_clause()
	}
	p.SetState(3820)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserVALUES:
		{
			p.SetState(3815)
			p.Values_clause()
		}
		p.SetState(3817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserRETURNING || _la == PlSqlParserRETURN {
			{
				p.SetState(3816)
				p.Static_returning_clause()
			}

		}

	case PlSqlParserSELECT, PlSqlParserWITH, PlSqlParserLEFT_PAREN:
		{
			p.SetState(3819)
			p.Select_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3823)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLOG {
		{
			p.SetState(3822)
			p.Error_logging_clause()
		}

	}

	return localctx
}

// IMulti_table_insertContext is an interface to support dynamic dispatch.
type IMulti_table_insertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_table_insertContext differentiates from other interfaces.
	IsMulti_table_insertContext()
}

type Multi_table_insertContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_table_insertContext() *Multi_table_insertContext {
	var p = new(Multi_table_insertContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_multi_table_insert
	return p
}

func (*Multi_table_insertContext) IsMulti_table_insertContext() {}

func NewMulti_table_insertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_table_insertContext {
	var p = new(Multi_table_insertContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_multi_table_insert

	return p
}

func (s *Multi_table_insertContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_table_insertContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Multi_table_insertContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Multi_table_insertContext) Conditional_insert_clause() IConditional_insert_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_insert_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_insert_clauseContext)
}

func (s *Multi_table_insertContext) AllMulti_table_element() []IMulti_table_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMulti_table_elementContext)(nil)).Elem())
	var tst = make([]IMulti_table_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMulti_table_elementContext)
		}
	}

	return tst
}

func (s *Multi_table_insertContext) Multi_table_element(i int) IMulti_table_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_table_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMulti_table_elementContext)
}

func (s *Multi_table_insertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_table_insertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_table_insertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMulti_table_insert(s)
	}
}

func (s *Multi_table_insertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMulti_table_insert(s)
	}
}

func (p *PlSqlParser) Multi_table_insert() (localctx IMulti_table_insertContext) {
	localctx = NewMulti_table_insertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, PlSqlParserRULE_multi_table_insert)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3832)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 454, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3825)
			p.Match(PlSqlParserALL)
		}
		p.SetState(3827)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PlSqlParserINTO {
			{
				p.SetState(3826)
				p.Multi_table_element()
			}

			p.SetState(3829)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(3831)
			p.Conditional_insert_clause()
		}

	}
	{
		p.SetState(3834)
		p.Select_statement()
	}

	return localctx
}

// IMulti_table_elementContext is an interface to support dynamic dispatch.
type IMulti_table_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_table_elementContext differentiates from other interfaces.
	IsMulti_table_elementContext()
}

type Multi_table_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_table_elementContext() *Multi_table_elementContext {
	var p = new(Multi_table_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_multi_table_element
	return p
}

func (*Multi_table_elementContext) IsMulti_table_elementContext() {}

func NewMulti_table_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_table_elementContext {
	var p = new(Multi_table_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_multi_table_element

	return p
}

func (s *Multi_table_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_table_elementContext) Insert_into_clause() IInsert_into_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsert_into_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsert_into_clauseContext)
}

func (s *Multi_table_elementContext) Values_clause() IValues_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValues_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValues_clauseContext)
}

func (s *Multi_table_elementContext) Error_logging_clause() IError_logging_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_logging_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_logging_clauseContext)
}

func (s *Multi_table_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_table_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_table_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMulti_table_element(s)
	}
}

func (s *Multi_table_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMulti_table_element(s)
	}
}

func (p *PlSqlParser) Multi_table_element() (localctx IMulti_table_elementContext) {
	localctx = NewMulti_table_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, PlSqlParserRULE_multi_table_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3836)
		p.Insert_into_clause()
	}
	p.SetState(3838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserVALUES {
		{
			p.SetState(3837)
			p.Values_clause()
		}

	}
	p.SetState(3841)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLOG {
		{
			p.SetState(3840)
			p.Error_logging_clause()
		}

	}

	return localctx
}

// IConditional_insert_clauseContext is an interface to support dynamic dispatch.
type IConditional_insert_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_insert_clauseContext differentiates from other interfaces.
	IsConditional_insert_clauseContext()
}

type Conditional_insert_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_insert_clauseContext() *Conditional_insert_clauseContext {
	var p = new(Conditional_insert_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_conditional_insert_clause
	return p
}

func (*Conditional_insert_clauseContext) IsConditional_insert_clauseContext() {}

func NewConditional_insert_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_insert_clauseContext {
	var p = new(Conditional_insert_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_conditional_insert_clause

	return p
}

func (s *Conditional_insert_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_insert_clauseContext) AllConditional_insert_when_part() []IConditional_insert_when_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditional_insert_when_partContext)(nil)).Elem())
	var tst = make([]IConditional_insert_when_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditional_insert_when_partContext)
		}
	}

	return tst
}

func (s *Conditional_insert_clauseContext) Conditional_insert_when_part(i int) IConditional_insert_when_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_insert_when_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditional_insert_when_partContext)
}

func (s *Conditional_insert_clauseContext) Conditional_insert_else_part() IConditional_insert_else_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_insert_else_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_insert_else_partContext)
}

func (s *Conditional_insert_clauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Conditional_insert_clauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFIRST, 0)
}

func (s *Conditional_insert_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_insert_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_insert_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterConditional_insert_clause(s)
	}
}

func (s *Conditional_insert_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitConditional_insert_clause(s)
	}
}

func (p *PlSqlParser) Conditional_insert_clause() (localctx IConditional_insert_clauseContext) {
	localctx = NewConditional_insert_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, PlSqlParserRULE_conditional_insert_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3844)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserALL || _la == PlSqlParserFIRST {
		{
			p.SetState(3843)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserALL || _la == PlSqlParserFIRST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PlSqlParserWHEN {
		{
			p.SetState(3846)
			p.Conditional_insert_when_part()
		}

		p.SetState(3849)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3852)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserELSE {
		{
			p.SetState(3851)
			p.Conditional_insert_else_part()
		}

	}

	return localctx
}

// IConditional_insert_when_partContext is an interface to support dynamic dispatch.
type IConditional_insert_when_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_insert_when_partContext differentiates from other interfaces.
	IsConditional_insert_when_partContext()
}

type Conditional_insert_when_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_insert_when_partContext() *Conditional_insert_when_partContext {
	var p = new(Conditional_insert_when_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_conditional_insert_when_part
	return p
}

func (*Conditional_insert_when_partContext) IsConditional_insert_when_partContext() {}

func NewConditional_insert_when_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_insert_when_partContext {
	var p = new(Conditional_insert_when_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_conditional_insert_when_part

	return p
}

func (s *Conditional_insert_when_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_insert_when_partContext) WHEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHEN, 0)
}

func (s *Conditional_insert_when_partContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Conditional_insert_when_partContext) THEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTHEN, 0)
}

func (s *Conditional_insert_when_partContext) AllMulti_table_element() []IMulti_table_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMulti_table_elementContext)(nil)).Elem())
	var tst = make([]IMulti_table_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMulti_table_elementContext)
		}
	}

	return tst
}

func (s *Conditional_insert_when_partContext) Multi_table_element(i int) IMulti_table_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_table_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMulti_table_elementContext)
}

func (s *Conditional_insert_when_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_insert_when_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_insert_when_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterConditional_insert_when_part(s)
	}
}

func (s *Conditional_insert_when_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitConditional_insert_when_part(s)
	}
}

func (p *PlSqlParser) Conditional_insert_when_part() (localctx IConditional_insert_when_partContext) {
	localctx = NewConditional_insert_when_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, PlSqlParserRULE_conditional_insert_when_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3854)
		p.Match(PlSqlParserWHEN)
	}
	{
		p.SetState(3855)
		p.Condition()
	}
	{
		p.SetState(3856)
		p.Match(PlSqlParserTHEN)
	}
	p.SetState(3858)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PlSqlParserINTO {
		{
			p.SetState(3857)
			p.Multi_table_element()
		}

		p.SetState(3860)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConditional_insert_else_partContext is an interface to support dynamic dispatch.
type IConditional_insert_else_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_insert_else_partContext differentiates from other interfaces.
	IsConditional_insert_else_partContext()
}

type Conditional_insert_else_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_insert_else_partContext() *Conditional_insert_else_partContext {
	var p = new(Conditional_insert_else_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_conditional_insert_else_part
	return p
}

func (*Conditional_insert_else_partContext) IsConditional_insert_else_partContext() {}

func NewConditional_insert_else_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_insert_else_partContext {
	var p = new(Conditional_insert_else_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_conditional_insert_else_part

	return p
}

func (s *Conditional_insert_else_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_insert_else_partContext) ELSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserELSE, 0)
}

func (s *Conditional_insert_else_partContext) AllMulti_table_element() []IMulti_table_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMulti_table_elementContext)(nil)).Elem())
	var tst = make([]IMulti_table_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMulti_table_elementContext)
		}
	}

	return tst
}

func (s *Conditional_insert_else_partContext) Multi_table_element(i int) IMulti_table_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_table_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMulti_table_elementContext)
}

func (s *Conditional_insert_else_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_insert_else_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_insert_else_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterConditional_insert_else_part(s)
	}
}

func (s *Conditional_insert_else_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitConditional_insert_else_part(s)
	}
}

func (p *PlSqlParser) Conditional_insert_else_part() (localctx IConditional_insert_else_partContext) {
	localctx = NewConditional_insert_else_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, PlSqlParserRULE_conditional_insert_else_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3862)
		p.Match(PlSqlParserELSE)
	}
	p.SetState(3864)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PlSqlParserINTO {
		{
			p.SetState(3863)
			p.Multi_table_element()
		}

		p.SetState(3866)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInsert_into_clauseContext is an interface to support dynamic dispatch.
type IInsert_into_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsert_into_clauseContext differentiates from other interfaces.
	IsInsert_into_clauseContext()
}

type Insert_into_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_into_clauseContext() *Insert_into_clauseContext {
	var p = new(Insert_into_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_insert_into_clause
	return p
}

func (*Insert_into_clauseContext) IsInsert_into_clauseContext() {}

func NewInsert_into_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_into_clauseContext {
	var p = new(Insert_into_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_insert_into_clause

	return p
}

func (s *Insert_into_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_into_clauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTO, 0)
}

func (s *Insert_into_clauseContext) General_table_ref() IGeneral_table_refContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_table_refContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_table_refContext)
}

func (s *Insert_into_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Insert_into_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Insert_into_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_into_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_into_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterInsert_into_clause(s)
	}
}

func (s *Insert_into_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitInsert_into_clause(s)
	}
}

func (p *PlSqlParser) Insert_into_clause() (localctx IInsert_into_clauseContext) {
	localctx = NewInsert_into_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, PlSqlParserRULE_insert_into_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3868)
		p.Match(PlSqlParserINTO)
	}
	{
		p.SetState(3869)
		p.General_table_ref()
	}
	p.SetState(3881)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 463, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3870)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3871)
			p.Column_name()
		}
		p.SetState(3876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3872)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3873)
				p.Column_name()
			}

			p.SetState(3878)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3879)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}

	return localctx
}

// IValues_clauseContext is an interface to support dynamic dispatch.
type IValues_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValues_clauseContext differentiates from other interfaces.
	IsValues_clauseContext()
}

type Values_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_clauseContext() *Values_clauseContext {
	var p = new(Values_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_values_clause
	return p
}

func (*Values_clauseContext) IsValues_clauseContext() {}

func NewValues_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_clauseContext {
	var p = new(Values_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_values_clause

	return p
}

func (s *Values_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_clauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALUES, 0)
}

func (s *Values_clauseContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Values_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Values_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterValues_clause(s)
	}
}

func (s *Values_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitValues_clause(s)
	}
}

func (p *PlSqlParser) Values_clause() (localctx IValues_clauseContext) {
	localctx = NewValues_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, PlSqlParserRULE_values_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3883)
		p.Match(PlSqlParserVALUES)
	}
	{
		p.SetState(3884)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(3886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
		{
			p.SetState(3885)
			p.Expressions()
		}

	}
	{
		p.SetState(3888)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IMerge_statementContext is an interface to support dynamic dispatch.
type IMerge_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMerge_statementContext differentiates from other interfaces.
	IsMerge_statementContext()
}

type Merge_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_statementContext() *Merge_statementContext {
	var p = new(Merge_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_merge_statement
	return p
}

func (*Merge_statementContext) IsMerge_statementContext() {}

func NewMerge_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_statementContext {
	var p = new(Merge_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_merge_statement

	return p
}

func (s *Merge_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_statementContext) MERGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMERGE, 0)
}

func (s *Merge_statementContext) INTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTO, 0)
}

func (s *Merge_statementContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Merge_statementContext) USING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSING, 0)
}

func (s *Merge_statementContext) Selected_tableview() ISelected_tableviewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_tableviewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_tableviewContext)
}

func (s *Merge_statementContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Merge_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Merge_statementContext) Table_alias() ITable_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_aliasContext)
}

func (s *Merge_statementContext) Merge_update_clause() IMerge_update_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMerge_update_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMerge_update_clauseContext)
}

func (s *Merge_statementContext) Merge_insert_clause() IMerge_insert_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMerge_insert_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMerge_insert_clauseContext)
}

func (s *Merge_statementContext) Error_logging_clause() IError_logging_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_logging_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_logging_clauseContext)
}

func (s *Merge_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMerge_statement(s)
	}
}

func (s *Merge_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMerge_statement(s)
	}
}

func (p *PlSqlParser) Merge_statement() (localctx IMerge_statementContext) {
	localctx = NewMerge_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, PlSqlParserRULE_merge_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3890)
		p.Match(PlSqlParserMERGE)
	}
	{
		p.SetState(3891)
		p.Match(PlSqlParserINTO)
	}
	{
		p.SetState(3892)
		p.Tableview_name()
	}
	p.SetState(3894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-521))|(1<<(PlSqlParserCHAR_STRING-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(3893)
			p.Table_alias()
		}

	}
	{
		p.SetState(3896)
		p.Match(PlSqlParserUSING)
	}
	{
		p.SetState(3897)
		p.Selected_tableview()
	}
	{
		p.SetState(3898)
		p.Match(PlSqlParserON)
	}
	{
		p.SetState(3899)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(3900)
		p.Condition()
	}
	{
		p.SetState(3901)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(3910)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 468, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3902)
			p.Merge_update_clause()
		}
		p.SetState(3904)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserWHEN {
			{
				p.SetState(3903)
				p.Merge_insert_clause()
			}

		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 468, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3906)
			p.Merge_insert_clause()
		}
		p.SetState(3908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserWHEN {
			{
				p.SetState(3907)
				p.Merge_update_clause()
			}

		}

	}
	p.SetState(3913)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLOG {
		{
			p.SetState(3912)
			p.Error_logging_clause()
		}

	}

	return localctx
}

// IMerge_update_clauseContext is an interface to support dynamic dispatch.
type IMerge_update_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMerge_update_clauseContext differentiates from other interfaces.
	IsMerge_update_clauseContext()
}

type Merge_update_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_update_clauseContext() *Merge_update_clauseContext {
	var p = new(Merge_update_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_merge_update_clause
	return p
}

func (*Merge_update_clauseContext) IsMerge_update_clauseContext() {}

func NewMerge_update_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_update_clauseContext {
	var p = new(Merge_update_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_merge_update_clause

	return p
}

func (s *Merge_update_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_update_clauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHEN, 0)
}

func (s *Merge_update_clauseContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMATCHED, 0)
}

func (s *Merge_update_clauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTHEN, 0)
}

func (s *Merge_update_clauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPDATE, 0)
}

func (s *Merge_update_clauseContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *Merge_update_clauseContext) AllMerge_element() []IMerge_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMerge_elementContext)(nil)).Elem())
	var tst = make([]IMerge_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMerge_elementContext)
		}
	}

	return tst
}

func (s *Merge_update_clauseContext) Merge_element(i int) IMerge_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMerge_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMerge_elementContext)
}

func (s *Merge_update_clauseContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Merge_update_clauseContext) Merge_update_delete_part() IMerge_update_delete_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMerge_update_delete_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMerge_update_delete_partContext)
}

func (s *Merge_update_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_update_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_update_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMerge_update_clause(s)
	}
}

func (s *Merge_update_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMerge_update_clause(s)
	}
}

func (p *PlSqlParser) Merge_update_clause() (localctx IMerge_update_clauseContext) {
	localctx = NewMerge_update_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, PlSqlParserRULE_merge_update_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3915)
		p.Match(PlSqlParserWHEN)
	}
	{
		p.SetState(3916)
		p.Match(PlSqlParserMATCHED)
	}
	{
		p.SetState(3917)
		p.Match(PlSqlParserTHEN)
	}
	{
		p.SetState(3918)
		p.Match(PlSqlParserUPDATE)
	}
	{
		p.SetState(3919)
		p.Match(PlSqlParserSET)
	}
	{
		p.SetState(3920)
		p.Merge_element()
	}
	p.SetState(3925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3921)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3922)
			p.Merge_element()
		}

		p.SetState(3927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3929)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWHERE {
		{
			p.SetState(3928)
			p.Where_clause()
		}

	}
	p.SetState(3932)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 472, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3931)
			p.Merge_update_delete_part()
		}

	}

	return localctx
}

// IMerge_elementContext is an interface to support dynamic dispatch.
type IMerge_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMerge_elementContext differentiates from other interfaces.
	IsMerge_elementContext()
}

type Merge_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_elementContext() *Merge_elementContext {
	var p = new(Merge_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_merge_element
	return p
}

func (*Merge_elementContext) IsMerge_elementContext() {}

func NewMerge_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_elementContext {
	var p = new(Merge_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_merge_element

	return p
}

func (s *Merge_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_elementContext) Column_name() IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Merge_elementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Merge_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMerge_element(s)
	}
}

func (s *Merge_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMerge_element(s)
	}
}

func (p *PlSqlParser) Merge_element() (localctx IMerge_elementContext) {
	localctx = NewMerge_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, PlSqlParserRULE_merge_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3934)
		p.Column_name()
	}
	{
		p.SetState(3935)
		p.Match(PlSqlParserEQUALS_OP)
	}
	{
		p.SetState(3936)
		p.Expression()
	}

	return localctx
}

// IMerge_update_delete_partContext is an interface to support dynamic dispatch.
type IMerge_update_delete_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMerge_update_delete_partContext differentiates from other interfaces.
	IsMerge_update_delete_partContext()
}

type Merge_update_delete_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_update_delete_partContext() *Merge_update_delete_partContext {
	var p = new(Merge_update_delete_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_merge_update_delete_part
	return p
}

func (*Merge_update_delete_partContext) IsMerge_update_delete_partContext() {}

func NewMerge_update_delete_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_update_delete_partContext {
	var p = new(Merge_update_delete_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_merge_update_delete_part

	return p
}

func (s *Merge_update_delete_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_update_delete_partContext) DELETE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDELETE, 0)
}

func (s *Merge_update_delete_partContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Merge_update_delete_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_update_delete_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_update_delete_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMerge_update_delete_part(s)
	}
}

func (s *Merge_update_delete_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMerge_update_delete_part(s)
	}
}

func (p *PlSqlParser) Merge_update_delete_part() (localctx IMerge_update_delete_partContext) {
	localctx = NewMerge_update_delete_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, PlSqlParserRULE_merge_update_delete_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3938)
		p.Match(PlSqlParserDELETE)
	}
	{
		p.SetState(3939)
		p.Where_clause()
	}

	return localctx
}

// IMerge_insert_clauseContext is an interface to support dynamic dispatch.
type IMerge_insert_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMerge_insert_clauseContext differentiates from other interfaces.
	IsMerge_insert_clauseContext()
}

type Merge_insert_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_insert_clauseContext() *Merge_insert_clauseContext {
	var p = new(Merge_insert_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_merge_insert_clause
	return p
}

func (*Merge_insert_clauseContext) IsMerge_insert_clauseContext() {}

func NewMerge_insert_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_insert_clauseContext {
	var p = new(Merge_insert_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_merge_insert_clause

	return p
}

func (s *Merge_insert_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_insert_clauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHEN, 0)
}

func (s *Merge_insert_clauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Merge_insert_clauseContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMATCHED, 0)
}

func (s *Merge_insert_clauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTHEN, 0)
}

func (s *Merge_insert_clauseContext) INSERT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINSERT, 0)
}

func (s *Merge_insert_clauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALUES, 0)
}

func (s *Merge_insert_clauseContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Merge_insert_clauseContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Merge_insert_clauseContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Merge_insert_clauseContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Merge_insert_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_insert_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_insert_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMerge_insert_clause(s)
	}
}

func (s *Merge_insert_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMerge_insert_clause(s)
	}
}

func (p *PlSqlParser) Merge_insert_clause() (localctx IMerge_insert_clauseContext) {
	localctx = NewMerge_insert_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, PlSqlParserRULE_merge_insert_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3941)
		p.Match(PlSqlParserWHEN)
	}
	{
		p.SetState(3942)
		p.Match(PlSqlParserNOT)
	}
	{
		p.SetState(3943)
		p.Match(PlSqlParserMATCHED)
	}
	{
		p.SetState(3944)
		p.Match(PlSqlParserTHEN)
	}
	{
		p.SetState(3945)
		p.Match(PlSqlParserINSERT)
	}
	p.SetState(3957)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserLEFT_PAREN {
		{
			p.SetState(3946)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3947)
			p.Column_name()
		}
		p.SetState(3952)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(3948)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(3949)
				p.Column_name()
			}

			p.SetState(3954)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3955)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(3959)
		p.Match(PlSqlParserVALUES)
	}
	{
		p.SetState(3960)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(3962)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
		{
			p.SetState(3961)
			p.Expressions()
		}

	}
	{
		p.SetState(3964)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(3966)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserWHERE {
		{
			p.SetState(3965)
			p.Where_clause()
		}

	}

	return localctx
}

// ISelected_tableviewContext is an interface to support dynamic dispatch.
type ISelected_tableviewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelected_tableviewContext differentiates from other interfaces.
	IsSelected_tableviewContext()
}

type Selected_tableviewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelected_tableviewContext() *Selected_tableviewContext {
	var p = new(Selected_tableviewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_selected_tableview
	return p
}

func (*Selected_tableviewContext) IsSelected_tableviewContext() {}

func NewSelected_tableviewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selected_tableviewContext {
	var p = new(Selected_tableviewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_selected_tableview

	return p
}

func (s *Selected_tableviewContext) GetParser() antlr.Parser { return s.parser }

func (s *Selected_tableviewContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Selected_tableviewContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Selected_tableviewContext) Table_alias() ITable_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_aliasContext)
}

func (s *Selected_tableviewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selected_tableviewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selected_tableviewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSelected_tableview(s)
	}
}

func (s *Selected_tableviewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSelected_tableview(s)
	}
}

func (p *PlSqlParser) Selected_tableview() (localctx ISelected_tableviewContext) {
	localctx = NewSelected_tableviewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, PlSqlParserRULE_selected_tableview)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3973)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(3968)
			p.Tableview_name()
		}

	case PlSqlParserLEFT_PAREN:
		{
			p.SetState(3969)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(3970)
			p.Select_statement()
		}
		{
			p.SetState(3971)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-521))|(1<<(PlSqlParserCHAR_STRING-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(3975)
			p.Table_alias()
		}

	}

	return localctx
}

// ILock_table_statementContext is an interface to support dynamic dispatch.
type ILock_table_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLock_table_statementContext differentiates from other interfaces.
	IsLock_table_statementContext()
}

type Lock_table_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_table_statementContext() *Lock_table_statementContext {
	var p = new(Lock_table_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_lock_table_statement
	return p
}

func (*Lock_table_statementContext) IsLock_table_statementContext() {}

func NewLock_table_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_table_statementContext {
	var p = new(Lock_table_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_lock_table_statement

	return p
}

func (s *Lock_table_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_table_statementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOCK, 0)
}

func (s *Lock_table_statementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Lock_table_statementContext) AllLock_table_element() []ILock_table_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILock_table_elementContext)(nil)).Elem())
	var tst = make([]ILock_table_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILock_table_elementContext)
		}
	}

	return tst
}

func (s *Lock_table_statementContext) Lock_table_element(i int) ILock_table_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILock_table_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILock_table_elementContext)
}

func (s *Lock_table_statementContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Lock_table_statementContext) Lock_mode() ILock_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILock_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILock_modeContext)
}

func (s *Lock_table_statementContext) MODE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMODE, 0)
}

func (s *Lock_table_statementContext) Wait_nowait_part() IWait_nowait_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWait_nowait_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWait_nowait_partContext)
}

func (s *Lock_table_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_table_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_table_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterLock_table_statement(s)
	}
}

func (s *Lock_table_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitLock_table_statement(s)
	}
}

func (p *PlSqlParser) Lock_table_statement() (localctx ILock_table_statementContext) {
	localctx = NewLock_table_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, PlSqlParserRULE_lock_table_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3978)
		p.Match(PlSqlParserLOCK)
	}
	{
		p.SetState(3979)
		p.Match(PlSqlParserTABLE)
	}
	{
		p.SetState(3980)
		p.Lock_table_element()
	}
	p.SetState(3985)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(3981)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(3982)
			p.Lock_table_element()
		}

		p.SetState(3987)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3988)
		p.Match(PlSqlParserIN)
	}
	{
		p.SetState(3989)
		p.Lock_mode()
	}
	{
		p.SetState(3990)
		p.Match(PlSqlParserMODE)
	}
	p.SetState(3992)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserNOWAIT || _la == PlSqlParserWAIT {
		{
			p.SetState(3991)
			p.Wait_nowait_part()
		}

	}

	return localctx
}

// IWait_nowait_partContext is an interface to support dynamic dispatch.
type IWait_nowait_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWait_nowait_partContext differentiates from other interfaces.
	IsWait_nowait_partContext()
}

type Wait_nowait_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWait_nowait_partContext() *Wait_nowait_partContext {
	var p = new(Wait_nowait_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_wait_nowait_part
	return p
}

func (*Wait_nowait_partContext) IsWait_nowait_partContext() {}

func NewWait_nowait_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wait_nowait_partContext {
	var p = new(Wait_nowait_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_wait_nowait_part

	return p
}

func (s *Wait_nowait_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Wait_nowait_partContext) WAIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWAIT, 0)
}

func (s *Wait_nowait_partContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Wait_nowait_partContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOWAIT, 0)
}

func (s *Wait_nowait_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wait_nowait_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wait_nowait_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterWait_nowait_part(s)
	}
}

func (s *Wait_nowait_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitWait_nowait_part(s)
	}
}

func (p *PlSqlParser) Wait_nowait_part() (localctx IWait_nowait_partContext) {
	localctx = NewWait_nowait_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, PlSqlParserRULE_wait_nowait_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3997)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserWAIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3994)
			p.Match(PlSqlParserWAIT)
		}
		{
			p.SetState(3995)
			p.Expression()
		}

	case PlSqlParserNOWAIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3996)
			p.Match(PlSqlParserNOWAIT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILock_table_elementContext is an interface to support dynamic dispatch.
type ILock_table_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLock_table_elementContext differentiates from other interfaces.
	IsLock_table_elementContext()
}

type Lock_table_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_table_elementContext() *Lock_table_elementContext {
	var p = new(Lock_table_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_lock_table_element
	return p
}

func (*Lock_table_elementContext) IsLock_table_elementContext() {}

func NewLock_table_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_table_elementContext {
	var p = new(Lock_table_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_lock_table_element

	return p
}

func (s *Lock_table_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_table_elementContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Lock_table_elementContext) Partition_extension_clause() IPartition_extension_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartition_extension_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartition_extension_clauseContext)
}

func (s *Lock_table_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_table_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_table_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterLock_table_element(s)
	}
}

func (s *Lock_table_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitLock_table_element(s)
	}
}

func (p *PlSqlParser) Lock_table_element() (localctx ILock_table_elementContext) {
	localctx = NewLock_table_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, PlSqlParserRULE_lock_table_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3999)
		p.Tableview_name()
	}
	p.SetState(4001)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPARTITION || _la == PlSqlParserSUBPARTITION {
		{
			p.SetState(4000)
			p.Partition_extension_clause()
		}

	}

	return localctx
}

// ILock_modeContext is an interface to support dynamic dispatch.
type ILock_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLock_modeContext differentiates from other interfaces.
	IsLock_modeContext()
}

type Lock_modeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_modeContext() *Lock_modeContext {
	var p = new(Lock_modeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_lock_mode
	return p
}

func (*Lock_modeContext) IsLock_modeContext() {}

func NewLock_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_modeContext {
	var p = new(Lock_modeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_lock_mode

	return p
}

func (s *Lock_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_modeContext) ROW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROW, 0)
}

func (s *Lock_modeContext) SHARE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSHARE, 0)
}

func (s *Lock_modeContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCLUSIVE, 0)
}

func (s *Lock_modeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPDATE, 0)
}

func (s *Lock_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterLock_mode(s)
	}
}

func (s *Lock_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitLock_mode(s)
	}
}

func (p *PlSqlParser) Lock_mode() (localctx ILock_modeContext) {
	localctx = NewLock_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, PlSqlParserRULE_lock_mode)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4015)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 484, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4003)
			p.Match(PlSqlParserROW)
		}
		{
			p.SetState(4004)
			p.Match(PlSqlParserSHARE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4005)
			p.Match(PlSqlParserROW)
		}
		{
			p.SetState(4006)
			p.Match(PlSqlParserEXCLUSIVE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4007)
			p.Match(PlSqlParserSHARE)
		}
		p.SetState(4009)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserUPDATE {
			{
				p.SetState(4008)
				p.Match(PlSqlParserUPDATE)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4011)
			p.Match(PlSqlParserSHARE)
		}
		{
			p.SetState(4012)
			p.Match(PlSqlParserROW)
		}
		{
			p.SetState(4013)
			p.Match(PlSqlParserEXCLUSIVE)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4014)
			p.Match(PlSqlParserEXCLUSIVE)
		}

	}

	return localctx
}

// IGeneral_table_refContext is an interface to support dynamic dispatch.
type IGeneral_table_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_table_refContext differentiates from other interfaces.
	IsGeneral_table_refContext()
}

type General_table_refContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_table_refContext() *General_table_refContext {
	var p = new(General_table_refContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_general_table_ref
	return p
}

func (*General_table_refContext) IsGeneral_table_refContext() {}

func NewGeneral_table_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_table_refContext {
	var p = new(General_table_refContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_general_table_ref

	return p
}

func (s *General_table_refContext) GetParser() antlr.Parser { return s.parser }

func (s *General_table_refContext) Dml_table_expression_clause() IDml_table_expression_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDml_table_expression_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDml_table_expression_clauseContext)
}

func (s *General_table_refContext) ONLY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserONLY, 0)
}

func (s *General_table_refContext) Table_alias() ITable_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_aliasContext)
}

func (s *General_table_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_table_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_table_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterGeneral_table_ref(s)
	}
}

func (s *General_table_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitGeneral_table_ref(s)
	}
}

func (p *PlSqlParser) General_table_ref() (localctx IGeneral_table_refContext) {
	localctx = NewGeneral_table_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, PlSqlParserRULE_general_table_ref)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4023)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 485, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4017)
			p.Dml_table_expression_clause()
		}

	case 2:
		{
			p.SetState(4018)
			p.Match(PlSqlParserONLY)
		}
		{
			p.SetState(4019)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4020)
			p.Dml_table_expression_clause()
		}
		{
			p.SetState(4021)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	p.SetState(4026)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 486, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4025)
			p.Table_alias()
		}

	}

	return localctx
}

// IStatic_returning_clauseContext is an interface to support dynamic dispatch.
type IStatic_returning_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatic_returning_clauseContext differentiates from other interfaces.
	IsStatic_returning_clauseContext()
}

type Static_returning_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatic_returning_clauseContext() *Static_returning_clauseContext {
	var p = new(Static_returning_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_static_returning_clause
	return p
}

func (*Static_returning_clauseContext) IsStatic_returning_clauseContext() {}

func NewStatic_returning_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Static_returning_clauseContext {
	var p = new(Static_returning_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_static_returning_clause

	return p
}

func (s *Static_returning_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Static_returning_clauseContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Static_returning_clauseContext) Into_clause() IInto_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInto_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInto_clauseContext)
}

func (s *Static_returning_clauseContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURNING, 0)
}

func (s *Static_returning_clauseContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Static_returning_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Static_returning_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Static_returning_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterStatic_returning_clause(s)
	}
}

func (s *Static_returning_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitStatic_returning_clause(s)
	}
}

func (p *PlSqlParser) Static_returning_clause() (localctx IStatic_returning_clauseContext) {
	localctx = NewStatic_returning_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, PlSqlParserRULE_static_returning_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4028)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserRETURNING || _la == PlSqlParserRETURN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4029)
		p.Expressions()
	}
	{
		p.SetState(4030)
		p.Into_clause()
	}

	return localctx
}

// IError_logging_clauseContext is an interface to support dynamic dispatch.
type IError_logging_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsError_logging_clauseContext differentiates from other interfaces.
	IsError_logging_clauseContext()
}

type Error_logging_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_logging_clauseContext() *Error_logging_clauseContext {
	var p = new(Error_logging_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_error_logging_clause
	return p
}

func (*Error_logging_clauseContext) IsError_logging_clauseContext() {}

func NewError_logging_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_logging_clauseContext {
	var p = new(Error_logging_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_error_logging_clause

	return p
}

func (s *Error_logging_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_logging_clauseContext) LOG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOG, 0)
}

func (s *Error_logging_clauseContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserERRORS, 0)
}

func (s *Error_logging_clauseContext) Error_logging_into_part() IError_logging_into_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_logging_into_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_logging_into_partContext)
}

func (s *Error_logging_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Error_logging_clauseContext) Error_logging_reject_part() IError_logging_reject_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_logging_reject_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_logging_reject_partContext)
}

func (s *Error_logging_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_logging_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_logging_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterError_logging_clause(s)
	}
}

func (s *Error_logging_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitError_logging_clause(s)
	}
}

func (p *PlSqlParser) Error_logging_clause() (localctx IError_logging_clauseContext) {
	localctx = NewError_logging_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, PlSqlParserRULE_error_logging_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4032)
		p.Match(PlSqlParserLOG)
	}
	{
		p.SetState(4033)
		p.Match(PlSqlParserERRORS)
	}
	p.SetState(4035)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 487, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4034)
			p.Error_logging_into_part()
		}

	}
	p.SetState(4038)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 488, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4037)
			p.Expression()
		}

	}
	p.SetState(4041)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserREJECT {
		{
			p.SetState(4040)
			p.Error_logging_reject_part()
		}

	}

	return localctx
}

// IError_logging_into_partContext is an interface to support dynamic dispatch.
type IError_logging_into_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsError_logging_into_partContext differentiates from other interfaces.
	IsError_logging_into_partContext()
}

type Error_logging_into_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_logging_into_partContext() *Error_logging_into_partContext {
	var p = new(Error_logging_into_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_error_logging_into_part
	return p
}

func (*Error_logging_into_partContext) IsError_logging_into_partContext() {}

func NewError_logging_into_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_logging_into_partContext {
	var p = new(Error_logging_into_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_error_logging_into_part

	return p
}

func (s *Error_logging_into_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_logging_into_partContext) INTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTO, 0)
}

func (s *Error_logging_into_partContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Error_logging_into_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_logging_into_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_logging_into_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterError_logging_into_part(s)
	}
}

func (s *Error_logging_into_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitError_logging_into_part(s)
	}
}

func (p *PlSqlParser) Error_logging_into_part() (localctx IError_logging_into_partContext) {
	localctx = NewError_logging_into_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, PlSqlParserRULE_error_logging_into_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4043)
		p.Match(PlSqlParserINTO)
	}
	{
		p.SetState(4044)
		p.Tableview_name()
	}

	return localctx
}

// IError_logging_reject_partContext is an interface to support dynamic dispatch.
type IError_logging_reject_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsError_logging_reject_partContext differentiates from other interfaces.
	IsError_logging_reject_partContext()
}

type Error_logging_reject_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_logging_reject_partContext() *Error_logging_reject_partContext {
	var p = new(Error_logging_reject_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_error_logging_reject_part
	return p
}

func (*Error_logging_reject_partContext) IsError_logging_reject_partContext() {}

func NewError_logging_reject_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_logging_reject_partContext {
	var p = new(Error_logging_reject_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_error_logging_reject_part

	return p
}

func (s *Error_logging_reject_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_logging_reject_partContext) REJECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREJECT, 0)
}

func (s *Error_logging_reject_partContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIMIT, 0)
}

func (s *Error_logging_reject_partContext) UNLIMITED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNLIMITED, 0)
}

func (s *Error_logging_reject_partContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Error_logging_reject_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_logging_reject_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_logging_reject_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterError_logging_reject_part(s)
	}
}

func (s *Error_logging_reject_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitError_logging_reject_part(s)
	}
}

func (p *PlSqlParser) Error_logging_reject_part() (localctx IError_logging_reject_partContext) {
	localctx = NewError_logging_reject_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, PlSqlParserRULE_error_logging_reject_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4046)
		p.Match(PlSqlParserREJECT)
	}
	{
		p.SetState(4047)
		p.Match(PlSqlParserLIMIT)
	}
	p.SetState(4050)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 490, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4048)
			p.Match(PlSqlParserUNLIMITED)
		}

	case 2:
		{
			p.SetState(4049)
			p.Expression()
		}

	}

	return localctx
}

// IDml_table_expression_clauseContext is an interface to support dynamic dispatch.
type IDml_table_expression_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDml_table_expression_clauseContext differentiates from other interfaces.
	IsDml_table_expression_clauseContext()
}

type Dml_table_expression_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDml_table_expression_clauseContext() *Dml_table_expression_clauseContext {
	var p = new(Dml_table_expression_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_dml_table_expression_clause
	return p
}

func (*Dml_table_expression_clauseContext) IsDml_table_expression_clauseContext() {}

func NewDml_table_expression_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dml_table_expression_clauseContext {
	var p = new(Dml_table_expression_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_dml_table_expression_clause

	return p
}

func (s *Dml_table_expression_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Dml_table_expression_clauseContext) Table_collection_expression() ITable_collection_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_collection_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_collection_expressionContext)
}

func (s *Dml_table_expression_clauseContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Dml_table_expression_clauseContext) Subquery_restriction_clause() ISubquery_restriction_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubquery_restriction_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubquery_restriction_clauseContext)
}

func (s *Dml_table_expression_clauseContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Dml_table_expression_clauseContext) Sample_clause() ISample_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISample_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISample_clauseContext)
}

func (s *Dml_table_expression_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dml_table_expression_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dml_table_expression_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDml_table_expression_clause(s)
	}
}

func (s *Dml_table_expression_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDml_table_expression_clause(s)
	}
}

func (p *PlSqlParser) Dml_table_expression_clause() (localctx IDml_table_expression_clauseContext) {
	localctx = NewDml_table_expression_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, PlSqlParserRULE_dml_table_expression_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4064)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserTABLE, PlSqlParserTHE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4052)
			p.Table_collection_expression()
		}

	case PlSqlParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4053)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4054)
			p.Select_statement()
		}
		p.SetState(4056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserWITH {
			{
				p.SetState(4055)
				p.Subquery_restriction_clause()
			}

		}
		{
			p.SetState(4058)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4060)
			p.Tableview_name()
		}
		p.SetState(4062)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 492, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4061)
				p.Sample_clause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_collection_expressionContext is an interface to support dynamic dispatch.
type ITable_collection_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_collection_expressionContext differentiates from other interfaces.
	IsTable_collection_expressionContext()
}

type Table_collection_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_collection_expressionContext() *Table_collection_expressionContext {
	var p = new(Table_collection_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_collection_expression
	return p
}

func (*Table_collection_expressionContext) IsTable_collection_expressionContext() {}

func NewTable_collection_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_collection_expressionContext {
	var p = new(Table_collection_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_collection_expression

	return p
}

func (s *Table_collection_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_collection_expressionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTABLE, 0)
}

func (s *Table_collection_expressionContext) THE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTHE, 0)
}

func (s *Table_collection_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Table_collection_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Table_collection_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_collection_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_collection_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_collection_expression(s)
	}
}

func (s *Table_collection_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_collection_expression(s)
	}
}

func (p *PlSqlParser) Table_collection_expression() (localctx ITable_collection_expressionContext) {
	localctx = NewTable_collection_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, PlSqlParserRULE_table_collection_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4066)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserTABLE || _la == PlSqlParserTHE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4079)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 495, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4067)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4068)
			p.Subquery()
		}
		{
			p.SetState(4069)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 2:
		{
			p.SetState(4071)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4072)
			p.Expression()
		}
		{
			p.SetState(4073)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4077)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 494, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4074)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			{
				p.SetState(4075)
				p.Match(PlSqlParserPLUS_SIGN)
			}
			{
				p.SetState(4076)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		}

	}

	return localctx
}

// ISubquery_restriction_clauseContext is an interface to support dynamic dispatch.
type ISubquery_restriction_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubquery_restriction_clauseContext differentiates from other interfaces.
	IsSubquery_restriction_clauseContext()
}

type Subquery_restriction_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubquery_restriction_clauseContext() *Subquery_restriction_clauseContext {
	var p = new(Subquery_restriction_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_subquery_restriction_clause
	return p
}

func (*Subquery_restriction_clauseContext) IsSubquery_restriction_clauseContext() {}

func NewSubquery_restriction_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subquery_restriction_clauseContext {
	var p = new(Subquery_restriction_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_subquery_restriction_clause

	return p
}

func (s *Subquery_restriction_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Subquery_restriction_clauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWITH, 0)
}

func (s *Subquery_restriction_clauseContext) READ() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREAD, 0)
}

func (s *Subquery_restriction_clauseContext) ONLY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserONLY, 0)
}

func (s *Subquery_restriction_clauseContext) CHECK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHECK, 0)
}

func (s *Subquery_restriction_clauseContext) OPTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOPTION, 0)
}

func (s *Subquery_restriction_clauseContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRAINT, 0)
}

func (s *Subquery_restriction_clauseContext) Constraint_name() IConstraint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Subquery_restriction_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subquery_restriction_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subquery_restriction_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSubquery_restriction_clause(s)
	}
}

func (s *Subquery_restriction_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSubquery_restriction_clause(s)
	}
}

func (p *PlSqlParser) Subquery_restriction_clause() (localctx ISubquery_restriction_clauseContext) {
	localctx = NewSubquery_restriction_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, PlSqlParserRULE_subquery_restriction_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4081)
		p.Match(PlSqlParserWITH)
	}
	p.SetState(4090)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserREAD:
		{
			p.SetState(4082)
			p.Match(PlSqlParserREAD)
		}
		{
			p.SetState(4083)
			p.Match(PlSqlParserONLY)
		}

	case PlSqlParserCHECK:
		{
			p.SetState(4084)
			p.Match(PlSqlParserCHECK)
		}
		{
			p.SetState(4085)
			p.Match(PlSqlParserOPTION)
		}
		p.SetState(4088)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCONSTRAINT {
			{
				p.SetState(4086)
				p.Match(PlSqlParserCONSTRAINT)
			}
			{
				p.SetState(4087)
				p.Constraint_name()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISample_clauseContext is an interface to support dynamic dispatch.
type ISample_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSample_clauseContext differentiates from other interfaces.
	IsSample_clauseContext()
}

type Sample_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_clauseContext() *Sample_clauseContext {
	var p = new(Sample_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_sample_clause
	return p
}

func (*Sample_clauseContext) IsSample_clauseContext() {}

func NewSample_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_clauseContext {
	var p = new(Sample_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_sample_clause

	return p
}

func (s *Sample_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_clauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSAMPLE, 0)
}

func (s *Sample_clauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Sample_clauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Sample_clauseContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBLOCK, 0)
}

func (s *Sample_clauseContext) Seed_part() ISeed_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeed_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeed_partContext)
}

func (s *Sample_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sample_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSample_clause(s)
	}
}

func (s *Sample_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSample_clause(s)
	}
}

func (p *PlSqlParser) Sample_clause() (localctx ISample_clauseContext) {
	localctx = NewSample_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, PlSqlParserRULE_sample_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4092)
		p.Match(PlSqlParserSAMPLE)
	}
	p.SetState(4094)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserBLOCK {
		{
			p.SetState(4093)
			p.Match(PlSqlParserBLOCK)
		}

	}
	{
		p.SetState(4096)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(4097)
		p.Expression()
	}
	p.SetState(4100)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserCOMMA {
		{
			p.SetState(4098)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(4099)
			p.Expression()
		}

	}
	{
		p.SetState(4102)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(4104)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 500, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4103)
			p.Seed_part()
		}

	}

	return localctx
}

// ISeed_partContext is an interface to support dynamic dispatch.
type ISeed_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeed_partContext differentiates from other interfaces.
	IsSeed_partContext()
}

type Seed_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeed_partContext() *Seed_partContext {
	var p = new(Seed_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_seed_part
	return p
}

func (*Seed_partContext) IsSeed_partContext() {}

func NewSeed_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seed_partContext {
	var p = new(Seed_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_seed_part

	return p
}

func (s *Seed_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Seed_partContext) SEED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEED, 0)
}

func (s *Seed_partContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Seed_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seed_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seed_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSeed_part(s)
	}
}

func (s *Seed_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSeed_part(s)
	}
}

func (p *PlSqlParser) Seed_part() (localctx ISeed_partContext) {
	localctx = NewSeed_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, PlSqlParserRULE_seed_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4106)
		p.Match(PlSqlParserSEED)
	}
	{
		p.SetState(4107)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(4108)
		p.Expression()
	}
	{
		p.SetState(4109)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_condition
	return p
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (p *PlSqlParser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, PlSqlParserRULE_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4111)
		p.Expression()
	}

	return localctx
}

// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_expressions
	return p
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterExpressions(s)
	}
}

func (s *ExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitExpressions(s)
	}
}

func (p *PlSqlParser) Expressions() (localctx IExpressionsContext) {
	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, PlSqlParserRULE_expressions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4113)
		p.Expression()
	}
	p.SetState(4118)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 501, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4114)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4115)
				p.Expression()
			}

		}
		p.SetState(4120)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 501, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Cursor_expression() ICursor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_expressionContext)
}

func (s *ExpressionContext) Logical_expression() ILogical_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_expressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *PlSqlParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, PlSqlParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4123)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 502, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4121)
			p.Cursor_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4122)
			p.logical_expression(0)
		}

	}

	return localctx
}

// ICursor_expressionContext is an interface to support dynamic dispatch.
type ICursor_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCursor_expressionContext differentiates from other interfaces.
	IsCursor_expressionContext()
}

type Cursor_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_expressionContext() *Cursor_expressionContext {
	var p = new(Cursor_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cursor_expression
	return p
}

func (*Cursor_expressionContext) IsCursor_expressionContext() {}

func NewCursor_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_expressionContext {
	var p = new(Cursor_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cursor_expression

	return p
}

func (s *Cursor_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_expressionContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCURSOR, 0)
}

func (s *Cursor_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Cursor_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cursor_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCursor_expression(s)
	}
}

func (s *Cursor_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCursor_expression(s)
	}
}

func (p *PlSqlParser) Cursor_expression() (localctx ICursor_expressionContext) {
	localctx = NewCursor_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, PlSqlParserRULE_cursor_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4125)
		p.Match(PlSqlParserCURSOR)
	}
	{
		p.SetState(4126)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(4127)
		p.Subquery()
	}
	{
		p.SetState(4128)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// ILogical_expressionContext is an interface to support dynamic dispatch.
type ILogical_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_expressionContext differentiates from other interfaces.
	IsLogical_expressionContext()
}

type Logical_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_expressionContext() *Logical_expressionContext {
	var p = new(Logical_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_logical_expression
	return p
}

func (*Logical_expressionContext) IsLogical_expressionContext() {}

func NewLogical_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_expressionContext {
	var p = new(Logical_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_logical_expression

	return p
}

func (s *Logical_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_expressionContext) Multiset_expression() IMultiset_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiset_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiset_expressionContext)
}

func (s *Logical_expressionContext) AllIS() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserIS)
}

func (s *Logical_expressionContext) IS(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserIS, i)
}

func (s *Logical_expressionContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserNULL)
}

func (s *Logical_expressionContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, i)
}

func (s *Logical_expressionContext) AllNAN() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserNAN)
}

func (s *Logical_expressionContext) NAN(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAN, i)
}

func (s *Logical_expressionContext) AllPRESENT() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserPRESENT)
}

func (s *Logical_expressionContext) PRESENT(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRESENT, i)
}

func (s *Logical_expressionContext) AllINFINITE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserINFINITE)
}

func (s *Logical_expressionContext) INFINITE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserINFINITE, i)
}

func (s *Logical_expressionContext) AllA_LETTER() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserA_LETTER)
}

func (s *Logical_expressionContext) A_LETTER(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserA_LETTER, i)
}

func (s *Logical_expressionContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserSET)
}

func (s *Logical_expressionContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, i)
}

func (s *Logical_expressionContext) AllEMPTY() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserEMPTY)
}

func (s *Logical_expressionContext) EMPTY(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserEMPTY, i)
}

func (s *Logical_expressionContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserOF)
}

func (s *Logical_expressionContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, i)
}

func (s *Logical_expressionContext) AllType_spec() []IType_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specContext)(nil)).Elem())
	var tst = make([]IType_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specContext)
		}
	}

	return tst
}

func (s *Logical_expressionContext) Type_spec(i int) IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Logical_expressionContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserNOT)
}

func (s *Logical_expressionContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, i)
}

func (s *Logical_expressionContext) AllTYPE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserTYPE)
}

func (s *Logical_expressionContext) TYPE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserTYPE, i)
}

func (s *Logical_expressionContext) AllONLY() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserONLY)
}

func (s *Logical_expressionContext) ONLY(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserONLY, i)
}

func (s *Logical_expressionContext) AllLogical_expression() []ILogical_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_expressionContext)(nil)).Elem())
	var tst = make([]ILogical_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_expressionContext)
		}
	}

	return tst
}

func (s *Logical_expressionContext) Logical_expression(i int) ILogical_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_expressionContext)
}

func (s *Logical_expressionContext) AND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAND, 0)
}

func (s *Logical_expressionContext) OR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOR, 0)
}

func (s *Logical_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterLogical_expression(s)
	}
}

func (s *Logical_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitLogical_expression(s)
	}
}

func (p *PlSqlParser) Logical_expression() (localctx ILogical_expressionContext) {
	return p.logical_expression(0)
}

func (p *PlSqlParser) logical_expression(_p int) (localctx ILogical_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewLogical_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogical_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 538
	p.EnterRecursionRule(localctx, 538, PlSqlParserRULE_logical_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4170)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALL, PlSqlParserANALYZE, PlSqlParserANY, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOALESCE, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONNECT_BY_ROOT, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDISTINCT, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXISTS, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFALSE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPRIOR, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUE, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserDECODE, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserNVL, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROUND, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTO_CHAR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserLEAST, PlSqlParserGREATEST, PlSqlParserTO_DATE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserPLUS_SIGN, PlSqlParserMINUS_SIGN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(4131)
			p.Multiset_expression()
		}
		p.SetState(4165)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 508, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4132)
					p.Match(PlSqlParserIS)
				}
				p.SetState(4134)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == PlSqlParserNOT {
					{
						p.SetState(4133)
						p.Match(PlSqlParserNOT)
					}

				}
				p.SetState(4161)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case PlSqlParserNULL:
					{
						p.SetState(4136)
						p.Match(PlSqlParserNULL)
					}

				case PlSqlParserNAN:
					{
						p.SetState(4137)
						p.Match(PlSqlParserNAN)
					}

				case PlSqlParserPRESENT:
					{
						p.SetState(4138)
						p.Match(PlSqlParserPRESENT)
					}

				case PlSqlParserINFINITE:
					{
						p.SetState(4139)
						p.Match(PlSqlParserINFINITE)
					}

				case PlSqlParserA_LETTER:
					{
						p.SetState(4140)
						p.Match(PlSqlParserA_LETTER)
					}
					{
						p.SetState(4141)
						p.Match(PlSqlParserSET)
					}

				case PlSqlParserEMPTY:
					{
						p.SetState(4142)
						p.Match(PlSqlParserEMPTY)
					}

				case PlSqlParserOF:
					{
						p.SetState(4143)
						p.Match(PlSqlParserOF)
					}
					p.SetState(4145)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == PlSqlParserTYPE {
						{
							p.SetState(4144)
							p.Match(PlSqlParserTYPE)
						}

					}
					{
						p.SetState(4147)
						p.Match(PlSqlParserLEFT_PAREN)
					}
					p.SetState(4149)
					p.GetErrorHandler().Sync(p)

					if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 505, p.GetParserRuleContext()) == 1 {
						{
							p.SetState(4148)
							p.Match(PlSqlParserONLY)
						}

					}
					{
						p.SetState(4151)
						p.Type_spec()
					}
					p.SetState(4156)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					for _la == PlSqlParserCOMMA {
						{
							p.SetState(4152)
							p.Match(PlSqlParserCOMMA)
						}
						{
							p.SetState(4153)
							p.Type_spec()
						}

						p.SetState(4158)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)
					}
					{
						p.SetState(4159)
						p.Match(PlSqlParserRIGHT_PAREN)
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}
			p.SetState(4167)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 508, p.GetParserRuleContext())
		}

	case PlSqlParserNOT:
		{
			p.SetState(4168)
			p.Match(PlSqlParserNOT)
		}
		{
			p.SetState(4169)
			p.logical_expression(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4180)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 511, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4178)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 510, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogical_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PlSqlParserRULE_logical_expression)
				p.SetState(4172)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(4173)
					p.Match(PlSqlParserAND)
				}
				{
					p.SetState(4174)
					p.logical_expression(3)
				}

			case 2:
				localctx = NewLogical_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PlSqlParserRULE_logical_expression)
				p.SetState(4175)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(4176)
					p.Match(PlSqlParserOR)
				}
				{
					p.SetState(4177)
					p.logical_expression(2)
				}

			}

		}
		p.SetState(4182)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 511, p.GetParserRuleContext())
	}

	return localctx
}

// IMultiset_expressionContext is an interface to support dynamic dispatch.
type IMultiset_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMultiset_type returns the multiset_type token.
	GetMultiset_type() antlr.Token

	// SetMultiset_type sets the multiset_type token.
	SetMultiset_type(antlr.Token)

	// IsMultiset_expressionContext differentiates from other interfaces.
	IsMultiset_expressionContext()
}

type Multiset_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	multiset_type antlr.Token
}

func NewEmptyMultiset_expressionContext() *Multiset_expressionContext {
	var p = new(Multiset_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_multiset_expression
	return p
}

func (*Multiset_expressionContext) IsMultiset_expressionContext() {}

func NewMultiset_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiset_expressionContext {
	var p = new(Multiset_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_multiset_expression

	return p
}

func (s *Multiset_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiset_expressionContext) GetMultiset_type() antlr.Token { return s.multiset_type }

func (s *Multiset_expressionContext) SetMultiset_type(v antlr.Token) { s.multiset_type = v }

func (s *Multiset_expressionContext) Relational_expression() IRelational_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelational_expressionContext)
}

func (s *Multiset_expressionContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Multiset_expressionContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEMBER, 0)
}

func (s *Multiset_expressionContext) SUBMULTISET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBMULTISET, 0)
}

func (s *Multiset_expressionContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Multiset_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiset_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiset_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMultiset_expression(s)
	}
}

func (s *Multiset_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMultiset_expression(s)
	}
}

func (p *PlSqlParser) Multiset_expression() (localctx IMultiset_expressionContext) {
	localctx = NewMultiset_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, PlSqlParserRULE_multiset_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4183)
		p.relational_expression(0)
	}
	p.SetState(4189)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 513, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4184)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Multiset_expressionContext).multiset_type = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserMEMBER || _la == PlSqlParserSUBMULTISET) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Multiset_expressionContext).multiset_type = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserOF {
			{
				p.SetState(4185)
				p.Match(PlSqlParserOF)
			}

		}
		{
			p.SetState(4188)
			p.concatenation(0)
		}

	}

	return localctx
}

// IRelational_expressionContext is an interface to support dynamic dispatch.
type IRelational_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelational_expressionContext differentiates from other interfaces.
	IsRelational_expressionContext()
}

type Relational_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelational_expressionContext() *Relational_expressionContext {
	var p = new(Relational_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_relational_expression
	return p
}

func (*Relational_expressionContext) IsRelational_expressionContext() {}

func NewRelational_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relational_expressionContext {
	var p = new(Relational_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_relational_expression

	return p
}

func (s *Relational_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Relational_expressionContext) Compound_expression() ICompound_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_expressionContext)
}

func (s *Relational_expressionContext) AllRelational_expression() []IRelational_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem())
	var tst = make([]IRelational_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelational_expressionContext)
		}
	}

	return tst
}

func (s *Relational_expressionContext) Relational_expression(i int) IRelational_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelational_expressionContext)
}

func (s *Relational_expressionContext) Relational_operator() IRelational_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelational_operatorContext)
}

func (s *Relational_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relational_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relational_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRelational_expression(s)
	}
}

func (s *Relational_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRelational_expression(s)
	}
}

func (p *PlSqlParser) Relational_expression() (localctx IRelational_expressionContext) {
	return p.relational_expression(0)
}

func (p *PlSqlParser) relational_expression(_p int) (localctx IRelational_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRelational_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelational_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 542
	p.EnterRecursionRule(localctx, 542, PlSqlParserRULE_relational_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4192)
		p.Compound_expression()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4200)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 514, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRelational_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PlSqlParserRULE_relational_expression)
			p.SetState(4194)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(4195)
				p.Relational_operator()
			}
			{
				p.SetState(4196)
				p.relational_expression(3)
			}

		}
		p.SetState(4202)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 514, p.GetParserRuleContext())
	}

	return localctx
}

// ICompound_expressionContext is an interface to support dynamic dispatch.
type ICompound_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLike_type returns the like_type token.
	GetLike_type() antlr.Token

	// SetLike_type sets the like_type token.
	SetLike_type(antlr.Token)

	// IsCompound_expressionContext differentiates from other interfaces.
	IsCompound_expressionContext()
}

type Compound_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	like_type antlr.Token
}

func NewEmptyCompound_expressionContext() *Compound_expressionContext {
	var p = new(Compound_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_compound_expression
	return p
}

func (*Compound_expressionContext) IsCompound_expressionContext() {}

func NewCompound_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_expressionContext {
	var p = new(Compound_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_compound_expression

	return p
}

func (s *Compound_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_expressionContext) GetLike_type() antlr.Token { return s.like_type }

func (s *Compound_expressionContext) SetLike_type(v antlr.Token) { s.like_type = v }

func (s *Compound_expressionContext) AllConcatenation() []IConcatenationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConcatenationContext)(nil)).Elem())
	var tst = make([]IConcatenationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConcatenationContext)
		}
	}

	return tst
}

func (s *Compound_expressionContext) Concatenation(i int) IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Compound_expressionContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Compound_expressionContext) In_elements() IIn_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIn_elementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIn_elementsContext)
}

func (s *Compound_expressionContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBETWEEN, 0)
}

func (s *Compound_expressionContext) Between_elements() IBetween_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBetween_elementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBetween_elementsContext)
}

func (s *Compound_expressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT, 0)
}

func (s *Compound_expressionContext) LIKE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIKE, 0)
}

func (s *Compound_expressionContext) LIKEC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIKEC, 0)
}

func (s *Compound_expressionContext) LIKE2() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIKE2, 0)
}

func (s *Compound_expressionContext) LIKE4() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIKE4, 0)
}

func (s *Compound_expressionContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserESCAPE, 0)
}

func (s *Compound_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCompound_expression(s)
	}
}

func (s *Compound_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCompound_expression(s)
	}
}

func (p *PlSqlParser) Compound_expression() (localctx ICompound_expressionContext) {
	localctx = NewCompound_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, PlSqlParserRULE_compound_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4203)
		p.concatenation(0)
	}
	p.SetState(4219)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 518, p.GetParserRuleContext()) == 1 {
		p.SetState(4205)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserNOT {
			{
				p.SetState(4204)
				p.Match(PlSqlParserNOT)
			}

		}
		p.SetState(4217)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserIN:
			{
				p.SetState(4207)
				p.Match(PlSqlParserIN)
			}
			{
				p.SetState(4208)
				p.In_elements()
			}

		case PlSqlParserBETWEEN:
			{
				p.SetState(4209)
				p.Match(PlSqlParserBETWEEN)
			}
			{
				p.SetState(4210)
				p.Between_elements()
			}

		case PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIKE:
			{
				p.SetState(4211)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*Compound_expressionContext).like_type = _lt

				_la = p.GetTokenStream().LA(1)

				if !(((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(PlSqlParserLIKE2-218))|(1<<(PlSqlParserLIKE4-218))|(1<<(PlSqlParserLIKEC-218))|(1<<(PlSqlParserLIKE-218)))) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*Compound_expressionContext).like_type = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(4212)
				p.concatenation(0)
			}
			p.SetState(4215)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 516, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4213)
					p.Match(PlSqlParserESCAPE)
				}
				{
					p.SetState(4214)
					p.concatenation(0)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IRelational_operatorContext is an interface to support dynamic dispatch.
type IRelational_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelational_operatorContext differentiates from other interfaces.
	IsRelational_operatorContext()
}

type Relational_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelational_operatorContext() *Relational_operatorContext {
	var p = new(Relational_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_relational_operator
	return p
}

func (*Relational_operatorContext) IsRelational_operatorContext() {}

func NewRelational_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relational_operatorContext {
	var p = new(Relational_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_relational_operator

	return p
}

func (s *Relational_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Relational_operatorContext) NOT_EQUAL_OP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOT_EQUAL_OP, 0)
}

func (s *Relational_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relational_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relational_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRelational_operator(s)
	}
}

func (s *Relational_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRelational_operator(s)
	}
}

func (p *PlSqlParser) Relational_operator() (localctx IRelational_operatorContext) {
	localctx = NewRelational_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, PlSqlParserRULE_relational_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4235)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 521, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4221)
			p.Match(PlSqlParserEQUALS_OP)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4229)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserNOT_EQUAL_OP:
			{
				p.SetState(4222)
				p.Match(PlSqlParserNOT_EQUAL_OP)
			}

		case PlSqlParserLESS_THAN_OP:
			{
				p.SetState(4223)
				p.Match(PlSqlParserLESS_THAN_OP)
			}
			{
				p.SetState(4224)
				p.Match(PlSqlParserGREATER_THAN_OP)
			}

		case PlSqlParserEXCLAMATION_OPERATOR_PART:
			{
				p.SetState(4225)
				p.Match(PlSqlParserEXCLAMATION_OPERATOR_PART)
			}
			{
				p.SetState(4226)
				p.Match(PlSqlParserEQUALS_OP)
			}

		case PlSqlParserCARRET_OPERATOR_PART:
			{
				p.SetState(4227)
				p.Match(PlSqlParserCARRET_OPERATOR_PART)
			}
			{
				p.SetState(4228)
				p.Match(PlSqlParserEQUALS_OP)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4231)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserGREATER_THAN_OP || _la == PlSqlParserLESS_THAN_OP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserEQUALS_OP {
			{
				p.SetState(4232)
				p.Match(PlSqlParserEQUALS_OP)
			}

		}

	}

	return localctx
}

// IIn_elementsContext is an interface to support dynamic dispatch.
type IIn_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIn_elementsContext differentiates from other interfaces.
	IsIn_elementsContext()
}

type In_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_elementsContext() *In_elementsContext {
	var p = new(In_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_in_elements
	return p
}

func (*In_elementsContext) IsIn_elementsContext() {}

func NewIn_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_elementsContext {
	var p = new(In_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_in_elements

	return p
}

func (s *In_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *In_elementsContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *In_elementsContext) AllConcatenation() []IConcatenationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConcatenationContext)(nil)).Elem())
	var tst = make([]IConcatenationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConcatenationContext)
		}
	}

	return tst
}

func (s *In_elementsContext) Concatenation(i int) IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *In_elementsContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *In_elementsContext) Bind_variable() IBind_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_variableContext)
}

func (s *In_elementsContext) General_element() IGeneral_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_elementContext)
}

func (s *In_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *In_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterIn_elements(s)
	}
}

func (s *In_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitIn_elements(s)
	}
}

func (p *PlSqlParser) In_elements() (localctx IIn_elementsContext) {
	localctx = NewIn_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, PlSqlParserRULE_in_elements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4255)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 523, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4237)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4238)
			p.Subquery()
		}
		{
			p.SetState(4239)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4241)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4242)
			p.concatenation(0)
		}
		p.SetState(4247)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(4243)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4244)
				p.concatenation(0)
			}

			p.SetState(4249)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4250)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4252)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4253)
			p.Bind_variable()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4254)
			p.General_element()
		}

	}

	return localctx
}

// IBetween_elementsContext is an interface to support dynamic dispatch.
type IBetween_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBetween_elementsContext differentiates from other interfaces.
	IsBetween_elementsContext()
}

type Between_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBetween_elementsContext() *Between_elementsContext {
	var p = new(Between_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_between_elements
	return p
}

func (*Between_elementsContext) IsBetween_elementsContext() {}

func NewBetween_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Between_elementsContext {
	var p = new(Between_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_between_elements

	return p
}

func (s *Between_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Between_elementsContext) AllConcatenation() []IConcatenationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConcatenationContext)(nil)).Elem())
	var tst = make([]IConcatenationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConcatenationContext)
		}
	}

	return tst
}

func (s *Between_elementsContext) Concatenation(i int) IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Between_elementsContext) AND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAND, 0)
}

func (s *Between_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Between_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Between_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterBetween_elements(s)
	}
}

func (s *Between_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitBetween_elements(s)
	}
}

func (p *PlSqlParser) Between_elements() (localctx IBetween_elementsContext) {
	localctx = NewBetween_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, PlSqlParserRULE_between_elements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4257)
		p.concatenation(0)
	}
	{
		p.SetState(4258)
		p.Match(PlSqlParserAND)
	}
	{
		p.SetState(4259)
		p.concatenation(0)
	}

	return localctx
}

// IConcatenationContext is an interface to support dynamic dispatch.
type IConcatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsConcatenationContext differentiates from other interfaces.
	IsConcatenationContext()
}

type ConcatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyConcatenationContext() *ConcatenationContext {
	var p = new(ConcatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_concatenation
	return p
}

func (*ConcatenationContext) IsConcatenationContext() {}

func NewConcatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_concatenation

	return p
}

func (s *ConcatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConcatenationContext) GetOp() antlr.Token { return s.op }

func (s *ConcatenationContext) SetOp(v antlr.Token) { s.op = v }

func (s *ConcatenationContext) Model_expression() IModel_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_expressionContext)
}

func (s *ConcatenationContext) AT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAT, 0)
}

func (s *ConcatenationContext) Interval_expression() IInterval_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterval_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterval_expressionContext)
}

func (s *ConcatenationContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOCAL, 0)
}

func (s *ConcatenationContext) TIME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIME, 0)
}

func (s *ConcatenationContext) ZONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserZONE, 0)
}

func (s *ConcatenationContext) AllConcatenation() []IConcatenationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConcatenationContext)(nil)).Elem())
	var tst = make([]IConcatenationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConcatenationContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) Concatenation(i int) IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *ConcatenationContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserASTERISK, 0)
}

func (s *ConcatenationContext) SOLIDUS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSOLIDUS, 0)
}

func (s *ConcatenationContext) PLUS_SIGN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPLUS_SIGN, 0)
}

func (s *ConcatenationContext) MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINUS_SIGN, 0)
}

func (s *ConcatenationContext) AllBAR() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserBAR)
}

func (s *ConcatenationContext) BAR(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserBAR, i)
}

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (p *PlSqlParser) Concatenation() (localctx IConcatenationContext) {
	return p.concatenation(0)
}

func (p *PlSqlParser) concatenation(_p int) (localctx IConcatenationContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewConcatenationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IConcatenationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 552
	p.EnterRecursionRule(localctx, 552, PlSqlParserRULE_concatenation, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4262)
		p.Model_expression()
	}
	p.SetState(4271)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 525, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4263)
			p.Match(PlSqlParserAT)
		}
		p.SetState(4268)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserLOCAL:
			{
				p.SetState(4264)
				p.Match(PlSqlParserLOCAL)
			}

		case PlSqlParserTIME:
			{
				p.SetState(4265)
				p.Match(PlSqlParserTIME)
			}
			{
				p.SetState(4266)
				p.Match(PlSqlParserZONE)
			}
			{
				p.SetState(4267)
				p.concatenation(0)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 525, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4270)
			p.Interval_expression()
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4285)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 527, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4283)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 526, p.GetParserRuleContext()) {
			case 1:
				localctx = NewConcatenationContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PlSqlParserRULE_concatenation)
				p.SetState(4273)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(4274)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ConcatenationContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserASTERISK || _la == PlSqlParserSOLIDUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ConcatenationContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4275)
					p.concatenation(4)
				}

			case 2:
				localctx = NewConcatenationContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PlSqlParserRULE_concatenation)
				p.SetState(4276)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(4277)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ConcatenationContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserPLUS_SIGN || _la == PlSqlParserMINUS_SIGN) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ConcatenationContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4278)
					p.concatenation(3)
				}

			case 3:
				localctx = NewConcatenationContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PlSqlParserRULE_concatenation)
				p.SetState(4279)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(4280)
					p.Match(PlSqlParserBAR)
				}
				{
					p.SetState(4281)
					p.Match(PlSqlParserBAR)
				}
				{
					p.SetState(4282)
					p.concatenation(2)
				}

			}

		}
		p.SetState(4287)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 527, p.GetParserRuleContext())
	}

	return localctx
}

// IInterval_expressionContext is an interface to support dynamic dispatch.
type IInterval_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterval_expressionContext differentiates from other interfaces.
	IsInterval_expressionContext()
}

type Interval_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterval_expressionContext() *Interval_expressionContext {
	var p = new(Interval_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_interval_expression
	return p
}

func (*Interval_expressionContext) IsInterval_expressionContext() {}

func NewInterval_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interval_expressionContext {
	var p = new(Interval_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_interval_expression

	return p
}

func (s *Interval_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Interval_expressionContext) DAY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDAY, 0)
}

func (s *Interval_expressionContext) TO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO, 0)
}

func (s *Interval_expressionContext) SECOND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSECOND, 0)
}

func (s *Interval_expressionContext) AllConcatenation() []IConcatenationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConcatenationContext)(nil)).Elem())
	var tst = make([]IConcatenationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConcatenationContext)
		}
	}

	return tst
}

func (s *Interval_expressionContext) Concatenation(i int) IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Interval_expressionContext) YEAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserYEAR, 0)
}

func (s *Interval_expressionContext) MONTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMONTH, 0)
}

func (s *Interval_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interval_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interval_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterInterval_expression(s)
	}
}

func (s *Interval_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitInterval_expression(s)
	}
}

func (p *PlSqlParser) Interval_expression() (localctx IInterval_expressionContext) {
	localctx = NewInterval_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, PlSqlParserRULE_interval_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4312)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserDAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4288)
			p.Match(PlSqlParserDAY)
		}
		p.SetState(4293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserLEFT_PAREN {
			{
				p.SetState(4289)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			{
				p.SetState(4290)
				p.concatenation(0)
			}
			{
				p.SetState(4291)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		}
		{
			p.SetState(4295)
			p.Match(PlSqlParserTO)
		}
		{
			p.SetState(4296)
			p.Match(PlSqlParserSECOND)
		}
		p.SetState(4301)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 529, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4297)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			{
				p.SetState(4298)
				p.concatenation(0)
			}
			{
				p.SetState(4299)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		}

	case PlSqlParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4303)
			p.Match(PlSqlParserYEAR)
		}
		p.SetState(4308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserLEFT_PAREN {
			{
				p.SetState(4304)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			{
				p.SetState(4305)
				p.concatenation(0)
			}
			{
				p.SetState(4306)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		}
		{
			p.SetState(4310)
			p.Match(PlSqlParserTO)
		}
		{
			p.SetState(4311)
			p.Match(PlSqlParserMONTH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModel_expressionContext is an interface to support dynamic dispatch.
type IModel_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_expressionContext differentiates from other interfaces.
	IsModel_expressionContext()
}

type Model_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_expressionContext() *Model_expressionContext {
	var p = new(Model_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_expression
	return p
}

func (*Model_expressionContext) IsModel_expressionContext() {}

func NewModel_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_expressionContext {
	var p = new(Model_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_expression

	return p
}

func (s *Model_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Model_expressionContext) Model_expression_element() IModel_expression_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_expression_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_expression_elementContext)
}

func (s *Model_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_expression(s)
	}
}

func (s *Model_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_expression(s)
	}
}

func (p *PlSqlParser) Model_expression() (localctx IModel_expressionContext) {
	localctx = NewModel_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, PlSqlParserRULE_model_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4314)
		p.Unary_expression()
	}
	p.SetState(4319)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 532, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4315)
			p.Match(PlSqlParserLEFT_BRACKET)
		}
		{
			p.SetState(4316)
			p.Model_expression_element()
		}
		{
			p.SetState(4317)
			p.Match(PlSqlParserRIGHT_BRACKET)
		}

	}

	return localctx
}

// IModel_expression_elementContext is an interface to support dynamic dispatch.
type IModel_expression_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_expression_elementContext differentiates from other interfaces.
	IsModel_expression_elementContext()
}

type Model_expression_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_expression_elementContext() *Model_expression_elementContext {
	var p = new(Model_expression_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_model_expression_element
	return p
}

func (*Model_expression_elementContext) IsModel_expression_elementContext() {}

func NewModel_expression_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_expression_elementContext {
	var p = new(Model_expression_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_model_expression_element

	return p
}

func (s *Model_expression_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_expression_elementContext) AllANY() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserANY)
}

func (s *Model_expression_elementContext) ANY(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserANY, i)
}

func (s *Model_expression_elementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Model_expression_elementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Model_expression_elementContext) AllSingle_column_for_loop() []ISingle_column_for_loopContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingle_column_for_loopContext)(nil)).Elem())
	var tst = make([]ISingle_column_for_loopContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingle_column_for_loopContext)
		}
	}

	return tst
}

func (s *Model_expression_elementContext) Single_column_for_loop(i int) ISingle_column_for_loopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_column_for_loopContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingle_column_for_loopContext)
}

func (s *Model_expression_elementContext) Multi_column_for_loop() IMulti_column_for_loopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_column_for_loopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_column_for_loopContext)
}

func (s *Model_expression_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_expression_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_expression_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterModel_expression_element(s)
	}
}

func (s *Model_expression_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitModel_expression_element(s)
	}
}

func (p *PlSqlParser) Model_expression_element() (localctx IModel_expression_elementContext) {
	localctx = NewModel_expression_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, PlSqlParserRULE_model_expression_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4344)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 537, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4323)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 533, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4321)
				p.Match(PlSqlParserANY)
			}

		case 2:
			{
				p.SetState(4322)
				p.Expression()
			}

		}
		p.SetState(4332)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(4325)
				p.Match(PlSqlParserCOMMA)
			}
			p.SetState(4328)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 534, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4326)
					p.Match(PlSqlParserANY)
				}

			case 2:
				{
					p.SetState(4327)
					p.Expression()
				}

			}

			p.SetState(4334)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4335)
			p.Single_column_for_loop()
		}
		p.SetState(4340)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(4336)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4337)
				p.Single_column_for_loop()
			}

			p.SetState(4342)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4343)
			p.Multi_column_for_loop()
		}

	}

	return localctx
}

// ISingle_column_for_loopContext is an interface to support dynamic dispatch.
type ISingle_column_for_loopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAction_type returns the action_type token.
	GetAction_type() antlr.Token

	// SetAction_type sets the action_type token.
	SetAction_type(antlr.Token)

	// GetFromExpr returns the fromExpr rule contexts.
	GetFromExpr() IExpressionContext

	// GetToExpr returns the toExpr rule contexts.
	GetToExpr() IExpressionContext

	// GetAction_expr returns the action_expr rule contexts.
	GetAction_expr() IExpressionContext

	// SetFromExpr sets the fromExpr rule contexts.
	SetFromExpr(IExpressionContext)

	// SetToExpr sets the toExpr rule contexts.
	SetToExpr(IExpressionContext)

	// SetAction_expr sets the action_expr rule contexts.
	SetAction_expr(IExpressionContext)

	// IsSingle_column_for_loopContext differentiates from other interfaces.
	IsSingle_column_for_loopContext()
}

type Single_column_for_loopContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	fromExpr    IExpressionContext
	toExpr      IExpressionContext
	action_type antlr.Token
	action_expr IExpressionContext
}

func NewEmptySingle_column_for_loopContext() *Single_column_for_loopContext {
	var p = new(Single_column_for_loopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_single_column_for_loop
	return p
}

func (*Single_column_for_loopContext) IsSingle_column_for_loopContext() {}

func NewSingle_column_for_loopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_column_for_loopContext {
	var p = new(Single_column_for_loopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_single_column_for_loop

	return p
}

func (s *Single_column_for_loopContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_column_for_loopContext) GetAction_type() antlr.Token { return s.action_type }

func (s *Single_column_for_loopContext) SetAction_type(v antlr.Token) { s.action_type = v }

func (s *Single_column_for_loopContext) GetFromExpr() IExpressionContext { return s.fromExpr }

func (s *Single_column_for_loopContext) GetToExpr() IExpressionContext { return s.toExpr }

func (s *Single_column_for_loopContext) GetAction_expr() IExpressionContext { return s.action_expr }

func (s *Single_column_for_loopContext) SetFromExpr(v IExpressionContext) { s.fromExpr = v }

func (s *Single_column_for_loopContext) SetToExpr(v IExpressionContext) { s.toExpr = v }

func (s *Single_column_for_loopContext) SetAction_expr(v IExpressionContext) { s.action_expr = v }

func (s *Single_column_for_loopContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Single_column_for_loopContext) Column_name() IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Single_column_for_loopContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Single_column_for_loopContext) FROM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFROM, 0)
}

func (s *Single_column_for_loopContext) TO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO, 0)
}

func (s *Single_column_for_loopContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Single_column_for_loopContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Single_column_for_loopContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINCREMENT, 0)
}

func (s *Single_column_for_loopContext) DECREMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECREMENT, 0)
}

func (s *Single_column_for_loopContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Single_column_for_loopContext) LIKE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIKE, 0)
}

func (s *Single_column_for_loopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_column_for_loopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_column_for_loopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSingle_column_for_loop(s)
	}
}

func (s *Single_column_for_loopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSingle_column_for_loop(s)
	}
}

func (p *PlSqlParser) Single_column_for_loop() (localctx ISingle_column_for_loopContext) {
	localctx = NewSingle_column_for_loopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, PlSqlParserRULE_single_column_for_loop)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4346)
		p.Match(PlSqlParserFOR)
	}
	{
		p.SetState(4347)
		p.Column_name()
	}
	p.SetState(4365)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserIN:
		{
			p.SetState(4348)
			p.Match(PlSqlParserIN)
		}
		{
			p.SetState(4349)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
			{
				p.SetState(4350)
				p.Expressions()
			}

		}
		{
			p.SetState(4353)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserFROM, PlSqlParserLIKE:
		p.SetState(4356)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserLIKE {
			{
				p.SetState(4354)
				p.Match(PlSqlParserLIKE)
			}
			{
				p.SetState(4355)
				p.Expression()
			}

		}
		{
			p.SetState(4358)
			p.Match(PlSqlParserFROM)
		}
		{
			p.SetState(4359)

			var _x = p.Expression()

			localctx.(*Single_column_for_loopContext).fromExpr = _x
		}
		{
			p.SetState(4360)
			p.Match(PlSqlParserTO)
		}
		{
			p.SetState(4361)

			var _x = p.Expression()

			localctx.(*Single_column_for_loopContext).toExpr = _x
		}
		{
			p.SetState(4362)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Single_column_for_loopContext).action_type = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserDECREMENT || _la == PlSqlParserINCREMENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Single_column_for_loopContext).action_type = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4363)

			var _x = p.Expression()

			localctx.(*Single_column_for_loopContext).action_expr = _x
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMulti_column_for_loopContext is an interface to support dynamic dispatch.
type IMulti_column_for_loopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_column_for_loopContext differentiates from other interfaces.
	IsMulti_column_for_loopContext()
}

type Multi_column_for_loopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_column_for_loopContext() *Multi_column_for_loopContext {
	var p = new(Multi_column_for_loopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_multi_column_for_loop
	return p
}

func (*Multi_column_for_loopContext) IsMulti_column_for_loopContext() {}

func NewMulti_column_for_loopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_column_for_loopContext {
	var p = new(Multi_column_for_loopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_multi_column_for_loop

	return p
}

func (s *Multi_column_for_loopContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_column_for_loopContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Multi_column_for_loopContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Multi_column_for_loopContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Multi_column_for_loopContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Multi_column_for_loopContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Multi_column_for_loopContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Multi_column_for_loopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_column_for_loopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_column_for_loopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMulti_column_for_loop(s)
	}
}

func (s *Multi_column_for_loopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMulti_column_for_loop(s)
	}
}

func (p *PlSqlParser) Multi_column_for_loop() (localctx IMulti_column_for_loopContext) {
	localctx = NewMulti_column_for_loopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, PlSqlParserRULE_multi_column_for_loop)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4367)
		p.Match(PlSqlParserFOR)
	}
	{
		p.SetState(4368)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(4369)
		p.Column_name()
	}
	p.SetState(4374)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(4370)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(4371)
			p.Column_name()
		}

		p.SetState(4376)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4377)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	{
		p.SetState(4378)
		p.Match(PlSqlParserIN)
	}
	{
		p.SetState(4379)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(4386)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 543, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4380)
			p.Subquery()
		}

	case 2:
		{
			p.SetState(4381)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4383)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
			{
				p.SetState(4382)
				p.Expressions()
			}

		}
		{
			p.SetState(4385)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}
	{
		p.SetState(4388)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IUnary_expressionContext is an interface to support dynamic dispatch.
type IUnary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_expressionContext differentiates from other interfaces.
	IsUnary_expressionContext()
}

type Unary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_expressionContext() *Unary_expressionContext {
	var p = new(Unary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_unary_expression
	return p
}

func (*Unary_expressionContext) IsUnary_expressionContext() {}

func NewUnary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_expressionContext {
	var p = new(Unary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_unary_expression

	return p
}

func (s *Unary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Unary_expressionContext) PRIOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRIOR, 0)
}

func (s *Unary_expressionContext) CONNECT_BY_ROOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONNECT_BY_ROOT, 0)
}

func (s *Unary_expressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNEW, 0)
}

func (s *Unary_expressionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISTINCT, 0)
}

func (s *Unary_expressionContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Unary_expressionContext) Case_statement() ICase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_statementContext)
}

func (s *Unary_expressionContext) Quantified_expression() IQuantified_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantified_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantified_expressionContext)
}

func (s *Unary_expressionContext) Standard_function() IStandard_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandard_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandard_functionContext)
}

func (s *Unary_expressionContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Unary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUnary_expression(s)
	}
}

func (s *Unary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUnary_expression(s)
	}
}

func (p *PlSqlParser) Unary_expression() (localctx IUnary_expressionContext) {
	localctx = NewUnary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, PlSqlParserRULE_unary_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4406)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 544, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4390)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserPLUS_SIGN || _la == PlSqlParserMINUS_SIGN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4391)
			p.Unary_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4392)
			p.Match(PlSqlParserPRIOR)
		}
		{
			p.SetState(4393)
			p.Unary_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4394)
			p.Match(PlSqlParserCONNECT_BY_ROOT)
		}
		{
			p.SetState(4395)
			p.Unary_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4396)
			p.Match(PlSqlParserNEW)
		}
		{
			p.SetState(4397)
			p.Unary_expression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4398)
			p.Match(PlSqlParserDISTINCT)
		}
		{
			p.SetState(4399)
			p.Unary_expression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4400)
			p.Match(PlSqlParserALL)
		}
		{
			p.SetState(4401)
			p.Unary_expression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4402)
			p.Case_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4403)
			p.Quantified_expression()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4404)
			p.Standard_function()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4405)
			p.Atom()
		}

	}

	return localctx
}

// ICase_statementContext is an interface to support dynamic dispatch.
type ICase_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statementContext differentiates from other interfaces.
	IsCase_statementContext()
}

type Case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statementContext() *Case_statementContext {
	var p = new(Case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_case_statement
	return p
}

func (*Case_statementContext) IsCase_statementContext() {}

func NewCase_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statementContext {
	var p = new(Case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_case_statement

	return p
}

func (s *Case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statementContext) Searched_case_statement() ISearched_case_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISearched_case_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISearched_case_statementContext)
}

func (s *Case_statementContext) Simple_case_statement() ISimple_case_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_case_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_case_statementContext)
}

func (s *Case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCase_statement(s)
	}
}

func (s *Case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCase_statement(s)
	}
}

func (p *PlSqlParser) Case_statement() (localctx ICase_statementContext) {
	localctx = NewCase_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, PlSqlParserRULE_case_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4410)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 545, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4408)
			p.Searched_case_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4409)
			p.Simple_case_statement()
		}

	}

	return localctx
}

// ISimple_case_statementContext is an interface to support dynamic dispatch.
type ISimple_case_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCk1 returns the ck1 token.
	GetCk1() antlr.Token

	// SetCk1 sets the ck1 token.
	SetCk1(antlr.Token)

	// IsSimple_case_statementContext differentiates from other interfaces.
	IsSimple_case_statementContext()
}

type Simple_case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	ck1    antlr.Token
}

func NewEmptySimple_case_statementContext() *Simple_case_statementContext {
	var p = new(Simple_case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_simple_case_statement
	return p
}

func (*Simple_case_statementContext) IsSimple_case_statementContext() {}

func NewSimple_case_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_case_statementContext {
	var p = new(Simple_case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_simple_case_statement

	return p
}

func (s *Simple_case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_case_statementContext) GetCk1() antlr.Token { return s.ck1 }

func (s *Simple_case_statementContext) SetCk1(v antlr.Token) { s.ck1 = v }

func (s *Simple_case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Simple_case_statementContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *Simple_case_statementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserCASE)
}

func (s *Simple_case_statementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserCASE, i)
}

func (s *Simple_case_statementContext) AllLabel_name() []ILabel_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem())
	var tst = make([]ILabel_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILabel_nameContext)
		}
	}

	return tst
}

func (s *Simple_case_statementContext) Label_name(i int) ILabel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILabel_nameContext)
}

func (s *Simple_case_statementContext) AllSimple_case_when_part() []ISimple_case_when_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_case_when_partContext)(nil)).Elem())
	var tst = make([]ISimple_case_when_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_case_when_partContext)
		}
	}

	return tst
}

func (s *Simple_case_statementContext) Simple_case_when_part(i int) ISimple_case_when_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_case_when_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_case_when_partContext)
}

func (s *Simple_case_statementContext) Case_else_part() ICase_else_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_else_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_else_partContext)
}

func (s *Simple_case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSimple_case_statement(s)
	}
}

func (s *Simple_case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSimple_case_statement(s)
	}
}

func (p *PlSqlParser) Simple_case_statement() (localctx ISimple_case_statementContext) {
	localctx = NewSimple_case_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, PlSqlParserRULE_simple_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4413)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(4412)
			p.Label_name()
		}

	}
	{
		p.SetState(4415)

		var _m = p.Match(PlSqlParserCASE)

		localctx.(*Simple_case_statementContext).ck1 = _m
	}
	{
		p.SetState(4416)
		p.Expression()
	}
	p.SetState(4418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PlSqlParserWHEN {
		{
			p.SetState(4417)
			p.Simple_case_when_part()
		}

		p.SetState(4420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4423)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserELSE {
		{
			p.SetState(4422)
			p.Case_else_part()
		}

	}
	{
		p.SetState(4425)
		p.Match(PlSqlParserEND)
	}
	p.SetState(4427)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 549, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4426)
			p.Match(PlSqlParserCASE)
		}

	}
	p.SetState(4430)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 550, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4429)
			p.Label_name()
		}

	}

	return localctx
}

// ISimple_case_when_partContext is an interface to support dynamic dispatch.
type ISimple_case_when_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_case_when_partContext differentiates from other interfaces.
	IsSimple_case_when_partContext()
}

type Simple_case_when_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_case_when_partContext() *Simple_case_when_partContext {
	var p = new(Simple_case_when_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_simple_case_when_part
	return p
}

func (*Simple_case_when_partContext) IsSimple_case_when_partContext() {}

func NewSimple_case_when_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_case_when_partContext {
	var p = new(Simple_case_when_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_simple_case_when_part

	return p
}

func (s *Simple_case_when_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_case_when_partContext) WHEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHEN, 0)
}

func (s *Simple_case_when_partContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Simple_case_when_partContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Simple_case_when_partContext) THEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTHEN, 0)
}

func (s *Simple_case_when_partContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *Simple_case_when_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_case_when_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_case_when_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSimple_case_when_part(s)
	}
}

func (s *Simple_case_when_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSimple_case_when_part(s)
	}
}

func (p *PlSqlParser) Simple_case_when_part() (localctx ISimple_case_when_partContext) {
	localctx = NewSimple_case_when_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, PlSqlParserRULE_simple_case_when_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4432)
		p.Match(PlSqlParserWHEN)
	}
	{
		p.SetState(4433)
		p.Expression()
	}
	{
		p.SetState(4434)
		p.Match(PlSqlParserTHEN)
	}
	p.SetState(4437)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 551, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4435)
			p.Seq_of_statements()
		}

	case 2:
		{
			p.SetState(4436)
			p.Expression()
		}

	}

	return localctx
}

// ISearched_case_statementContext is an interface to support dynamic dispatch.
type ISearched_case_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCk1 returns the ck1 token.
	GetCk1() antlr.Token

	// SetCk1 sets the ck1 token.
	SetCk1(antlr.Token)

	// IsSearched_case_statementContext differentiates from other interfaces.
	IsSearched_case_statementContext()
}

type Searched_case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	ck1    antlr.Token
}

func NewEmptySearched_case_statementContext() *Searched_case_statementContext {
	var p = new(Searched_case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_searched_case_statement
	return p
}

func (*Searched_case_statementContext) IsSearched_case_statementContext() {}

func NewSearched_case_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Searched_case_statementContext {
	var p = new(Searched_case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_searched_case_statement

	return p
}

func (s *Searched_case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Searched_case_statementContext) GetCk1() antlr.Token { return s.ck1 }

func (s *Searched_case_statementContext) SetCk1(v antlr.Token) { s.ck1 = v }

func (s *Searched_case_statementContext) END() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEND, 0)
}

func (s *Searched_case_statementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserCASE)
}

func (s *Searched_case_statementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserCASE, i)
}

func (s *Searched_case_statementContext) AllLabel_name() []ILabel_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem())
	var tst = make([]ILabel_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILabel_nameContext)
		}
	}

	return tst
}

func (s *Searched_case_statementContext) Label_name(i int) ILabel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILabel_nameContext)
}

func (s *Searched_case_statementContext) AllSearched_case_when_part() []ISearched_case_when_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISearched_case_when_partContext)(nil)).Elem())
	var tst = make([]ISearched_case_when_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISearched_case_when_partContext)
		}
	}

	return tst
}

func (s *Searched_case_statementContext) Searched_case_when_part(i int) ISearched_case_when_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISearched_case_when_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISearched_case_when_partContext)
}

func (s *Searched_case_statementContext) Case_else_part() ICase_else_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_else_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_else_partContext)
}

func (s *Searched_case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Searched_case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Searched_case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSearched_case_statement(s)
	}
}

func (s *Searched_case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSearched_case_statement(s)
	}
}

func (p *PlSqlParser) Searched_case_statement() (localctx ISearched_case_statementContext) {
	localctx = NewSearched_case_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, PlSqlParserRULE_searched_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4440)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(4439)
			p.Label_name()
		}

	}
	{
		p.SetState(4442)

		var _m = p.Match(PlSqlParserCASE)

		localctx.(*Searched_case_statementContext).ck1 = _m
	}
	p.SetState(4444)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PlSqlParserWHEN {
		{
			p.SetState(4443)
			p.Searched_case_when_part()
		}

		p.SetState(4446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4449)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserELSE {
		{
			p.SetState(4448)
			p.Case_else_part()
		}

	}
	{
		p.SetState(4451)
		p.Match(PlSqlParserEND)
	}
	p.SetState(4453)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 555, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4452)
			p.Match(PlSqlParserCASE)
		}

	}
	p.SetState(4456)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 556, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4455)
			p.Label_name()
		}

	}

	return localctx
}

// ISearched_case_when_partContext is an interface to support dynamic dispatch.
type ISearched_case_when_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearched_case_when_partContext differentiates from other interfaces.
	IsSearched_case_when_partContext()
}

type Searched_case_when_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearched_case_when_partContext() *Searched_case_when_partContext {
	var p = new(Searched_case_when_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_searched_case_when_part
	return p
}

func (*Searched_case_when_partContext) IsSearched_case_when_partContext() {}

func NewSearched_case_when_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Searched_case_when_partContext {
	var p = new(Searched_case_when_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_searched_case_when_part

	return p
}

func (s *Searched_case_when_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Searched_case_when_partContext) WHEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHEN, 0)
}

func (s *Searched_case_when_partContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Searched_case_when_partContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Searched_case_when_partContext) THEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTHEN, 0)
}

func (s *Searched_case_when_partContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *Searched_case_when_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Searched_case_when_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Searched_case_when_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSearched_case_when_part(s)
	}
}

func (s *Searched_case_when_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSearched_case_when_part(s)
	}
}

func (p *PlSqlParser) Searched_case_when_part() (localctx ISearched_case_when_partContext) {
	localctx = NewSearched_case_when_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, PlSqlParserRULE_searched_case_when_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4458)
		p.Match(PlSqlParserWHEN)
	}
	{
		p.SetState(4459)
		p.Expression()
	}
	{
		p.SetState(4460)
		p.Match(PlSqlParserTHEN)
	}
	p.SetState(4463)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 557, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4461)
			p.Seq_of_statements()
		}

	case 2:
		{
			p.SetState(4462)
			p.Expression()
		}

	}

	return localctx
}

// ICase_else_partContext is an interface to support dynamic dispatch.
type ICase_else_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_else_partContext differentiates from other interfaces.
	IsCase_else_partContext()
}

type Case_else_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_else_partContext() *Case_else_partContext {
	var p = new(Case_else_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_case_else_part
	return p
}

func (*Case_else_partContext) IsCase_else_partContext() {}

func NewCase_else_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_else_partContext {
	var p = new(Case_else_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_case_else_part

	return p
}

func (s *Case_else_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_else_partContext) ELSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserELSE, 0)
}

func (s *Case_else_partContext) Seq_of_statements() ISeq_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_of_statementsContext)
}

func (s *Case_else_partContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_else_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_else_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_else_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCase_else_part(s)
	}
}

func (s *Case_else_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCase_else_part(s)
	}
}

func (p *PlSqlParser) Case_else_part() (localctx ICase_else_partContext) {
	localctx = NewCase_else_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, PlSqlParserRULE_case_else_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4465)
		p.Match(PlSqlParserELSE)
	}
	p.SetState(4468)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 558, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4466)
			p.Seq_of_statements()
		}

	case 2:
		{
			p.SetState(4467)
			p.Expression()
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Table_element() ITable_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_elementContext)
}

func (s *AtomContext) Outer_join_sign() IOuter_join_signContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOuter_join_signContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOuter_join_signContext)
}

func (s *AtomContext) Bind_variable() IBind_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_variableContext)
}

func (s *AtomContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AtomContext) General_element() IGeneral_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_elementContext)
}

func (s *AtomContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *AtomContext) AllSubquery_operation_part() []ISubquery_operation_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubquery_operation_partContext)(nil)).Elem())
	var tst = make([]ISubquery_operation_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubquery_operation_partContext)
		}
	}

	return tst
}

func (s *AtomContext) Subquery_operation_part(i int) ISubquery_operation_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubquery_operation_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubquery_operation_partContext)
}

func (s *AtomContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *PlSqlParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, PlSqlParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(4489)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 560, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4470)
			p.Table_element()
		}
		{
			p.SetState(4471)
			p.Outer_join_sign()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4473)
			p.Bind_variable()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4474)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4475)
			p.General_element()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4476)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4477)
			p.Subquery()
		}
		{
			p.SetState(4478)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4482)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 559, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4479)
					p.Subquery_operation_part()
				}

			}
			p.SetState(4484)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 559, p.GetParserRuleContext())
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4485)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4486)
			p.Expressions()
		}
		{
			p.SetState(4487)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}

	return localctx
}

// IQuantified_expressionContext is an interface to support dynamic dispatch.
type IQuantified_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantified_expressionContext differentiates from other interfaces.
	IsQuantified_expressionContext()
}

type Quantified_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantified_expressionContext() *Quantified_expressionContext {
	var p = new(Quantified_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_quantified_expression
	return p
}

func (*Quantified_expressionContext) IsQuantified_expressionContext() {}

func NewQuantified_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quantified_expressionContext {
	var p = new(Quantified_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_quantified_expression

	return p
}

func (s *Quantified_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Quantified_expressionContext) SOME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSOME, 0)
}

func (s *Quantified_expressionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXISTS, 0)
}

func (s *Quantified_expressionContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Quantified_expressionContext) ANY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserANY, 0)
}

func (s *Quantified_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Quantified_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Quantified_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quantified_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quantified_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterQuantified_expression(s)
	}
}

func (s *Quantified_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitQuantified_expression(s)
	}
}

func (p *PlSqlParser) Quantified_expression() (localctx IQuantified_expressionContext) {
	localctx = NewQuantified_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, PlSqlParserRULE_quantified_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4491)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserALL || _la == PlSqlParserANY || _la == PlSqlParserEXISTS || _la == PlSqlParserSOME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4500)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 561, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4492)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4493)
			p.Subquery()
		}
		{
			p.SetState(4494)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 2:
		{
			p.SetState(4496)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4497)
			p.Expression()
		}
		{
			p.SetState(4498)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	}

	return localctx
}

// IString_functionContext is an interface to support dynamic dispatch.
type IString_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_functionContext differentiates from other interfaces.
	IsString_functionContext()
}

type String_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_functionContext() *String_functionContext {
	var p = new(String_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_string_function
	return p
}

func (*String_functionContext) IsString_functionContext() {}

func NewString_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_functionContext {
	var p = new(String_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_string_function

	return p
}

func (s *String_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *String_functionContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBSTR, 0)
}

func (s *String_functionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *String_functionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *String_functionContext) TO_CHAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO_CHAR, 0)
}

func (s *String_functionContext) Table_element() ITable_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_elementContext)
}

func (s *String_functionContext) Standard_function() IStandard_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandard_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandard_functionContext)
}

func (s *String_functionContext) AllQuoted_string() []IQuoted_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem())
	var tst = make([]IQuoted_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuoted_stringContext)
		}
	}

	return tst
}

func (s *String_functionContext) Quoted_string(i int) IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *String_functionContext) DECODE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECODE, 0)
}

func (s *String_functionContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *String_functionContext) CHR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHR, 0)
}

func (s *String_functionContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *String_functionContext) USING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSING, 0)
}

func (s *String_functionContext) NCHAR_CS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNCHAR_CS, 0)
}

func (s *String_functionContext) NVL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNVL, 0)
}

func (s *String_functionContext) TRIM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIM, 0)
}

func (s *String_functionContext) FROM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFROM, 0)
}

func (s *String_functionContext) LEADING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEADING, 0)
}

func (s *String_functionContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRAILING, 0)
}

func (s *String_functionContext) BOTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBOTH, 0)
}

func (s *String_functionContext) TO_DATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO_DATE, 0)
}

func (s *String_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterString_function(s)
	}
}

func (s *String_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitString_function(s)
	}
}

func (p *PlSqlParser) String_function() (localctx IString_functionContext) {
	localctx = NewString_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, PlSqlParserRULE_string_function)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4572)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserSUBSTR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4502)
			p.Match(PlSqlParserSUBSTR)
		}
		{
			p.SetState(4503)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4504)
			p.Expression()
		}
		{
			p.SetState(4505)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(4506)
			p.Expression()
		}
		p.SetState(4509)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOMMA {
			{
				p.SetState(4507)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4508)
				p.Expression()
			}

		}
		{
			p.SetState(4511)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserTO_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4513)
			p.Match(PlSqlParserTO_CHAR)
		}
		{
			p.SetState(4514)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4518)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 563, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4515)
				p.Table_element()
			}

		case 2:
			{
				p.SetState(4516)
				p.Standard_function()
			}

		case 3:
			{
				p.SetState(4517)
				p.Expression()
			}

		}
		p.SetState(4522)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 564, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4520)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4521)
				p.Quoted_string()
			}

		}
		p.SetState(4526)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOMMA {
			{
				p.SetState(4524)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4525)
				p.Quoted_string()
			}

		}
		{
			p.SetState(4528)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserDECODE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4530)
			p.Match(PlSqlParserDECODE)
		}
		{
			p.SetState(4531)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4532)
			p.Expressions()
		}
		{
			p.SetState(4533)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserCHR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4535)
			p.Match(PlSqlParserCHR)
		}
		{
			p.SetState(4536)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4537)
			p.concatenation(0)
		}
		{
			p.SetState(4538)
			p.Match(PlSqlParserUSING)
		}
		{
			p.SetState(4539)
			p.Match(PlSqlParserNCHAR_CS)
		}
		{
			p.SetState(4540)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserNVL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4542)
			p.Match(PlSqlParserNVL)
		}
		{
			p.SetState(4543)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4544)
			p.Expression()
		}
		{
			p.SetState(4545)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(4546)
			p.Expression()
		}
		{
			p.SetState(4547)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserTRIM:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4549)
			p.Match(PlSqlParserTRIM)
		}
		{
			p.SetState(4550)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4558)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 568, p.GetParserRuleContext()) == 1 {
			p.SetState(4552)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserBOTH || _la == PlSqlParserLEADING || _la == PlSqlParserTRAILING {
				{
					p.SetState(4551)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserBOTH || _la == PlSqlParserLEADING || _la == PlSqlParserTRAILING) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(4555)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserNATIONAL_CHAR_STRING_LIT || _la == PlSqlParserCHAR_STRING {
				{
					p.SetState(4554)
					p.Quoted_string()
				}

			}
			{
				p.SetState(4557)
				p.Match(PlSqlParserFROM)
			}

		}
		{
			p.SetState(4560)
			p.concatenation(0)
		}
		{
			p.SetState(4561)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserTO_DATE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4563)
			p.Match(PlSqlParserTO_DATE)
		}
		{
			p.SetState(4564)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4565)
			p.Expression()
		}
		p.SetState(4568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOMMA {
			{
				p.SetState(4566)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4567)
				p.Quoted_string()
			}

		}
		{
			p.SetState(4570)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStandard_functionContext is an interface to support dynamic dispatch.
type IStandard_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandard_functionContext differentiates from other interfaces.
	IsStandard_functionContext()
}

type Standard_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandard_functionContext() *Standard_functionContext {
	var p = new(Standard_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_standard_function
	return p
}

func (*Standard_functionContext) IsStandard_functionContext() {}

func NewStandard_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Standard_functionContext {
	var p = new(Standard_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_standard_function

	return p
}

func (s *Standard_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Standard_functionContext) String_function() IString_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_functionContext)
}

func (s *Standard_functionContext) Numeric_function_wrapper() INumeric_function_wrapperContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeric_function_wrapperContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeric_function_wrapperContext)
}

func (s *Standard_functionContext) Other_function() IOther_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOther_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOther_functionContext)
}

func (s *Standard_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Standard_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Standard_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterStandard_function(s)
	}
}

func (s *Standard_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitStandard_function(s)
	}
}

func (p *PlSqlParser) Standard_function() (localctx IStandard_functionContext) {
	localctx = NewStandard_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, PlSqlParserRULE_standard_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4577)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 571, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4574)
			p.String_function()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4575)
			p.Numeric_function_wrapper()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4576)
			p.Other_function()
		}

	}

	return localctx
}

// INumeric_function_wrapperContext is an interface to support dynamic dispatch.
type INumeric_function_wrapperContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeric_function_wrapperContext differentiates from other interfaces.
	IsNumeric_function_wrapperContext()
}

type Numeric_function_wrapperContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_function_wrapperContext() *Numeric_function_wrapperContext {
	var p = new(Numeric_function_wrapperContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_numeric_function_wrapper
	return p
}

func (*Numeric_function_wrapperContext) IsNumeric_function_wrapperContext() {}

func NewNumeric_function_wrapperContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_function_wrapperContext {
	var p = new(Numeric_function_wrapperContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_numeric_function_wrapper

	return p
}

func (s *Numeric_function_wrapperContext) GetParser() antlr.Parser { return s.parser }

func (s *Numeric_function_wrapperContext) Numeric_function() INumeric_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeric_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeric_functionContext)
}

func (s *Numeric_function_wrapperContext) Single_column_for_loop() ISingle_column_for_loopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_column_for_loopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_column_for_loopContext)
}

func (s *Numeric_function_wrapperContext) Multi_column_for_loop() IMulti_column_for_loopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_column_for_loopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_column_for_loopContext)
}

func (s *Numeric_function_wrapperContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_function_wrapperContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Numeric_function_wrapperContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNumeric_function_wrapper(s)
	}
}

func (s *Numeric_function_wrapperContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNumeric_function_wrapper(s)
	}
}

func (p *PlSqlParser) Numeric_function_wrapper() (localctx INumeric_function_wrapperContext) {
	localctx = NewNumeric_function_wrapperContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, PlSqlParserRULE_numeric_function_wrapper)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4579)
		p.Numeric_function()
	}
	p.SetState(4582)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 572, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4580)
			p.Single_column_for_loop()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 572, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4581)
			p.Multi_column_for_loop()
		}

	}

	return localctx
}

// INumeric_functionContext is an interface to support dynamic dispatch.
type INumeric_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeric_functionContext differentiates from other interfaces.
	IsNumeric_functionContext()
}

type Numeric_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_functionContext() *Numeric_functionContext {
	var p = new(Numeric_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_numeric_function
	return p
}

func (*Numeric_functionContext) IsNumeric_functionContext() {}

func NewNumeric_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_functionContext {
	var p = new(Numeric_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_numeric_function

	return p
}

func (s *Numeric_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Numeric_functionContext) SUM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUM, 0)
}

func (s *Numeric_functionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Numeric_functionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISTINCT, 0)
}

func (s *Numeric_functionContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Numeric_functionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOUNT, 0)
}

func (s *Numeric_functionContext) Over_clause() IOver_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOver_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOver_clauseContext)
}

func (s *Numeric_functionContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Numeric_functionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNIQUE, 0)
}

func (s *Numeric_functionContext) ROUND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROUND, 0)
}

func (s *Numeric_functionContext) UNSIGNED_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNSIGNED_INTEGER, 0)
}

func (s *Numeric_functionContext) AVG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAVG, 0)
}

func (s *Numeric_functionContext) MAX() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAX, 0)
}

func (s *Numeric_functionContext) LEAST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEAST, 0)
}

func (s *Numeric_functionContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Numeric_functionContext) GREATEST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserGREATEST, 0)
}

func (s *Numeric_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Numeric_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNumeric_function(s)
	}
}

func (s *Numeric_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNumeric_function(s)
	}
}

func (p *PlSqlParser) Numeric_function() (localctx INumeric_functionContext) {
	localctx = NewNumeric_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, PlSqlParserRULE_numeric_function)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4642)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserSUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4584)
			p.Match(PlSqlParserSUM)
		}
		{
			p.SetState(4585)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4587)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 573, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4586)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserALL || _la == PlSqlParserDISTINCT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(4589)
			p.Expression()
		}
		{
			p.SetState(4590)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserCOUNT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4592)
			p.Match(PlSqlParserCOUNT)
		}
		{
			p.SetState(4593)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4601)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserASTERISK:
			{
				p.SetState(4594)
				p.Match(PlSqlParserASTERISK)
			}

		case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALL, PlSqlParserANALYZE, PlSqlParserANY, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOALESCE, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONNECT_BY_ROOT, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDISTINCT, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXISTS, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFALSE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPRIOR, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUE, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNIQUE, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserDECODE, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserNVL, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROUND, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTO_CHAR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserLEAST, PlSqlParserGREATEST, PlSqlParserTO_DATE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserRIGHT_PAREN, PlSqlParserPLUS_SIGN, PlSqlParserMINUS_SIGN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
			p.SetState(4599)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNIQUE-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
				p.SetState(4596)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 574, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(4595)
						_la = p.GetTokenStream().LA(1)

						if !(_la == PlSqlParserALL || _la == PlSqlParserDISTINCT || _la == PlSqlParserUNIQUE) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				{
					p.SetState(4598)
					p.concatenation(0)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(4603)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4605)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 577, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4604)
				p.Over_clause()
			}

		}

	case PlSqlParserROUND:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4607)
			p.Match(PlSqlParserROUND)
		}
		{
			p.SetState(4608)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4609)
			p.Expression()
		}
		p.SetState(4612)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOMMA {
			{
				p.SetState(4610)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4611)
				p.Match(PlSqlParserUNSIGNED_INTEGER)
			}

		}
		{
			p.SetState(4614)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserAVG:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4616)
			p.Match(PlSqlParserAVG)
		}
		{
			p.SetState(4617)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4619)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 579, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4618)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserALL || _la == PlSqlParserDISTINCT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(4621)
			p.Expression()
		}
		{
			p.SetState(4622)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserMAX:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4624)
			p.Match(PlSqlParserMAX)
		}
		{
			p.SetState(4625)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4627)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 580, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4626)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserALL || _la == PlSqlParserDISTINCT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(4629)
			p.Expression()
		}
		{
			p.SetState(4630)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserLEAST:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4632)
			p.Match(PlSqlParserLEAST)
		}
		{
			p.SetState(4633)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4634)
			p.Expressions()
		}
		{
			p.SetState(4635)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserGREATEST:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4637)
			p.Match(PlSqlParserGREATEST)
		}
		{
			p.SetState(4638)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4639)
			p.Expressions()
		}
		{
			p.SetState(4640)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOther_functionContext is an interface to support dynamic dispatch.
type IOther_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOther_functionContext differentiates from other interfaces.
	IsOther_functionContext()
}

type Other_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOther_functionContext() *Other_functionContext {
	var p = new(Other_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_other_function
	return p
}

func (*Other_functionContext) IsOther_functionContext() {}

func NewOther_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Other_functionContext {
	var p = new(Other_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_other_function

	return p
}

func (s *Other_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Other_functionContext) Over_clause_keyword() IOver_clause_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOver_clause_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOver_clause_keywordContext)
}

func (s *Other_functionContext) Function_argument_analytic() IFunction_argument_analyticContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_argument_analyticContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_argument_analyticContext)
}

func (s *Other_functionContext) Over_clause() IOver_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOver_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOver_clauseContext)
}

func (s *Other_functionContext) Regular_id() IRegular_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegular_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegular_idContext)
}

func (s *Other_functionContext) Function_argument_modeling() IFunction_argument_modelingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_argument_modelingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_argument_modelingContext)
}

func (s *Other_functionContext) Using_clause() IUsing_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsing_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *Other_functionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOUNT, 0)
}

func (s *Other_functionContext) AllConcatenation() []IConcatenationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConcatenationContext)(nil)).Elem())
	var tst = make([]IConcatenationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConcatenationContext)
		}
	}

	return tst
}

func (s *Other_functionContext) Concatenation(i int) IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Other_functionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISTINCT, 0)
}

func (s *Other_functionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNIQUE, 0)
}

func (s *Other_functionContext) ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserALL, 0)
}

func (s *Other_functionContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Other_functionContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Other_functionContext) CAST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCAST, 0)
}

func (s *Other_functionContext) XMLCAST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLCAST, 0)
}

func (s *Other_functionContext) MULTISET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMULTISET, 0)
}

func (s *Other_functionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Other_functionContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOALESCE, 0)
}

func (s *Other_functionContext) Table_element() ITable_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_elementContext)
}

func (s *Other_functionContext) Numeric() INumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericContext)
}

func (s *Other_functionContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Other_functionContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOLLECT, 0)
}

func (s *Other_functionContext) Collect_order_by_part() ICollect_order_by_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollect_order_by_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollect_order_by_partContext)
}

func (s *Other_functionContext) Within_or_over_clause_keyword() IWithin_or_over_clause_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithin_or_over_clause_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithin_or_over_clause_keywordContext)
}

func (s *Other_functionContext) Function_argument() IFunction_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_argumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_argumentContext)
}

func (s *Other_functionContext) AllWithin_or_over_part() []IWithin_or_over_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWithin_or_over_partContext)(nil)).Elem())
	var tst = make([]IWithin_or_over_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWithin_or_over_partContext)
		}
	}

	return tst
}

func (s *Other_functionContext) Within_or_over_part(i int) IWithin_or_over_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithin_or_over_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWithin_or_over_partContext)
}

func (s *Other_functionContext) Cursor_name() ICursor_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_nameContext)
}

func (s *Other_functionContext) PERCENT_ISOPEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENT_ISOPEN, 0)
}

func (s *Other_functionContext) PERCENT_FOUND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENT_FOUND, 0)
}

func (s *Other_functionContext) PERCENT_NOTFOUND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENT_NOTFOUND, 0)
}

func (s *Other_functionContext) PERCENT_ROWCOUNT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENT_ROWCOUNT, 0)
}

func (s *Other_functionContext) DECOMPOSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECOMPOSE, 0)
}

func (s *Other_functionContext) CANONICAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCANONICAL, 0)
}

func (s *Other_functionContext) COMPATIBILITY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPATIBILITY, 0)
}

func (s *Other_functionContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXTRACT, 0)
}

func (s *Other_functionContext) FROM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFROM, 0)
}

func (s *Other_functionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFIRST_VALUE, 0)
}

func (s *Other_functionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLAST_VALUE, 0)
}

func (s *Other_functionContext) Respect_or_ignore_nulls() IRespect_or_ignore_nullsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRespect_or_ignore_nullsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRespect_or_ignore_nullsContext)
}

func (s *Other_functionContext) Standard_prediction_function_keyword() IStandard_prediction_function_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandard_prediction_function_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandard_prediction_function_keywordContext)
}

func (s *Other_functionContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Other_functionContext) Cost_matrix_clause() ICost_matrix_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICost_matrix_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICost_matrix_clauseContext)
}

func (s *Other_functionContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRANSLATE, 0)
}

func (s *Other_functionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Other_functionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Other_functionContext) USING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSING, 0)
}

func (s *Other_functionContext) CHAR_CS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR_CS, 0)
}

func (s *Other_functionContext) NCHAR_CS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNCHAR_CS, 0)
}

func (s *Other_functionContext) TREAT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTREAT, 0)
}

func (s *Other_functionContext) REF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREF, 0)
}

func (s *Other_functionContext) TRIM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIM, 0)
}

func (s *Other_functionContext) LEADING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEADING, 0)
}

func (s *Other_functionContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRAILING, 0)
}

func (s *Other_functionContext) BOTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBOTH, 0)
}

func (s *Other_functionContext) XMLAGG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLAGG, 0)
}

func (s *Other_functionContext) Order_by_clause() IOrder_by_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Other_functionContext) General_element_part() IGeneral_element_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_element_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_element_partContext)
}

func (s *Other_functionContext) AllXml_multiuse_expression_element() []IXml_multiuse_expression_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXml_multiuse_expression_elementContext)(nil)).Elem())
	var tst = make([]IXml_multiuse_expression_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXml_multiuse_expression_elementContext)
		}
	}

	return tst
}

func (s *Other_functionContext) Xml_multiuse_expression_element(i int) IXml_multiuse_expression_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXml_multiuse_expression_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXml_multiuse_expression_elementContext)
}

func (s *Other_functionContext) XMLCOLATTVAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLCOLATTVAL, 0)
}

func (s *Other_functionContext) XMLFOREST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLFOREST, 0)
}

func (s *Other_functionContext) XMLELEMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLELEMENT, 0)
}

func (s *Other_functionContext) Xml_attributes_clause() IXml_attributes_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXml_attributes_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXml_attributes_clauseContext)
}

func (s *Other_functionContext) ENTITYESCAPING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserENTITYESCAPING, 0)
}

func (s *Other_functionContext) NOENTITYESCAPING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOENTITYESCAPING, 0)
}

func (s *Other_functionContext) NAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAME, 0)
}

func (s *Other_functionContext) EVALNAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEVALNAME, 0)
}

func (s *Other_functionContext) AllColumn_alias() []IColumn_aliasContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem())
	var tst = make([]IColumn_aliasContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_aliasContext)
		}
	}

	return tst
}

func (s *Other_functionContext) Column_alias(i int) IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Other_functionContext) XMLEXISTS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLEXISTS, 0)
}

func (s *Other_functionContext) Xml_passing_clause() IXml_passing_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXml_passing_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXml_passing_clauseContext)
}

func (s *Other_functionContext) XMLPARSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLPARSE, 0)
}

func (s *Other_functionContext) DOCUMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDOCUMENT, 0)
}

func (s *Other_functionContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONTENT, 0)
}

func (s *Other_functionContext) WELLFORMED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWELLFORMED, 0)
}

func (s *Other_functionContext) XMLPI() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLPI, 0)
}

func (s *Other_functionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Other_functionContext) XMLQUERY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLQUERY, 0)
}

func (s *Other_functionContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURNING, 0)
}

func (s *Other_functionContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *Other_functionContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Other_functionContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEMPTY, 0)
}

func (s *Other_functionContext) XMLROOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLROOT, 0)
}

func (s *Other_functionContext) Xmlroot_param_version_part() IXmlroot_param_version_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXmlroot_param_version_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXmlroot_param_version_partContext)
}

func (s *Other_functionContext) Xmlroot_param_standalone_part() IXmlroot_param_standalone_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXmlroot_param_standalone_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXmlroot_param_standalone_partContext)
}

func (s *Other_functionContext) XMLSERIALIZE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLSERIALIZE, 0)
}

func (s *Other_functionContext) Xmlserialize_param_enconding_part() IXmlserialize_param_enconding_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXmlserialize_param_enconding_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXmlserialize_param_enconding_partContext)
}

func (s *Other_functionContext) Xmlserialize_param_version_part() IXmlserialize_param_version_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXmlserialize_param_version_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXmlserialize_param_version_partContext)
}

func (s *Other_functionContext) Xmlserialize_param_ident_part() IXmlserialize_param_ident_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXmlserialize_param_ident_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXmlserialize_param_ident_partContext)
}

func (s *Other_functionContext) DEFAULTS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFAULTS, 0)
}

func (s *Other_functionContext) HIDE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserHIDE, 0)
}

func (s *Other_functionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSHOW, 0)
}

func (s *Other_functionContext) XMLTABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLTABLE, 0)
}

func (s *Other_functionContext) Xml_namespaces_clause() IXml_namespaces_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXml_namespaces_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXml_namespaces_clauseContext)
}

func (s *Other_functionContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOLUMNS, 0)
}

func (s *Other_functionContext) AllXml_table_column() []IXml_table_columnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXml_table_columnContext)(nil)).Elem())
	var tst = make([]IXml_table_columnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXml_table_columnContext)
		}
	}

	return tst
}

func (s *Other_functionContext) Xml_table_column(i int) IXml_table_columnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXml_table_columnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXml_table_columnContext)
}

func (s *Other_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Other_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Other_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOther_function(s)
	}
}

func (s *Other_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOther_function(s)
	}
}

func (p *PlSqlParser) Other_function() (localctx IOther_functionContext) {
	localctx = NewOther_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, PlSqlParserRULE_other_function)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(4959)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 635, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4644)
			p.Over_clause_keyword()
		}
		{
			p.SetState(4645)
			p.Function_argument_analytic()
		}
		p.SetState(4647)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 582, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4646)
				p.Over_clause()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4649)
			p.Regular_id()
		}
		{
			p.SetState(4650)
			p.Function_argument_modeling()
		}
		p.SetState(4652)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 583, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4651)
				p.Using_clause()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4654)
			p.Match(PlSqlParserCOUNT)
		}
		{
			p.SetState(4655)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4661)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserASTERISK:
			{
				p.SetState(4656)
				p.Match(PlSqlParserASTERISK)
			}

		case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALL, PlSqlParserANALYZE, PlSqlParserANY, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOALESCE, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONNECT_BY_ROOT, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDISTINCT, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXISTS, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFALSE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPRIOR, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUE, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNIQUE, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserDECODE, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserNVL, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROUND, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTO_CHAR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserLEAST, PlSqlParserGREATEST, PlSqlParserTO_DATE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserPLUS_SIGN, PlSqlParserMINUS_SIGN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
			p.SetState(4658)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 584, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4657)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserALL || _la == PlSqlParserDISTINCT || _la == PlSqlParserUNIQUE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(4660)
				p.concatenation(0)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(4663)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4665)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 586, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4664)
				p.Over_clause()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4667)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserCAST || _la == PlSqlParserXMLCAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4668)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4675)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 587, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4669)
				p.Match(PlSqlParserMULTISET)
			}
			{
				p.SetState(4670)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			{
				p.SetState(4671)
				p.Subquery()
			}
			{
				p.SetState(4672)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		case 2:
			{
				p.SetState(4674)
				p.concatenation(0)
			}

		}
		{
			p.SetState(4677)
			p.Match(PlSqlParserAS)
		}
		{
			p.SetState(4678)
			p.Type_spec()
		}
		{
			p.SetState(4679)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4681)
			p.Match(PlSqlParserCOALESCE)
		}
		{
			p.SetState(4682)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4683)
			p.Table_element()
		}
		p.SetState(4689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOMMA {
			{
				p.SetState(4684)
				p.Match(PlSqlParserCOMMA)
			}
			p.SetState(4687)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT:
				{
					p.SetState(4685)
					p.Numeric()
				}

			case PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserCHAR_STRING:
				{
					p.SetState(4686)
					p.Quoted_string()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		{
			p.SetState(4691)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4693)
			p.Match(PlSqlParserCOLLECT)
		}
		{
			p.SetState(4694)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4696)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 590, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4695)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserDISTINCT || _la == PlSqlParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(4698)
			p.concatenation(0)
		}
		p.SetState(4700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserORDER {
			{
				p.SetState(4699)
				p.Collect_order_by_part()
			}

		}
		{
			p.SetState(4702)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4704)
			p.Within_or_over_clause_keyword()
		}
		{
			p.SetState(4705)
			p.Function_argument()
		}
		p.SetState(4707)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4706)
					p.Within_or_over_part()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(4709)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 592, p.GetParserRuleContext())
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4711)
			p.Cursor_name()
		}
		{
			p.SetState(4712)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-312)&-(0x1f+1)) == 0 && ((1<<uint((_la-312)))&((1<<(PlSqlParserPERCENT_FOUND-312))|(1<<(PlSqlParserPERCENT_ISOPEN-312))|(1<<(PlSqlParserPERCENT_NOTFOUND-312))|(1<<(PlSqlParserPERCENT_ROWCOUNT-312)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4714)
			p.Match(PlSqlParserDECOMPOSE)
		}
		{
			p.SetState(4715)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4716)
			p.concatenation(0)
		}
		p.SetState(4718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCANONICAL || _la == PlSqlParserCOMPATIBILITY {
			{
				p.SetState(4717)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserCANONICAL || _la == PlSqlParserCOMPATIBILITY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(4720)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4722)
			p.Match(PlSqlParserEXTRACT)
		}
		{
			p.SetState(4723)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4724)
			p.Regular_id()
		}
		{
			p.SetState(4725)
			p.Match(PlSqlParserFROM)
		}
		{
			p.SetState(4726)
			p.concatenation(0)
		}
		{
			p.SetState(4727)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4729)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserFIRST_VALUE || _la == PlSqlParserLAST_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4730)
			p.Function_argument_analytic()
		}
		p.SetState(4732)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserIGNORE || _la == PlSqlParserRESPECT {
			{
				p.SetState(4731)
				p.Respect_or_ignore_nulls()
			}

		}
		{
			p.SetState(4734)
			p.Over_clause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4736)
			p.Standard_prediction_function_keyword()
		}
		{
			p.SetState(4737)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4738)
			p.Expressions()
		}
		p.SetState(4740)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOST {
			{
				p.SetState(4739)
				p.Cost_matrix_clause()
			}

		}
		p.SetState(4743)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserUSING {
			{
				p.SetState(4742)
				p.Using_clause()
			}

		}
		{
			p.SetState(4745)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4747)
			p.Match(PlSqlParserTRANSLATE)
		}
		{
			p.SetState(4748)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4749)
			p.Expression()
		}
		p.SetState(4752)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserUSING {
			{
				p.SetState(4750)
				p.Match(PlSqlParserUSING)
			}
			{
				p.SetState(4751)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserCHAR_CS || _la == PlSqlParserNCHAR_CS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(4758)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(4754)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4755)
				p.Expression()
			}

			p.SetState(4760)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4761)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4763)
			p.Match(PlSqlParserTREAT)
		}
		{
			p.SetState(4764)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4765)
			p.Expression()
		}
		{
			p.SetState(4766)
			p.Match(PlSqlParserAS)
		}
		p.SetState(4768)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 599, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4767)
				p.Match(PlSqlParserREF)
			}

		}
		{
			p.SetState(4770)
			p.Type_spec()
		}
		{
			p.SetState(4771)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4773)
			p.Match(PlSqlParserTRIM)
		}
		{
			p.SetState(4774)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4782)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 602, p.GetParserRuleContext()) == 1 {
			p.SetState(4776)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserBOTH || _la == PlSqlParserLEADING || _la == PlSqlParserTRAILING {
				{
					p.SetState(4775)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PlSqlParserBOTH || _la == PlSqlParserLEADING || _la == PlSqlParserTRAILING) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(4779)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserNATIONAL_CHAR_STRING_LIT || _la == PlSqlParserCHAR_STRING {
				{
					p.SetState(4778)
					p.Quoted_string()
				}

			}
			{
				p.SetState(4781)
				p.Match(PlSqlParserFROM)
			}

		}
		{
			p.SetState(4784)
			p.concatenation(0)
		}
		{
			p.SetState(4785)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(4787)
			p.Match(PlSqlParserXMLAGG)
		}
		{
			p.SetState(4788)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4789)
			p.Expression()
		}
		p.SetState(4791)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserORDER {
			{
				p.SetState(4790)
				p.Order_by_clause()
			}

		}
		{
			p.SetState(4793)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4796)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 604, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4794)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(4795)
				p.General_element_part()
			}

		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(4798)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserXMLCOLATTVAL || _la == PlSqlParserXMLFOREST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4799)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4800)
			p.Xml_multiuse_expression_element()
		}
		p.SetState(4805)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(4801)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4802)
				p.Xml_multiuse_expression_element()
			}

			p.SetState(4807)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4808)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4811)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 606, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4809)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(4810)
				p.General_element_part()
			}

		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(4813)
			p.Match(PlSqlParserXMLELEMENT)
		}
		{
			p.SetState(4814)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4816)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 607, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4815)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserENTITYESCAPING || _la == PlSqlParserNOENTITYESCAPING) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(4819)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 608, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4818)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserEVALNAME || _la == PlSqlParserNAME) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(4821)
			p.Expression()
		}
		p.SetState(4824)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 609, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4822)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4823)
				p.Xml_attributes_clause()
			}

		}
		p.SetState(4833)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(4826)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4827)
				p.Expression()
			}
			p.SetState(4829)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserAS)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-521))|(1<<(PlSqlParserCHAR_STRING-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
				{
					p.SetState(4828)
					p.Column_alias()
				}

			}

			p.SetState(4835)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4836)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4839)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 612, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4837)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(4838)
				p.General_element_part()
			}

		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(4841)
			p.Match(PlSqlParserXMLEXISTS)
		}
		{
			p.SetState(4842)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4843)
			p.Expression()
		}
		p.SetState(4845)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserPASSING {
			{
				p.SetState(4844)
				p.Xml_passing_clause()
			}

		}
		{
			p.SetState(4847)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(4849)
			p.Match(PlSqlParserXMLPARSE)
		}
		{
			p.SetState(4850)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4851)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserCONTENT || _la == PlSqlParserDOCUMENT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4852)
			p.concatenation(0)
		}
		p.SetState(4854)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserWELLFORMED {
			{
				p.SetState(4853)
				p.Match(PlSqlParserWELLFORMED)
			}

		}
		{
			p.SetState(4856)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4859)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 615, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4857)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(4858)
				p.General_element_part()
			}

		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(4861)
			p.Match(PlSqlParserXMLPI)
		}
		{
			p.SetState(4862)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4867)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserNAME:
			{
				p.SetState(4863)
				p.Match(PlSqlParserNAME)
			}
			{
				p.SetState(4864)
				p.Identifier()
			}

		case PlSqlParserEVALNAME:
			{
				p.SetState(4865)
				p.Match(PlSqlParserEVALNAME)
			}
			{
				p.SetState(4866)
				p.concatenation(0)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(4871)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOMMA {
			{
				p.SetState(4869)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4870)
				p.concatenation(0)
			}

		}
		{
			p.SetState(4873)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4876)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 618, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4874)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(4875)
				p.General_element_part()
			}

		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(4878)
			p.Match(PlSqlParserXMLQUERY)
		}
		{
			p.SetState(4879)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4880)
			p.concatenation(0)
		}
		p.SetState(4882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserPASSING {
			{
				p.SetState(4881)
				p.Xml_passing_clause()
			}

		}
		{
			p.SetState(4884)
			p.Match(PlSqlParserRETURNING)
		}
		{
			p.SetState(4885)
			p.Match(PlSqlParserCONTENT)
		}
		p.SetState(4889)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserNULL {
			{
				p.SetState(4886)
				p.Match(PlSqlParserNULL)
			}
			{
				p.SetState(4887)
				p.Match(PlSqlParserON)
			}
			{
				p.SetState(4888)
				p.Match(PlSqlParserEMPTY)
			}

		}
		{
			p.SetState(4891)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4894)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 621, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4892)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(4893)
				p.General_element_part()
			}

		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(4896)
			p.Match(PlSqlParserXMLROOT)
		}
		{
			p.SetState(4897)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4898)
			p.concatenation(0)
		}
		p.SetState(4901)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 622, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4899)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4900)
				p.Xmlroot_param_version_part()
			}

		}
		p.SetState(4905)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOMMA {
			{
				p.SetState(4903)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4904)
				p.Xmlroot_param_standalone_part()
			}

		}
		{
			p.SetState(4907)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4910)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 624, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4908)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(4909)
				p.General_element_part()
			}

		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(4912)
			p.Match(PlSqlParserXMLSERIALIZE)
		}
		{
			p.SetState(4913)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(4914)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserCONTENT || _la == PlSqlParserDOCUMENT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4915)
			p.concatenation(0)
		}
		p.SetState(4918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserAS {
			{
				p.SetState(4916)
				p.Match(PlSqlParserAS)
			}
			{
				p.SetState(4917)
				p.Type_spec()
			}

		}
		p.SetState(4921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserENCODING {
			{
				p.SetState(4920)
				p.Xmlserialize_param_enconding_part()
			}

		}
		p.SetState(4924)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserVERSION {
			{
				p.SetState(4923)
				p.Xmlserialize_param_version_part()
			}

		}
		p.SetState(4927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserINDENT || _la == PlSqlParserNO {
			{
				p.SetState(4926)
				p.Xmlserialize_param_ident_part()
			}

		}
		p.SetState(4931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserHIDE || _la == PlSqlParserSHOW {
			{
				p.SetState(4929)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserHIDE || _la == PlSqlParserSHOW) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(4930)
				p.Match(PlSqlParserDEFAULTS)
			}

		}
		{
			p.SetState(4933)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4936)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 630, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4934)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(4935)
				p.General_element_part()
			}

		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(4938)
			p.Match(PlSqlParserXMLTABLE)
		}
		{
			p.SetState(4939)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(4941)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 631, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4940)
				p.Xml_namespaces_clause()
			}

		}
		{
			p.SetState(4943)
			p.concatenation(0)
		}
		p.SetState(4945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserPASSING {
			{
				p.SetState(4944)
				p.Xml_passing_clause()
			}

		}
		p.SetState(4952)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOLUMNS {
			{
				p.SetState(4947)
				p.Match(PlSqlParserCOLUMNS)
			}
			{
				p.SetState(4948)
				p.Xml_table_column()
			}

			{
				p.SetState(4949)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(4950)
				p.Xml_table_column()
			}

		}
		{
			p.SetState(4954)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		p.SetState(4957)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 634, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4955)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(4956)
				p.General_element_part()
			}

		}

	}

	return localctx
}

// IOver_clause_keywordContext is an interface to support dynamic dispatch.
type IOver_clause_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOver_clause_keywordContext differentiates from other interfaces.
	IsOver_clause_keywordContext()
}

type Over_clause_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOver_clause_keywordContext() *Over_clause_keywordContext {
	var p = new(Over_clause_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_over_clause_keyword
	return p
}

func (*Over_clause_keywordContext) IsOver_clause_keywordContext() {}

func NewOver_clause_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Over_clause_keywordContext {
	var p = new(Over_clause_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_over_clause_keyword

	return p
}

func (s *Over_clause_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Over_clause_keywordContext) AVG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAVG, 0)
}

func (s *Over_clause_keywordContext) CORR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCORR, 0)
}

func (s *Over_clause_keywordContext) LAG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLAG, 0)
}

func (s *Over_clause_keywordContext) LEAD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEAD, 0)
}

func (s *Over_clause_keywordContext) MAX() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAX, 0)
}

func (s *Over_clause_keywordContext) MEDIAN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEDIAN, 0)
}

func (s *Over_clause_keywordContext) MIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMIN, 0)
}

func (s *Over_clause_keywordContext) NTILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNTILE, 0)
}

func (s *Over_clause_keywordContext) RATIO_TO_REPORT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRATIO_TO_REPORT, 0)
}

func (s *Over_clause_keywordContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROW_NUMBER, 0)
}

func (s *Over_clause_keywordContext) SUM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUM, 0)
}

func (s *Over_clause_keywordContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARIANCE, 0)
}

func (s *Over_clause_keywordContext) REGR_() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREGR_, 0)
}

func (s *Over_clause_keywordContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTDDEV, 0)
}

func (s *Over_clause_keywordContext) VAR_() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVAR_, 0)
}

func (s *Over_clause_keywordContext) COVAR_() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOVAR_, 0)
}

func (s *Over_clause_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Over_clause_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Over_clause_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOver_clause_keyword(s)
	}
}

func (s *Over_clause_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOver_clause_keyword(s)
	}
}

func (p *PlSqlParser) Over_clause_keyword() (localctx IOver_clause_keywordContext) {
	localctx = NewOver_clause_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, PlSqlParserRULE_over_clause_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4961)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-507)&-(0x1f+1)) == 0 && ((1<<uint((_la-507)))&((1<<(PlSqlParserAVG-507))|(1<<(PlSqlParserCORR-507))|(1<<(PlSqlParserCOVAR_-507))|(1<<(PlSqlParserLAG-507))|(1<<(PlSqlParserLEAD-507))|(1<<(PlSqlParserMAX-507))|(1<<(PlSqlParserMEDIAN-507))|(1<<(PlSqlParserMIN-507))|(1<<(PlSqlParserNTILE-507))|(1<<(PlSqlParserRATIO_TO_REPORT-507))|(1<<(PlSqlParserREGR_-507))|(1<<(PlSqlParserROW_NUMBER-507))|(1<<(PlSqlParserSUM-507))|(1<<(PlSqlParserSTDDEV-507))|(1<<(PlSqlParserVAR_-507))|(1<<(PlSqlParserVARIANCE-507)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IWithin_or_over_clause_keywordContext is an interface to support dynamic dispatch.
type IWithin_or_over_clause_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithin_or_over_clause_keywordContext differentiates from other interfaces.
	IsWithin_or_over_clause_keywordContext()
}

type Within_or_over_clause_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithin_or_over_clause_keywordContext() *Within_or_over_clause_keywordContext {
	var p = new(Within_or_over_clause_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_within_or_over_clause_keyword
	return p
}

func (*Within_or_over_clause_keywordContext) IsWithin_or_over_clause_keywordContext() {}

func NewWithin_or_over_clause_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Within_or_over_clause_keywordContext {
	var p = new(Within_or_over_clause_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_within_or_over_clause_keyword

	return p
}

func (s *Within_or_over_clause_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Within_or_over_clause_keywordContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCUME_DIST, 0)
}

func (s *Within_or_over_clause_keywordContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDENSE_RANK, 0)
}

func (s *Within_or_over_clause_keywordContext) LISTAGG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLISTAGG, 0)
}

func (s *Within_or_over_clause_keywordContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENT_RANK, 0)
}

func (s *Within_or_over_clause_keywordContext) PERCENTILE_CONT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENTILE_CONT, 0)
}

func (s *Within_or_over_clause_keywordContext) PERCENTILE_DISC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENTILE_DISC, 0)
}

func (s *Within_or_over_clause_keywordContext) RANK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRANK, 0)
}

func (s *Within_or_over_clause_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Within_or_over_clause_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Within_or_over_clause_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterWithin_or_over_clause_keyword(s)
	}
}

func (s *Within_or_over_clause_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitWithin_or_over_clause_keyword(s)
	}
}

func (p *PlSqlParser) Within_or_over_clause_keyword() (localctx IWithin_or_over_clause_keywordContext) {
	localctx = NewWithin_or_over_clause_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, PlSqlParserRULE_within_or_over_clause_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4963)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-500)&-(0x1f+1)) == 0 && ((1<<uint((_la-500)))&((1<<(PlSqlParserCUME_DIST-500))|(1<<(PlSqlParserDENSE_RANK-500))|(1<<(PlSqlParserLISTAGG-500))|(1<<(PlSqlParserPERCENT_RANK-500))|(1<<(PlSqlParserPERCENTILE_CONT-500))|(1<<(PlSqlParserPERCENTILE_DISC-500))|(1<<(PlSqlParserRANK-500)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStandard_prediction_function_keywordContext is an interface to support dynamic dispatch.
type IStandard_prediction_function_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandard_prediction_function_keywordContext differentiates from other interfaces.
	IsStandard_prediction_function_keywordContext()
}

type Standard_prediction_function_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandard_prediction_function_keywordContext() *Standard_prediction_function_keywordContext {
	var p = new(Standard_prediction_function_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_standard_prediction_function_keyword
	return p
}

func (*Standard_prediction_function_keywordContext) IsStandard_prediction_function_keywordContext() {}

func NewStandard_prediction_function_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Standard_prediction_function_keywordContext {
	var p = new(Standard_prediction_function_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_standard_prediction_function_keyword

	return p
}

func (s *Standard_prediction_function_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Standard_prediction_function_keywordContext) PREDICTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION, 0)
}

func (s *Standard_prediction_function_keywordContext) PREDICTION_BOUNDS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_BOUNDS, 0)
}

func (s *Standard_prediction_function_keywordContext) PREDICTION_COST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_COST, 0)
}

func (s *Standard_prediction_function_keywordContext) PREDICTION_DETAILS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_DETAILS, 0)
}

func (s *Standard_prediction_function_keywordContext) PREDICTION_PROBABILITY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_PROBABILITY, 0)
}

func (s *Standard_prediction_function_keywordContext) PREDICTION_SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_SET, 0)
}

func (s *Standard_prediction_function_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Standard_prediction_function_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Standard_prediction_function_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterStandard_prediction_function_keyword(s)
	}
}

func (s *Standard_prediction_function_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitStandard_prediction_function_keyword(s)
	}
}

func (p *PlSqlParser) Standard_prediction_function_keyword() (localctx IStandard_prediction_function_keywordContext) {
	localctx = NewStandard_prediction_function_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, PlSqlParserRULE_standard_prediction_function_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4965)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-494)&-(0x1f+1)) == 0 && ((1<<uint((_la-494)))&((1<<(PlSqlParserPREDICTION-494))|(1<<(PlSqlParserPREDICTION_BOUNDS-494))|(1<<(PlSqlParserPREDICTION_COST-494))|(1<<(PlSqlParserPREDICTION_DETAILS-494))|(1<<(PlSqlParserPREDICTION_PROBABILITY-494))|(1<<(PlSqlParserPREDICTION_SET-494)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOver_clauseContext is an interface to support dynamic dispatch.
type IOver_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOver_clauseContext differentiates from other interfaces.
	IsOver_clauseContext()
}

type Over_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOver_clauseContext() *Over_clauseContext {
	var p = new(Over_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_over_clause
	return p
}

func (*Over_clauseContext) IsOver_clauseContext() {}

func NewOver_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Over_clauseContext {
	var p = new(Over_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_over_clause

	return p
}

func (s *Over_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Over_clauseContext) OVER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOVER, 0)
}

func (s *Over_clauseContext) Query_partition_clause() IQuery_partition_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_partition_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_partition_clauseContext)
}

func (s *Over_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Over_clauseContext) Windowing_clause() IWindowing_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowing_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowing_clauseContext)
}

func (s *Over_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Over_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Over_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOver_clause(s)
	}
}

func (s *Over_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOver_clause(s)
	}
}

func (p *PlSqlParser) Over_clause() (localctx IOver_clauseContext) {
	localctx = NewOver_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, PlSqlParserRULE_over_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4967)
		p.Match(PlSqlParserOVER)
	}
	{
		p.SetState(4968)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(4970)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPARTITION {
		{
			p.SetState(4969)
			p.Query_partition_clause()
		}

	}
	p.SetState(4976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserORDER {
		{
			p.SetState(4972)
			p.Order_by_clause()
		}
		p.SetState(4974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserRANGE || _la == PlSqlParserROWS {
			{
				p.SetState(4973)
				p.Windowing_clause()
			}

		}

	}
	{
		p.SetState(4978)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IWindowing_clauseContext is an interface to support dynamic dispatch.
type IWindowing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowing_clauseContext differentiates from other interfaces.
	IsWindowing_clauseContext()
}

type Windowing_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowing_clauseContext() *Windowing_clauseContext {
	var p = new(Windowing_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_windowing_clause
	return p
}

func (*Windowing_clauseContext) IsWindowing_clauseContext() {}

func NewWindowing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Windowing_clauseContext {
	var p = new(Windowing_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_windowing_clause

	return p
}

func (s *Windowing_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Windowing_clauseContext) Windowing_type() IWindowing_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowing_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowing_typeContext)
}

func (s *Windowing_clauseContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBETWEEN, 0)
}

func (s *Windowing_clauseContext) AllWindowing_elements() []IWindowing_elementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWindowing_elementsContext)(nil)).Elem())
	var tst = make([]IWindowing_elementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWindowing_elementsContext)
		}
	}

	return tst
}

func (s *Windowing_clauseContext) Windowing_elements(i int) IWindowing_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowing_elementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWindowing_elementsContext)
}

func (s *Windowing_clauseContext) AND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAND, 0)
}

func (s *Windowing_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Windowing_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Windowing_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterWindowing_clause(s)
	}
}

func (s *Windowing_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitWindowing_clause(s)
	}
}

func (p *PlSqlParser) Windowing_clause() (localctx IWindowing_clauseContext) {
	localctx = NewWindowing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, PlSqlParserRULE_windowing_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4980)
		p.Windowing_type()
	}
	p.SetState(4987)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserBETWEEN:
		{
			p.SetState(4981)
			p.Match(PlSqlParserBETWEEN)
		}
		{
			p.SetState(4982)
			p.Windowing_elements()
		}
		{
			p.SetState(4983)
			p.Match(PlSqlParserAND)
		}
		{
			p.SetState(4984)
			p.Windowing_elements()
		}

	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALL, PlSqlParserANALYZE, PlSqlParserANY, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOALESCE, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONNECT_BY_ROOT, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDISTINCT, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXISTS, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFALSE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPRIOR, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUE, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserDECODE, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserNVL, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROUND, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTO_CHAR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserLEAST, PlSqlParserGREATEST, PlSqlParserTO_DATE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserPLUS_SIGN, PlSqlParserMINUS_SIGN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(4986)
			p.Windowing_elements()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWindowing_typeContext is an interface to support dynamic dispatch.
type IWindowing_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowing_typeContext differentiates from other interfaces.
	IsWindowing_typeContext()
}

type Windowing_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowing_typeContext() *Windowing_typeContext {
	var p = new(Windowing_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_windowing_type
	return p
}

func (*Windowing_typeContext) IsWindowing_typeContext() {}

func NewWindowing_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Windowing_typeContext {
	var p = new(Windowing_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_windowing_type

	return p
}

func (s *Windowing_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Windowing_typeContext) ROWS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROWS, 0)
}

func (s *Windowing_typeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRANGE, 0)
}

func (s *Windowing_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Windowing_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Windowing_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterWindowing_type(s)
	}
}

func (s *Windowing_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitWindowing_type(s)
	}
}

func (p *PlSqlParser) Windowing_type() (localctx IWindowing_typeContext) {
	localctx = NewWindowing_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, PlSqlParserRULE_windowing_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4989)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserRANGE || _la == PlSqlParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IWindowing_elementsContext is an interface to support dynamic dispatch.
type IWindowing_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowing_elementsContext differentiates from other interfaces.
	IsWindowing_elementsContext()
}

type Windowing_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowing_elementsContext() *Windowing_elementsContext {
	var p = new(Windowing_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_windowing_elements
	return p
}

func (*Windowing_elementsContext) IsWindowing_elementsContext() {}

func NewWindowing_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Windowing_elementsContext {
	var p = new(Windowing_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_windowing_elements

	return p
}

func (s *Windowing_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Windowing_elementsContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNBOUNDED, 0)
}

func (s *Windowing_elementsContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRECEDING, 0)
}

func (s *Windowing_elementsContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCURRENT, 0)
}

func (s *Windowing_elementsContext) ROW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROW, 0)
}

func (s *Windowing_elementsContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Windowing_elementsContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOLLOWING, 0)
}

func (s *Windowing_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Windowing_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Windowing_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterWindowing_elements(s)
	}
}

func (s *Windowing_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitWindowing_elements(s)
	}
}

func (p *PlSqlParser) Windowing_elements() (localctx IWindowing_elementsContext) {
	localctx = NewWindowing_elementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, PlSqlParserRULE_windowing_elements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4998)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 640, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4991)
			p.Match(PlSqlParserUNBOUNDED)
		}
		{
			p.SetState(4992)
			p.Match(PlSqlParserPRECEDING)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4993)
			p.Match(PlSqlParserCURRENT)
		}
		{
			p.SetState(4994)
			p.Match(PlSqlParserROW)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4995)
			p.concatenation(0)
		}
		{
			p.SetState(4996)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserFOLLOWING || _la == PlSqlParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IUsing_clauseContext is an interface to support dynamic dispatch.
type IUsing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsing_clauseContext differentiates from other interfaces.
	IsUsing_clauseContext()
}

type Using_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_clauseContext() *Using_clauseContext {
	var p = new(Using_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_using_clause
	return p
}

func (*Using_clauseContext) IsUsing_clauseContext() {}

func NewUsing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_clauseContext {
	var p = new(Using_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_using_clause

	return p
}

func (s *Using_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_clauseContext) USING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSING, 0)
}

func (s *Using_clauseContext) AllUsing_element() []IUsing_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUsing_elementContext)(nil)).Elem())
	var tst = make([]IUsing_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUsing_elementContext)
		}
	}

	return tst
}

func (s *Using_clauseContext) Using_element(i int) IUsing_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsing_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUsing_elementContext)
}

func (s *Using_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Using_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUsing_clause(s)
	}
}

func (s *Using_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUsing_clause(s)
	}
}

func (p *PlSqlParser) Using_clause() (localctx IUsing_clauseContext) {
	localctx = NewUsing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, PlSqlParserRULE_using_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5000)
		p.Match(PlSqlParserUSING)
	}
	p.SetState(5010)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserASTERISK:
		{
			p.SetState(5001)
			p.Match(PlSqlParserASTERISK)
		}

	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALL, PlSqlParserANALYZE, PlSqlParserANY, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOALESCE, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONNECT_BY_ROOT, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDISTINCT, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXISTS, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFALSE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserIN, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNOT, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPRIOR, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUE, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserDECODE, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserNVL, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROUND, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTO_CHAR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserLEAST, PlSqlParserGREATEST, PlSqlParserTO_DATE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserPLUS_SIGN, PlSqlParserMINUS_SIGN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(5002)
			p.Using_element()
		}
		p.SetState(5007)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 641, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5003)
					p.Match(PlSqlParserCOMMA)
				}
				{
					p.SetState(5004)
					p.Using_element()
				}

			}
			p.SetState(5009)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 641, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUsing_elementContext is an interface to support dynamic dispatch.
type IUsing_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsing_elementContext differentiates from other interfaces.
	IsUsing_elementContext()
}

type Using_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_elementContext() *Using_elementContext {
	var p = new(Using_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_using_element
	return p
}

func (*Using_elementContext) IsUsing_elementContext() {}

func NewUsing_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_elementContext {
	var p = new(Using_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_using_element

	return p
}

func (s *Using_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_elementContext) Select_list_elements() ISelect_list_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_list_elementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_list_elementsContext)
}

func (s *Using_elementContext) IN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIN, 0)
}

func (s *Using_elementContext) OUT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOUT, 0)
}

func (s *Using_elementContext) Column_alias() IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Using_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Using_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterUsing_element(s)
	}
}

func (s *Using_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitUsing_element(s)
	}
}

func (p *PlSqlParser) Using_element() (localctx IUsing_elementContext) {
	localctx = NewUsing_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, PlSqlParserRULE_using_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5017)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 644, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5012)
			p.Match(PlSqlParserIN)
		}
		p.SetState(5014)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 643, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5013)
				p.Match(PlSqlParserOUT)
			}

		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 644, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5016)
			p.Match(PlSqlParserOUT)
		}

	}
	{
		p.SetState(5019)
		p.Select_list_elements()
	}
	p.SetState(5021)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 645, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5020)
			p.Column_alias()
		}

	}

	return localctx
}

// ICollect_order_by_partContext is an interface to support dynamic dispatch.
type ICollect_order_by_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollect_order_by_partContext differentiates from other interfaces.
	IsCollect_order_by_partContext()
}

type Collect_order_by_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollect_order_by_partContext() *Collect_order_by_partContext {
	var p = new(Collect_order_by_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_collect_order_by_part
	return p
}

func (*Collect_order_by_partContext) IsCollect_order_by_partContext() {}

func NewCollect_order_by_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collect_order_by_partContext {
	var p = new(Collect_order_by_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_collect_order_by_part

	return p
}

func (s *Collect_order_by_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Collect_order_by_partContext) ORDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORDER, 0)
}

func (s *Collect_order_by_partContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Collect_order_by_partContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Collect_order_by_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collect_order_by_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collect_order_by_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCollect_order_by_part(s)
	}
}

func (s *Collect_order_by_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCollect_order_by_part(s)
	}
}

func (p *PlSqlParser) Collect_order_by_part() (localctx ICollect_order_by_partContext) {
	localctx = NewCollect_order_by_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, PlSqlParserRULE_collect_order_by_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5023)
		p.Match(PlSqlParserORDER)
	}
	{
		p.SetState(5024)
		p.Match(PlSqlParserBY)
	}
	{
		p.SetState(5025)
		p.concatenation(0)
	}

	return localctx
}

// IWithin_or_over_partContext is an interface to support dynamic dispatch.
type IWithin_or_over_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithin_or_over_partContext differentiates from other interfaces.
	IsWithin_or_over_partContext()
}

type Within_or_over_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithin_or_over_partContext() *Within_or_over_partContext {
	var p = new(Within_or_over_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_within_or_over_part
	return p
}

func (*Within_or_over_partContext) IsWithin_or_over_partContext() {}

func NewWithin_or_over_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Within_or_over_partContext {
	var p = new(Within_or_over_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_within_or_over_part

	return p
}

func (s *Within_or_over_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Within_or_over_partContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWITHIN, 0)
}

func (s *Within_or_over_partContext) GROUP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserGROUP, 0)
}

func (s *Within_or_over_partContext) Order_by_clause() IOrder_by_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Within_or_over_partContext) Over_clause() IOver_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOver_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOver_clauseContext)
}

func (s *Within_or_over_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Within_or_over_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Within_or_over_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterWithin_or_over_part(s)
	}
}

func (s *Within_or_over_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitWithin_or_over_part(s)
	}
}

func (p *PlSqlParser) Within_or_over_part() (localctx IWithin_or_over_partContext) {
	localctx = NewWithin_or_over_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, PlSqlParserRULE_within_or_over_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5034)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserWITHIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5027)
			p.Match(PlSqlParserWITHIN)
		}
		{
			p.SetState(5028)
			p.Match(PlSqlParserGROUP)
		}
		{
			p.SetState(5029)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(5030)
			p.Order_by_clause()
		}
		{
			p.SetState(5031)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	case PlSqlParserOVER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5033)
			p.Over_clause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICost_matrix_clauseContext is an interface to support dynamic dispatch.
type ICost_matrix_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCost_matrix_clauseContext differentiates from other interfaces.
	IsCost_matrix_clauseContext()
}

type Cost_matrix_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCost_matrix_clauseContext() *Cost_matrix_clauseContext {
	var p = new(Cost_matrix_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cost_matrix_clause
	return p
}

func (*Cost_matrix_clauseContext) IsCost_matrix_clauseContext() {}

func NewCost_matrix_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cost_matrix_clauseContext {
	var p = new(Cost_matrix_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cost_matrix_clause

	return p
}

func (s *Cost_matrix_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Cost_matrix_clauseContext) COST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOST, 0)
}

func (s *Cost_matrix_clauseContext) MODEL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMODEL, 0)
}

func (s *Cost_matrix_clauseContext) AllCost_class_name() []ICost_class_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICost_class_nameContext)(nil)).Elem())
	var tst = make([]ICost_class_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICost_class_nameContext)
		}
	}

	return tst
}

func (s *Cost_matrix_clauseContext) Cost_class_name(i int) ICost_class_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICost_class_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICost_class_nameContext)
}

func (s *Cost_matrix_clauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALUES, 0)
}

func (s *Cost_matrix_clauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUTO, 0)
}

func (s *Cost_matrix_clauseContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Cost_matrix_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cost_matrix_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cost_matrix_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCost_matrix_clause(s)
	}
}

func (s *Cost_matrix_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCost_matrix_clause(s)
	}
}

func (p *PlSqlParser) Cost_matrix_clause() (localctx ICost_matrix_clauseContext) {
	localctx = NewCost_matrix_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, PlSqlParserRULE_cost_matrix_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5036)
		p.Match(PlSqlParserCOST)
	}
	p.SetState(5058)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserMODEL:
		{
			p.SetState(5037)
			p.Match(PlSqlParserMODEL)
		}
		p.SetState(5039)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserAUTO {
			{
				p.SetState(5038)
				p.Match(PlSqlParserAUTO)
			}

		}

	case PlSqlParserLEFT_PAREN:
		{
			p.SetState(5041)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		{
			p.SetState(5042)
			p.Cost_class_name()
		}
		p.SetState(5047)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(5043)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(5044)
				p.Cost_class_name()
			}

			p.SetState(5049)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5050)
			p.Match(PlSqlParserRIGHT_PAREN)
		}
		{
			p.SetState(5051)
			p.Match(PlSqlParserVALUES)
		}
		{
			p.SetState(5052)
			p.Match(PlSqlParserLEFT_PAREN)
		}
		p.SetState(5054)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
			{
				p.SetState(5053)
				p.Expressions()
			}

		}
		{
			p.SetState(5056)
			p.Match(PlSqlParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IXml_passing_clauseContext is an interface to support dynamic dispatch.
type IXml_passing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXml_passing_clauseContext differentiates from other interfaces.
	IsXml_passing_clauseContext()
}

type Xml_passing_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXml_passing_clauseContext() *Xml_passing_clauseContext {
	var p = new(Xml_passing_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xml_passing_clause
	return p
}

func (*Xml_passing_clauseContext) IsXml_passing_clauseContext() {}

func NewXml_passing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xml_passing_clauseContext {
	var p = new(Xml_passing_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xml_passing_clause

	return p
}

func (s *Xml_passing_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Xml_passing_clauseContext) PASSING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPASSING, 0)
}

func (s *Xml_passing_clauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Xml_passing_clauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Xml_passing_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBY, 0)
}

func (s *Xml_passing_clauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALUE, 0)
}

func (s *Xml_passing_clauseContext) AllColumn_alias() []IColumn_aliasContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem())
	var tst = make([]IColumn_aliasContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_aliasContext)
		}
	}

	return tst
}

func (s *Xml_passing_clauseContext) Column_alias(i int) IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Xml_passing_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xml_passing_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xml_passing_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXml_passing_clause(s)
	}
}

func (s *Xml_passing_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXml_passing_clause(s)
	}
}

func (p *PlSqlParser) Xml_passing_clause() (localctx IXml_passing_clauseContext) {
	localctx = NewXml_passing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, PlSqlParserRULE_xml_passing_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5060)
		p.Match(PlSqlParserPASSING)
	}
	p.SetState(5063)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserBY {
		{
			p.SetState(5061)
			p.Match(PlSqlParserBY)
		}
		{
			p.SetState(5062)
			p.Match(PlSqlParserVALUE)
		}

	}
	{
		p.SetState(5065)
		p.Expression()
	}
	p.SetState(5067)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserAS)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-521))|(1<<(PlSqlParserCHAR_STRING-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
		{
			p.SetState(5066)
			p.Column_alias()
		}

	}

	{
		p.SetState(5069)
		p.Match(PlSqlParserCOMMA)
	}
	{
		p.SetState(5070)
		p.Expression()
	}
	p.SetState(5072)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 653, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5071)
			p.Column_alias()
		}

	}

	return localctx
}

// IXml_attributes_clauseContext is an interface to support dynamic dispatch.
type IXml_attributes_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXml_attributes_clauseContext differentiates from other interfaces.
	IsXml_attributes_clauseContext()
}

type Xml_attributes_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXml_attributes_clauseContext() *Xml_attributes_clauseContext {
	var p = new(Xml_attributes_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xml_attributes_clause
	return p
}

func (*Xml_attributes_clauseContext) IsXml_attributes_clauseContext() {}

func NewXml_attributes_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xml_attributes_clauseContext {
	var p = new(Xml_attributes_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xml_attributes_clause

	return p
}

func (s *Xml_attributes_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Xml_attributes_clauseContext) XMLATTRIBUTES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLATTRIBUTES, 0)
}

func (s *Xml_attributes_clauseContext) AllXml_multiuse_expression_element() []IXml_multiuse_expression_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXml_multiuse_expression_elementContext)(nil)).Elem())
	var tst = make([]IXml_multiuse_expression_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXml_multiuse_expression_elementContext)
		}
	}

	return tst
}

func (s *Xml_attributes_clauseContext) Xml_multiuse_expression_element(i int) IXml_multiuse_expression_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXml_multiuse_expression_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXml_multiuse_expression_elementContext)
}

func (s *Xml_attributes_clauseContext) ENTITYESCAPING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserENTITYESCAPING, 0)
}

func (s *Xml_attributes_clauseContext) NOENTITYESCAPING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOENTITYESCAPING, 0)
}

func (s *Xml_attributes_clauseContext) SCHEMACHECK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSCHEMACHECK, 0)
}

func (s *Xml_attributes_clauseContext) NOSCHEMACHECK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOSCHEMACHECK, 0)
}

func (s *Xml_attributes_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xml_attributes_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xml_attributes_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXml_attributes_clause(s)
	}
}

func (s *Xml_attributes_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXml_attributes_clause(s)
	}
}

func (p *PlSqlParser) Xml_attributes_clause() (localctx IXml_attributes_clauseContext) {
	localctx = NewXml_attributes_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, PlSqlParserRULE_xml_attributes_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5074)
		p.Match(PlSqlParserXMLATTRIBUTES)
	}
	{
		p.SetState(5075)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(5077)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 654, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5076)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserENTITYESCAPING || _la == PlSqlParserNOENTITYESCAPING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(5080)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 655, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5079)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserNOSCHEMACHECK || _la == PlSqlParserSCHEMACHECK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5082)
		p.Xml_multiuse_expression_element()
	}
	p.SetState(5087)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(5083)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(5084)
			p.Xml_multiuse_expression_element()
		}

		p.SetState(5089)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5090)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IXml_namespaces_clauseContext is an interface to support dynamic dispatch.
type IXml_namespaces_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXml_namespaces_clauseContext differentiates from other interfaces.
	IsXml_namespaces_clauseContext()
}

type Xml_namespaces_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXml_namespaces_clauseContext() *Xml_namespaces_clauseContext {
	var p = new(Xml_namespaces_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xml_namespaces_clause
	return p
}

func (*Xml_namespaces_clauseContext) IsXml_namespaces_clauseContext() {}

func NewXml_namespaces_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xml_namespaces_clauseContext {
	var p = new(Xml_namespaces_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xml_namespaces_clause

	return p
}

func (s *Xml_namespaces_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Xml_namespaces_clauseContext) XMLNAMESPACES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLNAMESPACES, 0)
}

func (s *Xml_namespaces_clauseContext) AllConcatenation() []IConcatenationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConcatenationContext)(nil)).Elem())
	var tst = make([]IConcatenationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConcatenationContext)
		}
	}

	return tst
}

func (s *Xml_namespaces_clauseContext) Concatenation(i int) IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Xml_namespaces_clauseContext) AllColumn_alias() []IColumn_aliasContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem())
	var tst = make([]IColumn_aliasContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_aliasContext)
		}
	}

	return tst
}

func (s *Xml_namespaces_clauseContext) Column_alias(i int) IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Xml_namespaces_clauseContext) Xml_general_default_part() IXml_general_default_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXml_general_default_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXml_general_default_partContext)
}

func (s *Xml_namespaces_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xml_namespaces_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xml_namespaces_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXml_namespaces_clause(s)
	}
}

func (s *Xml_namespaces_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXml_namespaces_clause(s)
	}
}

func (p *PlSqlParser) Xml_namespaces_clause() (localctx IXml_namespaces_clauseContext) {
	localctx = NewXml_namespaces_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, PlSqlParserRULE_xml_namespaces_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5092)
		p.Match(PlSqlParserXMLNAMESPACES)
	}
	{
		p.SetState(5093)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(5097)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 657, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5094)
			p.concatenation(0)
		}
		{
			p.SetState(5095)
			p.Column_alias()
		}

	}
	p.SetState(5105)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(5099)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(5100)
			p.concatenation(0)
		}
		{
			p.SetState(5101)
			p.Column_alias()
		}

		p.SetState(5107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5109)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserDEFAULT {
		{
			p.SetState(5108)
			p.Xml_general_default_part()
		}

	}
	{
		p.SetState(5111)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IXml_table_columnContext is an interface to support dynamic dispatch.
type IXml_table_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXml_table_columnContext differentiates from other interfaces.
	IsXml_table_columnContext()
}

type Xml_table_columnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXml_table_columnContext() *Xml_table_columnContext {
	var p = new(Xml_table_columnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xml_table_column
	return p
}

func (*Xml_table_columnContext) IsXml_table_columnContext() {}

func NewXml_table_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xml_table_columnContext {
	var p = new(Xml_table_columnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xml_table_column

	return p
}

func (s *Xml_table_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Xml_table_columnContext) Xml_column_name() IXml_column_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXml_column_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXml_column_nameContext)
}

func (s *Xml_table_columnContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Xml_table_columnContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORDINALITY, 0)
}

func (s *Xml_table_columnContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Xml_table_columnContext) PATH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPATH, 0)
}

func (s *Xml_table_columnContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Xml_table_columnContext) Xml_general_default_part() IXml_general_default_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXml_general_default_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXml_general_default_partContext)
}

func (s *Xml_table_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xml_table_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xml_table_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXml_table_column(s)
	}
}

func (s *Xml_table_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXml_table_column(s)
	}
}

func (p *PlSqlParser) Xml_table_column() (localctx IXml_table_columnContext) {
	localctx = NewXml_table_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, PlSqlParserRULE_xml_table_column)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5113)
		p.Xml_column_name()
	}
	p.SetState(5124)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserFOR:
		{
			p.SetState(5114)
			p.Match(PlSqlParserFOR)
		}
		{
			p.SetState(5115)
			p.Match(PlSqlParserORDINALITY)
		}

	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserREGULAR_ID:
		{
			p.SetState(5116)
			p.Type_spec()
		}
		p.SetState(5119)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserPATH {
			{
				p.SetState(5117)
				p.Match(PlSqlParserPATH)
			}
			{
				p.SetState(5118)
				p.concatenation(0)
			}

		}
		p.SetState(5122)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserDEFAULT {
			{
				p.SetState(5121)
				p.Xml_general_default_part()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IXml_general_default_partContext is an interface to support dynamic dispatch.
type IXml_general_default_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXml_general_default_partContext differentiates from other interfaces.
	IsXml_general_default_partContext()
}

type Xml_general_default_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXml_general_default_partContext() *Xml_general_default_partContext {
	var p = new(Xml_general_default_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xml_general_default_part
	return p
}

func (*Xml_general_default_partContext) IsXml_general_default_partContext() {}

func NewXml_general_default_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xml_general_default_partContext {
	var p = new(Xml_general_default_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xml_general_default_part

	return p
}

func (s *Xml_general_default_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Xml_general_default_partContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFAULT, 0)
}

func (s *Xml_general_default_partContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Xml_general_default_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xml_general_default_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xml_general_default_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXml_general_default_part(s)
	}
}

func (s *Xml_general_default_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXml_general_default_part(s)
	}
}

func (p *PlSqlParser) Xml_general_default_part() (localctx IXml_general_default_partContext) {
	localctx = NewXml_general_default_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, PlSqlParserRULE_xml_general_default_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5126)
		p.Match(PlSqlParserDEFAULT)
	}
	{
		p.SetState(5127)
		p.concatenation(0)
	}

	return localctx
}

// IXml_multiuse_expression_elementContext is an interface to support dynamic dispatch.
type IXml_multiuse_expression_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXml_multiuse_expression_elementContext differentiates from other interfaces.
	IsXml_multiuse_expression_elementContext()
}

type Xml_multiuse_expression_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXml_multiuse_expression_elementContext() *Xml_multiuse_expression_elementContext {
	var p = new(Xml_multiuse_expression_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xml_multiuse_expression_element
	return p
}

func (*Xml_multiuse_expression_elementContext) IsXml_multiuse_expression_elementContext() {}

func NewXml_multiuse_expression_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xml_multiuse_expression_elementContext {
	var p = new(Xml_multiuse_expression_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xml_multiuse_expression_element

	return p
}

func (s *Xml_multiuse_expression_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Xml_multiuse_expression_elementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Xml_multiuse_expression_elementContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Xml_multiuse_expression_elementContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Xml_multiuse_expression_elementContext) EVALNAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEVALNAME, 0)
}

func (s *Xml_multiuse_expression_elementContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Xml_multiuse_expression_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xml_multiuse_expression_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xml_multiuse_expression_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXml_multiuse_expression_element(s)
	}
}

func (s *Xml_multiuse_expression_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXml_multiuse_expression_element(s)
	}
}

func (p *PlSqlParser) Xml_multiuse_expression_element() (localctx IXml_multiuse_expression_elementContext) {
	localctx = NewXml_multiuse_expression_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, PlSqlParserRULE_xml_multiuse_expression_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5129)
		p.Expression()
	}
	p.SetState(5136)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAS {
		{
			p.SetState(5130)
			p.Match(PlSqlParserAS)
		}
		p.SetState(5134)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 663, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5131)
				p.Id_expression()
			}

		case 2:
			{
				p.SetState(5132)
				p.Match(PlSqlParserEVALNAME)
			}
			{
				p.SetState(5133)
				p.concatenation(0)
			}

		}

	}

	return localctx
}

// IXmlroot_param_version_partContext is an interface to support dynamic dispatch.
type IXmlroot_param_version_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXmlroot_param_version_partContext differentiates from other interfaces.
	IsXmlroot_param_version_partContext()
}

type Xmlroot_param_version_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXmlroot_param_version_partContext() *Xmlroot_param_version_partContext {
	var p = new(Xmlroot_param_version_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xmlroot_param_version_part
	return p
}

func (*Xmlroot_param_version_partContext) IsXmlroot_param_version_partContext() {}

func NewXmlroot_param_version_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xmlroot_param_version_partContext {
	var p = new(Xmlroot_param_version_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xmlroot_param_version_part

	return p
}

func (s *Xmlroot_param_version_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Xmlroot_param_version_partContext) VERSION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVERSION, 0)
}

func (s *Xmlroot_param_version_partContext) NO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNO, 0)
}

func (s *Xmlroot_param_version_partContext) VALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALUE, 0)
}

func (s *Xmlroot_param_version_partContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Xmlroot_param_version_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xmlroot_param_version_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xmlroot_param_version_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXmlroot_param_version_part(s)
	}
}

func (s *Xmlroot_param_version_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXmlroot_param_version_part(s)
	}
}

func (p *PlSqlParser) Xmlroot_param_version_part() (localctx IXmlroot_param_version_partContext) {
	localctx = NewXmlroot_param_version_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, PlSqlParserRULE_xmlroot_param_version_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5138)
		p.Match(PlSqlParserVERSION)
	}
	p.SetState(5142)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 665, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5139)
			p.Match(PlSqlParserNO)
		}
		{
			p.SetState(5140)
			p.Match(PlSqlParserVALUE)
		}

	case 2:
		{
			p.SetState(5141)
			p.Expression()
		}

	}

	return localctx
}

// IXmlroot_param_standalone_partContext is an interface to support dynamic dispatch.
type IXmlroot_param_standalone_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXmlroot_param_standalone_partContext differentiates from other interfaces.
	IsXmlroot_param_standalone_partContext()
}

type Xmlroot_param_standalone_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXmlroot_param_standalone_partContext() *Xmlroot_param_standalone_partContext {
	var p = new(Xmlroot_param_standalone_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xmlroot_param_standalone_part
	return p
}

func (*Xmlroot_param_standalone_partContext) IsXmlroot_param_standalone_partContext() {}

func NewXmlroot_param_standalone_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xmlroot_param_standalone_partContext {
	var p = new(Xmlroot_param_standalone_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xmlroot_param_standalone_part

	return p
}

func (s *Xmlroot_param_standalone_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Xmlroot_param_standalone_partContext) STANDALONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTANDALONE, 0)
}

func (s *Xmlroot_param_standalone_partContext) YES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserYES, 0)
}

func (s *Xmlroot_param_standalone_partContext) NO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNO, 0)
}

func (s *Xmlroot_param_standalone_partContext) VALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALUE, 0)
}

func (s *Xmlroot_param_standalone_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xmlroot_param_standalone_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xmlroot_param_standalone_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXmlroot_param_standalone_part(s)
	}
}

func (s *Xmlroot_param_standalone_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXmlroot_param_standalone_part(s)
	}
}

func (p *PlSqlParser) Xmlroot_param_standalone_part() (localctx IXmlroot_param_standalone_partContext) {
	localctx = NewXmlroot_param_standalone_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, PlSqlParserRULE_xmlroot_param_standalone_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5144)
		p.Match(PlSqlParserSTANDALONE)
	}
	p.SetState(5150)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserYES:
		{
			p.SetState(5145)
			p.Match(PlSqlParserYES)
		}

	case PlSqlParserNO:
		{
			p.SetState(5146)
			p.Match(PlSqlParserNO)
		}
		p.SetState(5148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserVALUE {
			{
				p.SetState(5147)
				p.Match(PlSqlParserVALUE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IXmlserialize_param_enconding_partContext is an interface to support dynamic dispatch.
type IXmlserialize_param_enconding_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXmlserialize_param_enconding_partContext differentiates from other interfaces.
	IsXmlserialize_param_enconding_partContext()
}

type Xmlserialize_param_enconding_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXmlserialize_param_enconding_partContext() *Xmlserialize_param_enconding_partContext {
	var p = new(Xmlserialize_param_enconding_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xmlserialize_param_enconding_part
	return p
}

func (*Xmlserialize_param_enconding_partContext) IsXmlserialize_param_enconding_partContext() {}

func NewXmlserialize_param_enconding_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xmlserialize_param_enconding_partContext {
	var p = new(Xmlserialize_param_enconding_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xmlserialize_param_enconding_part

	return p
}

func (s *Xmlserialize_param_enconding_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Xmlserialize_param_enconding_partContext) ENCODING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserENCODING, 0)
}

func (s *Xmlserialize_param_enconding_partContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Xmlserialize_param_enconding_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xmlserialize_param_enconding_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xmlserialize_param_enconding_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXmlserialize_param_enconding_part(s)
	}
}

func (s *Xmlserialize_param_enconding_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXmlserialize_param_enconding_part(s)
	}
}

func (p *PlSqlParser) Xmlserialize_param_enconding_part() (localctx IXmlserialize_param_enconding_partContext) {
	localctx = NewXmlserialize_param_enconding_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, PlSqlParserRULE_xmlserialize_param_enconding_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5152)
		p.Match(PlSqlParserENCODING)
	}
	{
		p.SetState(5153)
		p.concatenation(0)
	}

	return localctx
}

// IXmlserialize_param_version_partContext is an interface to support dynamic dispatch.
type IXmlserialize_param_version_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXmlserialize_param_version_partContext differentiates from other interfaces.
	IsXmlserialize_param_version_partContext()
}

type Xmlserialize_param_version_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXmlserialize_param_version_partContext() *Xmlserialize_param_version_partContext {
	var p = new(Xmlserialize_param_version_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xmlserialize_param_version_part
	return p
}

func (*Xmlserialize_param_version_partContext) IsXmlserialize_param_version_partContext() {}

func NewXmlserialize_param_version_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xmlserialize_param_version_partContext {
	var p = new(Xmlserialize_param_version_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xmlserialize_param_version_part

	return p
}

func (s *Xmlserialize_param_version_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Xmlserialize_param_version_partContext) VERSION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVERSION, 0)
}

func (s *Xmlserialize_param_version_partContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Xmlserialize_param_version_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xmlserialize_param_version_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xmlserialize_param_version_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXmlserialize_param_version_part(s)
	}
}

func (s *Xmlserialize_param_version_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXmlserialize_param_version_part(s)
	}
}

func (p *PlSqlParser) Xmlserialize_param_version_part() (localctx IXmlserialize_param_version_partContext) {
	localctx = NewXmlserialize_param_version_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, PlSqlParserRULE_xmlserialize_param_version_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5155)
		p.Match(PlSqlParserVERSION)
	}
	{
		p.SetState(5156)
		p.concatenation(0)
	}

	return localctx
}

// IXmlserialize_param_ident_partContext is an interface to support dynamic dispatch.
type IXmlserialize_param_ident_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXmlserialize_param_ident_partContext differentiates from other interfaces.
	IsXmlserialize_param_ident_partContext()
}

type Xmlserialize_param_ident_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXmlserialize_param_ident_partContext() *Xmlserialize_param_ident_partContext {
	var p = new(Xmlserialize_param_ident_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xmlserialize_param_ident_part
	return p
}

func (*Xmlserialize_param_ident_partContext) IsXmlserialize_param_ident_partContext() {}

func NewXmlserialize_param_ident_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xmlserialize_param_ident_partContext {
	var p = new(Xmlserialize_param_ident_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xmlserialize_param_ident_part

	return p
}

func (s *Xmlserialize_param_ident_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Xmlserialize_param_ident_partContext) NO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNO, 0)
}

func (s *Xmlserialize_param_ident_partContext) INDENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDENT, 0)
}

func (s *Xmlserialize_param_ident_partContext) SIZE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSIZE, 0)
}

func (s *Xmlserialize_param_ident_partContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Xmlserialize_param_ident_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xmlserialize_param_ident_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xmlserialize_param_ident_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXmlserialize_param_ident_part(s)
	}
}

func (s *Xmlserialize_param_ident_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXmlserialize_param_ident_part(s)
	}
}

func (p *PlSqlParser) Xmlserialize_param_ident_part() (localctx IXmlserialize_param_ident_partContext) {
	localctx = NewXmlserialize_param_ident_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, PlSqlParserRULE_xmlserialize_param_ident_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5166)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserNO:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5158)
			p.Match(PlSqlParserNO)
		}
		{
			p.SetState(5159)
			p.Match(PlSqlParserINDENT)
		}

	case PlSqlParserINDENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5160)
			p.Match(PlSqlParserINDENT)
		}
		p.SetState(5164)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserSIZE {
			{
				p.SetState(5161)
				p.Match(PlSqlParserSIZE)
			}
			{
				p.SetState(5162)
				p.Match(PlSqlParserEQUALS_OP)
			}
			{
				p.SetState(5163)
				p.concatenation(0)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISql_plus_commandContext is an interface to support dynamic dispatch.
type ISql_plus_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSql_plus_commandContext differentiates from other interfaces.
	IsSql_plus_commandContext()
}

type Sql_plus_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_plus_commandContext() *Sql_plus_commandContext {
	var p = new(Sql_plus_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_sql_plus_command
	return p
}

func (*Sql_plus_commandContext) IsSql_plus_commandContext() {}

func NewSql_plus_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_plus_commandContext {
	var p = new(Sql_plus_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_sql_plus_command

	return p
}

func (s *Sql_plus_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_plus_commandContext) EXIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXIT, 0)
}

func (s *Sql_plus_commandContext) PROMPT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPROMPT, 0)
}

func (s *Sql_plus_commandContext) SHOW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSHOW, 0)
}

func (s *Sql_plus_commandContext) ERR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserERR, 0)
}

func (s *Sql_plus_commandContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserERRORS, 0)
}

func (s *Sql_plus_commandContext) START_CMD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTART_CMD, 0)
}

func (s *Sql_plus_commandContext) Whenever_command() IWhenever_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenever_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhenever_commandContext)
}

func (s *Sql_plus_commandContext) Set_command() ISet_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_commandContext)
}

func (s *Sql_plus_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_plus_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_plus_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSql_plus_command(s)
	}
}

func (s *Sql_plus_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSql_plus_command(s)
	}
}

func (p *PlSqlParser) Sql_plus_command() (localctx ISql_plus_commandContext) {
	localctx = NewSql_plus_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, PlSqlParserRULE_sql_plus_command)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5176)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserSOLIDUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5168)
			p.Match(PlSqlParserSOLIDUS)
		}

	case PlSqlParserEXIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5169)
			p.Match(PlSqlParserEXIT)
		}

	case PlSqlParserPROMPT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5170)
			p.Match(PlSqlParserPROMPT)
		}

	case PlSqlParserSHOW:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5171)
			p.Match(PlSqlParserSHOW)
		}
		{
			p.SetState(5172)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserERR || _la == PlSqlParserERRORS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case PlSqlParserSTART_CMD:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5173)
			p.Match(PlSqlParserSTART_CMD)
		}

	case PlSqlParserWHENEVER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5174)
			p.Whenever_command()
		}

	case PlSqlParserSET:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5175)
			p.Set_command()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhenever_commandContext is an interface to support dynamic dispatch.
type IWhenever_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenever_commandContext differentiates from other interfaces.
	IsWhenever_commandContext()
}

type Whenever_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenever_commandContext() *Whenever_commandContext {
	var p = new(Whenever_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_whenever_command
	return p
}

func (*Whenever_commandContext) IsWhenever_commandContext() {}

func NewWhenever_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Whenever_commandContext {
	var p = new(Whenever_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_whenever_command

	return p
}

func (s *Whenever_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Whenever_commandContext) WHENEVER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHENEVER, 0)
}

func (s *Whenever_commandContext) SQLERROR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSQLERROR, 0)
}

func (s *Whenever_commandContext) OSERROR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOSERROR, 0)
}

func (s *Whenever_commandContext) EXIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXIT, 0)
}

func (s *Whenever_commandContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONTINUE, 0)
}

func (s *Whenever_commandContext) SUCCESS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUCCESS, 0)
}

func (s *Whenever_commandContext) FAILURE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFAILURE, 0)
}

func (s *Whenever_commandContext) WARNING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWARNING, 0)
}

func (s *Whenever_commandContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMIT, 0)
}

func (s *Whenever_commandContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROLLBACK, 0)
}

func (s *Whenever_commandContext) NONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNONE, 0)
}

func (s *Whenever_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Whenever_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Whenever_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterWhenever_command(s)
	}
}

func (s *Whenever_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitWhenever_command(s)
	}
}

func (p *PlSqlParser) Whenever_command() (localctx IWhenever_commandContext) {
	localctx = NewWhenever_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, PlSqlParserRULE_whenever_command)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5178)
		p.Match(PlSqlParserWHENEVER)
	}
	{
		p.SetState(5179)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserOSERROR || _la == PlSqlParserSQLERROR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5185)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserEXIT:
		{
			p.SetState(5180)
			p.Match(PlSqlParserEXIT)
		}
		{
			p.SetState(5181)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserFAILURE || _la == PlSqlParserSUCCESS || _la == PlSqlParserWARNING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5182)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserCOMMIT || _la == PlSqlParserROLLBACK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case PlSqlParserCONTINUE:
		{
			p.SetState(5183)
			p.Match(PlSqlParserCONTINUE)
		}
		{
			p.SetState(5184)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserCOMMIT || _la == PlSqlParserNONE || _la == PlSqlParserROLLBACK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISet_commandContext is an interface to support dynamic dispatch.
type ISet_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_commandContext differentiates from other interfaces.
	IsSet_commandContext()
}

type Set_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_commandContext() *Set_commandContext {
	var p = new(Set_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_set_command
	return p
}

func (*Set_commandContext) IsSet_commandContext() {}

func NewSet_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_commandContext {
	var p = new(Set_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_set_command

	return p
}

func (s *Set_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_commandContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *Set_commandContext) AllRegular_id() []IRegular_idContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRegular_idContext)(nil)).Elem())
	var tst = make([]IRegular_idContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRegular_idContext)
		}
	}

	return tst
}

func (s *Set_commandContext) Regular_id(i int) IRegular_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegular_idContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRegular_idContext)
}

func (s *Set_commandContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR_STRING, 0)
}

func (s *Set_commandContext) ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserON, 0)
}

func (s *Set_commandContext) OFF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOFF, 0)
}

func (s *Set_commandContext) Numeric() INumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericContext)
}

func (s *Set_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSet_command(s)
	}
}

func (s *Set_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSet_command(s)
	}
}

func (p *PlSqlParser) Set_command() (localctx ISet_commandContext) {
	localctx = NewSet_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, PlSqlParserRULE_set_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5187)
		p.Match(PlSqlParserSET)
	}
	{
		p.SetState(5188)
		p.Regular_id()
	}
	p.SetState(5194)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 672, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5189)
			p.Match(PlSqlParserCHAR_STRING)
		}

	case 2:
		{
			p.SetState(5190)
			p.Match(PlSqlParserON)
		}

	case 3:
		{
			p.SetState(5191)
			p.Match(PlSqlParserOFF)
		}

	case 4:
		{
			p.SetState(5192)
			p.Numeric()
		}

	case 5:
		{
			p.SetState(5193)
			p.Regular_id()
		}

	}

	return localctx
}

// IPartition_extension_clauseContext is an interface to support dynamic dispatch.
type IPartition_extension_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartition_extension_clauseContext differentiates from other interfaces.
	IsPartition_extension_clauseContext()
}

type Partition_extension_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_extension_clauseContext() *Partition_extension_clauseContext {
	var p = new(Partition_extension_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_partition_extension_clause
	return p
}

func (*Partition_extension_clauseContext) IsPartition_extension_clauseContext() {}

func NewPartition_extension_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_extension_clauseContext {
	var p = new(Partition_extension_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_partition_extension_clause

	return p
}

func (s *Partition_extension_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_extension_clauseContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBPARTITION, 0)
}

func (s *Partition_extension_clauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARTITION, 0)
}

func (s *Partition_extension_clauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOR, 0)
}

func (s *Partition_extension_clauseContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *Partition_extension_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_extension_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_extension_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPartition_extension_clause(s)
	}
}

func (s *Partition_extension_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPartition_extension_clause(s)
	}
}

func (p *PlSqlParser) Partition_extension_clause() (localctx IPartition_extension_clauseContext) {
	localctx = NewPartition_extension_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, PlSqlParserRULE_partition_extension_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5196)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserPARTITION || _la == PlSqlParserSUBPARTITION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserFOR {
		{
			p.SetState(5197)
			p.Match(PlSqlParserFOR)
		}

	}
	{
		p.SetState(5200)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(5202)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
		{
			p.SetState(5201)
			p.Expressions()
		}

	}
	{
		p.SetState(5204)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IColumn_aliasContext is an interface to support dynamic dispatch.
type IColumn_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumn_aliasContext differentiates from other interfaces.
	IsColumn_aliasContext()
}

type Column_aliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_aliasContext() *Column_aliasContext {
	var p = new(Column_aliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_column_alias
	return p
}

func (*Column_aliasContext) IsColumn_aliasContext() {}

func NewColumn_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_aliasContext {
	var p = new(Column_aliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_column_alias

	return p
}

func (s *Column_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_aliasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Column_aliasContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Column_aliasContext) AS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAS, 0)
}

func (s *Column_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterColumn_alias(s)
	}
}

func (s *Column_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitColumn_alias(s)
	}
}

func (p *PlSqlParser) Column_alias() (localctx IColumn_aliasContext) {
	localctx = NewColumn_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, PlSqlParserRULE_column_alias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5214)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 677, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5207)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserAS {
			{
				p.SetState(5206)
				p.Match(PlSqlParserAS)
			}

		}
		p.SetState(5211)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
			{
				p.SetState(5209)
				p.Identifier()
			}

		case PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserCHAR_STRING:
			{
				p.SetState(5210)
				p.Quoted_string()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5213)
			p.Match(PlSqlParserAS)
		}

	}

	return localctx
}

// ITable_aliasContext is an interface to support dynamic dispatch.
type ITable_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_aliasContext differentiates from other interfaces.
	IsTable_aliasContext()
}

type Table_aliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_aliasContext() *Table_aliasContext {
	var p = new(Table_aliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_alias
	return p
}

func (*Table_aliasContext) IsTable_aliasContext() {}

func NewTable_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_aliasContext {
	var p = new(Table_aliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_alias

	return p
}

func (s *Table_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_aliasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Table_aliasContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Table_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_alias(s)
	}
}

func (s *Table_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_alias(s)
	}
}

func (p *PlSqlParser) Table_alias() (localctx ITable_aliasContext) {
	localctx = NewTable_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, PlSqlParserRULE_table_alias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5218)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5216)
			p.Identifier()
		}

	case PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserCHAR_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5217)
			p.Quoted_string()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhere_clauseContext is an interface to support dynamic dispatch.
type IWhere_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhere_clauseContext differentiates from other interfaces.
	IsWhere_clauseContext()
}

type Where_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhere_clauseContext() *Where_clauseContext {
	var p = new(Where_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_where_clause
	return p
}

func (*Where_clauseContext) IsWhere_clauseContext() {}

func NewWhere_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Where_clauseContext {
	var p = new(Where_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_where_clause

	return p
}

func (s *Where_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Where_clauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHERE, 0)
}

func (s *Where_clauseContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCURRENT, 0)
}

func (s *Where_clauseContext) OF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOF, 0)
}

func (s *Where_clauseContext) Cursor_name() ICursor_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursor_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursor_nameContext)
}

func (s *Where_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Where_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Where_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Where_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterWhere_clause(s)
	}
}

func (s *Where_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitWhere_clause(s)
	}
}

func (p *PlSqlParser) Where_clause() (localctx IWhere_clauseContext) {
	localctx = NewWhere_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, PlSqlParserRULE_where_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5220)
		p.Match(PlSqlParserWHERE)
	}
	p.SetState(5225)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserCURRENT:
		{
			p.SetState(5221)
			p.Match(PlSqlParserCURRENT)
		}
		{
			p.SetState(5222)
			p.Match(PlSqlParserOF)
		}
		{
			p.SetState(5223)
			p.Cursor_name()
		}

	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserALL, PlSqlParserANALYZE, PlSqlParserANY, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCASE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOALESCE, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONNECT_BY_ROOT, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDISTINCT, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXISTS, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFALSE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNOT, PlSqlParserNULL, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserPRIOR, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUE, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserDECODE, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserNVL, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROUND, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTO_CHAR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserLEAST, PlSqlParserGREATEST, PlSqlParserTO_DATE, PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT, PlSqlParserCHAR_STRING, PlSqlParserDELIMITED_ID, PlSqlParserLEFT_PAREN, PlSqlParserPLUS_SIGN, PlSqlParserMINUS_SIGN, PlSqlParserBINDVAR, PlSqlParserCOLON, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		{
			p.SetState(5224)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInto_clauseContext is an interface to support dynamic dispatch.
type IInto_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInto_clauseContext differentiates from other interfaces.
	IsInto_clauseContext()
}

type Into_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_clauseContext() *Into_clauseContext {
	var p = new(Into_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_into_clause
	return p
}

func (*Into_clauseContext) IsInto_clauseContext() {}

func NewInto_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_clauseContext {
	var p = new(Into_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_into_clause

	return p
}

func (s *Into_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_clauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTO, 0)
}

func (s *Into_clauseContext) AllVariable_name() []IVariable_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_nameContext)(nil)).Elem())
	var tst = make([]IVariable_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_nameContext)
		}
	}

	return tst
}

func (s *Into_clauseContext) Variable_name(i int) IVariable_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_nameContext)
}

func (s *Into_clauseContext) BULK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBULK, 0)
}

func (s *Into_clauseContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOLLECT, 0)
}

func (s *Into_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterInto_clause(s)
	}
}

func (s *Into_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitInto_clause(s)
	}
}

func (p *PlSqlParser) Into_clause() (localctx IInto_clauseContext) {
	localctx = NewInto_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, PlSqlParserRULE_into_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserBULK {
		{
			p.SetState(5227)
			p.Match(PlSqlParserBULK)
		}
		{
			p.SetState(5228)
			p.Match(PlSqlParserCOLLECT)
		}

	}
	{
		p.SetState(5231)
		p.Match(PlSqlParserINTO)
	}
	{
		p.SetState(5232)
		p.Variable_name()
	}
	p.SetState(5237)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(5233)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(5234)
			p.Variable_name()
		}

		p.SetState(5239)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IXml_column_nameContext is an interface to support dynamic dispatch.
type IXml_column_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXml_column_nameContext differentiates from other interfaces.
	IsXml_column_nameContext()
}

type Xml_column_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXml_column_nameContext() *Xml_column_nameContext {
	var p = new(Xml_column_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_xml_column_name
	return p
}

func (*Xml_column_nameContext) IsXml_column_nameContext() {}

func NewXml_column_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xml_column_nameContext {
	var p = new(Xml_column_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_xml_column_name

	return p
}

func (s *Xml_column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Xml_column_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Xml_column_nameContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Xml_column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xml_column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xml_column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterXml_column_name(s)
	}
}

func (s *Xml_column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitXml_column_name(s)
	}
}

func (p *PlSqlParser) Xml_column_name() (localctx IXml_column_nameContext) {
	localctx = NewXml_column_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, PlSqlParserRULE_xml_column_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5242)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5240)
			p.Identifier()
		}

	case PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserCHAR_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5241)
			p.Quoted_string()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICost_class_nameContext is an interface to support dynamic dispatch.
type ICost_class_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCost_class_nameContext differentiates from other interfaces.
	IsCost_class_nameContext()
}

type Cost_class_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCost_class_nameContext() *Cost_class_nameContext {
	var p = new(Cost_class_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cost_class_name
	return p
}

func (*Cost_class_nameContext) IsCost_class_nameContext() {}

func NewCost_class_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cost_class_nameContext {
	var p = new(Cost_class_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cost_class_name

	return p
}

func (s *Cost_class_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Cost_class_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cost_class_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cost_class_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cost_class_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCost_class_name(s)
	}
}

func (s *Cost_class_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCost_class_name(s)
	}
}

func (p *PlSqlParser) Cost_class_name() (localctx ICost_class_nameContext) {
	localctx = NewCost_class_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, PlSqlParserRULE_cost_class_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5244)
		p.Identifier()
	}

	return localctx
}

// IAttribute_nameContext is an interface to support dynamic dispatch.
type IAttribute_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_nameContext differentiates from other interfaces.
	IsAttribute_nameContext()
}

type Attribute_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_nameContext() *Attribute_nameContext {
	var p = new(Attribute_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_attribute_name
	return p
}

func (*Attribute_nameContext) IsAttribute_nameContext() {}

func NewAttribute_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_nameContext {
	var p = new(Attribute_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_attribute_name

	return p
}

func (s *Attribute_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Attribute_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAttribute_name(s)
	}
}

func (s *Attribute_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAttribute_name(s)
	}
}

func (p *PlSqlParser) Attribute_name() (localctx IAttribute_nameContext) {
	localctx = NewAttribute_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, PlSqlParserRULE_attribute_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5246)
		p.Identifier()
	}

	return localctx
}

// ISavepoint_nameContext is an interface to support dynamic dispatch.
type ISavepoint_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSavepoint_nameContext differentiates from other interfaces.
	IsSavepoint_nameContext()
}

type Savepoint_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepoint_nameContext() *Savepoint_nameContext {
	var p = new(Savepoint_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_savepoint_name
	return p
}

func (*Savepoint_nameContext) IsSavepoint_nameContext() {}

func NewSavepoint_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Savepoint_nameContext {
	var p = new(Savepoint_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_savepoint_name

	return p
}

func (s *Savepoint_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Savepoint_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Savepoint_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Savepoint_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Savepoint_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSavepoint_name(s)
	}
}

func (s *Savepoint_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSavepoint_name(s)
	}
}

func (p *PlSqlParser) Savepoint_name() (localctx ISavepoint_nameContext) {
	localctx = NewSavepoint_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, PlSqlParserRULE_savepoint_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5248)
		p.Identifier()
	}

	return localctx
}

// IRollback_segment_nameContext is an interface to support dynamic dispatch.
type IRollback_segment_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRollback_segment_nameContext differentiates from other interfaces.
	IsRollback_segment_nameContext()
}

type Rollback_segment_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollback_segment_nameContext() *Rollback_segment_nameContext {
	var p = new(Rollback_segment_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_rollback_segment_name
	return p
}

func (*Rollback_segment_nameContext) IsRollback_segment_nameContext() {}

func NewRollback_segment_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollback_segment_nameContext {
	var p = new(Rollback_segment_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_rollback_segment_name

	return p
}

func (s *Rollback_segment_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollback_segment_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Rollback_segment_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollback_segment_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rollback_segment_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRollback_segment_name(s)
	}
}

func (s *Rollback_segment_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRollback_segment_name(s)
	}
}

func (p *PlSqlParser) Rollback_segment_name() (localctx IRollback_segment_nameContext) {
	localctx = NewRollback_segment_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, PlSqlParserRULE_rollback_segment_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5250)
		p.Identifier()
	}

	return localctx
}

// ITable_var_nameContext is an interface to support dynamic dispatch.
type ITable_var_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_var_nameContext differentiates from other interfaces.
	IsTable_var_nameContext()
}

type Table_var_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_var_nameContext() *Table_var_nameContext {
	var p = new(Table_var_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_var_name
	return p
}

func (*Table_var_nameContext) IsTable_var_nameContext() {}

func NewTable_var_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_var_nameContext {
	var p = new(Table_var_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_var_name

	return p
}

func (s *Table_var_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_var_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Table_var_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_var_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_var_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_var_name(s)
	}
}

func (s *Table_var_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_var_name(s)
	}
}

func (p *PlSqlParser) Table_var_name() (localctx ITable_var_nameContext) {
	localctx = NewTable_var_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, PlSqlParserRULE_table_var_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5252)
		p.Identifier()
	}

	return localctx
}

// ISchema_nameContext is an interface to support dynamic dispatch.
type ISchema_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchema_nameContext differentiates from other interfaces.
	IsSchema_nameContext()
}

type Schema_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchema_nameContext() *Schema_nameContext {
	var p = new(Schema_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_schema_name
	return p
}

func (*Schema_nameContext) IsSchema_nameContext() {}

func NewSchema_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Schema_nameContext {
	var p = new(Schema_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_schema_name

	return p
}

func (s *Schema_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Schema_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Schema_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Schema_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Schema_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSchema_name(s)
	}
}

func (s *Schema_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSchema_name(s)
	}
}

func (p *PlSqlParser) Schema_name() (localctx ISchema_nameContext) {
	localctx = NewSchema_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, PlSqlParserRULE_schema_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5254)
		p.Identifier()
	}

	return localctx
}

// IRoutine_nameContext is an interface to support dynamic dispatch.
type IRoutine_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutine_nameContext differentiates from other interfaces.
	IsRoutine_nameContext()
}

type Routine_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutine_nameContext() *Routine_nameContext {
	var p = new(Routine_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_routine_name
	return p
}

func (*Routine_nameContext) IsRoutine_nameContext() {}

func NewRoutine_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Routine_nameContext {
	var p = new(Routine_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_routine_name

	return p
}

func (s *Routine_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Routine_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Routine_nameContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Routine_nameContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Routine_nameContext) Link_name() ILink_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_nameContext)
}

func (s *Routine_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Routine_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Routine_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRoutine_name(s)
	}
}

func (s *Routine_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRoutine_name(s)
	}
}

func (p *PlSqlParser) Routine_name() (localctx IRoutine_nameContext) {
	localctx = NewRoutine_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, PlSqlParserRULE_routine_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5256)
		p.Identifier()
	}
	p.SetState(5261)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserPERIOD {
		{
			p.SetState(5257)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5258)
			p.Id_expression()
		}

		p.SetState(5263)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5266)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAT_SIGN {
		{
			p.SetState(5264)
			p.Match(PlSqlParserAT_SIGN)
		}
		{
			p.SetState(5265)
			p.Link_name()
		}

	}

	return localctx
}

// IPackage_nameContext is an interface to support dynamic dispatch.
type IPackage_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_nameContext differentiates from other interfaces.
	IsPackage_nameContext()
}

type Package_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_nameContext() *Package_nameContext {
	var p = new(Package_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_package_name
	return p
}

func (*Package_nameContext) IsPackage_nameContext() {}

func NewPackage_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_nameContext {
	var p = new(Package_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_package_name

	return p
}

func (s *Package_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Package_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPackage_name(s)
	}
}

func (s *Package_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPackage_name(s)
	}
}

func (p *PlSqlParser) Package_name() (localctx IPackage_nameContext) {
	localctx = NewPackage_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, PlSqlParserRULE_package_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5268)
		p.Identifier()
	}

	return localctx
}

// IImplementation_type_nameContext is an interface to support dynamic dispatch.
type IImplementation_type_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementation_type_nameContext differentiates from other interfaces.
	IsImplementation_type_nameContext()
}

type Implementation_type_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementation_type_nameContext() *Implementation_type_nameContext {
	var p = new(Implementation_type_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_implementation_type_name
	return p
}

func (*Implementation_type_nameContext) IsImplementation_type_nameContext() {}

func NewImplementation_type_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Implementation_type_nameContext {
	var p = new(Implementation_type_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_implementation_type_name

	return p
}

func (s *Implementation_type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Implementation_type_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Implementation_type_nameContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Implementation_type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Implementation_type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Implementation_type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterImplementation_type_name(s)
	}
}

func (s *Implementation_type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitImplementation_type_name(s)
	}
}

func (p *PlSqlParser) Implementation_type_name() (localctx IImplementation_type_nameContext) {
	localctx = NewImplementation_type_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, PlSqlParserRULE_implementation_type_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5270)
		p.Identifier()
	}
	p.SetState(5273)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPERIOD {
		{
			p.SetState(5271)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5272)
			p.Id_expression()
		}

	}

	return localctx
}

// IParameter_nameContext is an interface to support dynamic dispatch.
type IParameter_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_nameContext differentiates from other interfaces.
	IsParameter_nameContext()
}

type Parameter_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_nameContext() *Parameter_nameContext {
	var p = new(Parameter_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_parameter_name
	return p
}

func (*Parameter_nameContext) IsParameter_nameContext() {}

func NewParameter_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_nameContext {
	var p = new(Parameter_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_parameter_name

	return p
}

func (s *Parameter_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Parameter_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterParameter_name(s)
	}
}

func (s *Parameter_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitParameter_name(s)
	}
}

func (p *PlSqlParser) Parameter_name() (localctx IParameter_nameContext) {
	localctx = NewParameter_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, PlSqlParserRULE_parameter_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5275)
		p.Identifier()
	}

	return localctx
}

// IReference_model_nameContext is an interface to support dynamic dispatch.
type IReference_model_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReference_model_nameContext differentiates from other interfaces.
	IsReference_model_nameContext()
}

type Reference_model_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReference_model_nameContext() *Reference_model_nameContext {
	var p = new(Reference_model_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_reference_model_name
	return p
}

func (*Reference_model_nameContext) IsReference_model_nameContext() {}

func NewReference_model_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reference_model_nameContext {
	var p = new(Reference_model_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_reference_model_name

	return p
}

func (s *Reference_model_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Reference_model_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Reference_model_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reference_model_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reference_model_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterReference_model_name(s)
	}
}

func (s *Reference_model_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitReference_model_name(s)
	}
}

func (p *PlSqlParser) Reference_model_name() (localctx IReference_model_nameContext) {
	localctx = NewReference_model_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, PlSqlParserRULE_reference_model_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5277)
		p.Identifier()
	}

	return localctx
}

// IMain_model_nameContext is an interface to support dynamic dispatch.
type IMain_model_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMain_model_nameContext differentiates from other interfaces.
	IsMain_model_nameContext()
}

type Main_model_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMain_model_nameContext() *Main_model_nameContext {
	var p = new(Main_model_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_main_model_name
	return p
}

func (*Main_model_nameContext) IsMain_model_nameContext() {}

func NewMain_model_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Main_model_nameContext {
	var p = new(Main_model_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_main_model_name

	return p
}

func (s *Main_model_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Main_model_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Main_model_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Main_model_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Main_model_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterMain_model_name(s)
	}
}

func (s *Main_model_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitMain_model_name(s)
	}
}

func (p *PlSqlParser) Main_model_name() (localctx IMain_model_nameContext) {
	localctx = NewMain_model_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, PlSqlParserRULE_main_model_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5279)
		p.Identifier()
	}

	return localctx
}

// IAggregate_function_nameContext is an interface to support dynamic dispatch.
type IAggregate_function_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregate_function_nameContext differentiates from other interfaces.
	IsAggregate_function_nameContext()
}

type Aggregate_function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregate_function_nameContext() *Aggregate_function_nameContext {
	var p = new(Aggregate_function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_aggregate_function_name
	return p
}

func (*Aggregate_function_nameContext) IsAggregate_function_nameContext() {}

func NewAggregate_function_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Aggregate_function_nameContext {
	var p = new(Aggregate_function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_aggregate_function_name

	return p
}

func (s *Aggregate_function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Aggregate_function_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Aggregate_function_nameContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Aggregate_function_nameContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Aggregate_function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Aggregate_function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Aggregate_function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterAggregate_function_name(s)
	}
}

func (s *Aggregate_function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitAggregate_function_name(s)
	}
}

func (p *PlSqlParser) Aggregate_function_name() (localctx IAggregate_function_nameContext) {
	localctx = NewAggregate_function_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, PlSqlParserRULE_aggregate_function_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5281)
		p.Identifier()
	}
	p.SetState(5286)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserPERIOD {
		{
			p.SetState(5282)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5283)
			p.Id_expression()
		}

		p.SetState(5288)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IQuery_nameContext is an interface to support dynamic dispatch.
type IQuery_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_nameContext differentiates from other interfaces.
	IsQuery_nameContext()
}

type Query_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_nameContext() *Query_nameContext {
	var p = new(Query_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_query_name
	return p
}

func (*Query_nameContext) IsQuery_nameContext() {}

func NewQuery_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_nameContext {
	var p = new(Query_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_query_name

	return p
}

func (s *Query_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Query_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterQuery_name(s)
	}
}

func (s *Query_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitQuery_name(s)
	}
}

func (p *PlSqlParser) Query_name() (localctx IQuery_nameContext) {
	localctx = NewQuery_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, PlSqlParserRULE_query_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5289)
		p.Identifier()
	}

	return localctx
}

// IConstraint_nameContext is an interface to support dynamic dispatch.
type IConstraint_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_nameContext differentiates from other interfaces.
	IsConstraint_nameContext()
}

type Constraint_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_nameContext() *Constraint_nameContext {
	var p = new(Constraint_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_constraint_name
	return p
}

func (*Constraint_nameContext) IsConstraint_nameContext() {}

func NewConstraint_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_nameContext {
	var p = new(Constraint_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_constraint_name

	return p
}

func (s *Constraint_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Constraint_nameContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Constraint_nameContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Constraint_nameContext) Link_name() ILink_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_nameContext)
}

func (s *Constraint_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterConstraint_name(s)
	}
}

func (s *Constraint_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitConstraint_name(s)
	}
}

func (p *PlSqlParser) Constraint_name() (localctx IConstraint_nameContext) {
	localctx = NewConstraint_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, PlSqlParserRULE_constraint_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5291)
		p.Identifier()
	}
	p.SetState(5296)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserPERIOD {
		{
			p.SetState(5292)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5293)
			p.Id_expression()
		}

		p.SetState(5298)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5301)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserAT_SIGN {
		{
			p.SetState(5299)
			p.Match(PlSqlParserAT_SIGN)
		}
		{
			p.SetState(5300)
			p.Link_name()
		}

	}

	return localctx
}

// ILabel_nameContext is an interface to support dynamic dispatch.
type ILabel_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabel_nameContext differentiates from other interfaces.
	IsLabel_nameContext()
}

type Label_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabel_nameContext() *Label_nameContext {
	var p = new(Label_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_label_name
	return p
}

func (*Label_nameContext) IsLabel_nameContext() {}

func NewLabel_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Label_nameContext {
	var p = new(Label_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_label_name

	return p
}

func (s *Label_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Label_nameContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Label_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Label_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Label_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterLabel_name(s)
	}
}

func (s *Label_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitLabel_name(s)
	}
}

func (p *PlSqlParser) Label_name() (localctx ILabel_nameContext) {
	localctx = NewLabel_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, PlSqlParserRULE_label_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5303)
		p.Id_expression()
	}

	return localctx
}

// IType_nameContext is an interface to support dynamic dispatch.
type IType_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_nameContext differentiates from other interfaces.
	IsType_nameContext()
}

type Type_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_nameContext() *Type_nameContext {
	var p = new(Type_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_type_name
	return p
}

func (*Type_nameContext) IsType_nameContext() {}

func NewType_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_nameContext {
	var p = new(Type_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_type_name

	return p
}

func (s *Type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_nameContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Type_nameContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterType_name(s)
	}
}

func (s *Type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitType_name(s)
	}
}

func (p *PlSqlParser) Type_name() (localctx IType_nameContext) {
	localctx = NewType_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, PlSqlParserRULE_type_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5305)
		p.Id_expression()
	}
	p.SetState(5310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserPERIOD {
		{
			p.SetState(5306)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5307)
			p.Id_expression()
		}

		p.SetState(5312)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISequence_nameContext is an interface to support dynamic dispatch.
type ISequence_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_nameContext differentiates from other interfaces.
	IsSequence_nameContext()
}

type Sequence_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_nameContext() *Sequence_nameContext {
	var p = new(Sequence_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_sequence_name
	return p
}

func (*Sequence_nameContext) IsSequence_nameContext() {}

func NewSequence_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_nameContext {
	var p = new(Sequence_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_sequence_name

	return p
}

func (s *Sequence_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_nameContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Sequence_nameContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Sequence_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSequence_name(s)
	}
}

func (s *Sequence_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSequence_name(s)
	}
}

func (p *PlSqlParser) Sequence_name() (localctx ISequence_nameContext) {
	localctx = NewSequence_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, PlSqlParserRULE_sequence_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5313)
		p.Id_expression()
	}
	p.SetState(5318)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserPERIOD {
		{
			p.SetState(5314)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5315)
			p.Id_expression()
		}

		p.SetState(5320)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IException_nameContext is an interface to support dynamic dispatch.
type IException_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_nameContext differentiates from other interfaces.
	IsException_nameContext()
}

type Exception_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_nameContext() *Exception_nameContext {
	var p = new(Exception_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_exception_name
	return p
}

func (*Exception_nameContext) IsException_nameContext() {}

func NewException_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_nameContext {
	var p = new(Exception_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_exception_name

	return p
}

func (s *Exception_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Exception_nameContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Exception_nameContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Exception_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterException_name(s)
	}
}

func (s *Exception_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitException_name(s)
	}
}

func (p *PlSqlParser) Exception_name() (localctx IException_nameContext) {
	localctx = NewException_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, PlSqlParserRULE_exception_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5321)
		p.Identifier()
	}
	p.SetState(5326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserPERIOD {
		{
			p.SetState(5322)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5323)
			p.Id_expression()
		}

		p.SetState(5328)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunction_nameContext is an interface to support dynamic dispatch.
type IFunction_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_nameContext differentiates from other interfaces.
	IsFunction_nameContext()
}

type Function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_nameContext() *Function_nameContext {
	var p = new(Function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_function_name
	return p
}

func (*Function_nameContext) IsFunction_nameContext() {}

func NewFunction_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_nameContext {
	var p = new(Function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_function_name

	return p
}

func (s *Function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_nameContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFunction_name(s)
	}
}

func (s *Function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFunction_name(s)
	}
}

func (p *PlSqlParser) Function_name() (localctx IFunction_nameContext) {
	localctx = NewFunction_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, PlSqlParserRULE_function_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5329)
		p.Identifier()
	}
	p.SetState(5332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPERIOD {
		{
			p.SetState(5330)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5331)
			p.Id_expression()
		}

	}

	return localctx
}

// IProcedure_nameContext is an interface to support dynamic dispatch.
type IProcedure_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedure_nameContext differentiates from other interfaces.
	IsProcedure_nameContext()
}

type Procedure_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_nameContext() *Procedure_nameContext {
	var p = new(Procedure_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_procedure_name
	return p
}

func (*Procedure_nameContext) IsProcedure_nameContext() {}

func NewProcedure_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_nameContext {
	var p = new(Procedure_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_procedure_name

	return p
}

func (s *Procedure_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Procedure_nameContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Procedure_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterProcedure_name(s)
	}
}

func (s *Procedure_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitProcedure_name(s)
	}
}

func (p *PlSqlParser) Procedure_name() (localctx IProcedure_nameContext) {
	localctx = NewProcedure_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, PlSqlParserRULE_procedure_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5334)
		p.Identifier()
	}
	p.SetState(5337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPERIOD {
		{
			p.SetState(5335)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5336)
			p.Id_expression()
		}

	}

	return localctx
}

// ITrigger_nameContext is an interface to support dynamic dispatch.
type ITrigger_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrigger_nameContext differentiates from other interfaces.
	IsTrigger_nameContext()
}

type Trigger_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrigger_nameContext() *Trigger_nameContext {
	var p = new(Trigger_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_trigger_name
	return p
}

func (*Trigger_nameContext) IsTrigger_nameContext() {}

func NewTrigger_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trigger_nameContext {
	var p = new(Trigger_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_trigger_name

	return p
}

func (s *Trigger_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Trigger_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Trigger_nameContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Trigger_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trigger_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trigger_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTrigger_name(s)
	}
}

func (s *Trigger_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTrigger_name(s)
	}
}

func (p *PlSqlParser) Trigger_name() (localctx ITrigger_nameContext) {
	localctx = NewTrigger_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, PlSqlParserRULE_trigger_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5339)
		p.Identifier()
	}
	p.SetState(5342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPERIOD {
		{
			p.SetState(5340)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5341)
			p.Id_expression()
		}

	}

	return localctx
}

// IVariable_nameContext is an interface to support dynamic dispatch.
type IVariable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_nameContext differentiates from other interfaces.
	IsVariable_nameContext()
}

type Variable_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_nameContext() *Variable_nameContext {
	var p = new(Variable_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_variable_name
	return p
}

func (*Variable_nameContext) IsVariable_nameContext() {}

func NewVariable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_nameContext {
	var p = new(Variable_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_variable_name

	return p
}

func (s *Variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_nameContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Variable_nameContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Variable_nameContext) INTRODUCER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTRODUCER, 0)
}

func (s *Variable_nameContext) Char_set_name() IChar_set_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_set_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_set_nameContext)
}

func (s *Variable_nameContext) Bind_variable() IBind_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_variableContext)
}

func (s *Variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterVariable_name(s)
	}
}

func (s *Variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitVariable_name(s)
	}
}

func (p *PlSqlParser) Variable_name() (localctx IVariable_nameContext) {
	localctx = NewVariable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, PlSqlParserRULE_variable_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5354)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5346)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserINTRODUCER {
			{
				p.SetState(5344)
				p.Match(PlSqlParserINTRODUCER)
			}
			{
				p.SetState(5345)
				p.Char_set_name()
			}

		}
		{
			p.SetState(5348)
			p.Id_expression()
		}
		p.SetState(5351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserPERIOD {
			{
				p.SetState(5349)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(5350)
				p.Id_expression()
			}

		}

	case PlSqlParserBINDVAR, PlSqlParserCOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5353)
			p.Bind_variable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndex_nameContext is an interface to support dynamic dispatch.
type IIndex_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndex_nameContext differentiates from other interfaces.
	IsIndex_nameContext()
}

type Index_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_nameContext() *Index_nameContext {
	var p = new(Index_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_index_name
	return p
}

func (*Index_nameContext) IsIndex_nameContext() {}

func NewIndex_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_nameContext {
	var p = new(Index_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_index_name

	return p
}

func (s *Index_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Index_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterIndex_name(s)
	}
}

func (s *Index_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitIndex_name(s)
	}
}

func (p *PlSqlParser) Index_name() (localctx IIndex_nameContext) {
	localctx = NewIndex_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, PlSqlParserRULE_index_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5356)
		p.Identifier()
	}

	return localctx
}

// ICursor_nameContext is an interface to support dynamic dispatch.
type ICursor_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCursor_nameContext differentiates from other interfaces.
	IsCursor_nameContext()
}

type Cursor_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_nameContext() *Cursor_nameContext {
	var p = new(Cursor_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_cursor_name
	return p
}

func (*Cursor_nameContext) IsCursor_nameContext() {}

func NewCursor_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_nameContext {
	var p = new(Cursor_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_cursor_name

	return p
}

func (s *Cursor_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cursor_nameContext) Bind_variable() IBind_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_variableContext)
}

func (s *Cursor_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cursor_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCursor_name(s)
	}
}

func (s *Cursor_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCursor_name(s)
	}
}

func (p *PlSqlParser) Cursor_name() (localctx ICursor_nameContext) {
	localctx = NewCursor_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, PlSqlParserRULE_cursor_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5360)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5358)
			p.Identifier()
		}

	case PlSqlParserBINDVAR, PlSqlParserCOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5359)
			p.Bind_variable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRecord_nameContext is an interface to support dynamic dispatch.
type IRecord_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecord_nameContext differentiates from other interfaces.
	IsRecord_nameContext()
}

type Record_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecord_nameContext() *Record_nameContext {
	var p = new(Record_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_record_name
	return p
}

func (*Record_nameContext) IsRecord_nameContext() {}

func NewRecord_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Record_nameContext {
	var p = new(Record_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_record_name

	return p
}

func (s *Record_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Record_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Record_nameContext) Bind_variable() IBind_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_variableContext)
}

func (s *Record_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Record_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Record_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRecord_name(s)
	}
}

func (s *Record_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRecord_name(s)
	}
}

func (p *PlSqlParser) Record_name() (localctx IRecord_nameContext) {
	localctx = NewRecord_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, PlSqlParserRULE_record_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5364)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5362)
			p.Identifier()
		}

	case PlSqlParserBINDVAR, PlSqlParserCOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5363)
			p.Bind_variable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollection_nameContext is an interface to support dynamic dispatch.
type ICollection_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_nameContext differentiates from other interfaces.
	IsCollection_nameContext()
}

type Collection_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_nameContext() *Collection_nameContext {
	var p = new(Collection_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_collection_name
	return p
}

func (*Collection_nameContext) IsCollection_nameContext() {}

func NewCollection_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_nameContext {
	var p = new(Collection_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_collection_name

	return p
}

func (s *Collection_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Collection_nameContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Collection_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterCollection_name(s)
	}
}

func (s *Collection_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitCollection_name(s)
	}
}

func (p *PlSqlParser) Collection_name() (localctx ICollection_nameContext) {
	localctx = NewCollection_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, PlSqlParserRULE_collection_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5366)
		p.Identifier()
	}
	p.SetState(5369)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserPERIOD {
		{
			p.SetState(5367)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5368)
			p.Id_expression()
		}

	}

	return localctx
}

// ILink_nameContext is an interface to support dynamic dispatch.
type ILink_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_nameContext differentiates from other interfaces.
	IsLink_nameContext()
}

type Link_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_nameContext() *Link_nameContext {
	var p = new(Link_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_link_name
	return p
}

func (*Link_nameContext) IsLink_nameContext() {}

func NewLink_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_nameContext {
	var p = new(Link_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_link_name

	return p
}

func (s *Link_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Link_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterLink_name(s)
	}
}

func (s *Link_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitLink_name(s)
	}
}

func (p *PlSqlParser) Link_name() (localctx ILink_nameContext) {
	localctx = NewLink_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, PlSqlParserRULE_link_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5371)
		p.Identifier()
	}

	return localctx
}

// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_column_name
	return p
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Column_nameContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Column_nameContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitColumn_name(s)
	}
}

func (p *PlSqlParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, PlSqlParserRULE_column_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5373)
		p.Identifier()
	}
	p.SetState(5378)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserPERIOD {
		{
			p.SetState(5374)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5375)
			p.Id_expression()
		}

		p.SetState(5380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableview_nameContext is an interface to support dynamic dispatch.
type ITableview_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableview_nameContext differentiates from other interfaces.
	IsTableview_nameContext()
}

type Tableview_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableview_nameContext() *Tableview_nameContext {
	var p = new(Tableview_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_tableview_name
	return p
}

func (*Tableview_nameContext) IsTableview_nameContext() {}

func NewTableview_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tableview_nameContext {
	var p = new(Tableview_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_tableview_name

	return p
}

func (s *Tableview_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Tableview_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Tableview_nameContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Tableview_nameContext) Link_name() ILink_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_nameContext)
}

func (s *Tableview_nameContext) Partition_extension_clause() IPartition_extension_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartition_extension_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartition_extension_clauseContext)
}

func (s *Tableview_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tableview_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tableview_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTableview_name(s)
	}
}

func (s *Tableview_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTableview_name(s)
	}
}

func (p *PlSqlParser) Tableview_name() (localctx ITableview_nameContext) {
	localctx = NewTableview_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, PlSqlParserRULE_tableview_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5381)
		p.Identifier()
	}
	p.SetState(5384)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 702, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5382)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5383)
			p.Id_expression()
		}

	}
	p.SetState(5389)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 703, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5386)
			p.Match(PlSqlParserAT_SIGN)
		}
		{
			p.SetState(5387)
			p.Link_name()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 703, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5388)
			p.Partition_extension_clause()
		}

	}

	return localctx
}

// IChar_set_nameContext is an interface to support dynamic dispatch.
type IChar_set_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChar_set_nameContext differentiates from other interfaces.
	IsChar_set_nameContext()
}

type Char_set_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChar_set_nameContext() *Char_set_nameContext {
	var p = new(Char_set_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_char_set_name
	return p
}

func (*Char_set_nameContext) IsChar_set_nameContext() {}

func NewChar_set_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Char_set_nameContext {
	var p = new(Char_set_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_char_set_name

	return p
}

func (s *Char_set_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Char_set_nameContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Char_set_nameContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Char_set_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Char_set_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Char_set_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterChar_set_name(s)
	}
}

func (s *Char_set_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitChar_set_name(s)
	}
}

func (p *PlSqlParser) Char_set_name() (localctx IChar_set_nameContext) {
	localctx = NewChar_set_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, PlSqlParserRULE_char_set_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5391)
		p.Id_expression()
	}
	p.SetState(5396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserPERIOD {
		{
			p.SetState(5392)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5393)
			p.Id_expression()
		}

		p.SetState(5398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISynonym_nameContext is an interface to support dynamic dispatch.
type ISynonym_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSynonym_nameContext differentiates from other interfaces.
	IsSynonym_nameContext()
}

type Synonym_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySynonym_nameContext() *Synonym_nameContext {
	var p = new(Synonym_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_synonym_name
	return p
}

func (*Synonym_nameContext) IsSynonym_nameContext() {}

func NewSynonym_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Synonym_nameContext {
	var p = new(Synonym_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_synonym_name

	return p
}

func (s *Synonym_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Synonym_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Synonym_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Synonym_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Synonym_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSynonym_name(s)
	}
}

func (s *Synonym_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSynonym_name(s)
	}
}

func (p *PlSqlParser) Synonym_name() (localctx ISynonym_nameContext) {
	localctx = NewSynonym_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, PlSqlParserRULE_synonym_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5399)
		p.Identifier()
	}

	return localctx
}

// ISchema_object_nameContext is an interface to support dynamic dispatch.
type ISchema_object_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchema_object_nameContext differentiates from other interfaces.
	IsSchema_object_nameContext()
}

type Schema_object_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchema_object_nameContext() *Schema_object_nameContext {
	var p = new(Schema_object_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_schema_object_name
	return p
}

func (*Schema_object_nameContext) IsSchema_object_nameContext() {}

func NewSchema_object_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Schema_object_nameContext {
	var p = new(Schema_object_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_schema_object_name

	return p
}

func (s *Schema_object_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Schema_object_nameContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Schema_object_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Schema_object_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Schema_object_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterSchema_object_name(s)
	}
}

func (s *Schema_object_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitSchema_object_name(s)
	}
}

func (p *PlSqlParser) Schema_object_name() (localctx ISchema_object_nameContext) {
	localctx = NewSchema_object_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, PlSqlParserRULE_schema_object_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5401)
		p.Id_expression()
	}

	return localctx
}

// IKeep_clauseContext is an interface to support dynamic dispatch.
type IKeep_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeep_clauseContext differentiates from other interfaces.
	IsKeep_clauseContext()
}

type Keep_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeep_clauseContext() *Keep_clauseContext {
	var p = new(Keep_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_keep_clause
	return p
}

func (*Keep_clauseContext) IsKeep_clauseContext() {}

func NewKeep_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keep_clauseContext {
	var p = new(Keep_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_keep_clause

	return p
}

func (s *Keep_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Keep_clauseContext) KEEP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserKEEP, 0)
}

func (s *Keep_clauseContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDENSE_RANK, 0)
}

func (s *Keep_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Keep_clauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFIRST, 0)
}

func (s *Keep_clauseContext) LAST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLAST, 0)
}

func (s *Keep_clauseContext) Over_clause() IOver_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOver_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOver_clauseContext)
}

func (s *Keep_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keep_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keep_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterKeep_clause(s)
	}
}

func (s *Keep_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitKeep_clause(s)
	}
}

func (p *PlSqlParser) Keep_clause() (localctx IKeep_clauseContext) {
	localctx = NewKeep_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, PlSqlParserRULE_keep_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5403)
		p.Match(PlSqlParserKEEP)
	}
	{
		p.SetState(5404)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(5405)
		p.Match(PlSqlParserDENSE_RANK)
	}
	{
		p.SetState(5406)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserFIRST || _la == PlSqlParserLAST) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5407)
		p.Order_by_clause()
	}
	{
		p.SetState(5408)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(5410)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 705, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5409)
			p.Over_clause()
		}

	}

	return localctx
}

// IFunction_argumentContext is an interface to support dynamic dispatch.
type IFunction_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_argumentContext differentiates from other interfaces.
	IsFunction_argumentContext()
}

type Function_argumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_argumentContext() *Function_argumentContext {
	var p = new(Function_argumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_function_argument
	return p
}

func (*Function_argumentContext) IsFunction_argumentContext() {}

func NewFunction_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_argumentContext {
	var p = new(Function_argumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_function_argument

	return p
}

func (s *Function_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_argumentContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *Function_argumentContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *Function_argumentContext) Keep_clause() IKeep_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeep_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeep_clauseContext)
}

func (s *Function_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFunction_argument(s)
	}
}

func (s *Function_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFunction_argument(s)
	}
}

func (p *PlSqlParser) Function_argument() (localctx IFunction_argumentContext) {
	localctx = NewFunction_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, PlSqlParserRULE_function_argument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5412)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(5414)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
		{
			p.SetState(5413)
			p.Argument()
		}

	}
	p.SetState(5420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(5416)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(5417)
			p.Argument()
		}

		p.SetState(5422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5423)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(5425)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5424)
			p.Keep_clause()
		}

	}

	return localctx
}

// IFunction_argument_analyticContext is an interface to support dynamic dispatch.
type IFunction_argument_analyticContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_argument_analyticContext differentiates from other interfaces.
	IsFunction_argument_analyticContext()
}

type Function_argument_analyticContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_argument_analyticContext() *Function_argument_analyticContext {
	var p = new(Function_argument_analyticContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_function_argument_analytic
	return p
}

func (*Function_argument_analyticContext) IsFunction_argument_analyticContext() {}

func NewFunction_argument_analyticContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_argument_analyticContext {
	var p = new(Function_argument_analyticContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_function_argument_analytic

	return p
}

func (s *Function_argument_analyticContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_argument_analyticContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *Function_argument_analyticContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *Function_argument_analyticContext) Keep_clause() IKeep_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeep_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeep_clauseContext)
}

func (s *Function_argument_analyticContext) AllRespect_or_ignore_nulls() []IRespect_or_ignore_nullsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRespect_or_ignore_nullsContext)(nil)).Elem())
	var tst = make([]IRespect_or_ignore_nullsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRespect_or_ignore_nullsContext)
		}
	}

	return tst
}

func (s *Function_argument_analyticContext) Respect_or_ignore_nulls(i int) IRespect_or_ignore_nullsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRespect_or_ignore_nullsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRespect_or_ignore_nullsContext)
}

func (s *Function_argument_analyticContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_argument_analyticContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_argument_analyticContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFunction_argument_analytic(s)
	}
}

func (s *Function_argument_analyticContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFunction_argument_analytic(s)
	}
}

func (p *PlSqlParser) Function_argument_analytic() (localctx IFunction_argument_analyticContext) {
	localctx = NewFunction_argument_analyticContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, PlSqlParserRULE_function_argument_analytic)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5427)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	p.SetState(5432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserALL)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserANY)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCASE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOALESCE-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONNECT_BY_ROOT-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDATE-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDISTINCT-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXISTS-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFALSE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNOT-260))|(1<<(PlSqlParserNULL-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserPRIOR-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUE-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserDECODE-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserNVL-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-520)&-(0x1f+1)) == 0 && ((1<<uint((_la-520)))&((1<<(PlSqlParserROUND-520))|(1<<(PlSqlParserROW_NUMBER-520))|(1<<(PlSqlParserSUBSTR-520))|(1<<(PlSqlParserTO_CHAR-520))|(1<<(PlSqlParserTRIM-520))|(1<<(PlSqlParserSUM-520))|(1<<(PlSqlParserSTDDEV-520))|(1<<(PlSqlParserVAR_-520))|(1<<(PlSqlParserVARIANCE-520))|(1<<(PlSqlParserLEAST-520))|(1<<(PlSqlParserGREATEST-520))|(1<<(PlSqlParserTO_DATE-520))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-520))|(1<<(PlSqlParserUNSIGNED_INTEGER-520))|(1<<(PlSqlParserAPPROXIMATE_NUM_LIT-520))|(1<<(PlSqlParserCHAR_STRING-520))|(1<<(PlSqlParserDELIMITED_ID-520))|(1<<(PlSqlParserLEFT_PAREN-520))|(1<<(PlSqlParserPLUS_SIGN-520))|(1<<(PlSqlParserMINUS_SIGN-520)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(PlSqlParserBINDVAR-553))|(1<<(PlSqlParserCOLON-553))|(1<<(PlSqlParserINTRODUCER-553))|(1<<(PlSqlParserREGULAR_ID-553)))) != 0) {
		{
			p.SetState(5428)
			p.Argument()
		}
		p.SetState(5430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserIGNORE || _la == PlSqlParserRESPECT {
			{
				p.SetState(5429)
				p.Respect_or_ignore_nulls()
			}

		}

	}
	p.SetState(5441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserCOMMA {
		{
			p.SetState(5434)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(5435)
			p.Argument()
		}
		p.SetState(5437)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserIGNORE || _la == PlSqlParserRESPECT {
			{
				p.SetState(5436)
				p.Respect_or_ignore_nulls()
			}

		}

		p.SetState(5443)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5444)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(5446)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 713, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5445)
			p.Keep_clause()
		}

	}

	return localctx
}

// IFunction_argument_modelingContext is an interface to support dynamic dispatch.
type IFunction_argument_modelingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_argument_modelingContext differentiates from other interfaces.
	IsFunction_argument_modelingContext()
}

type Function_argument_modelingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_argument_modelingContext() *Function_argument_modelingContext {
	var p = new(Function_argument_modelingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_function_argument_modeling
	return p
}

func (*Function_argument_modelingContext) IsFunction_argument_modelingContext() {}

func NewFunction_argument_modelingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_argument_modelingContext {
	var p = new(Function_argument_modelingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_function_argument_modeling

	return p
}

func (s *Function_argument_modelingContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_argument_modelingContext) Column_name() IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Function_argument_modelingContext) USING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSING, 0)
}

func (s *Function_argument_modelingContext) Tableview_name() ITableview_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableview_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableview_nameContext)
}

func (s *Function_argument_modelingContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Function_argument_modelingContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_argument_modelingContext) Keep_clause() IKeep_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeep_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeep_clauseContext)
}

func (s *Function_argument_modelingContext) AllNumeric() []INumericContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumericContext)(nil)).Elem())
	var tst = make([]INumericContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumericContext)
		}
	}

	return tst
}

func (s *Function_argument_modelingContext) Numeric(i int) INumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumericContext)
}

func (s *Function_argument_modelingContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserNULL)
}

func (s *Function_argument_modelingContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, i)
}

func (s *Function_argument_modelingContext) AllColumn_alias() []IColumn_aliasContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem())
	var tst = make([]IColumn_aliasContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_aliasContext)
		}
	}

	return tst
}

func (s *Function_argument_modelingContext) Column_alias(i int) IColumn_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_aliasContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_aliasContext)
}

func (s *Function_argument_modelingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_argument_modelingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_argument_modelingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterFunction_argument_modeling(s)
	}
}

func (s *Function_argument_modelingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitFunction_argument_modeling(s)
	}
}

func (p *PlSqlParser) Function_argument_modeling() (localctx IFunction_argument_modelingContext) {
	localctx = NewFunction_argument_modelingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, PlSqlParserRULE_function_argument_modeling)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5448)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(5449)
		p.Column_name()
	}
	p.SetState(5462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserCOMMA {
		{
			p.SetState(5450)
			p.Match(PlSqlParserCOMMA)
		}
		p.SetState(5453)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT:
			{
				p.SetState(5451)
				p.Numeric()
			}

		case PlSqlParserNULL:
			{
				p.SetState(5452)
				p.Match(PlSqlParserNULL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(5460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserCOMMA {
			{
				p.SetState(5455)
				p.Match(PlSqlParserCOMMA)
			}
			p.SetState(5458)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT:
				{
					p.SetState(5456)
					p.Numeric()
				}

			case PlSqlParserNULL:
				{
					p.SetState(5457)
					p.Match(PlSqlParserNULL)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}

	}
	{
		p.SetState(5464)
		p.Match(PlSqlParserUSING)
	}
	p.SetState(5484)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 721, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5465)
			p.Tableview_name()
		}
		{
			p.SetState(5466)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5467)
			p.Match(PlSqlParserASTERISK)
		}

	case 2:
		{
			p.SetState(5469)
			p.Match(PlSqlParserASTERISK)
		}

	case 3:
		{
			p.SetState(5470)
			p.Expression()
		}
		p.SetState(5472)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserAS)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-521))|(1<<(PlSqlParserCHAR_STRING-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
			{
				p.SetState(5471)
				p.Column_alias()
			}

		}
		p.SetState(5481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PlSqlParserCOMMA {
			{
				p.SetState(5474)
				p.Match(PlSqlParserCOMMA)
			}
			{
				p.SetState(5475)
				p.Expression()
			}
			p.SetState(5477)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserAS)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521))|(1<<(PlSqlParserNATIONAL_CHAR_STRING_LIT-521))|(1<<(PlSqlParserCHAR_STRING-521))|(1<<(PlSqlParserDELIMITED_ID-521)))) != 0) || _la == PlSqlParserINTRODUCER || _la == PlSqlParserREGULAR_ID {
				{
					p.SetState(5476)
					p.Column_alias()
				}

			}

			p.SetState(5483)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(5486)
		p.Match(PlSqlParserRIGHT_PAREN)
	}
	p.SetState(5488)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 722, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5487)
			p.Keep_clause()
		}

	}

	return localctx
}

// IRespect_or_ignore_nullsContext is an interface to support dynamic dispatch.
type IRespect_or_ignore_nullsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRespect_or_ignore_nullsContext differentiates from other interfaces.
	IsRespect_or_ignore_nullsContext()
}

type Respect_or_ignore_nullsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRespect_or_ignore_nullsContext() *Respect_or_ignore_nullsContext {
	var p = new(Respect_or_ignore_nullsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_respect_or_ignore_nulls
	return p
}

func (*Respect_or_ignore_nullsContext) IsRespect_or_ignore_nullsContext() {}

func NewRespect_or_ignore_nullsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Respect_or_ignore_nullsContext {
	var p = new(Respect_or_ignore_nullsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_respect_or_ignore_nulls

	return p
}

func (s *Respect_or_ignore_nullsContext) GetParser() antlr.Parser { return s.parser }

func (s *Respect_or_ignore_nullsContext) NULLS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULLS, 0)
}

func (s *Respect_or_ignore_nullsContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESPECT, 0)
}

func (s *Respect_or_ignore_nullsContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIGNORE, 0)
}

func (s *Respect_or_ignore_nullsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Respect_or_ignore_nullsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Respect_or_ignore_nullsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRespect_or_ignore_nulls(s)
	}
}

func (s *Respect_or_ignore_nullsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRespect_or_ignore_nulls(s)
	}
}

func (p *PlSqlParser) Respect_or_ignore_nulls() (localctx IRespect_or_ignore_nullsContext) {
	localctx = NewRespect_or_ignore_nullsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, PlSqlParserRULE_respect_or_ignore_nulls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5490)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserIGNORE || _la == PlSqlParserRESPECT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5491)
		p.Match(PlSqlParserNULLS)
	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *PlSqlParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, PlSqlParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5497)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 723, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5493)
			p.Identifier()
		}
		{
			p.SetState(5494)
			p.Match(PlSqlParserEQUALS_OP)
		}
		{
			p.SetState(5495)
			p.Match(PlSqlParserGREATER_THAN_OP)
		}

	}
	{
		p.SetState(5499)
		p.Expression()
	}

	return localctx
}

// IType_specContext is an interface to support dynamic dispatch.
type IType_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specContext differentiates from other interfaces.
	IsType_specContext()
}

type Type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specContext() *Type_specContext {
	var p = new(Type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_type_spec
	return p
}

func (*Type_specContext) IsType_specContext() {}

func NewType_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specContext {
	var p = new(Type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_type_spec

	return p
}

func (s *Type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specContext) Datatype() IDatatypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatatypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatatypeContext)
}

func (s *Type_specContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Type_specContext) REF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREF, 0)
}

func (s *Type_specContext) PERCENT_ROWTYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENT_ROWTYPE, 0)
}

func (s *Type_specContext) PERCENT_TYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENT_TYPE, 0)
}

func (s *Type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterType_spec(s)
	}
}

func (s *Type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitType_spec(s)
	}
}

func (p *PlSqlParser) Type_spec() (localctx IType_specContext) {
	localctx = NewType_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, PlSqlParserRULE_type_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5509)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 726, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5501)
			p.Datatype()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5503)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 724, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5502)
				p.Match(PlSqlParserREF)
			}

		}
		{
			p.SetState(5505)
			p.Type_name()
		}
		p.SetState(5507)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserPERCENT_ROWTYPE || _la == PlSqlParserPERCENT_TYPE {
			{
				p.SetState(5506)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PlSqlParserPERCENT_ROWTYPE || _la == PlSqlParserPERCENT_TYPE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}

	return localctx
}

// IDatatypeContext is an interface to support dynamic dispatch.
type IDatatypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatatypeContext differentiates from other interfaces.
	IsDatatypeContext()
}

type DatatypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatypeContext() *DatatypeContext {
	var p = new(DatatypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_datatype
	return p
}

func (*DatatypeContext) IsDatatypeContext() {}

func NewDatatypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatatypeContext {
	var p = new(DatatypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_datatype

	return p
}

func (s *DatatypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DatatypeContext) Native_datatype_element() INative_datatype_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INative_datatype_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INative_datatype_elementContext)
}

func (s *DatatypeContext) Precision_part() IPrecision_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrecision_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrecision_partContext)
}

func (s *DatatypeContext) WITH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWITH, 0)
}

func (s *DatatypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIME, 0)
}

func (s *DatatypeContext) ZONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserZONE, 0)
}

func (s *DatatypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHARACTER, 0)
}

func (s *DatatypeContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *DatatypeContext) Char_set_name() IChar_set_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_set_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_set_nameContext)
}

func (s *DatatypeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOCAL, 0)
}

func (s *DatatypeContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTERVAL, 0)
}

func (s *DatatypeContext) TO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO, 0)
}

func (s *DatatypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserYEAR, 0)
}

func (s *DatatypeContext) DAY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDAY, 0)
}

func (s *DatatypeContext) MONTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMONTH, 0)
}

func (s *DatatypeContext) SECOND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSECOND, 0)
}

func (s *DatatypeContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *DatatypeContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DatatypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatatypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatatypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterDatatype(s)
	}
}

func (s *DatatypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitDatatype(s)
	}
}

func (p *PlSqlParser) Datatype() (localctx IDatatypeContext) {
	localctx = NewDatatypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, PlSqlParserRULE_datatype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5542)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBOOLEAN, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCLOB, PlSqlParserDATE, PlSqlParserDAY, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserFLOAT, PlSqlParserHOUR, PlSqlParserINTEGER, PlSqlParserINT, PlSqlParserLONG, PlSqlParserMINUTE, PlSqlParserMLSLABEL, PlSqlParserMONTH, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserRAW, PlSqlParserREAL, PlSqlParserROWID, PlSqlParserSECOND, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSMALLINT, PlSqlParserSTRING, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserUROWID, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserYEAR, PlSqlParserYMINTERVAL_UNCONSTRAINED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5511)
			p.Native_datatype_element()
		}
		p.SetState(5513)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 727, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5512)
				p.Precision_part()
			}

		}
		p.SetState(5524)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserWITH:
			{
				p.SetState(5515)
				p.Match(PlSqlParserWITH)
			}
			p.SetState(5517)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserLOCAL {
				{
					p.SetState(5516)
					p.Match(PlSqlParserLOCAL)
				}

			}
			{
				p.SetState(5519)
				p.Match(PlSqlParserTIME)
			}
			{
				p.SetState(5520)
				p.Match(PlSqlParserZONE)
			}

		case PlSqlParserCHARACTER:
			{
				p.SetState(5521)
				p.Match(PlSqlParserCHARACTER)
			}
			{
				p.SetState(5522)
				p.Match(PlSqlParserSET)
			}
			{
				p.SetState(5523)
				p.Char_set_name()
			}

		case PlSqlParserEOF, PlSqlParserAGGREGATE, PlSqlParserAS, PlSqlParserAUTHID, PlSqlParserCASCADE, PlSqlParserCONSTRUCTOR, PlSqlParserDEFAULT, PlSqlParserDETERMINISTIC, PlSqlParserENCODING, PlSqlParserEXTERNAL, PlSqlParserFINAL, PlSqlParserHIDE, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDEX, PlSqlParserINSTANTIABLE, PlSqlParserINVALIDATE, PlSqlParserIS, PlSqlParserMAP, PlSqlParserMEMBER, PlSqlParserNO, PlSqlParserNOT, PlSqlParserORDER, PlSqlParserOVERRIDING, PlSqlParserPARALLEL_ENABLE, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserRANGE, PlSqlParserRESULT_CACHE, PlSqlParserRETURN, PlSqlParserSHOW, PlSqlParserSTATIC, PlSqlParserVERSION, PlSqlParserLEFT_PAREN, PlSqlParserRIGHT_PAREN, PlSqlParserCOMMA, PlSqlParserASSIGN_OP, PlSqlParserSEMICOLON:

		default:
		}

	case PlSqlParserINTERVAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5526)
			p.Match(PlSqlParserINTERVAL)
		}
		{
			p.SetState(5527)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserDAY || _la == PlSqlParserYEAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5532)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserLEFT_PAREN {
			{
				p.SetState(5528)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			{
				p.SetState(5529)
				p.Expression()
			}
			{
				p.SetState(5530)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		}
		{
			p.SetState(5534)
			p.Match(PlSqlParserTO)
		}
		{
			p.SetState(5535)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserMONTH || _la == PlSqlParserSECOND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5540)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 731, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5536)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			{
				p.SetState(5537)
				p.Expression()
			}
			{
				p.SetState(5538)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrecision_partContext is an interface to support dynamic dispatch.
type IPrecision_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrecision_partContext differentiates from other interfaces.
	IsPrecision_partContext()
}

type Precision_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecision_partContext() *Precision_partContext {
	var p = new(Precision_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_precision_part
	return p
}

func (*Precision_partContext) IsPrecision_partContext() {}

func NewPrecision_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Precision_partContext {
	var p = new(Precision_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_precision_part

	return p
}

func (s *Precision_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Precision_partContext) AllNumeric() []INumericContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumericContext)(nil)).Elem())
	var tst = make([]INumericContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumericContext)
		}
	}

	return tst
}

func (s *Precision_partContext) Numeric(i int) INumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumericContext)
}

func (s *Precision_partContext) CHAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR, 0)
}

func (s *Precision_partContext) BYTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBYTE, 0)
}

func (s *Precision_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Precision_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Precision_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterPrecision_part(s)
	}
}

func (s *Precision_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitPrecision_part(s)
	}
}

func (p *PlSqlParser) Precision_part() (localctx IPrecision_partContext) {
	localctx = NewPrecision_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, PlSqlParserRULE_precision_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5544)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(5545)
		p.Numeric()
	}
	p.SetState(5548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserCOMMA {
		{
			p.SetState(5546)
			p.Match(PlSqlParserCOMMA)
		}
		{
			p.SetState(5547)
			p.Numeric()
		}

	}
	p.SetState(5551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserBYTE || _la == PlSqlParserCHAR {
		{
			p.SetState(5550)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserBYTE || _la == PlSqlParserCHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5553)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// INative_datatype_elementContext is an interface to support dynamic dispatch.
type INative_datatype_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNative_datatype_elementContext differentiates from other interfaces.
	IsNative_datatype_elementContext()
}

type Native_datatype_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNative_datatype_elementContext() *Native_datatype_elementContext {
	var p = new(Native_datatype_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_native_datatype_element
	return p
}

func (*Native_datatype_elementContext) IsNative_datatype_elementContext() {}

func NewNative_datatype_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Native_datatype_elementContext {
	var p = new(Native_datatype_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_native_datatype_element

	return p
}

func (s *Native_datatype_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Native_datatype_elementContext) BINARY_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBINARY_INTEGER, 0)
}

func (s *Native_datatype_elementContext) PLS_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPLS_INTEGER, 0)
}

func (s *Native_datatype_elementContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNATURAL, 0)
}

func (s *Native_datatype_elementContext) BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBINARY_FLOAT, 0)
}

func (s *Native_datatype_elementContext) BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBINARY_DOUBLE, 0)
}

func (s *Native_datatype_elementContext) NATURALN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNATURALN, 0)
}

func (s *Native_datatype_elementContext) POSITIVE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPOSITIVE, 0)
}

func (s *Native_datatype_elementContext) POSITIVEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPOSITIVEN, 0)
}

func (s *Native_datatype_elementContext) SIGNTYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSIGNTYPE, 0)
}

func (s *Native_datatype_elementContext) SIMPLE_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSIMPLE_INTEGER, 0)
}

func (s *Native_datatype_elementContext) NVARCHAR2() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNVARCHAR2, 0)
}

func (s *Native_datatype_elementContext) DEC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEC, 0)
}

func (s *Native_datatype_elementContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTEGER, 0)
}

func (s *Native_datatype_elementContext) INT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINT, 0)
}

func (s *Native_datatype_elementContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNUMERIC, 0)
}

func (s *Native_datatype_elementContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSMALLINT, 0)
}

func (s *Native_datatype_elementContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNUMBER, 0)
}

func (s *Native_datatype_elementContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECIMAL, 0)
}

func (s *Native_datatype_elementContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDOUBLE, 0)
}

func (s *Native_datatype_elementContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRECISION, 0)
}

func (s *Native_datatype_elementContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFLOAT, 0)
}

func (s *Native_datatype_elementContext) REAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREAL, 0)
}

func (s *Native_datatype_elementContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNCHAR, 0)
}

func (s *Native_datatype_elementContext) LONG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLONG, 0)
}

func (s *Native_datatype_elementContext) RAW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRAW, 0)
}

func (s *Native_datatype_elementContext) CHAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR, 0)
}

func (s *Native_datatype_elementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHARACTER, 0)
}

func (s *Native_datatype_elementContext) VARCHAR2() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARCHAR2, 0)
}

func (s *Native_datatype_elementContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARCHAR, 0)
}

func (s *Native_datatype_elementContext) STRING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTRING, 0)
}

func (s *Native_datatype_elementContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBOOLEAN, 0)
}

func (s *Native_datatype_elementContext) DATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDATE, 0)
}

func (s *Native_datatype_elementContext) ROWID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROWID, 0)
}

func (s *Native_datatype_elementContext) UROWID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUROWID, 0)
}

func (s *Native_datatype_elementContext) YEAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserYEAR, 0)
}

func (s *Native_datatype_elementContext) MONTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMONTH, 0)
}

func (s *Native_datatype_elementContext) DAY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDAY, 0)
}

func (s *Native_datatype_elementContext) HOUR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserHOUR, 0)
}

func (s *Native_datatype_elementContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINUTE, 0)
}

func (s *Native_datatype_elementContext) SECOND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSECOND, 0)
}

func (s *Native_datatype_elementContext) TIMEZONE_HOUR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMEZONE_HOUR, 0)
}

func (s *Native_datatype_elementContext) TIMEZONE_MINUTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMEZONE_MINUTE, 0)
}

func (s *Native_datatype_elementContext) TIMEZONE_REGION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMEZONE_REGION, 0)
}

func (s *Native_datatype_elementContext) TIMEZONE_ABBR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMEZONE_ABBR, 0)
}

func (s *Native_datatype_elementContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP, 0)
}

func (s *Native_datatype_elementContext) TIMESTAMP_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP_UNCONSTRAINED, 0)
}

func (s *Native_datatype_elementContext) TIMESTAMP_TZ_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, 0)
}

func (s *Native_datatype_elementContext) TIMESTAMP_LTZ_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, 0)
}

func (s *Native_datatype_elementContext) YMINTERVAL_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserYMINTERVAL_UNCONSTRAINED, 0)
}

func (s *Native_datatype_elementContext) DSINTERVAL_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDSINTERVAL_UNCONSTRAINED, 0)
}

func (s *Native_datatype_elementContext) BFILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBFILE, 0)
}

func (s *Native_datatype_elementContext) BLOB() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBLOB, 0)
}

func (s *Native_datatype_elementContext) CLOB() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCLOB, 0)
}

func (s *Native_datatype_elementContext) NCLOB() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNCLOB, 0)
}

func (s *Native_datatype_elementContext) MLSLABEL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMLSLABEL, 0)
}

func (s *Native_datatype_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Native_datatype_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Native_datatype_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNative_datatype_element(s)
	}
}

func (s *Native_datatype_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNative_datatype_element(s)
	}
}

func (p *PlSqlParser) Native_datatype_element() (localctx INative_datatype_elementContext) {
	localctx = NewNative_datatype_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, PlSqlParserRULE_native_datatype_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5615)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserBINARY_INTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5555)
			p.Match(PlSqlParserBINARY_INTEGER)
		}

	case PlSqlParserPLS_INTEGER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5556)
			p.Match(PlSqlParserPLS_INTEGER)
		}

	case PlSqlParserNATURAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5557)
			p.Match(PlSqlParserNATURAL)
		}

	case PlSqlParserBINARY_FLOAT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5558)
			p.Match(PlSqlParserBINARY_FLOAT)
		}

	case PlSqlParserBINARY_DOUBLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5559)
			p.Match(PlSqlParserBINARY_DOUBLE)
		}

	case PlSqlParserNATURALN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5560)
			p.Match(PlSqlParserNATURALN)
		}

	case PlSqlParserPOSITIVE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5561)
			p.Match(PlSqlParserPOSITIVE)
		}

	case PlSqlParserPOSITIVEN:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5562)
			p.Match(PlSqlParserPOSITIVEN)
		}

	case PlSqlParserSIGNTYPE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5563)
			p.Match(PlSqlParserSIGNTYPE)
		}

	case PlSqlParserSIMPLE_INTEGER:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5564)
			p.Match(PlSqlParserSIMPLE_INTEGER)
		}

	case PlSqlParserNVARCHAR2:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5565)
			p.Match(PlSqlParserNVARCHAR2)
		}

	case PlSqlParserDEC:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5566)
			p.Match(PlSqlParserDEC)
		}

	case PlSqlParserINTEGER:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5567)
			p.Match(PlSqlParserINTEGER)
		}

	case PlSqlParserINT:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5568)
			p.Match(PlSqlParserINT)
		}

	case PlSqlParserNUMERIC:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5569)
			p.Match(PlSqlParserNUMERIC)
		}

	case PlSqlParserSMALLINT:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5570)
			p.Match(PlSqlParserSMALLINT)
		}

	case PlSqlParserNUMBER:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5571)
			p.Match(PlSqlParserNUMBER)
		}

	case PlSqlParserDECIMAL:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5572)
			p.Match(PlSqlParserDECIMAL)
		}

	case PlSqlParserDOUBLE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5573)
			p.Match(PlSqlParserDOUBLE)
		}
		p.SetState(5575)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserPRECISION {
			{
				p.SetState(5574)
				p.Match(PlSqlParserPRECISION)
			}

		}

	case PlSqlParserFLOAT:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5577)
			p.Match(PlSqlParserFLOAT)
		}

	case PlSqlParserREAL:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(5578)
			p.Match(PlSqlParserREAL)
		}

	case PlSqlParserNCHAR:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(5579)
			p.Match(PlSqlParserNCHAR)
		}

	case PlSqlParserLONG:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(5580)
			p.Match(PlSqlParserLONG)
		}
		p.SetState(5582)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserRAW {
			{
				p.SetState(5581)
				p.Match(PlSqlParserRAW)
			}

		}

	case PlSqlParserCHAR:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(5584)
			p.Match(PlSqlParserCHAR)
		}

	case PlSqlParserCHARACTER:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(5585)
			p.Match(PlSqlParserCHARACTER)
		}

	case PlSqlParserVARCHAR2:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(5586)
			p.Match(PlSqlParserVARCHAR2)
		}

	case PlSqlParserVARCHAR:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(5587)
			p.Match(PlSqlParserVARCHAR)
		}

	case PlSqlParserSTRING:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(5588)
			p.Match(PlSqlParserSTRING)
		}

	case PlSqlParserRAW:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(5589)
			p.Match(PlSqlParserRAW)
		}

	case PlSqlParserBOOLEAN:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(5590)
			p.Match(PlSqlParserBOOLEAN)
		}

	case PlSqlParserDATE:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(5591)
			p.Match(PlSqlParserDATE)
		}

	case PlSqlParserROWID:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(5592)
			p.Match(PlSqlParserROWID)
		}

	case PlSqlParserUROWID:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(5593)
			p.Match(PlSqlParserUROWID)
		}

	case PlSqlParserYEAR:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(5594)
			p.Match(PlSqlParserYEAR)
		}

	case PlSqlParserMONTH:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(5595)
			p.Match(PlSqlParserMONTH)
		}

	case PlSqlParserDAY:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(5596)
			p.Match(PlSqlParserDAY)
		}

	case PlSqlParserHOUR:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(5597)
			p.Match(PlSqlParserHOUR)
		}

	case PlSqlParserMINUTE:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(5598)
			p.Match(PlSqlParserMINUTE)
		}

	case PlSqlParserSECOND:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(5599)
			p.Match(PlSqlParserSECOND)
		}

	case PlSqlParserTIMEZONE_HOUR:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(5600)
			p.Match(PlSqlParserTIMEZONE_HOUR)
		}

	case PlSqlParserTIMEZONE_MINUTE:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(5601)
			p.Match(PlSqlParserTIMEZONE_MINUTE)
		}

	case PlSqlParserTIMEZONE_REGION:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(5602)
			p.Match(PlSqlParserTIMEZONE_REGION)
		}

	case PlSqlParserTIMEZONE_ABBR:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(5603)
			p.Match(PlSqlParserTIMEZONE_ABBR)
		}

	case PlSqlParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(5604)
			p.Match(PlSqlParserTIMESTAMP)
		}

	case PlSqlParserTIMESTAMP_UNCONSTRAINED:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(5605)
			p.Match(PlSqlParserTIMESTAMP_UNCONSTRAINED)
		}

	case PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(5606)
			p.Match(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED)
		}

	case PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(5607)
			p.Match(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED)
		}

	case PlSqlParserYMINTERVAL_UNCONSTRAINED:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(5608)
			p.Match(PlSqlParserYMINTERVAL_UNCONSTRAINED)
		}

	case PlSqlParserDSINTERVAL_UNCONSTRAINED:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(5609)
			p.Match(PlSqlParserDSINTERVAL_UNCONSTRAINED)
		}

	case PlSqlParserBFILE:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(5610)
			p.Match(PlSqlParserBFILE)
		}

	case PlSqlParserBLOB:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(5611)
			p.Match(PlSqlParserBLOB)
		}

	case PlSqlParserCLOB:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(5612)
			p.Match(PlSqlParserCLOB)
		}

	case PlSqlParserNCLOB:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(5613)
			p.Match(PlSqlParserNCLOB)
		}

	case PlSqlParserMLSLABEL:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(5614)
			p.Match(PlSqlParserMLSLABEL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBind_variableContext is an interface to support dynamic dispatch.
type IBind_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBind_variableContext differentiates from other interfaces.
	IsBind_variableContext()
}

type Bind_variableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_variableContext() *Bind_variableContext {
	var p = new(Bind_variableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_bind_variable
	return p
}

func (*Bind_variableContext) IsBind_variableContext() {}

func NewBind_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_variableContext {
	var p = new(Bind_variableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_bind_variable

	return p
}

func (s *Bind_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_variableContext) AllBINDVAR() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserBINDVAR)
}

func (s *Bind_variableContext) BINDVAR(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserBINDVAR, i)
}

func (s *Bind_variableContext) AllUNSIGNED_INTEGER() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserUNSIGNED_INTEGER)
}

func (s *Bind_variableContext) UNSIGNED_INTEGER(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNSIGNED_INTEGER, i)
}

func (s *Bind_variableContext) AllGeneral_element_part() []IGeneral_element_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGeneral_element_partContext)(nil)).Elem())
	var tst = make([]IGeneral_element_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGeneral_element_partContext)
		}
	}

	return tst
}

func (s *Bind_variableContext) General_element_part(i int) IGeneral_element_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_element_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGeneral_element_partContext)
}

func (s *Bind_variableContext) INDICATOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDICATOR, 0)
}

func (s *Bind_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bind_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterBind_variable(s)
	}
}

func (s *Bind_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitBind_variable(s)
	}
}

func (p *PlSqlParser) Bind_variable() (localctx IBind_variableContext) {
	localctx = NewBind_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, PlSqlParserRULE_bind_variable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5620)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserBINDVAR:
		{
			p.SetState(5617)
			p.Match(PlSqlParserBINDVAR)
		}

	case PlSqlParserCOLON:
		{
			p.SetState(5618)
			p.Match(PlSqlParserCOLON)
		}
		{
			p.SetState(5619)
			p.Match(PlSqlParserUNSIGNED_INTEGER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(5630)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 741, p.GetParserRuleContext()) == 1 {
		p.SetState(5623)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PlSqlParserINDICATOR {
			{
				p.SetState(5622)
				p.Match(PlSqlParserINDICATOR)
			}

		}
		p.SetState(5628)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserBINDVAR:
			{
				p.SetState(5625)
				p.Match(PlSqlParserBINDVAR)
			}

		case PlSqlParserCOLON:
			{
				p.SetState(5626)
				p.Match(PlSqlParserCOLON)
			}
			{
				p.SetState(5627)
				p.Match(PlSqlParserUNSIGNED_INTEGER)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}
	p.SetState(5636)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 742, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5632)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(5633)
				p.General_element_part()
			}

		}
		p.SetState(5638)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 742, p.GetParserRuleContext())
	}

	return localctx
}

// IGeneral_elementContext is an interface to support dynamic dispatch.
type IGeneral_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_elementContext differentiates from other interfaces.
	IsGeneral_elementContext()
}

type General_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_elementContext() *General_elementContext {
	var p = new(General_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_general_element
	return p
}

func (*General_elementContext) IsGeneral_elementContext() {}

func NewGeneral_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_elementContext {
	var p = new(General_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_general_element

	return p
}

func (s *General_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *General_elementContext) AllGeneral_element_part() []IGeneral_element_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGeneral_element_partContext)(nil)).Elem())
	var tst = make([]IGeneral_element_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGeneral_element_partContext)
		}
	}

	return tst
}

func (s *General_elementContext) General_element_part(i int) IGeneral_element_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_element_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGeneral_element_partContext)
}

func (s *General_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterGeneral_element(s)
	}
}

func (s *General_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitGeneral_element(s)
	}
}

func (p *PlSqlParser) General_element() (localctx IGeneral_elementContext) {
	localctx = NewGeneral_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, PlSqlParserRULE_general_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5639)
		p.General_element_part()
	}
	p.SetState(5644)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 743, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5640)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(5641)
				p.General_element_part()
			}

		}
		p.SetState(5646)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 743, p.GetParserRuleContext())
	}

	return localctx
}

// IGeneral_element_partContext is an interface to support dynamic dispatch.
type IGeneral_element_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_element_partContext differentiates from other interfaces.
	IsGeneral_element_partContext()
}

type General_element_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_element_partContext() *General_element_partContext {
	var p = new(General_element_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_general_element_part
	return p
}

func (*General_element_partContext) IsGeneral_element_partContext() {}

func NewGeneral_element_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_element_partContext {
	var p = new(General_element_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_general_element_part

	return p
}

func (s *General_element_partContext) GetParser() antlr.Parser { return s.parser }

func (s *General_element_partContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *General_element_partContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *General_element_partContext) INTRODUCER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTRODUCER, 0)
}

func (s *General_element_partContext) Char_set_name() IChar_set_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_set_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_set_nameContext)
}

func (s *General_element_partContext) Link_name() ILink_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_nameContext)
}

func (s *General_element_partContext) Function_argument() IFunction_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_argumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_argumentContext)
}

func (s *General_element_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_element_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_element_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterGeneral_element_part(s)
	}
}

func (s *General_element_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitGeneral_element_part(s)
	}
}

func (p *PlSqlParser) General_element_part() (localctx IGeneral_element_partContext) {
	localctx = NewGeneral_element_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, PlSqlParserRULE_general_element_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserINTRODUCER {
		{
			p.SetState(5647)
			p.Match(PlSqlParserINTRODUCER)
		}
		{
			p.SetState(5648)
			p.Char_set_name()
		}

	}
	{
		p.SetState(5651)
		p.Id_expression()
	}
	p.SetState(5656)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 745, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5652)
				p.Match(PlSqlParserPERIOD)
			}
			{
				p.SetState(5653)
				p.Id_expression()
			}

		}
		p.SetState(5658)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 745, p.GetParserRuleContext())
	}
	p.SetState(5661)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 746, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5659)
			p.Match(PlSqlParserAT_SIGN)
		}
		{
			p.SetState(5660)
			p.Link_name()
		}

	}
	p.SetState(5664)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 747, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5663)
			p.Function_argument()
		}

	}

	return localctx
}

// ITable_elementContext is an interface to support dynamic dispatch.
type ITable_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_elementContext differentiates from other interfaces.
	IsTable_elementContext()
}

type Table_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_elementContext() *Table_elementContext {
	var p = new(Table_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_table_element
	return p
}

func (*Table_elementContext) IsTable_elementContext() {}

func NewTable_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_elementContext {
	var p = new(Table_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_table_element

	return p
}

func (s *Table_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_elementContext) AllId_expression() []IId_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IId_expressionContext)(nil)).Elem())
	var tst = make([]IId_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IId_expressionContext)
		}
	}

	return tst
}

func (s *Table_elementContext) Id_expression(i int) IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Table_elementContext) INTRODUCER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTRODUCER, 0)
}

func (s *Table_elementContext) Char_set_name() IChar_set_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_set_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_set_nameContext)
}

func (s *Table_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterTable_element(s)
	}
}

func (s *Table_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitTable_element(s)
	}
}

func (p *PlSqlParser) Table_element() (localctx ITable_elementContext) {
	localctx = NewTable_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, PlSqlParserRULE_table_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserINTRODUCER {
		{
			p.SetState(5666)
			p.Match(PlSqlParserINTRODUCER)
		}
		{
			p.SetState(5667)
			p.Char_set_name()
		}

	}
	{
		p.SetState(5670)
		p.Id_expression()
	}
	p.SetState(5675)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PlSqlParserPERIOD {
		{
			p.SetState(5671)
			p.Match(PlSqlParserPERIOD)
		}
		{
			p.SetState(5672)
			p.Id_expression()
		}

		p.SetState(5677)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP, 0)
}

func (s *ConstantContext) AllQuoted_string() []IQuoted_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem())
	var tst = make([]IQuoted_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuoted_stringContext)
		}
	}

	return tst
}

func (s *ConstantContext) Quoted_string(i int) IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *ConstantContext) AllBind_variable() []IBind_variableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBind_variableContext)(nil)).Elem())
	var tst = make([]IBind_variableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBind_variableContext)
		}
	}

	return tst
}

func (s *ConstantContext) Bind_variable(i int) IBind_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_variableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBind_variableContext)
}

func (s *ConstantContext) AT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAT, 0)
}

func (s *ConstantContext) TIME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIME, 0)
}

func (s *ConstantContext) ZONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserZONE, 0)
}

func (s *ConstantContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTERVAL, 0)
}

func (s *ConstantContext) YEAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserYEAR, 0)
}

func (s *ConstantContext) MONTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMONTH, 0)
}

func (s *ConstantContext) AllDAY() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserDAY)
}

func (s *ConstantContext) DAY(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserDAY, i)
}

func (s *ConstantContext) AllHOUR() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserHOUR)
}

func (s *ConstantContext) HOUR(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserHOUR, i)
}

func (s *ConstantContext) AllMINUTE() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserMINUTE)
}

func (s *ConstantContext) MINUTE(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINUTE, i)
}

func (s *ConstantContext) AllSECOND() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserSECOND)
}

func (s *ConstantContext) SECOND(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserSECOND, i)
}

func (s *ConstantContext) General_element_part() IGeneral_element_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_element_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_element_partContext)
}

func (s *ConstantContext) TO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO, 0)
}

func (s *ConstantContext) AllUNSIGNED_INTEGER() []antlr.TerminalNode {
	return s.GetTokens(PlSqlParserUNSIGNED_INTEGER)
}

func (s *ConstantContext) UNSIGNED_INTEGER(i int) antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNSIGNED_INTEGER, i)
}

func (s *ConstantContext) Numeric() INumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericContext)
}

func (s *ConstantContext) DATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDATE, 0)
}

func (s *ConstantContext) NULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULL, 0)
}

func (s *ConstantContext) TRUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRUE, 0)
}

func (s *ConstantContext) FALSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFALSE, 0)
}

func (s *ConstantContext) DBTIMEZONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDBTIMEZONE, 0)
}

func (s *ConstantContext) SESSIONTIMEZONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSESSIONTIMEZONE, 0)
}

func (s *ConstantContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINVALUE, 0)
}

func (s *ConstantContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAXVALUE, 0)
}

func (s *ConstantContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFAULT, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *PlSqlParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, PlSqlParserRULE_constant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5740)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5678)
			p.Match(PlSqlParserTIMESTAMP)
		}
		p.SetState(5681)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserCHAR_STRING:
			{
				p.SetState(5679)
				p.Quoted_string()
			}

		case PlSqlParserBINDVAR, PlSqlParserCOLON:
			{
				p.SetState(5680)
				p.Bind_variable()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(5687)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 751, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5683)
				p.Match(PlSqlParserAT)
			}
			{
				p.SetState(5684)
				p.Match(PlSqlParserTIME)
			}
			{
				p.SetState(5685)
				p.Match(PlSqlParserZONE)
			}
			{
				p.SetState(5686)
				p.Quoted_string()
			}

		}

	case PlSqlParserINTERVAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5689)
			p.Match(PlSqlParserINTERVAL)
		}
		p.SetState(5693)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserCHAR_STRING:
			{
				p.SetState(5690)
				p.Quoted_string()
			}

		case PlSqlParserBINDVAR, PlSqlParserCOLON:
			{
				p.SetState(5691)
				p.Bind_variable()
			}

		case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserDELIMITED_ID, PlSqlParserINTRODUCER, PlSqlParserREGULAR_ID:
			{
				p.SetState(5692)
				p.General_element_part()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(5695)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PlSqlParserDAY || _la == PlSqlParserHOUR || _la == PlSqlParserMINUTE || _la == PlSqlParserMONTH || _la == PlSqlParserSECOND || _la == PlSqlParserYEAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5709)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 756, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5696)
				p.Match(PlSqlParserLEFT_PAREN)
			}
			p.SetState(5699)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PlSqlParserUNSIGNED_INTEGER:
				{
					p.SetState(5697)
					p.Match(PlSqlParserUNSIGNED_INTEGER)
				}

			case PlSqlParserBINDVAR, PlSqlParserCOLON:
				{
					p.SetState(5698)
					p.Bind_variable()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			p.SetState(5706)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PlSqlParserCOMMA {
				{
					p.SetState(5701)
					p.Match(PlSqlParserCOMMA)
				}
				p.SetState(5704)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case PlSqlParserUNSIGNED_INTEGER:
					{
						p.SetState(5702)
						p.Match(PlSqlParserUNSIGNED_INTEGER)
					}

				case PlSqlParserBINDVAR, PlSqlParserCOLON:
					{
						p.SetState(5703)
						p.Bind_variable()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}
			{
				p.SetState(5708)
				p.Match(PlSqlParserRIGHT_PAREN)
			}

		}
		p.SetState(5726)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 760, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5711)
				p.Match(PlSqlParserTO)
			}
			p.SetState(5724)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PlSqlParserDAY:
				{
					p.SetState(5712)
					p.Match(PlSqlParserDAY)
				}

			case PlSqlParserHOUR:
				{
					p.SetState(5713)
					p.Match(PlSqlParserHOUR)
				}

			case PlSqlParserMINUTE:
				{
					p.SetState(5714)
					p.Match(PlSqlParserMINUTE)
				}

			case PlSqlParserSECOND:
				{
					p.SetState(5715)
					p.Match(PlSqlParserSECOND)
				}
				p.SetState(5722)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 758, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(5716)
						p.Match(PlSqlParserLEFT_PAREN)
					}
					p.SetState(5719)
					p.GetErrorHandler().Sync(p)

					switch p.GetTokenStream().LA(1) {
					case PlSqlParserUNSIGNED_INTEGER:
						{
							p.SetState(5717)
							p.Match(PlSqlParserUNSIGNED_INTEGER)
						}

					case PlSqlParserBINDVAR, PlSqlParserCOLON:
						{
							p.SetState(5718)
							p.Bind_variable()
						}

					default:
						panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					}
					{
						p.SetState(5721)
						p.Match(PlSqlParserRIGHT_PAREN)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}

	case PlSqlParserUNSIGNED_INTEGER, PlSqlParserAPPROXIMATE_NUM_LIT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5728)
			p.Numeric()
		}

	case PlSqlParserDATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5729)
			p.Match(PlSqlParserDATE)
		}
		{
			p.SetState(5730)
			p.Quoted_string()
		}

	case PlSqlParserNATIONAL_CHAR_STRING_LIT, PlSqlParserCHAR_STRING:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5731)
			p.Quoted_string()
		}

	case PlSqlParserNULL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5732)
			p.Match(PlSqlParserNULL)
		}

	case PlSqlParserTRUE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5733)
			p.Match(PlSqlParserTRUE)
		}

	case PlSqlParserFALSE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5734)
			p.Match(PlSqlParserFALSE)
		}

	case PlSqlParserDBTIMEZONE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5735)
			p.Match(PlSqlParserDBTIMEZONE)
		}

	case PlSqlParserSESSIONTIMEZONE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5736)
			p.Match(PlSqlParserSESSIONTIMEZONE)
		}

	case PlSqlParserMINVALUE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5737)
			p.Match(PlSqlParserMINVALUE)
		}

	case PlSqlParserMAXVALUE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5738)
			p.Match(PlSqlParserMAXVALUE)
		}

	case PlSqlParserDEFAULT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5739)
			p.Match(PlSqlParserDEFAULT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericContext is an interface to support dynamic dispatch.
type INumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericContext differentiates from other interfaces.
	IsNumericContext()
}

type NumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericContext() *NumericContext {
	var p = new(NumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_numeric
	return p
}

func (*NumericContext) IsNumericContext() {}

func NewNumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericContext {
	var p = new(NumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_numeric

	return p
}

func (s *NumericContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericContext) UNSIGNED_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNSIGNED_INTEGER, 0)
}

func (s *NumericContext) APPROXIMATE_NUM_LIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAPPROXIMATE_NUM_LIT, 0)
}

func (s *NumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNumeric(s)
	}
}

func (s *NumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNumeric(s)
	}
}

func (p *PlSqlParser) Numeric() (localctx INumericContext) {
	localctx = NewNumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, PlSqlParserRULE_numeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5742)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserUNSIGNED_INTEGER || _la == PlSqlParserAPPROXIMATE_NUM_LIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INumeric_negativeContext is an interface to support dynamic dispatch.
type INumeric_negativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeric_negativeContext differentiates from other interfaces.
	IsNumeric_negativeContext()
}

type Numeric_negativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_negativeContext() *Numeric_negativeContext {
	var p = new(Numeric_negativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_numeric_negative
	return p
}

func (*Numeric_negativeContext) IsNumeric_negativeContext() {}

func NewNumeric_negativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_negativeContext {
	var p = new(Numeric_negativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_numeric_negative

	return p
}

func (s *Numeric_negativeContext) GetParser() antlr.Parser { return s.parser }

func (s *Numeric_negativeContext) MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINUS_SIGN, 0)
}

func (s *Numeric_negativeContext) Numeric() INumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericContext)
}

func (s *Numeric_negativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_negativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Numeric_negativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNumeric_negative(s)
	}
}

func (s *Numeric_negativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNumeric_negative(s)
	}
}

func (p *PlSqlParser) Numeric_negative() (localctx INumeric_negativeContext) {
	localctx = NewNumeric_negativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, PlSqlParserRULE_numeric_negative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5744)
		p.Match(PlSqlParserMINUS_SIGN)
	}
	{
		p.SetState(5745)
		p.Numeric()
	}

	return localctx
}

// IQuoted_stringContext is an interface to support dynamic dispatch.
type IQuoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuoted_stringContext differentiates from other interfaces.
	IsQuoted_stringContext()
}

type Quoted_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_stringContext() *Quoted_stringContext {
	var p = new(Quoted_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_quoted_string
	return p
}

func (*Quoted_stringContext) IsQuoted_stringContext() {}

func NewQuoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_stringContext {
	var p = new(Quoted_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_quoted_string

	return p
}

func (s *Quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_stringContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR_STRING, 0)
}

func (s *Quoted_stringContext) NATIONAL_CHAR_STRING_LIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNATIONAL_CHAR_STRING_LIT, 0)
}

func (s *Quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterQuoted_string(s)
	}
}

func (s *Quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitQuoted_string(s)
	}
}

func (p *PlSqlParser) Quoted_string() (localctx IQuoted_stringContext) {
	localctx = NewQuoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, PlSqlParserRULE_quoted_string)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5747)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserNATIONAL_CHAR_STRING_LIT || _la == PlSqlParserCHAR_STRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *IdentifierContext) INTRODUCER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTRODUCER, 0)
}

func (s *IdentifierContext) Char_set_name() IChar_set_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_set_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_set_nameContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *PlSqlParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, PlSqlParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5751)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PlSqlParserINTRODUCER {
		{
			p.SetState(5749)
			p.Match(PlSqlParserINTRODUCER)
		}
		{
			p.SetState(5750)
			p.Char_set_name()
		}

	}
	{
		p.SetState(5753)
		p.Id_expression()
	}

	return localctx
}

// IId_expressionContext is an interface to support dynamic dispatch.
type IId_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsId_expressionContext differentiates from other interfaces.
	IsId_expressionContext()
}

type Id_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_expressionContext() *Id_expressionContext {
	var p = new(Id_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_id_expression
	return p
}

func (*Id_expressionContext) IsId_expressionContext() {}

func NewId_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_expressionContext {
	var p = new(Id_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_id_expression

	return p
}

func (s *Id_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_expressionContext) Regular_id() IRegular_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegular_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegular_idContext)
}

func (s *Id_expressionContext) DELIMITED_ID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDELIMITED_ID, 0)
}

func (s *Id_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterId_expression(s)
	}
}

func (s *Id_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitId_expression(s)
	}
}

func (p *PlSqlParser) Id_expression() (localctx IId_expressionContext) {
	localctx = NewId_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, PlSqlParserRULE_id_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5757)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PlSqlParserADD, PlSqlParserAFTER, PlSqlParserAGENT, PlSqlParserAGGREGATE, PlSqlParserA_LETTER, PlSqlParserANALYZE, PlSqlParserARRAY, PlSqlParserASSOCIATE, PlSqlParserAT, PlSqlParserATTRIBUTE, PlSqlParserAUDIT, PlSqlParserAUTHID, PlSqlParserAUTO, PlSqlParserAUTOMATIC, PlSqlParserAUTONOMOUS_TRANSACTION, PlSqlParserBATCH, PlSqlParserBEFORE, PlSqlParserBFILE, PlSqlParserBINARY_DOUBLE, PlSqlParserBINARY_FLOAT, PlSqlParserBINARY_INTEGER, PlSqlParserBLOB, PlSqlParserBLOCK, PlSqlParserBODY, PlSqlParserBOOLEAN, PlSqlParserBOTH, PlSqlParserBULK, PlSqlParserBYTE, PlSqlParserCALL, PlSqlParserCANONICAL, PlSqlParserCASCADE, PlSqlParserCAST, PlSqlParserCHARACTER, PlSqlParserCHAR, PlSqlParserCHAR_CS, PlSqlParserCHR, PlSqlParserC_LETTER, PlSqlParserCLOB, PlSqlParserCLOSE, PlSqlParserCLUSTER, PlSqlParserCOLLECT, PlSqlParserCOLUMNS, PlSqlParserCOMMENT, PlSqlParserCOMMIT, PlSqlParserCOMMITTED, PlSqlParserCOMPATIBILITY, PlSqlParserCOMPILE, PlSqlParserCOMPOUND, PlSqlParserCONSTANT, PlSqlParserCONSTRAINT, PlSqlParserCONSTRAINTS, PlSqlParserCONSTRUCTOR, PlSqlParserCONTENT, PlSqlParserCONTEXT, PlSqlParserCONTINUE, PlSqlParserCONVERT, PlSqlParserCORRUPT_XID_ALL, PlSqlParserCORRUPT_XID, PlSqlParserCOST, PlSqlParserCOUNT, PlSqlParserCROSS, PlSqlParserCUBE, PlSqlParserCURRENT_USER, PlSqlParserCURSOR, PlSqlParserCUSTOMDATUM, PlSqlParserCYCLE, PlSqlParserDATABASE, PlSqlParserDATA, PlSqlParserDAY, PlSqlParserDB_ROLE_CHANGE, PlSqlParserDBTIMEZONE, PlSqlParserDDL, PlSqlParserDEBUG, PlSqlParserDEC, PlSqlParserDECIMAL, PlSqlParserDECOMPOSE, PlSqlParserDECREMENT, PlSqlParserDEFAULTS, PlSqlParserDEFERRED, PlSqlParserDEFINER, PlSqlParserDELETE, PlSqlParserDETERMINISTIC, PlSqlParserDIMENSION, PlSqlParserDISABLE, PlSqlParserDISASSOCIATE, PlSqlParserDOCUMENT, PlSqlParserDOUBLE, PlSqlParserDSINTERVAL_UNCONSTRAINED, PlSqlParserEACH, PlSqlParserELEMENT, PlSqlParserEMPTY, PlSqlParserENABLE, PlSqlParserENCODING, PlSqlParserENTITYESCAPING, PlSqlParserERR, PlSqlParserERRORS, PlSqlParserESCAPE, PlSqlParserEVALNAME, PlSqlParserEXCEPTION, PlSqlParserEXCEPTION_INIT, PlSqlParserEXCEPTIONS, PlSqlParserEXCLUDE, PlSqlParserEXECUTE, PlSqlParserEXIT, PlSqlParserEXPLAIN, PlSqlParserEXTERNAL, PlSqlParserEXTRACT, PlSqlParserFAILURE, PlSqlParserFINAL, PlSqlParserFIRST, PlSqlParserFIRST_VALUE, PlSqlParserFLOAT, PlSqlParserFOLLOWING, PlSqlParserFOLLOWS, PlSqlParserFORALL, PlSqlParserFORCE, PlSqlParserFULL, PlSqlParserFUNCTION, PlSqlParserGROUPING, PlSqlParserHASH, PlSqlParserHIDE, PlSqlParserHOUR, PlSqlParserIGNORE, PlSqlParserIMMEDIATE, PlSqlParserINCLUDE, PlSqlParserINCLUDING, PlSqlParserINCREMENT, PlSqlParserINDENT, PlSqlParserINDEXED, PlSqlParserINDICATOR, PlSqlParserINDICES, PlSqlParserINFINITE, PlSqlParserINLINE, PlSqlParserINNER, PlSqlParserINOUT, PlSqlParserINSTANTIABLE, PlSqlParserINSTEAD, PlSqlParserINTEGER, PlSqlParserINTERVAL, PlSqlParserINT, PlSqlParserINVALIDATE, PlSqlParserISOLATION, PlSqlParserITERATE, PlSqlParserJAVA, PlSqlParserJOIN, PlSqlParserKEEP, PlSqlParserKEY, PlSqlParserLANGUAGE, PlSqlParserLAST, PlSqlParserLAST_VALUE, PlSqlParserLEADING, PlSqlParserLEFT, PlSqlParserLEVEL, PlSqlParserLIBRARY, PlSqlParserLIKE2, PlSqlParserLIKE4, PlSqlParserLIKEC, PlSqlParserLIMIT, PlSqlParserLOCAL, PlSqlParserLOCKED, PlSqlParserLOG, PlSqlParserLOGOFF, PlSqlParserLOGON, PlSqlParserLONG, PlSqlParserLOOP, PlSqlParserMAIN, PlSqlParserMAP, PlSqlParserMATCHED, PlSqlParserMAXVALUE, PlSqlParserMEASURES, PlSqlParserMEMBER, PlSqlParserMERGE, PlSqlParserMINUTE, PlSqlParserMINVALUE, PlSqlParserMLSLABEL, PlSqlParserMODEL, PlSqlParserMODIFY, PlSqlParserMONTH, PlSqlParserMULTISET, PlSqlParserNAME, PlSqlParserNAN, PlSqlParserNATURAL, PlSqlParserNATURALN, PlSqlParserNAV, PlSqlParserNCHAR_CS, PlSqlParserNCHAR, PlSqlParserNCLOB, PlSqlParserNESTED, PlSqlParserNEW, PlSqlParserNOAUDIT, PlSqlParserNOCOPY, PlSqlParserNOCYCLE, PlSqlParserNOENTITYESCAPING, PlSqlParserNONE, PlSqlParserNO, PlSqlParserNOSCHEMACHECK, PlSqlParserNULLS, PlSqlParserNUMBER, PlSqlParserNUMERIC, PlSqlParserNVARCHAR2, PlSqlParserOBJECT, PlSqlParserOFF, PlSqlParserOID, PlSqlParserOLD, PlSqlParserONLY, PlSqlParserOPEN, PlSqlParserORADATA, PlSqlParserORDINALITY, PlSqlParserOSERROR, PlSqlParserOUTER, PlSqlParserOUT, PlSqlParserOVER, PlSqlParserOVERRIDING, PlSqlParserPACKAGE, PlSqlParserPARALLEL_ENABLE, PlSqlParserPARAMETERS, PlSqlParserPARENT, PlSqlParserPARTITION, PlSqlParserPASSING, PlSqlParserPATH, PlSqlParserPIPELINED, PlSqlParserPLAN, PlSqlParserPLS_INTEGER, PlSqlParserPOSITIVEN, PlSqlParserPOSITIVE, PlSqlParserPRAGMA, PlSqlParserPRECEDING, PlSqlParserPRECISION, PlSqlParserPRESENT, PlSqlParserRAISE, PlSqlParserRANGE, PlSqlParserRAW, PlSqlParserREAD, PlSqlParserREAL, PlSqlParserRECORD, PlSqlParserREFERENCE, PlSqlParserREFERENCING, PlSqlParserREF, PlSqlParserREJECT, PlSqlParserRELIES_ON, PlSqlParserRENAME, PlSqlParserREPLACE, PlSqlParserRESPECT, PlSqlParserRESTRICT_REFERENCES, PlSqlParserRESULT_CACHE, PlSqlParserRESULT, PlSqlParserRETURNING, PlSqlParserRETURN, PlSqlParserREUSE, PlSqlParserREVERSE, PlSqlParserRIGHT, PlSqlParserROLLBACK, PlSqlParserROLLUP, PlSqlParserROWID, PlSqlParserROW, PlSqlParserROWS, PlSqlParserRULES, PlSqlParserSAMPLE, PlSqlParserSAVEPOINT, PlSqlParserSAVE, PlSqlParserSCHEMACHECK, PlSqlParserSCHEMA, PlSqlParserSCN, PlSqlParserSECOND, PlSqlParserSEED, PlSqlParserSEGMENT, PlSqlParserSELF, PlSqlParserSEQUENTIAL, PlSqlParserSERIALIZABLE, PlSqlParserSERIALLY_REUSABLE, PlSqlParserSERVERERROR, PlSqlParserSESSIONTIMEZONE, PlSqlParserSET, PlSqlParserSETS, PlSqlParserSETTINGS, PlSqlParserSHOW, PlSqlParserSHUTDOWN, PlSqlParserSIBLINGS, PlSqlParserSIGNTYPE, PlSqlParserSIMPLE_INTEGER, PlSqlParserSINGLE, PlSqlParserSKIP_, PlSqlParserSMALLINT, PlSqlParserSNAPSHOT, PlSqlParserSOME, PlSqlParserSPECIFICATION, PlSqlParserSQLDATA, PlSqlParserSQLERROR, PlSqlParserSTANDALONE, PlSqlParserSTARTUP, PlSqlParserSTATEMENT_ID, PlSqlParserSTATEMENT, PlSqlParserSTATIC, PlSqlParserSTATISTICS, PlSqlParserSTRING, PlSqlParserSUBMULTISET, PlSqlParserSUBPARTITION, PlSqlParserSUBSTITUTABLE, PlSqlParserSUBTYPE, PlSqlParserSUCCESS, PlSqlParserSUSPEND, PlSqlParserTEMPORARY, PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, PlSqlParserTIMESTAMP, PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, PlSqlParserTIMESTAMP_UNCONSTRAINED, PlSqlParserTIME, PlSqlParserTIMEZONE_ABBR, PlSqlParserTIMEZONE_HOUR, PlSqlParserTIMEZONE_MINUTE, PlSqlParserTIMEZONE_REGION, PlSqlParserTRAILING, PlSqlParserTRANSACTION, PlSqlParserTRANSLATE, PlSqlParserTREAT, PlSqlParserTRIGGER, PlSqlParserTRUNCATE, PlSqlParserTYPE, PlSqlParserUNBOUNDED, PlSqlParserUNDER, PlSqlParserUNLIMITED, PlSqlParserUNTIL, PlSqlParserUPDATED, PlSqlParserUPSERT, PlSqlParserUROWID, PlSqlParserUSE, PlSqlParserVALIDATE, PlSqlParserVALUE, PlSqlParserVARCHAR2, PlSqlParserVARCHAR, PlSqlParserVARIABLE, PlSqlParserVARRAY, PlSqlParserVARYING, PlSqlParserVERSIONS, PlSqlParserVERSION, PlSqlParserWAIT, PlSqlParserWARNING, PlSqlParserWELLFORMED, PlSqlParserWHENEVER, PlSqlParserWHILE, PlSqlParserWITHIN, PlSqlParserWORK, PlSqlParserWRITE, PlSqlParserXMLAGG, PlSqlParserXMLATTRIBUTES, PlSqlParserXMLCAST, PlSqlParserXMLCOLATTVAL, PlSqlParserXMLELEMENT, PlSqlParserXMLEXISTS, PlSqlParserXMLFOREST, PlSqlParserXMLNAMESPACES, PlSqlParserXMLPARSE, PlSqlParserXMLPI, PlSqlParserXMLQUERY, PlSqlParserXMLROOT, PlSqlParserXMLSERIALIZE, PlSqlParserXMLTABLE, PlSqlParserXML, PlSqlParserYEAR, PlSqlParserYES, PlSqlParserYMINTERVAL_UNCONSTRAINED, PlSqlParserZONE, PlSqlParserPREDICTION, PlSqlParserPREDICTION_BOUNDS, PlSqlParserPREDICTION_COST, PlSqlParserPREDICTION_DETAILS, PlSqlParserPREDICTION_PROBABILITY, PlSqlParserPREDICTION_SET, PlSqlParserCUME_DIST, PlSqlParserDENSE_RANK, PlSqlParserLISTAGG, PlSqlParserPERCENT_RANK, PlSqlParserPERCENTILE_CONT, PlSqlParserPERCENTILE_DISC, PlSqlParserRANK, PlSqlParserAVG, PlSqlParserCORR, PlSqlParserCOVAR_, PlSqlParserLAG, PlSqlParserLEAD, PlSqlParserMAX, PlSqlParserMEDIAN, PlSqlParserMIN, PlSqlParserNTILE, PlSqlParserRATIO_TO_REPORT, PlSqlParserREGR_, PlSqlParserROW_NUMBER, PlSqlParserSUBSTR, PlSqlParserTRIM, PlSqlParserSUM, PlSqlParserSTDDEV, PlSqlParserVAR_, PlSqlParserVARIANCE, PlSqlParserREGULAR_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5755)
			p.Regular_id()
		}

	case PlSqlParserDELIMITED_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5756)
			p.Match(PlSqlParserDELIMITED_ID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOuter_join_signContext is an interface to support dynamic dispatch.
type IOuter_join_signContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOuter_join_signContext differentiates from other interfaces.
	IsOuter_join_signContext()
}

type Outer_join_signContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOuter_join_signContext() *Outer_join_signContext {
	var p = new(Outer_join_signContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_outer_join_sign
	return p
}

func (*Outer_join_signContext) IsOuter_join_signContext() {}

func NewOuter_join_signContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Outer_join_signContext {
	var p = new(Outer_join_signContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_outer_join_sign

	return p
}

func (s *Outer_join_signContext) GetParser() antlr.Parser { return s.parser }
func (s *Outer_join_signContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Outer_join_signContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Outer_join_signContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterOuter_join_sign(s)
	}
}

func (s *Outer_join_signContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitOuter_join_sign(s)
	}
}

func (p *PlSqlParser) Outer_join_sign() (localctx IOuter_join_signContext) {
	localctx = NewOuter_join_signContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, PlSqlParserRULE_outer_join_sign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5759)
		p.Match(PlSqlParserLEFT_PAREN)
	}
	{
		p.SetState(5760)
		p.Match(PlSqlParserPLUS_SIGN)
	}
	{
		p.SetState(5761)
		p.Match(PlSqlParserRIGHT_PAREN)
	}

	return localctx
}

// IRegular_idContext is an interface to support dynamic dispatch.
type IRegular_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegular_idContext differentiates from other interfaces.
	IsRegular_idContext()
}

type Regular_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegular_idContext() *Regular_idContext {
	var p = new(Regular_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_regular_id
	return p
}

func (*Regular_idContext) IsRegular_idContext() {}

func NewRegular_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Regular_idContext {
	var p = new(Regular_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_regular_id

	return p
}

func (s *Regular_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Regular_idContext) REGULAR_ID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREGULAR_ID, 0)
}

func (s *Regular_idContext) A_LETTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserA_LETTER, 0)
}

func (s *Regular_idContext) ADD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserADD, 0)
}

func (s *Regular_idContext) AFTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAFTER, 0)
}

func (s *Regular_idContext) AGENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAGENT, 0)
}

func (s *Regular_idContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAGGREGATE, 0)
}

func (s *Regular_idContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserANALYZE, 0)
}

func (s *Regular_idContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserARRAY, 0)
}

func (s *Regular_idContext) ASSOCIATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserASSOCIATE, 0)
}

func (s *Regular_idContext) AT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAT, 0)
}

func (s *Regular_idContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserATTRIBUTE, 0)
}

func (s *Regular_idContext) AUDIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUDIT, 0)
}

func (s *Regular_idContext) AUTHID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUTHID, 0)
}

func (s *Regular_idContext) AUTO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUTO, 0)
}

func (s *Regular_idContext) AUTOMATIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUTOMATIC, 0)
}

func (s *Regular_idContext) AUTONOMOUS_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAUTONOMOUS_TRANSACTION, 0)
}

func (s *Regular_idContext) BATCH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBATCH, 0)
}

func (s *Regular_idContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBEFORE, 0)
}

func (s *Regular_idContext) BFILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBFILE, 0)
}

func (s *Regular_idContext) BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBINARY_DOUBLE, 0)
}

func (s *Regular_idContext) BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBINARY_FLOAT, 0)
}

func (s *Regular_idContext) BINARY_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBINARY_INTEGER, 0)
}

func (s *Regular_idContext) BLOB() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBLOB, 0)
}

func (s *Regular_idContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBLOCK, 0)
}

func (s *Regular_idContext) BODY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBODY, 0)
}

func (s *Regular_idContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBOOLEAN, 0)
}

func (s *Regular_idContext) BOTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBOTH, 0)
}

func (s *Regular_idContext) BULK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBULK, 0)
}

func (s *Regular_idContext) BYTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserBYTE, 0)
}

func (s *Regular_idContext) C_LETTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserC_LETTER, 0)
}

func (s *Regular_idContext) CALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCALL, 0)
}

func (s *Regular_idContext) CANONICAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCANONICAL, 0)
}

func (s *Regular_idContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCASCADE, 0)
}

func (s *Regular_idContext) CAST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCAST, 0)
}

func (s *Regular_idContext) CHAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR, 0)
}

func (s *Regular_idContext) CHAR_CS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHAR_CS, 0)
}

func (s *Regular_idContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHARACTER, 0)
}

func (s *Regular_idContext) CHR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHR, 0)
}

func (s *Regular_idContext) CLOB() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCLOB, 0)
}

func (s *Regular_idContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCLOSE, 0)
}

func (s *Regular_idContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCLUSTER, 0)
}

func (s *Regular_idContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOLLECT, 0)
}

func (s *Regular_idContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOLUMNS, 0)
}

func (s *Regular_idContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMENT, 0)
}

func (s *Regular_idContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMIT, 0)
}

func (s *Regular_idContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMMITTED, 0)
}

func (s *Regular_idContext) COMPATIBILITY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPATIBILITY, 0)
}

func (s *Regular_idContext) COMPILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPILE, 0)
}

func (s *Regular_idContext) COMPOUND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOMPOUND, 0)
}

func (s *Regular_idContext) CONSTANT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTANT, 0)
}

func (s *Regular_idContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRAINT, 0)
}

func (s *Regular_idContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRAINTS, 0)
}

func (s *Regular_idContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONSTRUCTOR, 0)
}

func (s *Regular_idContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONTENT, 0)
}

func (s *Regular_idContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONTEXT, 0)
}

func (s *Regular_idContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONTINUE, 0)
}

func (s *Regular_idContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCONVERT, 0)
}

func (s *Regular_idContext) CORRUPT_XID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCORRUPT_XID, 0)
}

func (s *Regular_idContext) CORRUPT_XID_ALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCORRUPT_XID_ALL, 0)
}

func (s *Regular_idContext) COST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOST, 0)
}

func (s *Regular_idContext) COUNT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOUNT, 0)
}

func (s *Regular_idContext) CROSS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCROSS, 0)
}

func (s *Regular_idContext) CUBE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCUBE, 0)
}

func (s *Regular_idContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCURRENT_USER, 0)
}

func (s *Regular_idContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCURSOR, 0)
}

func (s *Regular_idContext) CUSTOMDATUM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCUSTOMDATUM, 0)
}

func (s *Regular_idContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCYCLE, 0)
}

func (s *Regular_idContext) DATA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDATA, 0)
}

func (s *Regular_idContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDATABASE, 0)
}

func (s *Regular_idContext) DAY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDAY, 0)
}

func (s *Regular_idContext) DB_ROLE_CHANGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDB_ROLE_CHANGE, 0)
}

func (s *Regular_idContext) DBTIMEZONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDBTIMEZONE, 0)
}

func (s *Regular_idContext) DDL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDDL, 0)
}

func (s *Regular_idContext) DEBUG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEBUG, 0)
}

func (s *Regular_idContext) DEC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEC, 0)
}

func (s *Regular_idContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECIMAL, 0)
}

func (s *Regular_idContext) DECOMPOSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECOMPOSE, 0)
}

func (s *Regular_idContext) DECREMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECREMENT, 0)
}

func (s *Regular_idContext) DEFAULTS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFAULTS, 0)
}

func (s *Regular_idContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFERRED, 0)
}

func (s *Regular_idContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDEFINER, 0)
}

func (s *Regular_idContext) DELETE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDELETE, 0)
}

func (s *Regular_idContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDETERMINISTIC, 0)
}

func (s *Regular_idContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDIMENSION, 0)
}

func (s *Regular_idContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISABLE, 0)
}

func (s *Regular_idContext) DISASSOCIATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDISASSOCIATE, 0)
}

func (s *Regular_idContext) DOCUMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDOCUMENT, 0)
}

func (s *Regular_idContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDOUBLE, 0)
}

func (s *Regular_idContext) DSINTERVAL_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDSINTERVAL_UNCONSTRAINED, 0)
}

func (s *Regular_idContext) EACH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEACH, 0)
}

func (s *Regular_idContext) ELEMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserELEMENT, 0)
}

func (s *Regular_idContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEMPTY, 0)
}

func (s *Regular_idContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserENABLE, 0)
}

func (s *Regular_idContext) ENCODING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserENCODING, 0)
}

func (s *Regular_idContext) ENTITYESCAPING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserENTITYESCAPING, 0)
}

func (s *Regular_idContext) ERR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserERR, 0)
}

func (s *Regular_idContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserERRORS, 0)
}

func (s *Regular_idContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserESCAPE, 0)
}

func (s *Regular_idContext) EVALNAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEVALNAME, 0)
}

func (s *Regular_idContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCEPTION, 0)
}

func (s *Regular_idContext) EXCEPTION_INIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCEPTION_INIT, 0)
}

func (s *Regular_idContext) EXCEPTIONS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCEPTIONS, 0)
}

func (s *Regular_idContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXCLUDE, 0)
}

func (s *Regular_idContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXECUTE, 0)
}

func (s *Regular_idContext) EXIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXIT, 0)
}

func (s *Regular_idContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXPLAIN, 0)
}

func (s *Regular_idContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXTERNAL, 0)
}

func (s *Regular_idContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserEXTRACT, 0)
}

func (s *Regular_idContext) FAILURE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFAILURE, 0)
}

func (s *Regular_idContext) FINAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFINAL, 0)
}

func (s *Regular_idContext) FIRST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFIRST, 0)
}

func (s *Regular_idContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFIRST_VALUE, 0)
}

func (s *Regular_idContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFLOAT, 0)
}

func (s *Regular_idContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOLLOWING, 0)
}

func (s *Regular_idContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFOLLOWS, 0)
}

func (s *Regular_idContext) FORALL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFORALL, 0)
}

func (s *Regular_idContext) FORCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFORCE, 0)
}

func (s *Regular_idContext) FULL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFULL, 0)
}

func (s *Regular_idContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserFUNCTION, 0)
}

func (s *Regular_idContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserGROUPING, 0)
}

func (s *Regular_idContext) HASH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserHASH, 0)
}

func (s *Regular_idContext) HIDE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserHIDE, 0)
}

func (s *Regular_idContext) HOUR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserHOUR, 0)
}

func (s *Regular_idContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIGNORE, 0)
}

func (s *Regular_idContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserIMMEDIATE, 0)
}

func (s *Regular_idContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINCLUDE, 0)
}

func (s *Regular_idContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINCLUDING, 0)
}

func (s *Regular_idContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINCREMENT, 0)
}

func (s *Regular_idContext) INDENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDENT, 0)
}

func (s *Regular_idContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDEXED, 0)
}

func (s *Regular_idContext) INDICATOR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDICATOR, 0)
}

func (s *Regular_idContext) INDICES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINDICES, 0)
}

func (s *Regular_idContext) INFINITE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINFINITE, 0)
}

func (s *Regular_idContext) INLINE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINLINE, 0)
}

func (s *Regular_idContext) INNER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINNER, 0)
}

func (s *Regular_idContext) INOUT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINOUT, 0)
}

func (s *Regular_idContext) INSTANTIABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINSTANTIABLE, 0)
}

func (s *Regular_idContext) INSTEAD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINSTEAD, 0)
}

func (s *Regular_idContext) INT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINT, 0)
}

func (s *Regular_idContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTEGER, 0)
}

func (s *Regular_idContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINTERVAL, 0)
}

func (s *Regular_idContext) INVALIDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserINVALIDATE, 0)
}

func (s *Regular_idContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserISOLATION, 0)
}

func (s *Regular_idContext) ITERATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserITERATE, 0)
}

func (s *Regular_idContext) JAVA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserJAVA, 0)
}

func (s *Regular_idContext) JOIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserJOIN, 0)
}

func (s *Regular_idContext) KEEP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserKEEP, 0)
}

func (s *Regular_idContext) KEY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserKEY, 0)
}

func (s *Regular_idContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLANGUAGE, 0)
}

func (s *Regular_idContext) LAST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLAST, 0)
}

func (s *Regular_idContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLAST_VALUE, 0)
}

func (s *Regular_idContext) LEADING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEADING, 0)
}

func (s *Regular_idContext) LEFT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEFT, 0)
}

func (s *Regular_idContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEVEL, 0)
}

func (s *Regular_idContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIBRARY, 0)
}

func (s *Regular_idContext) LIKE2() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIKE2, 0)
}

func (s *Regular_idContext) LIKE4() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIKE4, 0)
}

func (s *Regular_idContext) LIKEC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIKEC, 0)
}

func (s *Regular_idContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLIMIT, 0)
}

func (s *Regular_idContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOCAL, 0)
}

func (s *Regular_idContext) LOCKED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOCKED, 0)
}

func (s *Regular_idContext) LOG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOG, 0)
}

func (s *Regular_idContext) LOGOFF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOGOFF, 0)
}

func (s *Regular_idContext) LOGON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOGON, 0)
}

func (s *Regular_idContext) LONG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLONG, 0)
}

func (s *Regular_idContext) LOOP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLOOP, 0)
}

func (s *Regular_idContext) MAIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAIN, 0)
}

func (s *Regular_idContext) MAP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAP, 0)
}

func (s *Regular_idContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMATCHED, 0)
}

func (s *Regular_idContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAXVALUE, 0)
}

func (s *Regular_idContext) MEASURES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEASURES, 0)
}

func (s *Regular_idContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEMBER, 0)
}

func (s *Regular_idContext) MERGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMERGE, 0)
}

func (s *Regular_idContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINUTE, 0)
}

func (s *Regular_idContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMINVALUE, 0)
}

func (s *Regular_idContext) MLSLABEL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMLSLABEL, 0)
}

func (s *Regular_idContext) MODEL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMODEL, 0)
}

func (s *Regular_idContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMODIFY, 0)
}

func (s *Regular_idContext) MONTH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMONTH, 0)
}

func (s *Regular_idContext) MULTISET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMULTISET, 0)
}

func (s *Regular_idContext) NAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAME, 0)
}

func (s *Regular_idContext) NAN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAN, 0)
}

func (s *Regular_idContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNATURAL, 0)
}

func (s *Regular_idContext) NATURALN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNATURALN, 0)
}

func (s *Regular_idContext) NAV() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNAV, 0)
}

func (s *Regular_idContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNCHAR, 0)
}

func (s *Regular_idContext) NCHAR_CS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNCHAR_CS, 0)
}

func (s *Regular_idContext) NCLOB() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNCLOB, 0)
}

func (s *Regular_idContext) NESTED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNESTED, 0)
}

func (s *Regular_idContext) NEW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNEW, 0)
}

func (s *Regular_idContext) NO() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNO, 0)
}

func (s *Regular_idContext) NOAUDIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOAUDIT, 0)
}

func (s *Regular_idContext) NOCOPY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOCOPY, 0)
}

func (s *Regular_idContext) NOCYCLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOCYCLE, 0)
}

func (s *Regular_idContext) NOENTITYESCAPING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOENTITYESCAPING, 0)
}

func (s *Regular_idContext) NONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNONE, 0)
}

func (s *Regular_idContext) NOSCHEMACHECK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNOSCHEMACHECK, 0)
}

func (s *Regular_idContext) NULLS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNULLS, 0)
}

func (s *Regular_idContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNUMBER, 0)
}

func (s *Regular_idContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNUMERIC, 0)
}

func (s *Regular_idContext) NVARCHAR2() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNVARCHAR2, 0)
}

func (s *Regular_idContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOBJECT, 0)
}

func (s *Regular_idContext) OFF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOFF, 0)
}

func (s *Regular_idContext) OID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOID, 0)
}

func (s *Regular_idContext) OLD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOLD, 0)
}

func (s *Regular_idContext) ONLY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserONLY, 0)
}

func (s *Regular_idContext) OPEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOPEN, 0)
}

func (s *Regular_idContext) ORADATA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORADATA, 0)
}

func (s *Regular_idContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserORDINALITY, 0)
}

func (s *Regular_idContext) OSERROR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOSERROR, 0)
}

func (s *Regular_idContext) OUT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOUT, 0)
}

func (s *Regular_idContext) OUTER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOUTER, 0)
}

func (s *Regular_idContext) OVER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOVER, 0)
}

func (s *Regular_idContext) OVERRIDING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserOVERRIDING, 0)
}

func (s *Regular_idContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPACKAGE, 0)
}

func (s *Regular_idContext) PARALLEL_ENABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARALLEL_ENABLE, 0)
}

func (s *Regular_idContext) PARAMETERS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARAMETERS, 0)
}

func (s *Regular_idContext) PARENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARENT, 0)
}

func (s *Regular_idContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPARTITION, 0)
}

func (s *Regular_idContext) PASSING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPASSING, 0)
}

func (s *Regular_idContext) PATH() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPATH, 0)
}

func (s *Regular_idContext) PIPELINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPIPELINED, 0)
}

func (s *Regular_idContext) PLAN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPLAN, 0)
}

func (s *Regular_idContext) PLS_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPLS_INTEGER, 0)
}

func (s *Regular_idContext) POSITIVE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPOSITIVE, 0)
}

func (s *Regular_idContext) POSITIVEN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPOSITIVEN, 0)
}

func (s *Regular_idContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRAGMA, 0)
}

func (s *Regular_idContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRECEDING, 0)
}

func (s *Regular_idContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRECISION, 0)
}

func (s *Regular_idContext) PRESENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPRESENT, 0)
}

func (s *Regular_idContext) RAISE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRAISE, 0)
}

func (s *Regular_idContext) RANGE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRANGE, 0)
}

func (s *Regular_idContext) RAW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRAW, 0)
}

func (s *Regular_idContext) READ() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREAD, 0)
}

func (s *Regular_idContext) REAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREAL, 0)
}

func (s *Regular_idContext) RECORD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRECORD, 0)
}

func (s *Regular_idContext) REF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREF, 0)
}

func (s *Regular_idContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREFERENCE, 0)
}

func (s *Regular_idContext) REFERENCING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREFERENCING, 0)
}

func (s *Regular_idContext) REJECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREJECT, 0)
}

func (s *Regular_idContext) RELIES_ON() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRELIES_ON, 0)
}

func (s *Regular_idContext) RENAME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRENAME, 0)
}

func (s *Regular_idContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREPLACE, 0)
}

func (s *Regular_idContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESPECT, 0)
}

func (s *Regular_idContext) RESTRICT_REFERENCES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESTRICT_REFERENCES, 0)
}

func (s *Regular_idContext) RESULT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESULT, 0)
}

func (s *Regular_idContext) RESULT_CACHE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRESULT_CACHE, 0)
}

func (s *Regular_idContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURN, 0)
}

func (s *Regular_idContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRETURNING, 0)
}

func (s *Regular_idContext) REUSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREUSE, 0)
}

func (s *Regular_idContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREVERSE, 0)
}

func (s *Regular_idContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRIGHT, 0)
}

func (s *Regular_idContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROLLBACK, 0)
}

func (s *Regular_idContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROLLUP, 0)
}

func (s *Regular_idContext) ROW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROW, 0)
}

func (s *Regular_idContext) ROWID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROWID, 0)
}

func (s *Regular_idContext) ROWS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROWS, 0)
}

func (s *Regular_idContext) RULES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRULES, 0)
}

func (s *Regular_idContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSAMPLE, 0)
}

func (s *Regular_idContext) SAVE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSAVE, 0)
}

func (s *Regular_idContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSAVEPOINT, 0)
}

func (s *Regular_idContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSCHEMA, 0)
}

func (s *Regular_idContext) SCHEMACHECK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSCHEMACHECK, 0)
}

func (s *Regular_idContext) SCN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSCN, 0)
}

func (s *Regular_idContext) SECOND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSECOND, 0)
}

func (s *Regular_idContext) SEED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEED, 0)
}

func (s *Regular_idContext) SEGMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEGMENT, 0)
}

func (s *Regular_idContext) SELF() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSELF, 0)
}

func (s *Regular_idContext) SEQUENTIAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSEQUENTIAL, 0)
}

func (s *Regular_idContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSERIALIZABLE, 0)
}

func (s *Regular_idContext) SERIALLY_REUSABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSERIALLY_REUSABLE, 0)
}

func (s *Regular_idContext) SERVERERROR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSERVERERROR, 0)
}

func (s *Regular_idContext) SESSIONTIMEZONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSESSIONTIMEZONE, 0)
}

func (s *Regular_idContext) SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSET, 0)
}

func (s *Regular_idContext) SETS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSETS, 0)
}

func (s *Regular_idContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSETTINGS, 0)
}

func (s *Regular_idContext) SHOW() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSHOW, 0)
}

func (s *Regular_idContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSHUTDOWN, 0)
}

func (s *Regular_idContext) SIBLINGS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSIBLINGS, 0)
}

func (s *Regular_idContext) SIGNTYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSIGNTYPE, 0)
}

func (s *Regular_idContext) SIMPLE_INTEGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSIMPLE_INTEGER, 0)
}

func (s *Regular_idContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSINGLE, 0)
}

func (s *Regular_idContext) SKIP_() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSKIP_, 0)
}

func (s *Regular_idContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSMALLINT, 0)
}

func (s *Regular_idContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSNAPSHOT, 0)
}

func (s *Regular_idContext) SOME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSOME, 0)
}

func (s *Regular_idContext) SPECIFICATION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSPECIFICATION, 0)
}

func (s *Regular_idContext) SQLDATA() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSQLDATA, 0)
}

func (s *Regular_idContext) SQLERROR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSQLERROR, 0)
}

func (s *Regular_idContext) STANDALONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTANDALONE, 0)
}

func (s *Regular_idContext) STARTUP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTARTUP, 0)
}

func (s *Regular_idContext) STATEMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATEMENT, 0)
}

func (s *Regular_idContext) STATEMENT_ID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATEMENT_ID, 0)
}

func (s *Regular_idContext) STATIC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATIC, 0)
}

func (s *Regular_idContext) STATISTICS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTATISTICS, 0)
}

func (s *Regular_idContext) STRING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTRING, 0)
}

func (s *Regular_idContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBSTR, 0)
}

func (s *Regular_idContext) SUBMULTISET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBMULTISET, 0)
}

func (s *Regular_idContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBPARTITION, 0)
}

func (s *Regular_idContext) SUBSTITUTABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBSTITUTABLE, 0)
}

func (s *Regular_idContext) SUBTYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBTYPE, 0)
}

func (s *Regular_idContext) SUCCESS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUCCESS, 0)
}

func (s *Regular_idContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUSPEND, 0)
}

func (s *Regular_idContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTEMPORARY, 0)
}

func (s *Regular_idContext) TIME() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIME, 0)
}

func (s *Regular_idContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP, 0)
}

func (s *Regular_idContext) TIMESTAMP_LTZ_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED, 0)
}

func (s *Regular_idContext) TIMESTAMP_TZ_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED, 0)
}

func (s *Regular_idContext) TIMESTAMP_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMESTAMP_UNCONSTRAINED, 0)
}

func (s *Regular_idContext) TIMEZONE_ABBR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMEZONE_ABBR, 0)
}

func (s *Regular_idContext) TIMEZONE_HOUR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMEZONE_HOUR, 0)
}

func (s *Regular_idContext) TIMEZONE_MINUTE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMEZONE_MINUTE, 0)
}

func (s *Regular_idContext) TIMEZONE_REGION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTIMEZONE_REGION, 0)
}

func (s *Regular_idContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRAILING, 0)
}

func (s *Regular_idContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRANSACTION, 0)
}

func (s *Regular_idContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRANSLATE, 0)
}

func (s *Regular_idContext) TREAT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTREAT, 0)
}

func (s *Regular_idContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIGGER, 0)
}

func (s *Regular_idContext) TRIM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIM, 0)
}

func (s *Regular_idContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRUNCATE, 0)
}

func (s *Regular_idContext) TYPE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTYPE, 0)
}

func (s *Regular_idContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNBOUNDED, 0)
}

func (s *Regular_idContext) UNDER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNDER, 0)
}

func (s *Regular_idContext) UNLIMITED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNLIMITED, 0)
}

func (s *Regular_idContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUNTIL, 0)
}

func (s *Regular_idContext) UPDATED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPDATED, 0)
}

func (s *Regular_idContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUPSERT, 0)
}

func (s *Regular_idContext) UROWID() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUROWID, 0)
}

func (s *Regular_idContext) USE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserUSE, 0)
}

func (s *Regular_idContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALIDATE, 0)
}

func (s *Regular_idContext) VALUE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVALUE, 0)
}

func (s *Regular_idContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARCHAR, 0)
}

func (s *Regular_idContext) VARCHAR2() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARCHAR2, 0)
}

func (s *Regular_idContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARIABLE, 0)
}

func (s *Regular_idContext) VARRAY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARRAY, 0)
}

func (s *Regular_idContext) VARYING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARYING, 0)
}

func (s *Regular_idContext) VERSION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVERSION, 0)
}

func (s *Regular_idContext) VERSIONS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVERSIONS, 0)
}

func (s *Regular_idContext) WAIT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWAIT, 0)
}

func (s *Regular_idContext) WARNING() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWARNING, 0)
}

func (s *Regular_idContext) WELLFORMED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWELLFORMED, 0)
}

func (s *Regular_idContext) WHENEVER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHENEVER, 0)
}

func (s *Regular_idContext) WHILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWHILE, 0)
}

func (s *Regular_idContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWITHIN, 0)
}

func (s *Regular_idContext) WORK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWORK, 0)
}

func (s *Regular_idContext) WRITE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserWRITE, 0)
}

func (s *Regular_idContext) XML() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXML, 0)
}

func (s *Regular_idContext) XMLAGG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLAGG, 0)
}

func (s *Regular_idContext) XMLATTRIBUTES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLATTRIBUTES, 0)
}

func (s *Regular_idContext) XMLCAST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLCAST, 0)
}

func (s *Regular_idContext) XMLCOLATTVAL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLCOLATTVAL, 0)
}

func (s *Regular_idContext) XMLELEMENT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLELEMENT, 0)
}

func (s *Regular_idContext) XMLEXISTS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLEXISTS, 0)
}

func (s *Regular_idContext) XMLFOREST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLFOREST, 0)
}

func (s *Regular_idContext) XMLNAMESPACES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLNAMESPACES, 0)
}

func (s *Regular_idContext) XMLPARSE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLPARSE, 0)
}

func (s *Regular_idContext) XMLPI() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLPI, 0)
}

func (s *Regular_idContext) XMLQUERY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLQUERY, 0)
}

func (s *Regular_idContext) XMLROOT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLROOT, 0)
}

func (s *Regular_idContext) XMLSERIALIZE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLSERIALIZE, 0)
}

func (s *Regular_idContext) XMLTABLE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserXMLTABLE, 0)
}

func (s *Regular_idContext) YEAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserYEAR, 0)
}

func (s *Regular_idContext) YES() antlr.TerminalNode {
	return s.GetToken(PlSqlParserYES, 0)
}

func (s *Regular_idContext) YMINTERVAL_UNCONSTRAINED() antlr.TerminalNode {
	return s.GetToken(PlSqlParserYMINTERVAL_UNCONSTRAINED, 0)
}

func (s *Regular_idContext) ZONE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserZONE, 0)
}

func (s *Regular_idContext) PREDICTION() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION, 0)
}

func (s *Regular_idContext) PREDICTION_BOUNDS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_BOUNDS, 0)
}

func (s *Regular_idContext) PREDICTION_COST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_COST, 0)
}

func (s *Regular_idContext) PREDICTION_DETAILS() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_DETAILS, 0)
}

func (s *Regular_idContext) PREDICTION_PROBABILITY() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_PROBABILITY, 0)
}

func (s *Regular_idContext) PREDICTION_SET() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPREDICTION_SET, 0)
}

func (s *Regular_idContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCUME_DIST, 0)
}

func (s *Regular_idContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDENSE_RANK, 0)
}

func (s *Regular_idContext) LISTAGG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLISTAGG, 0)
}

func (s *Regular_idContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENT_RANK, 0)
}

func (s *Regular_idContext) PERCENTILE_CONT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENTILE_CONT, 0)
}

func (s *Regular_idContext) PERCENTILE_DISC() antlr.TerminalNode {
	return s.GetToken(PlSqlParserPERCENTILE_DISC, 0)
}

func (s *Regular_idContext) RANK() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRANK, 0)
}

func (s *Regular_idContext) AVG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAVG, 0)
}

func (s *Regular_idContext) CORR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCORR, 0)
}

func (s *Regular_idContext) LAG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLAG, 0)
}

func (s *Regular_idContext) LEAD() antlr.TerminalNode {
	return s.GetToken(PlSqlParserLEAD, 0)
}

func (s *Regular_idContext) MAX() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMAX, 0)
}

func (s *Regular_idContext) MEDIAN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMEDIAN, 0)
}

func (s *Regular_idContext) MIN() antlr.TerminalNode {
	return s.GetToken(PlSqlParserMIN, 0)
}

func (s *Regular_idContext) NTILE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNTILE, 0)
}

func (s *Regular_idContext) RATIO_TO_REPORT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserRATIO_TO_REPORT, 0)
}

func (s *Regular_idContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROW_NUMBER, 0)
}

func (s *Regular_idContext) SUM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUM, 0)
}

func (s *Regular_idContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVARIANCE, 0)
}

func (s *Regular_idContext) REGR_() antlr.TerminalNode {
	return s.GetToken(PlSqlParserREGR_, 0)
}

func (s *Regular_idContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSTDDEV, 0)
}

func (s *Regular_idContext) VAR_() antlr.TerminalNode {
	return s.GetToken(PlSqlParserVAR_, 0)
}

func (s *Regular_idContext) COVAR_() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOVAR_, 0)
}

func (s *Regular_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Regular_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Regular_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterRegular_id(s)
	}
}

func (s *Regular_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitRegular_id(s)
	}
}

func (p *PlSqlParser) Regular_id() (localctx IRegular_idContext) {
	localctx = NewRegular_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, PlSqlParserRULE_regular_id)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5763)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PlSqlParserADD)|(1<<PlSqlParserAFTER)|(1<<PlSqlParserAGENT)|(1<<PlSqlParserAGGREGATE)|(1<<PlSqlParserA_LETTER)|(1<<PlSqlParserANALYZE)|(1<<PlSqlParserARRAY)|(1<<PlSqlParserASSOCIATE)|(1<<PlSqlParserAT)|(1<<PlSqlParserATTRIBUTE)|(1<<PlSqlParserAUDIT)|(1<<PlSqlParserAUTHID)|(1<<PlSqlParserAUTO)|(1<<PlSqlParserAUTOMATIC)|(1<<PlSqlParserAUTONOMOUS_TRANSACTION)|(1<<PlSqlParserBATCH)|(1<<PlSqlParserBEFORE)|(1<<PlSqlParserBFILE)|(1<<PlSqlParserBINARY_DOUBLE)|(1<<PlSqlParserBINARY_FLOAT)|(1<<PlSqlParserBINARY_INTEGER))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PlSqlParserBLOB-32))|(1<<(PlSqlParserBLOCK-32))|(1<<(PlSqlParserBODY-32))|(1<<(PlSqlParserBOOLEAN-32))|(1<<(PlSqlParserBOTH-32))|(1<<(PlSqlParserBULK-32))|(1<<(PlSqlParserBYTE-32))|(1<<(PlSqlParserCALL-32))|(1<<(PlSqlParserCANONICAL-32))|(1<<(PlSqlParserCASCADE-32))|(1<<(PlSqlParserCAST-32))|(1<<(PlSqlParserCHARACTER-32))|(1<<(PlSqlParserCHAR-32))|(1<<(PlSqlParserCHAR_CS-32))|(1<<(PlSqlParserCHR-32))|(1<<(PlSqlParserC_LETTER-32))|(1<<(PlSqlParserCLOB-32))|(1<<(PlSqlParserCLOSE-32))|(1<<(PlSqlParserCLUSTER-32))|(1<<(PlSqlParserCOLLECT-32))|(1<<(PlSqlParserCOLUMNS-32))|(1<<(PlSqlParserCOMMENT-32))|(1<<(PlSqlParserCOMMIT-32))|(1<<(PlSqlParserCOMMITTED-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PlSqlParserCOMPATIBILITY-64))|(1<<(PlSqlParserCOMPILE-64))|(1<<(PlSqlParserCOMPOUND-64))|(1<<(PlSqlParserCONSTANT-64))|(1<<(PlSqlParserCONSTRAINT-64))|(1<<(PlSqlParserCONSTRAINTS-64))|(1<<(PlSqlParserCONSTRUCTOR-64))|(1<<(PlSqlParserCONTENT-64))|(1<<(PlSqlParserCONTEXT-64))|(1<<(PlSqlParserCONTINUE-64))|(1<<(PlSqlParserCONVERT-64))|(1<<(PlSqlParserCORRUPT_XID_ALL-64))|(1<<(PlSqlParserCORRUPT_XID-64))|(1<<(PlSqlParserCOST-64))|(1<<(PlSqlParserCOUNT-64))|(1<<(PlSqlParserCROSS-64))|(1<<(PlSqlParserCUBE-64))|(1<<(PlSqlParserCURRENT_USER-64))|(1<<(PlSqlParserCURSOR-64))|(1<<(PlSqlParserCUSTOMDATUM-64))|(1<<(PlSqlParserCYCLE-64))|(1<<(PlSqlParserDATABASE-64))|(1<<(PlSqlParserDATA-64))|(1<<(PlSqlParserDAY-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PlSqlParserDB_ROLE_CHANGE-96))|(1<<(PlSqlParserDBTIMEZONE-96))|(1<<(PlSqlParserDDL-96))|(1<<(PlSqlParserDEBUG-96))|(1<<(PlSqlParserDEC-96))|(1<<(PlSqlParserDECIMAL-96))|(1<<(PlSqlParserDECOMPOSE-96))|(1<<(PlSqlParserDECREMENT-96))|(1<<(PlSqlParserDEFAULTS-96))|(1<<(PlSqlParserDEFERRED-96))|(1<<(PlSqlParserDEFINER-96))|(1<<(PlSqlParserDELETE-96))|(1<<(PlSqlParserDETERMINISTIC-96))|(1<<(PlSqlParserDIMENSION-96))|(1<<(PlSqlParserDISABLE-96))|(1<<(PlSqlParserDISASSOCIATE-96))|(1<<(PlSqlParserDOCUMENT-96))|(1<<(PlSqlParserDOUBLE-96))|(1<<(PlSqlParserDSINTERVAL_UNCONSTRAINED-96))|(1<<(PlSqlParserEACH-96))|(1<<(PlSqlParserELEMENT-96))|(1<<(PlSqlParserEMPTY-96))|(1<<(PlSqlParserENABLE-96))|(1<<(PlSqlParserENCODING-96)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(PlSqlParserENTITYESCAPING-130))|(1<<(PlSqlParserERR-130))|(1<<(PlSqlParserERRORS-130))|(1<<(PlSqlParserESCAPE-130))|(1<<(PlSqlParserEVALNAME-130))|(1<<(PlSqlParserEXCEPTION-130))|(1<<(PlSqlParserEXCEPTION_INIT-130))|(1<<(PlSqlParserEXCEPTIONS-130))|(1<<(PlSqlParserEXCLUDE-130))|(1<<(PlSqlParserEXECUTE-130))|(1<<(PlSqlParserEXIT-130))|(1<<(PlSqlParserEXPLAIN-130))|(1<<(PlSqlParserEXTERNAL-130))|(1<<(PlSqlParserEXTRACT-130))|(1<<(PlSqlParserFAILURE-130))|(1<<(PlSqlParserFINAL-130))|(1<<(PlSqlParserFIRST-130))|(1<<(PlSqlParserFIRST_VALUE-130))|(1<<(PlSqlParserFLOAT-130))|(1<<(PlSqlParserFOLLOWING-130))|(1<<(PlSqlParserFOLLOWS-130))|(1<<(PlSqlParserFORALL-130))|(1<<(PlSqlParserFORCE-130)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(PlSqlParserFULL-164))|(1<<(PlSqlParserFUNCTION-164))|(1<<(PlSqlParserGROUPING-164))|(1<<(PlSqlParserHASH-164))|(1<<(PlSqlParserHIDE-164))|(1<<(PlSqlParserHOUR-164))|(1<<(PlSqlParserIGNORE-164))|(1<<(PlSqlParserIMMEDIATE-164))|(1<<(PlSqlParserINCLUDE-164))|(1<<(PlSqlParserINCLUDING-164))|(1<<(PlSqlParserINCREMENT-164))|(1<<(PlSqlParserINDENT-164))|(1<<(PlSqlParserINDEXED-164))|(1<<(PlSqlParserINDICATOR-164))|(1<<(PlSqlParserINDICES-164))|(1<<(PlSqlParserINFINITE-164))|(1<<(PlSqlParserINLINE-164))|(1<<(PlSqlParserINNER-164))|(1<<(PlSqlParserINOUT-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(PlSqlParserINSTANTIABLE-196))|(1<<(PlSqlParserINSTEAD-196))|(1<<(PlSqlParserINTEGER-196))|(1<<(PlSqlParserINTERVAL-196))|(1<<(PlSqlParserINT-196))|(1<<(PlSqlParserINVALIDATE-196))|(1<<(PlSqlParserISOLATION-196))|(1<<(PlSqlParserITERATE-196))|(1<<(PlSqlParserJAVA-196))|(1<<(PlSqlParserJOIN-196))|(1<<(PlSqlParserKEEP-196))|(1<<(PlSqlParserKEY-196))|(1<<(PlSqlParserLANGUAGE-196))|(1<<(PlSqlParserLAST-196))|(1<<(PlSqlParserLAST_VALUE-196))|(1<<(PlSqlParserLEADING-196))|(1<<(PlSqlParserLEFT-196))|(1<<(PlSqlParserLEVEL-196))|(1<<(PlSqlParserLIBRARY-196))|(1<<(PlSqlParserLIKE2-196))|(1<<(PlSqlParserLIKE4-196))|(1<<(PlSqlParserLIKEC-196))|(1<<(PlSqlParserLIMIT-196))|(1<<(PlSqlParserLOCAL-196))|(1<<(PlSqlParserLOCKED-196)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(PlSqlParserLOG-228))|(1<<(PlSqlParserLOGOFF-228))|(1<<(PlSqlParserLOGON-228))|(1<<(PlSqlParserLONG-228))|(1<<(PlSqlParserLOOP-228))|(1<<(PlSqlParserMAIN-228))|(1<<(PlSqlParserMAP-228))|(1<<(PlSqlParserMATCHED-228))|(1<<(PlSqlParserMAXVALUE-228))|(1<<(PlSqlParserMEASURES-228))|(1<<(PlSqlParserMEMBER-228))|(1<<(PlSqlParserMERGE-228))|(1<<(PlSqlParserMINUTE-228))|(1<<(PlSqlParserMINVALUE-228))|(1<<(PlSqlParserMLSLABEL-228))|(1<<(PlSqlParserMODEL-228))|(1<<(PlSqlParserMODIFY-228))|(1<<(PlSqlParserMONTH-228))|(1<<(PlSqlParserMULTISET-228))|(1<<(PlSqlParserNAME-228))|(1<<(PlSqlParserNAN-228))|(1<<(PlSqlParserNATURAL-228))|(1<<(PlSqlParserNATURALN-228))|(1<<(PlSqlParserNAV-228))|(1<<(PlSqlParserNCHAR_CS-228))|(1<<(PlSqlParserNCHAR-228))|(1<<(PlSqlParserNCLOB-228))|(1<<(PlSqlParserNESTED-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(PlSqlParserNEW-260))|(1<<(PlSqlParserNOAUDIT-260))|(1<<(PlSqlParserNOCOPY-260))|(1<<(PlSqlParserNOCYCLE-260))|(1<<(PlSqlParserNOENTITYESCAPING-260))|(1<<(PlSqlParserNONE-260))|(1<<(PlSqlParserNO-260))|(1<<(PlSqlParserNOSCHEMACHECK-260))|(1<<(PlSqlParserNULLS-260))|(1<<(PlSqlParserNUMBER-260))|(1<<(PlSqlParserNUMERIC-260))|(1<<(PlSqlParserNVARCHAR2-260))|(1<<(PlSqlParserOBJECT-260))|(1<<(PlSqlParserOFF-260))|(1<<(PlSqlParserOID-260))|(1<<(PlSqlParserOLD-260))|(1<<(PlSqlParserONLY-260))|(1<<(PlSqlParserOPEN-260)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(PlSqlParserORADATA-293))|(1<<(PlSqlParserORDINALITY-293))|(1<<(PlSqlParserOSERROR-293))|(1<<(PlSqlParserOUTER-293))|(1<<(PlSqlParserOUT-293))|(1<<(PlSqlParserOVER-293))|(1<<(PlSqlParserOVERRIDING-293))|(1<<(PlSqlParserPACKAGE-293))|(1<<(PlSqlParserPARALLEL_ENABLE-293))|(1<<(PlSqlParserPARAMETERS-293))|(1<<(PlSqlParserPARENT-293))|(1<<(PlSqlParserPARTITION-293))|(1<<(PlSqlParserPASSING-293))|(1<<(PlSqlParserPATH-293))|(1<<(PlSqlParserPIPELINED-293))|(1<<(PlSqlParserPLAN-293))|(1<<(PlSqlParserPLS_INTEGER-293))|(1<<(PlSqlParserPOSITIVEN-293))|(1<<(PlSqlParserPOSITIVE-293)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(PlSqlParserPRAGMA-325))|(1<<(PlSqlParserPRECEDING-325))|(1<<(PlSqlParserPRECISION-325))|(1<<(PlSqlParserPRESENT-325))|(1<<(PlSqlParserRAISE-325))|(1<<(PlSqlParserRANGE-325))|(1<<(PlSqlParserRAW-325))|(1<<(PlSqlParserREAD-325))|(1<<(PlSqlParserREAL-325))|(1<<(PlSqlParserRECORD-325))|(1<<(PlSqlParserREFERENCE-325))|(1<<(PlSqlParserREFERENCING-325))|(1<<(PlSqlParserREF-325))|(1<<(PlSqlParserREJECT-325))|(1<<(PlSqlParserRELIES_ON-325))|(1<<(PlSqlParserRENAME-325))|(1<<(PlSqlParserREPLACE-325))|(1<<(PlSqlParserRESPECT-325))|(1<<(PlSqlParserRESTRICT_REFERENCES-325))|(1<<(PlSqlParserRESULT_CACHE-325))|(1<<(PlSqlParserRESULT-325))|(1<<(PlSqlParserRETURNING-325))|(1<<(PlSqlParserRETURN-325))|(1<<(PlSqlParserREUSE-325)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(PlSqlParserREVERSE-357))|(1<<(PlSqlParserRIGHT-357))|(1<<(PlSqlParserROLLBACK-357))|(1<<(PlSqlParserROLLUP-357))|(1<<(PlSqlParserROWID-357))|(1<<(PlSqlParserROW-357))|(1<<(PlSqlParserROWS-357))|(1<<(PlSqlParserRULES-357))|(1<<(PlSqlParserSAMPLE-357))|(1<<(PlSqlParserSAVEPOINT-357))|(1<<(PlSqlParserSAVE-357))|(1<<(PlSqlParserSCHEMACHECK-357))|(1<<(PlSqlParserSCHEMA-357))|(1<<(PlSqlParserSCN-357))|(1<<(PlSqlParserSECOND-357))|(1<<(PlSqlParserSEED-357))|(1<<(PlSqlParserSEGMENT-357))|(1<<(PlSqlParserSELF-357))|(1<<(PlSqlParserSEQUENTIAL-357))|(1<<(PlSqlParserSERIALIZABLE-357))|(1<<(PlSqlParserSERIALLY_REUSABLE-357))|(1<<(PlSqlParserSERVERERROR-357))|(1<<(PlSqlParserSESSIONTIMEZONE-357))|(1<<(PlSqlParserSET-357))|(1<<(PlSqlParserSETS-357))|(1<<(PlSqlParserSETTINGS-357))|(1<<(PlSqlParserSHOW-357)))) != 0) || (((_la-389)&-(0x1f+1)) == 0 && ((1<<uint((_la-389)))&((1<<(PlSqlParserSHUTDOWN-389))|(1<<(PlSqlParserSIBLINGS-389))|(1<<(PlSqlParserSIGNTYPE-389))|(1<<(PlSqlParserSIMPLE_INTEGER-389))|(1<<(PlSqlParserSINGLE-389))|(1<<(PlSqlParserSKIP_-389))|(1<<(PlSqlParserSMALLINT-389))|(1<<(PlSqlParserSNAPSHOT-389))|(1<<(PlSqlParserSOME-389))|(1<<(PlSqlParserSPECIFICATION-389))|(1<<(PlSqlParserSQLDATA-389))|(1<<(PlSqlParserSQLERROR-389))|(1<<(PlSqlParserSTANDALONE-389))|(1<<(PlSqlParserSTARTUP-389))|(1<<(PlSqlParserSTATEMENT_ID-389))|(1<<(PlSqlParserSTATEMENT-389))|(1<<(PlSqlParserSTATIC-389))|(1<<(PlSqlParserSTATISTICS-389))|(1<<(PlSqlParserSTRING-389))|(1<<(PlSqlParserSUBMULTISET-389))|(1<<(PlSqlParserSUBPARTITION-389))|(1<<(PlSqlParserSUBSTITUTABLE-389))|(1<<(PlSqlParserSUBTYPE-389))|(1<<(PlSqlParserSUCCESS-389))|(1<<(PlSqlParserSUSPEND-389))|(1<<(PlSqlParserTEMPORARY-389)))) != 0) || (((_la-423)&-(0x1f+1)) == 0 && ((1<<uint((_la-423)))&((1<<(PlSqlParserTIMESTAMP_LTZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP-423))|(1<<(PlSqlParserTIMESTAMP_TZ_UNCONSTRAINED-423))|(1<<(PlSqlParserTIMESTAMP_UNCONSTRAINED-423))|(1<<(PlSqlParserTIME-423))|(1<<(PlSqlParserTIMEZONE_ABBR-423))|(1<<(PlSqlParserTIMEZONE_HOUR-423))|(1<<(PlSqlParserTIMEZONE_MINUTE-423))|(1<<(PlSqlParserTIMEZONE_REGION-423))|(1<<(PlSqlParserTRAILING-423))|(1<<(PlSqlParserTRANSACTION-423))|(1<<(PlSqlParserTRANSLATE-423))|(1<<(PlSqlParserTREAT-423))|(1<<(PlSqlParserTRIGGER-423))|(1<<(PlSqlParserTRUNCATE-423))|(1<<(PlSqlParserTYPE-423))|(1<<(PlSqlParserUNBOUNDED-423))|(1<<(PlSqlParserUNDER-423))|(1<<(PlSqlParserUNLIMITED-423))|(1<<(PlSqlParserUNTIL-423))|(1<<(PlSqlParserUPDATED-423))|(1<<(PlSqlParserUPSERT-423))|(1<<(PlSqlParserUROWID-423))|(1<<(PlSqlParserUSE-423))|(1<<(PlSqlParserVALIDATE-423)))) != 0) || (((_la-456)&-(0x1f+1)) == 0 && ((1<<uint((_la-456)))&((1<<(PlSqlParserVALUE-456))|(1<<(PlSqlParserVARCHAR2-456))|(1<<(PlSqlParserVARCHAR-456))|(1<<(PlSqlParserVARIABLE-456))|(1<<(PlSqlParserVARRAY-456))|(1<<(PlSqlParserVARYING-456))|(1<<(PlSqlParserVERSIONS-456))|(1<<(PlSqlParserVERSION-456))|(1<<(PlSqlParserWAIT-456))|(1<<(PlSqlParserWARNING-456))|(1<<(PlSqlParserWELLFORMED-456))|(1<<(PlSqlParserWHENEVER-456))|(1<<(PlSqlParserWHILE-456))|(1<<(PlSqlParserWITHIN-456))|(1<<(PlSqlParserWORK-456))|(1<<(PlSqlParserWRITE-456))|(1<<(PlSqlParserXMLAGG-456))|(1<<(PlSqlParserXMLATTRIBUTES-456))|(1<<(PlSqlParserXMLCAST-456))|(1<<(PlSqlParserXMLCOLATTVAL-456))|(1<<(PlSqlParserXMLELEMENT-456))|(1<<(PlSqlParserXMLEXISTS-456))|(1<<(PlSqlParserXMLFOREST-456))|(1<<(PlSqlParserXMLNAMESPACES-456))|(1<<(PlSqlParserXMLPARSE-456))|(1<<(PlSqlParserXMLPI-456))|(1<<(PlSqlParserXMLQUERY-456))|(1<<(PlSqlParserXMLROOT-456))|(1<<(PlSqlParserXMLSERIALIZE-456)))) != 0) || (((_la-488)&-(0x1f+1)) == 0 && ((1<<uint((_la-488)))&((1<<(PlSqlParserXMLTABLE-488))|(1<<(PlSqlParserXML-488))|(1<<(PlSqlParserYEAR-488))|(1<<(PlSqlParserYES-488))|(1<<(PlSqlParserYMINTERVAL_UNCONSTRAINED-488))|(1<<(PlSqlParserZONE-488))|(1<<(PlSqlParserPREDICTION-488))|(1<<(PlSqlParserPREDICTION_BOUNDS-488))|(1<<(PlSqlParserPREDICTION_COST-488))|(1<<(PlSqlParserPREDICTION_DETAILS-488))|(1<<(PlSqlParserPREDICTION_PROBABILITY-488))|(1<<(PlSqlParserPREDICTION_SET-488))|(1<<(PlSqlParserCUME_DIST-488))|(1<<(PlSqlParserDENSE_RANK-488))|(1<<(PlSqlParserLISTAGG-488))|(1<<(PlSqlParserPERCENT_RANK-488))|(1<<(PlSqlParserPERCENTILE_CONT-488))|(1<<(PlSqlParserPERCENTILE_DISC-488))|(1<<(PlSqlParserRANK-488))|(1<<(PlSqlParserAVG-488))|(1<<(PlSqlParserCORR-488))|(1<<(PlSqlParserCOVAR_-488))|(1<<(PlSqlParserLAG-488))|(1<<(PlSqlParserLEAD-488))|(1<<(PlSqlParserMAX-488))|(1<<(PlSqlParserMEDIAN-488))|(1<<(PlSqlParserMIN-488))|(1<<(PlSqlParserNTILE-488))|(1<<(PlSqlParserRATIO_TO_REPORT-488))|(1<<(PlSqlParserREGR_-488)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(PlSqlParserROW_NUMBER-521))|(1<<(PlSqlParserSUBSTR-521))|(1<<(PlSqlParserTRIM-521))|(1<<(PlSqlParserSUM-521))|(1<<(PlSqlParserSTDDEV-521))|(1<<(PlSqlParserVAR_-521))|(1<<(PlSqlParserVARIANCE-521)))) != 0) || _la == PlSqlParserREGULAR_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IString_function_nameContext is an interface to support dynamic dispatch.
type IString_function_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_function_nameContext differentiates from other interfaces.
	IsString_function_nameContext()
}

type String_function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_function_nameContext() *String_function_nameContext {
	var p = new(String_function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_string_function_name
	return p
}

func (*String_function_nameContext) IsString_function_nameContext() {}

func NewString_function_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_function_nameContext {
	var p = new(String_function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_string_function_name

	return p
}

func (s *String_function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *String_function_nameContext) CHR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCHR, 0)
}

func (s *String_function_nameContext) DECODE() antlr.TerminalNode {
	return s.GetToken(PlSqlParserDECODE, 0)
}

func (s *String_function_nameContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUBSTR, 0)
}

func (s *String_function_nameContext) TO_CHAR() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTO_CHAR, 0)
}

func (s *String_function_nameContext) TRIM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserTRIM, 0)
}

func (s *String_function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterString_function_name(s)
	}
}

func (s *String_function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitString_function_name(s)
	}
}

func (p *PlSqlParser) String_function_name() (localctx IString_function_nameContext) {
	localctx = NewString_function_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, PlSqlParserRULE_string_function_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5765)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserCHR || (((_la-510)&-(0x1f+1)) == 0 && ((1<<uint((_la-510)))&((1<<(PlSqlParserDECODE-510))|(1<<(PlSqlParserSUBSTR-510))|(1<<(PlSqlParserTO_CHAR-510))|(1<<(PlSqlParserTRIM-510)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INumeric_function_nameContext is an interface to support dynamic dispatch.
type INumeric_function_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeric_function_nameContext differentiates from other interfaces.
	IsNumeric_function_nameContext()
}

type Numeric_function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_function_nameContext() *Numeric_function_nameContext {
	var p = new(Numeric_function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PlSqlParserRULE_numeric_function_name
	return p
}

func (*Numeric_function_nameContext) IsNumeric_function_nameContext() {}

func NewNumeric_function_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_function_nameContext {
	var p = new(Numeric_function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PlSqlParserRULE_numeric_function_name

	return p
}

func (s *Numeric_function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Numeric_function_nameContext) AVG() antlr.TerminalNode {
	return s.GetToken(PlSqlParserAVG, 0)
}

func (s *Numeric_function_nameContext) COUNT() antlr.TerminalNode {
	return s.GetToken(PlSqlParserCOUNT, 0)
}

func (s *Numeric_function_nameContext) NVL() antlr.TerminalNode {
	return s.GetToken(PlSqlParserNVL, 0)
}

func (s *Numeric_function_nameContext) ROUND() antlr.TerminalNode {
	return s.GetToken(PlSqlParserROUND, 0)
}

func (s *Numeric_function_nameContext) SUM() antlr.TerminalNode {
	return s.GetToken(PlSqlParserSUM, 0)
}

func (s *Numeric_function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Numeric_function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.EnterNumeric_function_name(s)
	}
}

func (s *Numeric_function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PlSqlParserListener); ok {
		listenerT.ExitNumeric_function_name(s)
	}
}

func (p *PlSqlParser) Numeric_function_name() (localctx INumeric_function_nameContext) {
	localctx = NewNumeric_function_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, PlSqlParserRULE_numeric_function_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5767)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PlSqlParserCOUNT || (((_la-507)&-(0x1f+1)) == 0 && ((1<<uint((_la-507)))&((1<<(PlSqlParserAVG-507))|(1<<(PlSqlParserNVL-507))|(1<<(PlSqlParserROUND-507))|(1<<(PlSqlParserSUM-507)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *PlSqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 269:
		var t *Logical_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Logical_expressionContext)
		}
		return p.Logical_expression_Sempred(t, predIndex)

	case 271:
		var t *Relational_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Relational_expressionContext)
		}
		return p.Relational_expression_Sempred(t, predIndex)

	case 276:
		var t *ConcatenationContext = nil
		if localctx != nil {
			t = localctx.(*ConcatenationContext)
		}
		return p.Concatenation_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *PlSqlParser) Logical_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PlSqlParser) Relational_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PlSqlParser) Concatenation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
