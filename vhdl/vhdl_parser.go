// Code generated from vhdl.g4 by ANTLR 4.9.3. DO NOT EDIT.

package vhdl // vhdl
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 164, 2601,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 5, 4,
	520, 10, 4, 3, 4, 3, 4, 5, 4, 524, 10, 4, 3, 4, 3, 4, 3, 5, 3, 5, 5, 5,
	530, 10, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 540,
	10, 7, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9, 7, 9, 548, 10, 9, 12, 9, 14,
	9, 551, 11, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 559, 10,
	10, 3, 10, 3, 10, 3, 10, 5, 10, 564, 10, 10, 3, 10, 3, 10, 3, 11, 3, 11,
	3, 11, 5, 11, 571, 10, 11, 3, 12, 3, 12, 5, 12, 575, 10, 12, 3, 13, 3,
	13, 3, 13, 5, 13, 580, 10, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 592, 10, 14, 3, 14, 5, 14, 595, 10,
	14, 3, 14, 3, 14, 3, 15, 7, 15, 600, 10, 15, 12, 15, 14, 15, 603, 11, 15,
	3, 16, 3, 16, 3, 16, 5, 16, 608, 10, 16, 3, 16, 3, 16, 5, 16, 612, 10,
	16, 3, 16, 3, 16, 5, 16, 616, 10, 16, 3, 16, 5, 16, 619, 10, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 626, 10, 16, 3, 17, 7, 17, 629, 10,
	17, 12, 17, 14, 17, 632, 11, 17, 3, 18, 3, 18, 5, 18, 636, 10, 18, 3, 19,
	3, 19, 5, 19, 640, 10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 646, 10,
	20, 3, 20, 3, 20, 5, 20, 650, 10, 20, 3, 21, 5, 21, 653, 10, 21, 3, 21,
	3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 5, 22, 661, 10, 22, 3, 22, 3, 22, 3,
	23, 3, 23, 3, 23, 7, 23, 668, 10, 23, 12, 23, 14, 23, 671, 11, 23, 3, 24,
	3, 24, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3,
	25, 5, 25, 685, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26,
	3, 26, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28, 5, 28, 700, 10, 28, 3, 28, 5,
	28, 703, 10, 28, 3, 28, 5, 28, 706, 10, 28, 3, 29, 3, 29, 3, 29, 7, 29,
	711, 10, 29, 12, 29, 14, 29, 714, 11, 29, 3, 29, 7, 29, 717, 10, 29, 12,
	29, 14, 29, 720, 11, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 748,
	10, 30, 3, 31, 7, 31, 751, 10, 31, 12, 31, 14, 31, 754, 11, 31, 3, 32,
	3, 32, 3, 32, 3, 32, 5, 32, 760, 10, 32, 5, 32, 762, 10, 32, 3, 32, 3,
	32, 3, 32, 3, 32, 5, 32, 768, 10, 32, 5, 32, 770, 10, 32, 3, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 5, 33, 777, 10, 33, 3, 33, 5, 33, 780, 10, 33, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 788, 10, 34, 3, 34, 5, 34,
	791, 10, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 800,
	10, 34, 3, 34, 3, 34, 3, 35, 7, 35, 805, 10, 35, 12, 35, 14, 35, 808, 11,
	35, 3, 36, 3, 36, 5, 36, 812, 10, 36, 3, 36, 5, 36, 815, 10, 36, 3, 36,
	3, 36, 3, 36, 3, 37, 5, 37, 821, 10, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	38, 3, 38, 3, 38, 7, 38, 830, 10, 38, 12, 38, 14, 38, 833, 11, 38, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 40, 5, 40, 840, 10, 40, 3, 40, 3, 40, 5, 40, 844,
	10, 40, 3, 40, 3, 40, 5, 40, 848, 10, 40, 3, 40, 3, 40, 3, 41, 5, 41, 853,
	10, 41, 3, 41, 3, 41, 3, 41, 3, 41, 6, 41, 859, 10, 41, 13, 41, 14, 41,
	860, 3, 41, 3, 41, 3, 41, 5, 41, 866, 10, 41, 3, 41, 3, 41, 3, 42, 3, 42,
	3, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 879, 10, 43, 3,
	44, 3, 44, 3, 44, 7, 44, 884, 10, 44, 12, 44, 14, 44, 887, 11, 44, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 894, 10, 45, 3, 45, 5, 45, 897, 10,
	45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 5, 46, 906, 10, 46,
	3, 46, 5, 46, 909, 10, 46, 3, 46, 5, 46, 912, 10, 46, 3, 46, 3, 46, 3,
	46, 5, 46, 917, 10, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 5, 47, 924,
	10, 47, 3, 47, 5, 47, 927, 10, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3,
	48, 3, 49, 3, 49, 5, 49, 937, 10, 49, 3, 50, 3, 50, 5, 50, 941, 10, 50,
	3, 51, 5, 51, 944, 10, 51, 3, 51, 5, 51, 947, 10, 51, 3, 51, 3, 51, 3,
	51, 3, 52, 5, 52, 953, 10, 52, 3, 52, 3, 52, 5, 52, 957, 10, 52, 3, 52,
	5, 52, 960, 10, 52, 3, 52, 3, 52, 5, 52, 964, 10, 52, 3, 52, 3, 52, 3,
	53, 5, 53, 969, 10, 53, 3, 53, 5, 53, 972, 10, 53, 3, 53, 3, 53, 3, 53,
	3, 54, 5, 54, 978, 10, 54, 3, 54, 5, 54, 981, 10, 54, 3, 54, 3, 54, 5,
	54, 985, 10, 54, 3, 55, 3, 55, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57,
	3, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1003, 10,
	58, 5, 58, 1005, 10, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59,
	3, 59, 3, 59, 5, 59, 1016, 10, 59, 3, 59, 5, 59, 1019, 10, 59, 3, 59, 3,
	59, 3, 60, 3, 60, 3, 60, 5, 60, 1026, 10, 60, 3, 61, 7, 61, 1029, 10, 61,
	12, 61, 14, 61, 1032, 11, 61, 3, 62, 3, 62, 5, 62, 1036, 10, 62, 3, 63,
	3, 63, 3, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 5,
	64, 1049, 10, 64, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 66,
	3, 66, 3, 66, 3, 66, 3, 66, 3, 67, 3, 67, 5, 67, 1065, 10, 67, 3, 68, 7,
	68, 1068, 10, 68, 12, 68, 14, 68, 1071, 11, 68, 3, 69, 3, 69, 5, 69, 1075,
	10, 69, 3, 70, 3, 70, 3, 70, 5, 70, 1080, 10, 70, 3, 70, 5, 70, 1083, 10,
	70, 3, 71, 7, 71, 1086, 10, 71, 12, 71, 14, 71, 1089, 11, 71, 3, 71, 3,
	71, 3, 72, 3, 72, 3, 72, 3, 73, 3, 73, 5, 73, 1098, 10, 73, 3, 74, 3, 74,
	3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 76, 3, 76, 5, 76, 1110, 10,
	76, 3, 77, 3, 77, 3, 77, 5, 77, 1115, 10, 77, 3, 77, 3, 77, 3, 78, 3, 78,
	3, 78, 3, 78, 3, 78, 3, 79, 3, 79, 3, 80, 3, 80, 3, 81, 3, 81, 3, 81, 3,
	81, 3, 81, 3, 81, 5, 81, 1134, 10, 81, 3, 81, 3, 81, 3, 81, 5, 81, 1139,
	10, 81, 3, 82, 3, 82, 3, 83, 3, 83, 5, 83, 1145, 10, 83, 3, 84, 3, 84,
	3, 84, 7, 84, 1150, 10, 84, 12, 84, 14, 84, 1153, 11, 84, 3, 85, 3, 85,
	3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 1162, 10, 85, 3, 85, 3, 85, 5,
	85, 1166, 10, 85, 3, 85, 5, 85, 1169, 10, 85, 3, 85, 3, 85, 3, 86, 3, 86,
	3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3,
	86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 5, 86, 1193, 10, 86,
	3, 87, 7, 87, 1196, 10, 87, 12, 87, 14, 87, 1199, 11, 87, 3, 88, 3, 88,
	5, 88, 1203, 10, 88, 3, 89, 5, 89, 1206, 10, 89, 3, 89, 5, 89, 1209, 10,
	89, 3, 90, 3, 90, 3, 90, 7, 90, 1214, 10, 90, 12, 90, 14, 90, 1217, 11,
	90, 3, 90, 3, 90, 5, 90, 1221, 10, 90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 92,
	3, 92, 3, 92, 5, 92, 1230, 10, 92, 3, 93, 7, 93, 1233, 10, 93, 12, 93,
	14, 93, 1236, 11, 93, 3, 94, 3, 94, 3, 94, 5, 94, 1241, 10, 94, 3, 95,
	3, 95, 5, 95, 1245, 10, 95, 3, 96, 3, 96, 3, 96, 3, 96, 7, 96, 1251, 10,
	96, 12, 96, 14, 96, 1254, 11, 96, 3, 96, 3, 96, 3, 97, 5, 97, 1259, 10,
	97, 3, 97, 3, 97, 5, 97, 1263, 10, 97, 3, 97, 3, 97, 5, 97, 1267, 10, 97,
	3, 97, 3, 97, 3, 98, 3, 98, 3, 98, 3, 98, 7, 98, 1275, 10, 98, 12, 98,
	14, 98, 1278, 11, 98, 3, 99, 3, 99, 3, 99, 5, 99, 1283, 10, 99, 3, 99,
	3, 99, 3, 99, 3, 99, 5, 99, 1289, 10, 99, 3, 100, 3, 100, 3, 100, 3, 100,
	3, 100, 5, 100, 1296, 10, 100, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102,
	3, 102, 5, 102, 1304, 10, 102, 3, 102, 3, 102, 3, 102, 3, 103, 3, 103,
	3, 103, 3, 103, 3, 104, 3, 104, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105,
	3, 105, 5, 105, 1321, 10, 105, 3, 106, 3, 106, 3, 106, 3, 106, 3, 106,
	3, 106, 5, 106, 1329, 10, 106, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107,
	3, 107, 7, 107, 1337, 10, 107, 12, 107, 14, 107, 1340, 11, 107, 3, 107,
	5, 107, 1343, 10, 107, 3, 107, 7, 107, 1346, 10, 107, 12, 107, 14, 107,
	1349, 11, 107, 3, 107, 3, 107, 3, 107, 5, 107, 1354, 10, 107, 3, 107, 3,
	107, 3, 108, 3, 108, 3, 108, 3, 108, 5, 108, 1362, 10, 108, 3, 109, 3,
	109, 3, 109, 3, 109, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 7, 110, 1373,
	10, 110, 12, 110, 14, 110, 1376, 11, 110, 3, 111, 3, 111, 3, 111, 3, 111,
	3, 111, 3, 111, 3, 112, 3, 112, 5, 112, 1386, 10, 112, 3, 113, 3, 113,
	3, 113, 7, 113, 1391, 10, 113, 12, 113, 14, 113, 1394, 11, 113, 3, 114,
	3, 114, 3, 114, 3, 114, 3, 114, 3, 114, 3, 114, 3, 114, 3, 115, 3, 115,
	3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 116, 3, 116, 3, 116,
	3, 116, 3, 117, 3, 117, 3, 118, 3, 118, 3, 118, 7, 118, 1421, 10, 118,
	12, 118, 14, 118, 1424, 11, 118, 3, 119, 5, 119, 1427, 10, 119, 3, 119,
	3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 7, 119,
	1438, 10, 119, 12, 119, 14, 119, 1441, 11, 119, 3, 119, 3, 119, 5, 119,
	1445, 10, 119, 3, 119, 3, 119, 3, 119, 5, 119, 1450, 10, 119, 3, 119, 3,
	119, 3, 120, 3, 120, 3, 120, 3, 120, 7, 120, 1458, 10, 120, 12, 120, 14,
	120, 1461, 11, 120, 3, 120, 3, 120, 3, 121, 3, 121, 5, 121, 1467, 10, 121,
	3, 122, 3, 122, 3, 122, 3, 122, 3, 123, 5, 123, 1474, 10, 123, 3, 123,
	3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 5, 123, 1483, 10, 123,
	3, 123, 3, 123, 5, 123, 1487, 10, 123, 3, 124, 3, 124, 3, 124, 7, 124,
	1492, 10, 124, 12, 124, 14, 124, 1495, 11, 124, 3, 124, 3, 124, 5, 124,
	1499, 10, 124, 3, 125, 5, 125, 1502, 10, 125, 3, 125, 3, 125, 3, 125, 5,
	125, 1507, 10, 125, 3, 125, 3, 125, 3, 125, 5, 125, 1512, 10, 125, 3, 126,
	3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 5, 126, 1520, 10, 126, 3, 127,
	3, 127, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 129, 3, 129, 3, 129,
	7, 129, 1532, 10, 129, 12, 129, 14, 129, 1535, 11, 129, 3, 130, 3, 130,
	3, 130, 7, 130, 1540, 10, 130, 12, 130, 14, 130, 1543, 11, 130, 3, 131,
	3, 131, 3, 131, 7, 131, 1548, 10, 131, 12, 131, 14, 131, 1551, 11, 131,
	3, 132, 3, 132, 3, 132, 3, 132, 5, 132, 1557, 10, 132, 3, 132, 3, 132,
	3, 132, 5, 132, 1562, 10, 132, 3, 133, 3, 133, 3, 133, 5, 133, 1567, 10,
	133, 3, 133, 3, 133, 5, 133, 1571, 10, 133, 3, 133, 3, 133, 5, 133, 1575,
	10, 133, 3, 134, 3, 134, 3, 134, 3, 134, 5, 134, 1581, 10, 134, 3, 134,
	3, 134, 5, 134, 1585, 10, 134, 3, 134, 3, 134, 5, 134, 1589, 10, 134, 3,
	135, 3, 135, 3, 135, 3, 135, 3, 135, 3, 136, 5, 136, 1597, 10, 136, 3,
	136, 3, 136, 3, 136, 5, 136, 1602, 10, 136, 3, 136, 3, 136, 3, 136, 5,
	136, 1607, 10, 136, 3, 137, 3, 137, 3, 137, 3, 137, 5, 137, 1613, 10, 137,
	3, 138, 3, 138, 3, 138, 3, 139, 3, 139, 3, 139, 3, 139, 3, 140, 3, 140,
	5, 140, 1624, 10, 140, 3, 141, 3, 141, 3, 141, 3, 141, 3, 141, 5, 141,
	1631, 10, 141, 3, 142, 3, 142, 3, 143, 3, 143, 3, 143, 7, 143, 1638, 10,
	143, 12, 143, 14, 143, 1641, 11, 143, 3, 144, 3, 144, 3, 145, 5, 145, 1646,
	10, 145, 3, 145, 5, 145, 1649, 10, 145, 3, 145, 3, 145, 3, 145, 3, 145,
	3, 145, 5, 145, 1656, 10, 145, 3, 145, 3, 145, 3, 146, 3, 146, 3, 147,
	3, 147, 3, 148, 3, 148, 5, 148, 1666, 10, 148, 3, 148, 7, 148, 1669, 10,
	148, 12, 148, 14, 148, 1672, 11, 148, 3, 149, 3, 149, 3, 149, 3, 149, 5,
	149, 1678, 10, 149, 3, 150, 3, 150, 3, 150, 7, 150, 1683, 10, 150, 12,
	150, 14, 150, 1686, 11, 150, 3, 151, 3, 151, 6, 151, 1690, 10, 151, 13,
	151, 14, 151, 1691, 3, 152, 3, 152, 3, 152, 3, 152, 3, 153, 3, 153, 3,
	153, 3, 153, 3, 154, 5, 154, 1703, 10, 154, 3, 154, 3, 154, 3, 154, 3,
	154, 3, 154, 3, 154, 5, 154, 1711, 10, 154, 3, 155, 3, 155, 3, 155, 3,
	155, 3, 155, 3, 155, 3, 156, 3, 156, 5, 156, 1721, 10, 156, 3, 157, 3,
	157, 3, 157, 3, 157, 3, 158, 5, 158, 1728, 10, 158, 3, 158, 3, 158, 5,
	158, 1732, 10, 158, 3, 158, 3, 158, 5, 158, 1736, 10, 158, 3, 158, 3, 158,
	3, 159, 3, 159, 5, 159, 1742, 10, 159, 3, 160, 3, 160, 3, 160, 3, 160,
	3, 160, 3, 160, 5, 160, 1750, 10, 160, 3, 161, 5, 161, 1753, 10, 161, 3,
	161, 5, 161, 1756, 10, 161, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3,
	162, 3, 162, 3, 162, 5, 162, 1766, 10, 162, 3, 162, 5, 162, 1769, 10, 162,
	3, 162, 3, 162, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163,
	3, 163, 3, 163, 3, 163, 3, 163, 5, 163, 1784, 10, 163, 3, 164, 7, 164,
	1787, 10, 164, 12, 164, 14, 164, 1790, 11, 164, 3, 165, 3, 165, 3, 165,
	3, 165, 3, 165, 3, 165, 5, 165, 1798, 10, 165, 3, 165, 5, 165, 1801, 10,
	165, 3, 165, 3, 165, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3,
	166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3,
	166, 3, 166, 3, 166, 3, 166, 5, 166, 1824, 10, 166, 3, 167, 7, 167, 1827,
	10, 167, 12, 167, 14, 167, 1830, 11, 167, 3, 168, 3, 168, 3, 168, 3, 168,
	3, 169, 3, 169, 3, 169, 3, 170, 3, 170, 3, 170, 3, 170, 7, 170, 1843, 10,
	170, 12, 170, 14, 170, 1846, 11, 170, 3, 170, 3, 170, 3, 170, 5, 170, 1851,
	10, 170, 3, 171, 3, 171, 3, 171, 3, 171, 3, 171, 3, 171, 3, 172, 3, 172,
	3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 3, 174, 3, 174, 3, 174,
	3, 174, 3, 174, 3, 174, 3, 174, 3, 174, 3, 174, 5, 174, 1876, 10, 174,
	3, 175, 3, 175, 3, 175, 5, 175, 1881, 10, 175, 3, 176, 3, 176, 3, 176,
	3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176,
	5, 176, 1895, 10, 176, 3, 177, 7, 177, 1898, 10, 177, 12, 177, 14, 177,
	1901, 11, 177, 3, 178, 7, 178, 1904, 10, 178, 12, 178, 14, 178, 1907, 11,
	178, 3, 179, 3, 179, 3, 179, 3, 179, 3, 179, 5, 179, 1914, 10, 179, 3,
	180, 5, 180, 1917, 10, 180, 3, 180, 3, 180, 3, 180, 3, 181, 3, 181, 3,
	181, 3, 181, 3, 181, 3, 181, 3, 181, 3, 181, 3, 181, 3, 181, 3, 181, 3,
	181, 3, 181, 5, 181, 1935, 10, 181, 3, 182, 7, 182, 1938, 10, 182, 12,
	182, 14, 182, 1941, 11, 182, 3, 183, 5, 183, 1944, 10, 183, 3, 183, 5,
	183, 1947, 10, 183, 3, 183, 3, 183, 3, 183, 3, 183, 3, 183, 5, 183, 1954,
	10, 183, 3, 183, 5, 183, 1957, 10, 183, 3, 183, 3, 183, 3, 183, 3, 183,
	3, 183, 5, 183, 1964, 10, 183, 3, 183, 3, 183, 5, 183, 1968, 10, 183, 3,
	183, 3, 183, 3, 184, 7, 184, 1973, 10, 184, 12, 184, 14, 184, 1976, 11,
	184, 3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 5, 185, 1985,
	10, 185, 3, 186, 3, 186, 3, 186, 5, 186, 1990, 10, 186, 3, 187, 3, 187,
	3, 187, 7, 187, 1995, 10, 187, 12, 187, 14, 187, 1998, 11, 187, 3, 187,
	3, 187, 5, 187, 2002, 10, 187, 3, 188, 3, 188, 3, 188, 3, 188, 3, 189,
	3, 189, 5, 189, 2010, 10, 189, 3, 190, 3, 190, 3, 190, 3, 190, 5, 190,
	2016, 10, 190, 3, 191, 3, 191, 3, 191, 3, 192, 3, 192, 6, 192, 2023, 10,
	192, 13, 192, 14, 192, 2024, 3, 192, 3, 192, 3, 192, 5, 192, 2030, 10,
	192, 3, 193, 3, 193, 6, 193, 2034, 10, 193, 13, 193, 14, 193, 2035, 3,
	193, 3, 193, 3, 193, 5, 193, 2041, 10, 193, 3, 194, 3, 194, 3, 194, 3,
	194, 5, 194, 2047, 10, 194, 3, 195, 3, 195, 3, 196, 5, 196, 2052, 10, 196,
	3, 196, 3, 196, 3, 196, 3, 196, 5, 196, 2058, 10, 196, 3, 196, 3, 196,
	3, 197, 5, 197, 2063, 10, 197, 3, 197, 3, 197, 5, 197, 2067, 10, 197, 3,
	197, 3, 197, 3, 198, 3, 198, 3, 198, 3, 198, 3, 198, 3, 198, 3, 198, 3,
	199, 3, 199, 3, 199, 5, 199, 2081, 10, 199, 3, 200, 3, 200, 5, 200, 2085,
	10, 200, 3, 201, 3, 201, 3, 201, 3, 201, 3, 201, 3, 202, 3, 202, 3, 202,
	3, 202, 3, 202, 3, 202, 3, 202, 3, 202, 3, 202, 3, 203, 3, 203, 3, 203,
	3, 203, 3, 203, 3, 203, 3, 203, 3, 203, 7, 203, 2109, 10, 203, 12, 203,
	14, 203, 2112, 11, 203, 3, 204, 3, 204, 3, 204, 3, 205, 3, 205, 3, 205,
	7, 205, 2120, 10, 205, 12, 205, 14, 205, 2123, 11, 205, 3, 206, 7, 206,
	2126, 10, 206, 12, 206, 14, 206, 2129, 11, 206, 3, 207, 3, 207, 3, 207,
	3, 207, 3, 207, 3, 207, 3, 207, 3, 207, 3, 207, 3, 207, 3, 207, 3, 207,
	5, 207, 2143, 10, 207, 3, 207, 3, 207, 3, 207, 3, 207, 5, 207, 2149, 10,
	207, 3, 208, 3, 208, 3, 208, 3, 208, 5, 208, 2155, 10, 208, 3, 209, 3,
	209, 3, 210, 5, 210, 2160, 10, 210, 3, 210, 3, 210, 3, 210, 5, 210, 2165,
	10, 210, 3, 210, 3, 210, 3, 210, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211,
	5, 211, 2175, 10, 211, 3, 211, 3, 211, 5, 211, 2179, 10, 211, 3, 211, 3,
	211, 3, 212, 3, 212, 3, 213, 3, 213, 3, 213, 7, 213, 2188, 10, 213, 12,
	213, 14, 213, 2191, 11, 213, 3, 213, 3, 213, 5, 213, 2195, 10, 213, 3,
	214, 3, 214, 3, 214, 3, 214, 7, 214, 2201, 10, 214, 12, 214, 14, 214, 2204,
	11, 214, 5, 214, 2206, 10, 214, 3, 214, 3, 214, 5, 214, 2210, 10, 214,
	3, 214, 3, 214, 3, 215, 5, 215, 2215, 10, 215, 3, 215, 3, 215, 3, 215,
	3, 215, 7, 215, 2221, 10, 215, 12, 215, 14, 215, 2224, 11, 215, 3, 216,
	5, 216, 2227, 10, 216, 3, 216, 3, 216, 3, 216, 3, 216, 5, 216, 2233, 10,
	216, 3, 216, 3, 216, 3, 217, 3, 217, 3, 217, 3, 217, 3, 217, 3, 218, 5,
	218, 2243, 10, 218, 3, 218, 3, 218, 3, 218, 3, 218, 6, 218, 2249, 10, 218,
	13, 218, 14, 218, 2250, 3, 218, 3, 218, 3, 218, 5, 218, 2256, 10, 218,
	3, 218, 3, 218, 3, 219, 5, 219, 2261, 10, 219, 3, 219, 3, 219, 3, 219,
	3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 7, 219, 2272, 10, 219,
	12, 219, 14, 219, 2275, 11, 219, 3, 219, 3, 219, 5, 219, 2279, 10, 219,
	3, 219, 3, 219, 3, 219, 5, 219, 2284, 10, 219, 3, 219, 3, 219, 3, 220,
	5, 220, 2289, 10, 220, 3, 220, 3, 220, 5, 220, 2293, 10, 220, 3, 220, 3,
	220, 3, 220, 3, 220, 3, 220, 3, 220, 5, 220, 2301, 10, 220, 3, 220, 3,
	220, 3, 221, 3, 221, 3, 221, 3, 221, 3, 221, 5, 221, 2310, 10, 221, 3,
	221, 3, 221, 5, 221, 2314, 10, 221, 3, 222, 7, 222, 2317, 10, 222, 12,
	222, 14, 222, 2320, 11, 222, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3,
	223, 3, 223, 5, 223, 2329, 10, 223, 3, 224, 3, 224, 3, 224, 3, 224, 3,
	224, 3, 224, 3, 224, 3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 3,
	226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 227, 3, 227, 5, 227, 2352,
	10, 227, 3, 227, 3, 227, 3, 227, 3, 227, 3, 227, 3, 227, 5, 227, 2360,
	10, 227, 3, 228, 3, 228, 3, 228, 3, 228, 3, 228, 3, 228, 3, 228, 5, 228,
	2369, 10, 228, 3, 228, 5, 228, 2372, 10, 228, 3, 228, 3, 228, 3, 229, 3,
	229, 3, 229, 3, 230, 3, 230, 3, 230, 3, 230, 3, 230, 3, 230, 3, 230, 3,
	230, 3, 230, 3, 230, 3, 230, 3, 230, 3, 230, 5, 230, 2392, 10, 230, 3,
	231, 7, 231, 2395, 10, 231, 12, 231, 14, 231, 2398, 11, 231, 3, 232, 3,
	232, 3, 233, 3, 233, 5, 233, 2404, 10, 233, 3, 234, 3, 234, 3, 234, 3,
	234, 3, 234, 3, 234, 5, 234, 2412, 10, 234, 3, 235, 5, 235, 2415, 10, 235,
	3, 235, 3, 235, 3, 235, 3, 235, 3, 235, 3, 235, 5, 235, 2423, 10, 235,
	3, 235, 3, 235, 3, 235, 3, 236, 7, 236, 2429, 10, 236, 12, 236, 14, 236,
	2432, 11, 236, 3, 237, 3, 237, 3, 237, 3, 237, 3, 237, 3, 237, 3, 238,
	3, 238, 5, 238, 2442, 10, 238, 3, 238, 5, 238, 2445, 10, 238, 3, 238, 5,
	238, 2448, 10, 238, 3, 239, 3, 239, 3, 239, 3, 239, 5, 239, 2454, 10, 239,
	3, 240, 3, 240, 5, 240, 2458, 10, 240, 3, 241, 3, 241, 3, 241, 3, 241,
	7, 241, 2464, 10, 241, 12, 241, 14, 241, 2467, 11, 241, 3, 242, 3, 242,
	3, 242, 5, 242, 2472, 10, 242, 3, 243, 3, 243, 3, 243, 3, 243, 3, 243,
	3, 243, 3, 244, 3, 244, 5, 244, 2482, 10, 244, 3, 244, 3, 244, 5, 244,
	2486, 10, 244, 3, 244, 3, 244, 3, 245, 3, 245, 3, 245, 3, 246, 3, 246,
	3, 246, 3, 247, 3, 247, 3, 247, 3, 247, 5, 247, 2500, 10, 247, 3, 247,
	3, 247, 3, 248, 3, 248, 3, 248, 3, 248, 5, 248, 2508, 10, 248, 3, 249,
	3, 249, 3, 249, 3, 249, 3, 249, 7, 249, 2515, 10, 249, 12, 249, 14, 249,
	2518, 11, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 250, 3, 250, 3, 250,
	3, 250, 3, 250, 7, 250, 2529, 10, 250, 12, 250, 14, 250, 2532, 11, 250,
	3, 250, 3, 250, 3, 250, 3, 250, 3, 251, 3, 251, 3, 251, 3, 251, 7, 251,
	2542, 10, 251, 12, 251, 14, 251, 2545, 11, 251, 3, 251, 3, 251, 3, 252,
	5, 252, 2550, 10, 252, 3, 252, 3, 252, 3, 252, 3, 252, 3, 252, 3, 253,
	5, 253, 2558, 10, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253,
	5, 253, 2566, 10, 253, 3, 253, 3, 253, 3, 254, 5, 254, 2571, 10, 254, 3,
	254, 3, 254, 5, 254, 2575, 10, 254, 3, 254, 5, 254, 2578, 10, 254, 3, 254,
	5, 254, 2581, 10, 254, 3, 254, 3, 254, 3, 255, 3, 255, 3, 255, 7, 255,
	2588, 10, 255, 12, 255, 14, 255, 2591, 11, 255, 3, 255, 5, 255, 2594, 10,
	255, 3, 256, 3, 256, 3, 256, 5, 256, 2599, 10, 256, 3, 256, 2, 2, 257,
	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
	40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
	76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
	110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
	140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
	170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
	200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
	230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
	260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
	290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
	320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348,
	350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378,
	380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408,
	410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438,
	440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468,
	470, 472, 474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498,
	500, 502, 504, 506, 508, 510, 2, 17, 5, 2, 114, 114, 119, 119, 160, 160,
	4, 2, 142, 142, 150, 151, 4, 2, 25, 25, 99, 99, 19, 2, 10, 10, 21, 23,
	27, 27, 31, 31, 33, 33, 36, 36, 44, 44, 48, 48, 53, 53, 66, 66, 70, 70,
	73, 73, 88, 88, 94, 96, 102, 102, 104, 104, 107, 107, 3, 2, 120, 121, 4,
	2, 40, 40, 65, 65, 7, 2, 9, 9, 52, 52, 57, 57, 63, 63, 112, 113, 7, 2,
	18, 18, 40, 40, 42, 42, 47, 47, 65, 65, 5, 2, 51, 51, 77, 77, 148, 149,
	5, 2, 133, 134, 136, 136, 152, 154, 5, 2, 83, 84, 89, 90, 92, 93, 4, 2,
	19, 19, 80, 80, 3, 2, 150, 151, 4, 2, 33, 33, 70, 70, 4, 2, 39, 39, 72,
	72, 2, 2799, 2, 512, 3, 2, 2, 2, 4, 514, 3, 2, 2, 2, 6, 517, 3, 2, 2, 2,
	8, 529, 3, 2, 2, 2, 10, 531, 3, 2, 2, 2, 12, 539, 3, 2, 2, 2, 14, 541,
	3, 2, 2, 2, 16, 543, 3, 2, 2, 2, 18, 554, 3, 2, 2, 2, 20, 570, 3, 2, 2,
	2, 22, 574, 3, 2, 2, 2, 24, 576, 3, 2, 2, 2, 26, 581, 3, 2, 2, 2, 28, 601,
	3, 2, 2, 2, 30, 625, 3, 2, 2, 2, 32, 630, 3, 2, 2, 2, 34, 635, 3, 2, 2,
	2, 36, 639, 3, 2, 2, 2, 38, 641, 3, 2, 2, 2, 40, 652, 3, 2, 2, 2, 42, 660,
	3, 2, 2, 2, 44, 664, 3, 2, 2, 2, 46, 672, 3, 2, 2, 2, 48, 684, 3, 2, 2,
	2, 50, 686, 3, 2, 2, 2, 52, 694, 3, 2, 2, 2, 54, 699, 3, 2, 2, 2, 56, 707,
	3, 2, 2, 2, 58, 747, 3, 2, 2, 2, 60, 752, 3, 2, 2, 2, 62, 761, 3, 2, 2,
	2, 64, 779, 3, 2, 2, 2, 66, 781, 3, 2, 2, 2, 68, 806, 3, 2, 2, 2, 70, 809,
	3, 2, 2, 2, 72, 820, 3, 2, 2, 2, 74, 826, 3, 2, 2, 2, 76, 834, 3, 2, 2,
	2, 78, 839, 3, 2, 2, 2, 80, 852, 3, 2, 2, 2, 82, 869, 3, 2, 2, 2, 84, 878,
	3, 2, 2, 2, 86, 880, 3, 2, 2, 2, 88, 888, 3, 2, 2, 2, 90, 902, 3, 2, 2,
	2, 92, 920, 3, 2, 2, 2, 94, 930, 3, 2, 2, 2, 96, 936, 3, 2, 2, 2, 98, 940,
	3, 2, 2, 2, 100, 943, 3, 2, 2, 2, 102, 952, 3, 2, 2, 2, 104, 968, 3, 2,
	2, 2, 106, 977, 3, 2, 2, 2, 108, 986, 3, 2, 2, 2, 110, 988, 3, 2, 2, 2,
	112, 991, 3, 2, 2, 2, 114, 997, 3, 2, 2, 2, 116, 1006, 3, 2, 2, 2, 118,
	1025, 3, 2, 2, 2, 120, 1030, 3, 2, 2, 2, 122, 1035, 3, 2, 2, 2, 124, 1037,
	3, 2, 2, 2, 126, 1042, 3, 2, 2, 2, 128, 1052, 3, 2, 2, 2, 130, 1057, 3,
	2, 2, 2, 132, 1064, 3, 2, 2, 2, 134, 1069, 3, 2, 2, 2, 136, 1074, 3, 2,
	2, 2, 138, 1082, 3, 2, 2, 2, 140, 1087, 3, 2, 2, 2, 142, 1092, 3, 2, 2,
	2, 144, 1097, 3, 2, 2, 2, 146, 1099, 3, 2, 2, 2, 148, 1101, 3, 2, 2, 2,
	150, 1109, 3, 2, 2, 2, 152, 1114, 3, 2, 2, 2, 154, 1118, 3, 2, 2, 2, 156,
	1123, 3, 2, 2, 2, 158, 1125, 3, 2, 2, 2, 160, 1138, 3, 2, 2, 2, 162, 1140,
	3, 2, 2, 2, 164, 1142, 3, 2, 2, 2, 166, 1146, 3, 2, 2, 2, 168, 1154, 3,
	2, 2, 2, 170, 1192, 3, 2, 2, 2, 172, 1197, 3, 2, 2, 2, 174, 1200, 3, 2,
	2, 2, 176, 1205, 3, 2, 2, 2, 178, 1220, 3, 2, 2, 2, 180, 1222, 3, 2, 2,
	2, 182, 1229, 3, 2, 2, 2, 184, 1234, 3, 2, 2, 2, 186, 1240, 3, 2, 2, 2,
	188, 1244, 3, 2, 2, 2, 190, 1246, 3, 2, 2, 2, 192, 1258, 3, 2, 2, 2, 194,
	1270, 3, 2, 2, 2, 196, 1288, 3, 2, 2, 2, 198, 1290, 3, 2, 2, 2, 200, 1299,
	3, 2, 2, 2, 202, 1303, 3, 2, 2, 2, 204, 1308, 3, 2, 2, 2, 206, 1312, 3,
	2, 2, 2, 208, 1320, 3, 2, 2, 2, 210, 1322, 3, 2, 2, 2, 212, 1332, 3, 2,
	2, 2, 214, 1361, 3, 2, 2, 2, 216, 1363, 3, 2, 2, 2, 218, 1369, 3, 2, 2,
	2, 220, 1377, 3, 2, 2, 2, 222, 1385, 3, 2, 2, 2, 224, 1387, 3, 2, 2, 2,
	226, 1395, 3, 2, 2, 2, 228, 1403, 3, 2, 2, 2, 230, 1411, 3, 2, 2, 2, 232,
	1415, 3, 2, 2, 2, 234, 1417, 3, 2, 2, 2, 236, 1426, 3, 2, 2, 2, 238, 1453,
	3, 2, 2, 2, 240, 1466, 3, 2, 2, 2, 242, 1468, 3, 2, 2, 2, 244, 1486, 3,
	2, 2, 2, 246, 1498, 3, 2, 2, 2, 248, 1501, 3, 2, 2, 2, 250, 1519, 3, 2,
	2, 2, 252, 1521, 3, 2, 2, 2, 254, 1523, 3, 2, 2, 2, 256, 1528, 3, 2, 2,
	2, 258, 1536, 3, 2, 2, 2, 260, 1544, 3, 2, 2, 2, 262, 1552, 3, 2, 2, 2,
	264, 1563, 3, 2, 2, 2, 266, 1576, 3, 2, 2, 2, 268, 1590, 3, 2, 2, 2, 270,
	1596, 3, 2, 2, 2, 272, 1612, 3, 2, 2, 2, 274, 1614, 3, 2, 2, 2, 276, 1617,
	3, 2, 2, 2, 278, 1623, 3, 2, 2, 2, 280, 1630, 3, 2, 2, 2, 282, 1632, 3,
	2, 2, 2, 284, 1634, 3, 2, 2, 2, 286, 1642, 3, 2, 2, 2, 288, 1645, 3, 2,
	2, 2, 290, 1659, 3, 2, 2, 2, 292, 1661, 3, 2, 2, 2, 294, 1665, 3, 2, 2,
	2, 296, 1677, 3, 2, 2, 2, 298, 1679, 3, 2, 2, 2, 300, 1689, 3, 2, 2, 2,
	302, 1693, 3, 2, 2, 2, 304, 1697, 3, 2, 2, 2, 306, 1702, 3, 2, 2, 2, 308,
	1712, 3, 2, 2, 2, 310, 1720, 3, 2, 2, 2, 312, 1722, 3, 2, 2, 2, 314, 1727,
	3, 2, 2, 2, 316, 1741, 3, 2, 2, 2, 318, 1749, 3, 2, 2, 2, 320, 1752, 3,
	2, 2, 2, 322, 1757, 3, 2, 2, 2, 324, 1783, 3, 2, 2, 2, 326, 1788, 3, 2,
	2, 2, 328, 1791, 3, 2, 2, 2, 330, 1823, 3, 2, 2, 2, 332, 1828, 3, 2, 2,
	2, 334, 1831, 3, 2, 2, 2, 336, 1835, 3, 2, 2, 2, 338, 1838, 3, 2, 2, 2,
	340, 1852, 3, 2, 2, 2, 342, 1858, 3, 2, 2, 2, 344, 1860, 3, 2, 2, 2, 346,
	1875, 3, 2, 2, 2, 348, 1880, 3, 2, 2, 2, 350, 1894, 3, 2, 2, 2, 352, 1899,
	3, 2, 2, 2, 354, 1905, 3, 2, 2, 2, 356, 1908, 3, 2, 2, 2, 358, 1916, 3,
	2, 2, 2, 360, 1934, 3, 2, 2, 2, 362, 1939, 3, 2, 2, 2, 364, 1943, 3, 2,
	2, 2, 366, 1974, 3, 2, 2, 2, 368, 1977, 3, 2, 2, 2, 370, 1989, 3, 2, 2,
	2, 372, 2001, 3, 2, 2, 2, 374, 2003, 3, 2, 2, 2, 376, 2009, 3, 2, 2, 2,
	378, 2011, 3, 2, 2, 2, 380, 2017, 3, 2, 2, 2, 382, 2020, 3, 2, 2, 2, 384,
	2031, 3, 2, 2, 2, 386, 2042, 3, 2, 2, 2, 388, 2048, 3, 2, 2, 2, 390, 2051,
	3, 2, 2, 2, 392, 2062, 3, 2, 2, 2, 394, 2070, 3, 2, 2, 2, 396, 2080, 3,
	2, 2, 2, 398, 2084, 3, 2, 2, 2, 400, 2086, 3, 2, 2, 2, 402, 2091, 3, 2,
	2, 2, 404, 2100, 3, 2, 2, 2, 406, 2113, 3, 2, 2, 2, 408, 2116, 3, 2, 2,
	2, 410, 2127, 3, 2, 2, 2, 412, 2148, 3, 2, 2, 2, 414, 2150, 3, 2, 2, 2,
	416, 2156, 3, 2, 2, 2, 418, 2159, 3, 2, 2, 2, 420, 2169, 3, 2, 2, 2, 422,
	2182, 3, 2, 2, 2, 424, 2194, 3, 2, 2, 2, 426, 2196, 3, 2, 2, 2, 428, 2214,
	3, 2, 2, 2, 430, 2226, 3, 2, 2, 2, 432, 2236, 3, 2, 2, 2, 434, 2242, 3,
	2, 2, 2, 436, 2260, 3, 2, 2, 2, 438, 2288, 3, 2, 2, 2, 440, 2313, 3, 2,
	2, 2, 442, 2318, 3, 2, 2, 2, 444, 2328, 3, 2, 2, 2, 446, 2330, 3, 2, 2,
	2, 448, 2337, 3, 2, 2, 2, 450, 2343, 3, 2, 2, 2, 452, 2349, 3, 2, 2, 2,
	454, 2361, 3, 2, 2, 2, 456, 2375, 3, 2, 2, 2, 458, 2391, 3, 2, 2, 2, 460,
	2396, 3, 2, 2, 2, 462, 2399, 3, 2, 2, 2, 464, 2403, 3, 2, 2, 2, 466, 2405,
	3, 2, 2, 2, 468, 2414, 3, 2, 2, 2, 470, 2430, 3, 2, 2, 2, 472, 2433, 3,
	2, 2, 2, 474, 2439, 3, 2, 2, 2, 476, 2453, 3, 2, 2, 2, 478, 2457, 3, 2,
	2, 2, 480, 2459, 3, 2, 2, 2, 482, 2468, 3, 2, 2, 2, 484, 2473, 3, 2, 2,
	2, 486, 2479, 3, 2, 2, 2, 488, 2489, 3, 2, 2, 2, 490, 2492, 3, 2, 2, 2,
	492, 2495, 3, 2, 2, 2, 494, 2507, 3, 2, 2, 2, 496, 2509, 3, 2, 2, 2, 498,
	2523, 3, 2, 2, 2, 500, 2537, 3, 2, 2, 2, 502, 2549, 3, 2, 2, 2, 504, 2557,
	3, 2, 2, 2, 506, 2570, 3, 2, 2, 2, 508, 2593, 3, 2, 2, 2, 510, 2595, 3,
	2, 2, 2, 512, 513, 9, 2, 2, 2, 513, 3, 3, 2, 2, 2, 514, 515, 7, 4, 2, 2,
	515, 516, 5, 474, 238, 2, 516, 5, 3, 2, 2, 2, 517, 519, 5, 234, 118, 2,
	518, 520, 5, 490, 246, 2, 519, 518, 3, 2, 2, 2, 519, 520, 3, 2, 2, 2, 520,
	523, 3, 2, 2, 2, 521, 522, 7, 137, 2, 2, 522, 524, 5, 194, 98, 2, 523,
	521, 3, 2, 2, 2, 523, 524, 3, 2, 2, 2, 524, 525, 3, 2, 2, 2, 525, 526,
	7, 5, 2, 2, 526, 7, 3, 2, 2, 2, 527, 530, 5, 194, 98, 2, 528, 530, 7, 62,
	2, 2, 529, 527, 3, 2, 2, 2, 529, 528, 3, 2, 2, 2, 530, 9, 3, 2, 2, 2, 531,
	532, 5, 44, 23, 2, 532, 11, 3, 2, 2, 2, 533, 534, 5, 294, 148, 2, 534,
	535, 7, 143, 2, 2, 535, 536, 5, 8, 5, 2, 536, 537, 7, 144, 2, 2, 537, 540,
	3, 2, 2, 2, 538, 540, 5, 8, 5, 2, 539, 533, 3, 2, 2, 2, 539, 538, 3, 2,
	2, 2, 540, 13, 3, 2, 2, 2, 541, 542, 9, 3, 2, 2, 542, 15, 3, 2, 2, 2, 543,
	544, 7, 143, 2, 2, 544, 549, 5, 152, 77, 2, 545, 546, 7, 141, 2, 2, 546,
	548, 5, 152, 77, 2, 547, 545, 3, 2, 2, 2, 548, 551, 3, 2, 2, 2, 549, 547,
	3, 2, 2, 2, 549, 550, 3, 2, 2, 2, 550, 552, 3, 2, 2, 2, 551, 549, 3, 2,
	2, 2, 552, 553, 7, 144, 2, 2, 553, 17, 3, 2, 2, 2, 554, 555, 7, 7, 2, 2,
	555, 558, 5, 20, 11, 2, 556, 557, 7, 147, 2, 2, 557, 559, 5, 22, 12, 2,
	558, 556, 3, 2, 2, 2, 558, 559, 3, 2, 2, 2, 559, 560, 3, 2, 2, 2, 560,
	561, 7, 43, 2, 2, 561, 563, 5, 294, 148, 2, 562, 564, 5, 426, 214, 2, 563,
	562, 3, 2, 2, 2, 563, 564, 3, 2, 2, 2, 564, 565, 3, 2, 2, 2, 565, 566,
	7, 140, 2, 2, 566, 19, 3, 2, 2, 2, 567, 571, 5, 232, 117, 2, 568, 571,
	7, 128, 2, 2, 569, 571, 7, 129, 2, 2, 570, 567, 3, 2, 2, 2, 570, 568, 3,
	2, 2, 2, 570, 569, 3, 2, 2, 2, 571, 21, 3, 2, 2, 2, 572, 575, 5, 452, 227,
	2, 573, 575, 5, 474, 238, 2, 574, 572, 3, 2, 2, 2, 574, 573, 3, 2, 2, 2,
	575, 23, 3, 2, 2, 2, 576, 579, 7, 54, 2, 2, 577, 580, 5, 368, 185, 2, 578,
	580, 5, 474, 238, 2, 579, 577, 3, 2, 2, 2, 579, 578, 3, 2, 2, 2, 580, 25,
	3, 2, 2, 2, 581, 582, 7, 10, 2, 2, 582, 583, 5, 232, 117, 2, 583, 584,
	7, 60, 2, 2, 584, 585, 5, 232, 117, 2, 585, 586, 7, 43, 2, 2, 586, 587,
	5, 28, 15, 2, 587, 588, 7, 14, 2, 2, 588, 589, 5, 32, 17, 2, 589, 591,
	7, 26, 2, 2, 590, 592, 7, 10, 2, 2, 591, 590, 3, 2, 2, 2, 591, 592, 3,
	2, 2, 2, 592, 594, 3, 2, 2, 2, 593, 595, 5, 232, 117, 2, 594, 593, 3, 2,
	2, 2, 594, 595, 3, 2, 2, 2, 595, 596, 3, 2, 2, 2, 596, 597, 7, 140, 2,
	2, 597, 27, 3, 2, 2, 2, 598, 600, 5, 58, 30, 2, 599, 598, 3, 2, 2, 2, 600,
	603, 3, 2, 2, 2, 601, 599, 3, 2, 2, 2, 601, 602, 3, 2, 2, 2, 602, 29, 3,
	2, 2, 2, 603, 601, 3, 2, 2, 2, 604, 626, 5, 66, 34, 2, 605, 626, 5, 364,
	183, 2, 606, 608, 5, 274, 138, 2, 607, 606, 3, 2, 2, 2, 607, 608, 3, 2,
	2, 2, 608, 609, 3, 2, 2, 2, 609, 626, 5, 104, 53, 2, 610, 612, 5, 274,
	138, 2, 611, 610, 3, 2, 2, 2, 611, 612, 3, 2, 2, 2, 612, 613, 3, 2, 2,
	2, 613, 626, 5, 100, 51, 2, 614, 616, 5, 274, 138, 2, 615, 614, 3, 2, 2,
	2, 615, 616, 3, 2, 2, 2, 616, 618, 3, 2, 2, 2, 617, 619, 7, 68, 2, 2, 618,
	617, 3, 2, 2, 2, 618, 619, 3, 2, 2, 2, 619, 620, 3, 2, 2, 2, 620, 626,
	5, 106, 54, 2, 621, 626, 5, 92, 47, 2, 622, 626, 5, 212, 107, 2, 623, 626,
	5, 102, 52, 2, 624, 626, 5, 440, 221, 2, 625, 604, 3, 2, 2, 2, 625, 605,
	3, 2, 2, 2, 625, 607, 3, 2, 2, 2, 625, 611, 3, 2, 2, 2, 625, 615, 3, 2,
	2, 2, 625, 621, 3, 2, 2, 2, 625, 622, 3, 2, 2, 2, 625, 623, 3, 2, 2, 2,
	625, 624, 3, 2, 2, 2, 626, 31, 3, 2, 2, 2, 627, 629, 5, 30, 16, 2, 628,
	627, 3, 2, 2, 2, 629, 632, 3, 2, 2, 2, 630, 628, 3, 2, 2, 2, 630, 631,
	3, 2, 2, 2, 631, 33, 3, 2, 2, 2, 632, 630, 3, 2, 2, 2, 633, 636, 5, 498,
	250, 2, 634, 636, 5, 130, 66, 2, 635, 633, 3, 2, 2, 2, 635, 634, 3, 2,
	2, 2, 636, 35, 3, 2, 2, 2, 637, 640, 5, 496, 249, 2, 638, 640, 5, 128,
	65, 2, 639, 637, 3, 2, 2, 2, 639, 638, 3, 2, 2, 2, 640, 37, 3, 2, 2, 2,
	641, 642, 7, 12, 2, 2, 642, 645, 5, 108, 55, 2, 643, 644, 7, 81, 2, 2,
	644, 646, 5, 194, 98, 2, 645, 643, 3, 2, 2, 2, 645, 646, 3, 2, 2, 2, 646,
	649, 3, 2, 2, 2, 647, 648, 7, 86, 2, 2, 648, 650, 5, 194, 98, 2, 649, 647,
	3, 2, 2, 2, 649, 650, 3, 2, 2, 2, 650, 39, 3, 2, 2, 2, 651, 653, 5, 274,
	138, 2, 652, 651, 3, 2, 2, 2, 652, 653, 3, 2, 2, 2, 653, 654, 3, 2, 2,
	2, 654, 655, 5, 38, 20, 2, 655, 656, 7, 140, 2, 2, 656, 41, 3, 2, 2, 2,
	657, 658, 5, 208, 105, 2, 658, 659, 7, 135, 2, 2, 659, 661, 3, 2, 2, 2,
	660, 657, 3, 2, 2, 2, 660, 661, 3, 2, 2, 2, 661, 662, 3, 2, 2, 2, 662,
	663, 5, 12, 7, 2, 663, 43, 3, 2, 2, 2, 664, 669, 5, 42, 22, 2, 665, 666,
	7, 141, 2, 2, 666, 668, 5, 42, 22, 2, 667, 665, 3, 2, 2, 2, 668, 671, 3,
	2, 2, 2, 669, 667, 3, 2, 2, 2, 669, 670, 3, 2, 2, 2, 670, 45, 3, 2, 2,
	2, 671, 669, 3, 2, 2, 2, 672, 673, 7, 13, 2, 2, 673, 674, 5, 274, 138,
	2, 674, 675, 5, 294, 148, 2, 675, 676, 7, 140, 2, 2, 676, 47, 3, 2, 2,
	2, 677, 685, 5, 232, 117, 2, 678, 685, 7, 74, 2, 2, 679, 685, 7, 75, 2,
	2, 680, 685, 7, 5, 2, 2, 681, 685, 7, 98, 2, 2, 682, 685, 7, 79, 2, 2,
	683, 685, 7, 100, 2, 2, 684, 677, 3, 2, 2, 2, 684, 678, 3, 2, 2, 2, 684,
	679, 3, 2, 2, 2, 684, 680, 3, 2, 2, 2, 684, 681, 3, 2, 2, 2, 684, 682,
	3, 2, 2, 2, 684, 683, 3, 2, 2, 2, 685, 49, 3, 2, 2, 2, 686, 687, 7, 13,
	2, 2, 687, 688, 5, 48, 25, 2, 688, 689, 7, 60, 2, 2, 689, 690, 5, 180,
	91, 2, 690, 691, 7, 43, 2, 2, 691, 692, 5, 194, 98, 2, 692, 693, 7, 140,
	2, 2, 693, 51, 3, 2, 2, 2, 694, 695, 5, 232, 117, 2, 695, 696, 7, 140,
	2, 2, 696, 53, 3, 2, 2, 2, 697, 698, 7, 106, 2, 2, 698, 700, 5, 160, 81,
	2, 699, 697, 3, 2, 2, 2, 699, 700, 3, 2, 2, 2, 700, 702, 3, 2, 2, 2, 701,
	703, 5, 220, 111, 2, 702, 701, 3, 2, 2, 2, 702, 703, 3, 2, 2, 2, 703, 705,
	3, 2, 2, 2, 704, 706, 5, 344, 173, 2, 705, 704, 3, 2, 2, 2, 705, 706, 3,
	2, 2, 2, 706, 55, 3, 2, 2, 2, 707, 708, 7, 32, 2, 2, 708, 712, 5, 64, 33,
	2, 709, 711, 5, 500, 251, 2, 710, 709, 3, 2, 2, 2, 711, 714, 3, 2, 2, 2,
	712, 710, 3, 2, 2, 2, 712, 713, 3, 2, 2, 2, 713, 718, 3, 2, 2, 2, 714,
	712, 3, 2, 2, 2, 715, 717, 5, 122, 62, 2, 716, 715, 3, 2, 2, 2, 717, 720,
	3, 2, 2, 2, 718, 716, 3, 2, 2, 2, 718, 719, 3, 2, 2, 2, 719, 721, 3, 2,
	2, 2, 720, 718, 3, 2, 2, 2, 721, 722, 7, 26, 2, 2, 722, 723, 7, 32, 2,
	2, 723, 724, 7, 140, 2, 2, 724, 57, 3, 2, 2, 2, 725, 748, 5, 456, 229,
	2, 726, 748, 5, 454, 228, 2, 727, 748, 5, 492, 247, 2, 728, 748, 5, 472,
	237, 2, 729, 748, 5, 126, 64, 2, 730, 748, 5, 420, 211, 2, 731, 748, 5,
	504, 253, 2, 732, 748, 5, 198, 100, 2, 733, 748, 5, 18, 10, 2, 734, 748,
	5, 90, 46, 2, 735, 748, 5, 46, 24, 2, 736, 748, 5, 50, 26, 2, 737, 748,
	5, 124, 63, 2, 738, 748, 5, 148, 75, 2, 739, 748, 5, 448, 225, 2, 740,
	748, 5, 500, 251, 2, 741, 748, 5, 228, 115, 2, 742, 748, 5, 226, 114, 2,
	743, 748, 5, 308, 155, 2, 744, 748, 5, 450, 226, 2, 745, 748, 5, 370, 186,
	2, 746, 748, 5, 484, 243, 2, 747, 725, 3, 2, 2, 2, 747, 726, 3, 2, 2, 2,
	747, 727, 3, 2, 2, 2, 747, 728, 3, 2, 2, 2, 747, 729, 3, 2, 2, 2, 747,
	730, 3, 2, 2, 2, 747, 731, 3, 2, 2, 2, 747, 732, 3, 2, 2, 2, 747, 733,
	3, 2, 2, 2, 747, 734, 3, 2, 2, 2, 747, 735, 3, 2, 2, 2, 747, 736, 3, 2,
	2, 2, 747, 737, 3, 2, 2, 2, 747, 738, 3, 2, 2, 2, 747, 739, 3, 2, 2, 2,
	747, 740, 3, 2, 2, 2, 747, 741, 3, 2, 2, 2, 747, 742, 3, 2, 2, 2, 747,
	743, 3, 2, 2, 2, 747, 744, 3, 2, 2, 2, 747, 745, 3, 2, 2, 2, 747, 746,
	3, 2, 2, 2, 748, 59, 3, 2, 2, 2, 749, 751, 5, 58, 30, 2, 750, 749, 3, 2,
	2, 2, 751, 754, 3, 2, 2, 2, 752, 750, 3, 2, 2, 2, 752, 753, 3, 2, 2, 2,
	753, 61, 3, 2, 2, 2, 754, 752, 3, 2, 2, 2, 755, 759, 5, 216, 109, 2, 756,
	757, 5, 220, 111, 2, 757, 758, 7, 140, 2, 2, 758, 760, 3, 2, 2, 2, 759,
	756, 3, 2, 2, 2, 759, 760, 3, 2, 2, 2, 760, 762, 3, 2, 2, 2, 761, 755,
	3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 769, 3, 2, 2, 2, 763, 767, 5, 340,
	171, 2, 764, 765, 5, 344, 173, 2, 765, 766, 7, 140, 2, 2, 766, 768, 3,
	2, 2, 2, 767, 764, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 770, 3, 2, 2,
	2, 769, 763, 3, 2, 2, 2, 769, 770, 3, 2, 2, 2, 770, 63, 3, 2, 2, 2, 771,
	776, 5, 232, 117, 2, 772, 773, 7, 143, 2, 2, 773, 774, 5, 240, 121, 2,
	774, 775, 7, 144, 2, 2, 775, 777, 3, 2, 2, 2, 776, 772, 3, 2, 2, 2, 776,
	777, 3, 2, 2, 2, 777, 780, 3, 2, 2, 2, 778, 780, 5, 294, 148, 2, 779, 771,
	3, 2, 2, 2, 779, 778, 3, 2, 2, 2, 780, 65, 3, 2, 2, 2, 781, 782, 5, 274,
	138, 2, 782, 787, 7, 15, 2, 2, 783, 784, 7, 143, 2, 2, 784, 785, 5, 194,
	98, 2, 785, 786, 7, 144, 2, 2, 786, 788, 3, 2, 2, 2, 787, 783, 3, 2, 2,
	2, 787, 788, 3, 2, 2, 2, 788, 790, 3, 2, 2, 2, 789, 791, 7, 43, 2, 2, 790,
	789, 3, 2, 2, 2, 790, 791, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 793,
	5, 62, 32, 2, 793, 794, 5, 60, 31, 2, 794, 795, 7, 14, 2, 2, 795, 796,
	5, 68, 35, 2, 796, 797, 7, 26, 2, 2, 797, 799, 7, 15, 2, 2, 798, 800, 5,
	232, 117, 2, 799, 798, 3, 2, 2, 2, 799, 800, 3, 2, 2, 2, 800, 801, 3, 2,
	2, 2, 801, 802, 7, 140, 2, 2, 802, 67, 3, 2, 2, 2, 803, 805, 5, 30, 16,
	2, 804, 803, 3, 2, 2, 2, 805, 808, 3, 2, 2, 2, 806, 804, 3, 2, 2, 2, 806,
	807, 3, 2, 2, 2, 807, 69, 3, 2, 2, 2, 808, 806, 3, 2, 2, 2, 809, 811, 7,
	73, 2, 2, 810, 812, 5, 6, 4, 2, 811, 810, 3, 2, 2, 2, 811, 812, 3, 2, 2,
	2, 812, 814, 3, 2, 2, 2, 813, 815, 5, 486, 244, 2, 814, 813, 3, 2, 2, 2,
	814, 815, 3, 2, 2, 2, 815, 816, 3, 2, 2, 2, 816, 817, 5, 482, 242, 2, 817,
	818, 7, 140, 2, 2, 818, 71, 3, 2, 2, 2, 819, 821, 5, 76, 39, 2, 820, 819,
	3, 2, 2, 2, 820, 821, 3, 2, 2, 2, 821, 822, 3, 2, 2, 2, 822, 823, 5, 294,
	148, 2, 823, 824, 7, 135, 2, 2, 824, 825, 5, 194, 98, 2, 825, 73, 3, 2,
	2, 2, 826, 831, 5, 72, 37, 2, 827, 828, 7, 141, 2, 2, 828, 830, 5, 72,
	37, 2, 829, 827, 3, 2, 2, 2, 830, 833, 3, 2, 2, 2, 831, 829, 3, 2, 2, 2,
	831, 832, 3, 2, 2, 2, 832, 75, 3, 2, 2, 2, 833, 831, 3, 2, 2, 2, 834, 835,
	7, 32, 2, 2, 835, 836, 5, 294, 148, 2, 836, 837, 7, 106, 2, 2, 837, 77,
	3, 2, 2, 2, 838, 840, 5, 274, 138, 2, 839, 838, 3, 2, 2, 2, 839, 840, 3,
	2, 2, 2, 840, 841, 3, 2, 2, 2, 841, 843, 7, 17, 2, 2, 842, 844, 5, 74,
	38, 2, 843, 842, 3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 847, 3, 2, 2, 2,
	845, 846, 7, 110, 2, 2, 846, 848, 5, 108, 55, 2, 847, 845, 3, 2, 2, 2,
	847, 848, 3, 2, 2, 2, 848, 849, 3, 2, 2, 2, 849, 850, 7, 140, 2, 2, 850,
	79, 3, 2, 2, 2, 851, 853, 5, 274, 138, 2, 852, 851, 3, 2, 2, 2, 852, 853,
	3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854, 855, 7, 20, 2, 2, 855, 856, 5, 194,
	98, 2, 856, 858, 7, 43, 2, 2, 857, 859, 5, 82, 42, 2, 858, 857, 3, 2, 2,
	2, 859, 860, 3, 2, 2, 2, 860, 858, 3, 2, 2, 2, 860, 861, 3, 2, 2, 2, 861,
	862, 3, 2, 2, 2, 862, 863, 7, 26, 2, 2, 863, 865, 7, 20, 2, 2, 864, 866,
	5, 232, 117, 2, 865, 864, 3, 2, 2, 2, 865, 866, 3, 2, 2, 2, 866, 867, 3,
	2, 2, 2, 867, 868, 7, 140, 2, 2, 868, 81, 3, 2, 2, 2, 869, 870, 7, 110,
	2, 2, 870, 871, 5, 86, 44, 2, 871, 872, 7, 135, 2, 2, 872, 873, 5, 410,
	206, 2, 873, 83, 3, 2, 2, 2, 874, 879, 5, 232, 117, 2, 875, 879, 5, 150,
	76, 2, 876, 879, 5, 428, 215, 2, 877, 879, 7, 64, 2, 2, 878, 874, 3, 2,
	2, 2, 878, 875, 3, 2, 2, 2, 878, 876, 3, 2, 2, 2, 878, 877, 3, 2, 2, 2,
	879, 85, 3, 2, 2, 2, 880, 885, 5, 84, 43, 2, 881, 882, 7, 155, 2, 2, 882,
	884, 5, 84, 43, 2, 883, 881, 3, 2, 2, 2, 884, 887, 3, 2, 2, 2, 885, 883,
	3, 2, 2, 2, 885, 886, 3, 2, 2, 2, 886, 87, 3, 2, 2, 2, 887, 885, 3, 2,
	2, 2, 888, 889, 7, 32, 2, 2, 889, 893, 5, 94, 48, 2, 890, 891, 5, 54, 28,
	2, 891, 892, 7, 140, 2, 2, 892, 894, 3, 2, 2, 2, 893, 890, 3, 2, 2, 2,
	893, 894, 3, 2, 2, 2, 894, 896, 3, 2, 2, 2, 895, 897, 5, 56, 29, 2, 896,
	895, 3, 2, 2, 2, 896, 897, 3, 2, 2, 2, 897, 898, 3, 2, 2, 2, 898, 899,
	7, 26, 2, 2, 899, 900, 7, 32, 2, 2, 900, 901, 7, 140, 2, 2, 901, 89, 3,
	2, 2, 2, 902, 903, 7, 21, 2, 2, 903, 905, 5, 232, 117, 2, 904, 906, 7,
	43, 2, 2, 905, 904, 3, 2, 2, 2, 905, 906, 3, 2, 2, 2, 906, 908, 3, 2, 2,
	2, 907, 909, 5, 216, 109, 2, 908, 907, 3, 2, 2, 2, 908, 909, 3, 2, 2, 2,
	909, 911, 3, 2, 2, 2, 910, 912, 5, 340, 171, 2, 911, 910, 3, 2, 2, 2, 911,
	912, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2, 913, 914, 7, 26, 2, 2, 914, 916,
	7, 21, 2, 2, 915, 917, 5, 232, 117, 2, 916, 915, 3, 2, 2, 2, 916, 917,
	3, 2, 2, 2, 917, 918, 3, 2, 2, 2, 918, 919, 7, 140, 2, 2, 919, 91, 3, 2,
	2, 2, 920, 921, 5, 274, 138, 2, 921, 923, 5, 244, 123, 2, 922, 924, 5,
	220, 111, 2, 923, 922, 3, 2, 2, 2, 923, 924, 3, 2, 2, 2, 924, 926, 3, 2,
	2, 2, 925, 927, 5, 344, 173, 2, 926, 925, 3, 2, 2, 2, 926, 927, 3, 2, 2,
	2, 927, 928, 3, 2, 2, 2, 928, 929, 7, 140, 2, 2, 929, 93, 3, 2, 2, 2, 930,
	931, 5, 246, 124, 2, 931, 932, 7, 147, 2, 2, 932, 933, 5, 294, 148, 2,
	933, 95, 3, 2, 2, 2, 934, 937, 5, 34, 18, 2, 935, 937, 5, 382, 192, 2,
	936, 934, 3, 2, 2, 2, 936, 935, 3, 2, 2, 2, 937, 97, 3, 2, 2, 2, 938, 941,
	5, 36, 19, 2, 939, 941, 5, 384, 193, 2, 940, 938, 3, 2, 2, 2, 940, 939,
	3, 2, 2, 2, 941, 99, 3, 2, 2, 2, 942, 944, 5, 274, 138, 2, 943, 942, 3,
	2, 2, 2, 943, 944, 3, 2, 2, 2, 944, 946, 3, 2, 2, 2, 945, 947, 7, 68, 2,
	2, 946, 945, 3, 2, 2, 2, 946, 947, 3, 2, 2, 2, 947, 948, 3, 2, 2, 2, 948,
	949, 5, 38, 20, 2, 949, 950, 7, 140, 2, 2, 950, 101, 3, 2, 2, 2, 951, 953,
	5, 274, 138, 2, 952, 951, 3, 2, 2, 2, 952, 953, 3, 2, 2, 2, 953, 954, 3,
	2, 2, 2, 954, 956, 7, 17, 2, 2, 955, 957, 5, 74, 38, 2, 956, 955, 3, 2,
	2, 2, 956, 957, 3, 2, 2, 2, 957, 959, 3, 2, 2, 2, 958, 960, 5, 406, 204,
	2, 959, 958, 3, 2, 2, 2, 959, 960, 3, 2, 2, 2, 960, 963, 3, 2, 2, 2, 961,
	962, 7, 110, 2, 2, 962, 964, 5, 108, 55, 2, 963, 961, 3, 2, 2, 2, 963,
	964, 3, 2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 966, 7, 140, 2, 2, 966, 103,
	3, 2, 2, 2, 967, 969, 5, 274, 138, 2, 968, 967, 3, 2, 2, 2, 968, 969, 3,
	2, 2, 2, 969, 971, 3, 2, 2, 2, 970, 972, 7, 68, 2, 2, 971, 970, 3, 2, 2,
	2, 971, 972, 3, 2, 2, 2, 972, 973, 3, 2, 2, 2, 973, 974, 5, 356, 179, 2,
	974, 975, 7, 140, 2, 2, 975, 105, 3, 2, 2, 2, 976, 978, 5, 274, 138, 2,
	977, 976, 3, 2, 2, 2, 977, 978, 3, 2, 2, 2, 978, 980, 3, 2, 2, 2, 979,
	981, 7, 68, 2, 2, 980, 979, 3, 2, 2, 2, 980, 981, 3, 2, 2, 2, 981, 984,
	3, 2, 2, 2, 982, 985, 5, 112, 57, 2, 983, 985, 5, 402, 202, 2, 984, 982,
	3, 2, 2, 2, 984, 983, 3, 2, 2, 2, 985, 107, 3, 2, 2, 2, 986, 987, 5, 194,
	98, 2, 987, 109, 3, 2, 2, 2, 988, 989, 7, 105, 2, 2, 989, 990, 5, 108,
	55, 2, 990, 111, 3, 2, 2, 2, 991, 992, 5, 478, 240, 2, 992, 993, 7, 133,
	2, 2, 993, 994, 5, 320, 161, 2, 994, 995, 5, 114, 58, 2, 995, 996, 7, 140,
	2, 2, 996, 113, 3, 2, 2, 2, 997, 1004, 5, 508, 255, 2, 998, 999, 7, 110,
	2, 2, 999, 1002, 5, 108, 55, 2, 1000, 1001, 7, 28, 2, 2, 1001, 1003, 5,
	114, 58, 2, 1002, 1000, 3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 1005,
	3, 2, 2, 2, 1004, 998, 3, 2, 2, 2, 1004, 1005, 3, 2, 2, 2, 1005, 115, 3,
	2, 2, 2, 1006, 1007, 7, 22, 2, 2, 1007, 1008, 5, 232, 117, 2, 1008, 1009,
	7, 60, 2, 2, 1009, 1010, 5, 294, 148, 2, 1010, 1011, 7, 43, 2, 2, 1011,
	1012, 5, 120, 61, 2, 1012, 1013, 5, 56, 29, 2, 1013, 1015, 7, 26, 2, 2,
	1014, 1016, 7, 22, 2, 2, 1015, 1014, 3, 2, 2, 2, 1015, 1016, 3, 2, 2, 2,
	1016, 1018, 3, 2, 2, 2, 1017, 1019, 5, 232, 117, 2, 1018, 1017, 3, 2, 2,
	2, 1018, 1019, 3, 2, 2, 2, 1019, 1020, 3, 2, 2, 2, 1020, 1021, 7, 140,
	2, 2, 1021, 117, 3, 2, 2, 2, 1022, 1026, 5, 500, 251, 2, 1023, 1026, 5,
	50, 26, 2, 1024, 1026, 5, 226, 114, 2, 1025, 1022, 3, 2, 2, 2, 1025, 1023,
	3, 2, 2, 2, 1025, 1024, 3, 2, 2, 2, 1026, 119, 3, 2, 2, 2, 1027, 1029,
	5, 118, 60, 2, 1028, 1027, 3, 2, 2, 2, 1029, 1032, 3, 2, 2, 2, 1030, 1028,
	3, 2, 2, 2, 1030, 1031, 3, 2, 2, 2, 1031, 121, 3, 2, 2, 2, 1032, 1030,
	3, 2, 2, 2, 1033, 1036, 5, 56, 29, 2, 1034, 1036, 5, 88, 45, 2, 1035, 1033,
	3, 2, 2, 2, 1035, 1034, 3, 2, 2, 2, 1036, 123, 3, 2, 2, 2, 1037, 1038,
	7, 32, 2, 2, 1038, 1039, 5, 94, 48, 2, 1039, 1040, 5, 54, 28, 2, 1040,
	1041, 7, 140, 2, 2, 1041, 125, 3, 2, 2, 2, 1042, 1043, 7, 23, 2, 2, 1043,
	1044, 5, 234, 118, 2, 1044, 1045, 7, 147, 2, 2, 1045, 1048, 5, 474, 238,
	2, 1046, 1047, 7, 137, 2, 2, 1047, 1049, 5, 194, 98, 2, 1048, 1046, 3,
	2, 2, 2, 1048, 1049, 3, 2, 2, 2, 1049, 1050, 3, 2, 2, 2, 1050, 1051, 7,
	140, 2, 2, 1051, 127, 3, 2, 2, 2, 1052, 1053, 7, 11, 2, 2, 1053, 1054,
	5, 238, 120, 2, 1054, 1055, 7, 60, 2, 2, 1055, 1056, 5, 474, 238, 2, 1056,
	129, 3, 2, 2, 2, 1057, 1058, 7, 11, 2, 2, 1058, 1059, 5, 238, 120, 2, 1059,
	1060, 7, 60, 2, 2, 1060, 1061, 5, 452, 227, 2, 1061, 131, 3, 2, 2, 2, 1062,
	1065, 5, 380, 191, 2, 1063, 1065, 5, 238, 120, 2, 1064, 1062, 3, 2, 2,
	2, 1064, 1063, 3, 2, 2, 2, 1065, 133, 3, 2, 2, 2, 1066, 1068, 5, 136, 69,
	2, 1067, 1066, 3, 2, 2, 2, 1068, 1071, 3, 2, 2, 2, 1069, 1067, 3, 2, 2,
	2, 1069, 1070, 3, 2, 2, 2, 1070, 135, 3, 2, 2, 2, 1071, 1069, 3, 2, 2,
	2, 1072, 1075, 5, 276, 139, 2, 1073, 1075, 5, 500, 251, 2, 1074, 1072,
	3, 2, 2, 2, 1074, 1073, 3, 2, 2, 2, 1075, 137, 3, 2, 2, 2, 1076, 1083,
	7, 101, 2, 2, 1077, 1078, 7, 76, 2, 2, 1078, 1080, 5, 194, 98, 2, 1079,
	1077, 3, 2, 2, 2, 1079, 1080, 3, 2, 2, 2, 1080, 1081, 3, 2, 2, 2, 1081,
	1083, 7, 41, 2, 2, 1082, 1076, 3, 2, 2, 2, 1082, 1079, 3, 2, 2, 2, 1083,
	139, 3, 2, 2, 2, 1084, 1086, 5, 142, 72, 2, 1085, 1084, 3, 2, 2, 2, 1086,
	1089, 3, 2, 2, 2, 1087, 1085, 3, 2, 2, 2, 1087, 1088, 3, 2, 2, 2, 1088,
	1090, 3, 2, 2, 2, 1089, 1087, 3, 2, 2, 2, 1090, 1091, 7, 2, 2, 3, 1091,
	141, 3, 2, 2, 2, 1092, 1093, 5, 134, 68, 2, 1093, 1094, 5, 278, 140, 2,
	1094, 143, 3, 2, 2, 2, 1095, 1098, 5, 232, 117, 2, 1096, 1098, 7, 129,
	2, 2, 1097, 1095, 3, 2, 2, 2, 1097, 1096, 3, 2, 2, 2, 1098, 145, 3, 2,
	2, 2, 1099, 1100, 9, 4, 2, 2, 1100, 147, 3, 2, 2, 2, 1101, 1102, 7, 24,
	2, 2, 1102, 1103, 5, 230, 116, 2, 1103, 1104, 7, 6, 2, 2, 1104, 1105, 5,
	194, 98, 2, 1105, 1106, 7, 140, 2, 2, 1106, 149, 3, 2, 2, 2, 1107, 1110,
	5, 376, 189, 2, 1108, 1110, 5, 474, 238, 2, 1109, 1107, 3, 2, 2, 2, 1109,
	1108, 3, 2, 2, 2, 1110, 151, 3, 2, 2, 2, 1111, 1112, 5, 86, 44, 2, 1112,
	1113, 7, 135, 2, 2, 1113, 1115, 3, 2, 2, 2, 1114, 1111, 3, 2, 2, 2, 1114,
	1115, 3, 2, 2, 2, 1115, 1116, 3, 2, 2, 2, 1116, 1117, 5, 194, 98, 2, 1117,
	153, 3, 2, 2, 2, 1118, 1119, 5, 234, 118, 2, 1119, 1120, 7, 147, 2, 2,
	1120, 1121, 5, 158, 80, 2, 1121, 1122, 7, 140, 2, 2, 1122, 155, 3, 2, 2,
	2, 1123, 1124, 5, 452, 227, 2, 1124, 157, 3, 2, 2, 2, 1125, 1126, 5, 474,
	238, 2, 1126, 159, 3, 2, 2, 2, 1127, 1128, 7, 27, 2, 2, 1128, 1133, 5,
	294, 148, 2, 1129, 1130, 7, 143, 2, 2, 1130, 1131, 5, 232, 117, 2, 1131,
	1132, 7, 144, 2, 2, 1132, 1134, 3, 2, 2, 2, 1133, 1129, 3, 2, 2, 2, 1133,
	1134, 3, 2, 2, 2, 1134, 1139, 3, 2, 2, 2, 1135, 1136, 7, 22, 2, 2, 1136,
	1139, 5, 294, 148, 2, 1137, 1139, 7, 62, 2, 2, 1138, 1127, 3, 2, 2, 2,
	1138, 1135, 3, 2, 2, 2, 1138, 1137, 3, 2, 2, 2, 1139, 161, 3, 2, 2, 2,
	1140, 1141, 9, 5, 2, 2, 1141, 163, 3, 2, 2, 2, 1142, 1144, 5, 162, 82,
	2, 1143, 1145, 7, 138, 2, 2, 1144, 1143, 3, 2, 2, 2, 1144, 1145, 3, 2,
	2, 2, 1145, 165, 3, 2, 2, 2, 1146, 1151, 5, 164, 83, 2, 1147, 1148, 7,
	141, 2, 2, 1148, 1150, 5, 164, 83, 2, 1149, 1147, 3, 2, 2, 2, 1150, 1153,
	3, 2, 2, 2, 1151, 1149, 3, 2, 2, 2, 1151, 1152, 3, 2, 2, 2, 1152, 167,
	3, 2, 2, 2, 1153, 1151, 3, 2, 2, 2, 1154, 1155, 7, 27, 2, 2, 1155, 1156,
	5, 232, 117, 2, 1156, 1157, 7, 43, 2, 2, 1157, 1158, 5, 176, 89, 2, 1158,
	1161, 5, 172, 87, 2, 1159, 1160, 7, 14, 2, 2, 1160, 1162, 5, 184, 93, 2,
	1161, 1159, 3, 2, 2, 2, 1161, 1162, 3, 2, 2, 2, 1162, 1163, 3, 2, 2, 2,
	1163, 1165, 7, 26, 2, 2, 1164, 1166, 7, 27, 2, 2, 1165, 1164, 3, 2, 2,
	2, 1165, 1166, 3, 2, 2, 2, 1166, 1168, 3, 2, 2, 2, 1167, 1169, 5, 232,
	117, 2, 1168, 1167, 3, 2, 2, 2, 1168, 1169, 3, 2, 2, 2, 1169, 1170, 3,
	2, 2, 2, 1170, 1171, 7, 140, 2, 2, 1171, 169, 3, 2, 2, 2, 1172, 1193, 5,
	456, 229, 2, 1173, 1193, 5, 454, 228, 2, 1174, 1193, 5, 492, 247, 2, 1175,
	1193, 5, 472, 237, 2, 1176, 1193, 5, 126, 64, 2, 1177, 1193, 5, 420, 211,
	2, 1178, 1193, 5, 504, 253, 2, 1179, 1193, 5, 198, 100, 2, 1180, 1193,
	5, 18, 10, 2, 1181, 1193, 5, 46, 24, 2, 1182, 1193, 5, 50, 26, 2, 1183,
	1193, 5, 148, 75, 2, 1184, 1193, 5, 448, 225, 2, 1185, 1193, 5, 500, 251,
	2, 1186, 1193, 5, 228, 115, 2, 1187, 1193, 5, 226, 114, 2, 1188, 1193,
	5, 308, 155, 2, 1189, 1193, 5, 450, 226, 2, 1190, 1193, 5, 370, 186, 2,
	1191, 1193, 5, 484, 243, 2, 1192, 1172, 3, 2, 2, 2, 1192, 1173, 3, 2, 2,
	2, 1192, 1174, 3, 2, 2, 2, 1192, 1175, 3, 2, 2, 2, 1192, 1176, 3, 2, 2,
	2, 1192, 1177, 3, 2, 2, 2, 1192, 1178, 3, 2, 2, 2, 1192, 1179, 3, 2, 2,
	2, 1192, 1180, 3, 2, 2, 2, 1192, 1181, 3, 2, 2, 2, 1192, 1182, 3, 2, 2,
	2, 1192, 1183, 3, 2, 2, 2, 1192, 1184, 3, 2, 2, 2, 1192, 1185, 3, 2, 2,
	2, 1192, 1186, 3, 2, 2, 2, 1192, 1187, 3, 2, 2, 2, 1192, 1188, 3, 2, 2,
	2, 1192, 1189, 3, 2, 2, 2, 1192, 1190, 3, 2, 2, 2, 1192, 1191, 3, 2, 2,
	2, 1193, 171, 3, 2, 2, 2, 1194, 1196, 5, 170, 86, 2, 1195, 1194, 3, 2,
	2, 2, 1196, 1199, 3, 2, 2, 2, 1197, 1195, 3, 2, 2, 2, 1197, 1198, 3, 2,
	2, 2, 1198, 173, 3, 2, 2, 2, 1199, 1197, 3, 2, 2, 2, 1200, 1202, 5, 186,
	94, 2, 1201, 1203, 5, 426, 214, 2, 1202, 1201, 3, 2, 2, 2, 1202, 1203,
	3, 2, 2, 2, 1203, 175, 3, 2, 2, 2, 1204, 1206, 5, 216, 109, 2, 1205, 1204,
	3, 2, 2, 2, 1205, 1206, 3, 2, 2, 2, 1206, 1208, 3, 2, 2, 2, 1207, 1209,
	5, 340, 171, 2, 1208, 1207, 3, 2, 2, 2, 1208, 1209, 3, 2, 2, 2, 1209, 177,
	3, 2, 2, 2, 1210, 1215, 5, 174, 88, 2, 1211, 1212, 7, 141, 2, 2, 1212,
	1214, 5, 174, 88, 2, 1213, 1211, 3, 2, 2, 2, 1214, 1217, 3, 2, 2, 2, 1215,
	1213, 3, 2, 2, 2, 1215, 1216, 3, 2, 2, 2, 1216, 1221, 3, 2, 2, 2, 1217,
	1215, 3, 2, 2, 2, 1218, 1221, 7, 64, 2, 2, 1219, 1221, 7, 8, 2, 2, 1220,
	1210, 3, 2, 2, 2, 1220, 1218, 3, 2, 2, 2, 1220, 1219, 3, 2, 2, 2, 1221,
	179, 3, 2, 2, 2, 1222, 1223, 5, 178, 90, 2, 1223, 1224, 7, 147, 2, 2, 1224,
	1225, 5, 162, 82, 2, 1225, 181, 3, 2, 2, 2, 1226, 1230, 5, 100, 51, 2,
	1227, 1230, 5, 364, 183, 2, 1228, 1230, 5, 104, 53, 2, 1229, 1226, 3, 2,
	2, 2, 1229, 1227, 3, 2, 2, 2, 1229, 1228, 3, 2, 2, 2, 1230, 183, 3, 2,
	2, 2, 1231, 1233, 5, 182, 92, 2, 1232, 1231, 3, 2, 2, 2, 1233, 1236, 3,
	2, 2, 2, 1234, 1232, 3, 2, 2, 2, 1234, 1235, 3, 2, 2, 2, 1235, 185, 3,
	2, 2, 2, 1236, 1234, 3, 2, 2, 2, 1237, 1241, 5, 232, 117, 2, 1238, 1241,
	7, 128, 2, 2, 1239, 1241, 7, 129, 2, 2, 1240, 1237, 3, 2, 2, 2, 1240, 1238,
	3, 2, 2, 2, 1240, 1239, 3, 2, 2, 2, 1241, 187, 3, 2, 2, 2, 1242, 1245,
	5, 232, 117, 2, 1243, 1245, 7, 128, 2, 2, 1244, 1242, 3, 2, 2, 2, 1244,
	1243, 3, 2, 2, 2, 1245, 189, 3, 2, 2, 2, 1246, 1247, 7, 143, 2, 2, 1247,
	1252, 5, 188, 95, 2, 1248, 1249, 7, 141, 2, 2, 1249, 1251, 5, 188, 95,
	2, 1250, 1248, 3, 2, 2, 2, 1251, 1254, 3, 2, 2, 2, 1252, 1250, 3, 2, 2,
	2, 1252, 1253, 3, 2, 2, 2, 1253, 1255, 3, 2, 2, 2, 1254, 1252, 3, 2, 2,
	2, 1255, 1256, 7, 144, 2, 2, 1256, 191, 3, 2, 2, 2, 1257, 1259, 5, 274,
	138, 2, 1258, 1257, 3, 2, 2, 2, 1258, 1259, 3, 2, 2, 2, 1259, 1260, 3,
	2, 2, 2, 1260, 1262, 7, 30, 2, 2, 1261, 1263, 5, 232, 117, 2, 1262, 1261,
	3, 2, 2, 2, 1262, 1263, 3, 2, 2, 2, 1263, 1266, 3, 2, 2, 2, 1264, 1265,
	7, 110, 2, 2, 1265, 1267, 5, 108, 55, 2, 1266, 1264, 3, 2, 2, 2, 1266,
	1267, 3, 2, 2, 2, 1267, 1268, 3, 2, 2, 2, 1268, 1269, 7, 140, 2, 2, 1269,
	193, 3, 2, 2, 2, 1270, 1276, 5, 386, 194, 2, 1271, 1272, 5, 286, 144, 2,
	1272, 1273, 5, 386, 194, 2, 1273, 1275, 3, 2, 2, 2, 1274, 1271, 3, 2, 2,
	2, 1275, 1278, 3, 2, 2, 2, 1276, 1274, 3, 2, 2, 2, 1276, 1277, 3, 2, 2,
	2, 1277, 195, 3, 2, 2, 2, 1278, 1276, 3, 2, 2, 2, 1279, 1282, 5, 346, 174,
	2, 1280, 1281, 7, 131, 2, 2, 1281, 1283, 5, 346, 174, 2, 1282, 1280, 3,
	2, 2, 2, 1282, 1283, 3, 2, 2, 2, 1283, 1289, 3, 2, 2, 2, 1284, 1285, 7,
	3, 2, 2, 1285, 1289, 5, 346, 174, 2, 1286, 1287, 7, 58, 2, 2, 1287, 1289,
	5, 346, 174, 2, 1288, 1279, 3, 2, 2, 2, 1288, 1284, 3, 2, 2, 2, 1288, 1286,
	3, 2, 2, 2, 1289, 197, 3, 2, 2, 2, 1290, 1291, 7, 31, 2, 2, 1291, 1292,
	5, 234, 118, 2, 1292, 1293, 7, 147, 2, 2, 1293, 1295, 5, 474, 238, 2, 1294,
	1296, 5, 202, 102, 2, 1295, 1294, 3, 2, 2, 2, 1295, 1296, 3, 2, 2, 2, 1296,
	1297, 3, 2, 2, 2, 1297, 1298, 7, 140, 2, 2, 1298, 199, 3, 2, 2, 2, 1299,
	1300, 5, 194, 98, 2, 1300, 201, 3, 2, 2, 2, 1301, 1302, 7, 62, 2, 2, 1302,
	1304, 5, 194, 98, 2, 1303, 1301, 3, 2, 2, 2, 1303, 1304, 3, 2, 2, 2, 1304,
	1305, 3, 2, 2, 2, 1305, 1306, 7, 43, 2, 2, 1306, 1307, 5, 200, 101, 2,
	1307, 203, 3, 2, 2, 2, 1308, 1309, 7, 31, 2, 2, 1309, 1310, 7, 60, 2, 2,
	1310, 1311, 5, 474, 238, 2, 1311, 205, 3, 2, 2, 2, 1312, 1313, 5, 260,
	131, 2, 1313, 207, 3, 2, 2, 2, 1314, 1321, 5, 232, 117, 2, 1315, 1316,
	5, 232, 117, 2, 1316, 1317, 7, 143, 2, 2, 1317, 1318, 5, 378, 190, 2, 1318,
	1319, 7, 144, 2, 2, 1319, 1321, 3, 2, 2, 2, 1320, 1314, 3, 2, 2, 2, 1320,
	1315, 3, 2, 2, 2, 1321, 209, 3, 2, 2, 2, 1322, 1323, 7, 73, 2, 2, 1323,
	1324, 5, 234, 118, 2, 1324, 1325, 7, 147, 2, 2, 1325, 1328, 5, 474, 238,
	2, 1326, 1327, 7, 137, 2, 2, 1327, 1329, 5, 194, 98, 2, 1328, 1326, 3,
	2, 2, 2, 1328, 1329, 3, 2, 2, 2, 1329, 1330, 3, 2, 2, 2, 1330, 1331, 7,
	140, 2, 2, 1331, 211, 3, 2, 2, 2, 1332, 1333, 5, 274, 138, 2, 1333, 1334,
	5, 214, 108, 2, 1334, 1342, 7, 34, 2, 2, 1335, 1337, 5, 58, 30, 2, 1336,
	1335, 3, 2, 2, 2, 1337, 1340, 3, 2, 2, 2, 1338, 1336, 3, 2, 2, 2, 1338,
	1339, 3, 2, 2, 2, 1339, 1341, 3, 2, 2, 2, 1340, 1338, 3, 2, 2, 2, 1341,
	1343, 7, 14, 2, 2, 1342, 1338, 3, 2, 2, 2, 1342, 1343, 3, 2, 2, 2, 1343,
	1347, 3, 2, 2, 2, 1344, 1346, 5, 30, 16, 2, 1345, 1344, 3, 2, 2, 2, 1346,
	1349, 3, 2, 2, 2, 1347, 1345, 3, 2, 2, 2, 1347, 1348, 3, 2, 2, 2, 1348,
	1350, 3, 2, 2, 2, 1349, 1347, 3, 2, 2, 2, 1350, 1351, 7, 26, 2, 2, 1351,
	1353, 7, 34, 2, 2, 1352, 1354, 5, 232, 117, 2, 1353, 1352, 3, 2, 2, 2,
	1353, 1354, 3, 2, 2, 2, 1354, 1355, 3, 2, 2, 2, 1355, 1356, 7, 140, 2,
	2, 1356, 213, 3, 2, 2, 2, 1357, 1358, 7, 32, 2, 2, 1358, 1362, 5, 334,
	168, 2, 1359, 1360, 7, 38, 2, 2, 1360, 1362, 5, 108, 55, 2, 1361, 1357,
	3, 2, 2, 2, 1361, 1359, 3, 2, 2, 2, 1362, 215, 3, 2, 2, 2, 1363, 1364,
	7, 35, 2, 2, 1364, 1365, 7, 143, 2, 2, 1365, 1366, 5, 218, 110, 2, 1366,
	1367, 7, 144, 2, 2, 1367, 1368, 7, 140, 2, 2, 1368, 217, 3, 2, 2, 2, 1369,
	1374, 5, 248, 125, 2, 1370, 1371, 7, 140, 2, 2, 1371, 1373, 5, 248, 125,
	2, 1372, 1370, 3, 2, 2, 2, 1373, 1376, 3, 2, 2, 2, 1374, 1372, 3, 2, 2,
	2, 1374, 1375, 3, 2, 2, 2, 1375, 219, 3, 2, 2, 2, 1376, 1374, 3, 2, 2,
	2, 1377, 1378, 7, 35, 2, 2, 1378, 1379, 7, 50, 2, 2, 1379, 1380, 7, 143,
	2, 2, 1380, 1381, 5, 44, 23, 2, 1381, 1382, 7, 144, 2, 2, 1382, 221, 3,
	2, 2, 2, 1383, 1386, 5, 294, 148, 2, 1384, 1386, 7, 128, 2, 2, 1385, 1383,
	3, 2, 2, 2, 1385, 1384, 3, 2, 2, 2, 1386, 223, 3, 2, 2, 2, 1387, 1392,
	5, 222, 112, 2, 1388, 1389, 7, 141, 2, 2, 1389, 1391, 5, 222, 112, 2, 1390,
	1388, 3, 2, 2, 2, 1391, 1394, 3, 2, 2, 2, 1392, 1390, 3, 2, 2, 2, 1392,
	1393, 3, 2, 2, 2, 1393, 225, 3, 2, 2, 2, 1394, 1392, 3, 2, 2, 2, 1395,
	1396, 7, 36, 2, 2, 1396, 1397, 5, 274, 138, 2, 1397, 1398, 5, 294, 148,
	2, 1398, 1399, 7, 143, 2, 2, 1399, 1400, 5, 224, 113, 2, 1400, 1401, 7,
	144, 2, 2, 1401, 1402, 7, 140, 2, 2, 1402, 227, 3, 2, 2, 2, 1403, 1404,
	7, 36, 2, 2, 1404, 1405, 5, 232, 117, 2, 1405, 1406, 7, 43, 2, 2, 1406,
	1407, 7, 143, 2, 2, 1407, 1408, 5, 166, 84, 2, 1408, 1409, 7, 144, 2, 2,
	1409, 1410, 7, 140, 2, 2, 1410, 229, 3, 2, 2, 2, 1411, 1412, 5, 424, 213,
	2, 1412, 1413, 7, 147, 2, 2, 1413, 1414, 5, 294, 148, 2, 1414, 231, 3,
	2, 2, 2, 1415, 1416, 9, 6, 2, 2, 1416, 233, 3, 2, 2, 2, 1417, 1422, 5,
	232, 117, 2, 1418, 1419, 7, 141, 2, 2, 1419, 1421, 5, 232, 117, 2, 1420,
	1418, 3, 2, 2, 2, 1421, 1424, 3, 2, 2, 2, 1422, 1420, 3, 2, 2, 2, 1422,
	1423, 3, 2, 2, 2, 1423, 235, 3, 2, 2, 2, 1424, 1422, 3, 2, 2, 2, 1425,
	1427, 5, 274, 138, 2, 1426, 1425, 3, 2, 2, 2, 1426, 1427, 3, 2, 2, 2, 1427,
	1428, 3, 2, 2, 2, 1428, 1429, 7, 38, 2, 2, 1429, 1430, 5, 108, 55, 2, 1430,
	1431, 7, 97, 2, 2, 1431, 1439, 5, 410, 206, 2, 1432, 1433, 7, 29, 2, 2,
	1433, 1434, 5, 108, 55, 2, 1434, 1435, 7, 97, 2, 2, 1435, 1436, 5, 410,
	206, 2, 1436, 1438, 3, 2, 2, 2, 1437, 1432, 3, 2, 2, 2, 1438, 1441, 3,
	2, 2, 2, 1439, 1437, 3, 2, 2, 2, 1439, 1440, 3, 2, 2, 2, 1440, 1444, 3,
	2, 2, 2, 1441, 1439, 3, 2, 2, 2, 1442, 1443, 7, 28, 2, 2, 1443, 1445, 5,
	410, 206, 2, 1444, 1442, 3, 2, 2, 2, 1444, 1445, 3, 2, 2, 2, 1445, 1446,
	3, 2, 2, 2, 1446, 1447, 7, 26, 2, 2, 1447, 1449, 7, 38, 2, 2, 1448, 1450,
	5, 232, 117, 2, 1449, 1448, 3, 2, 2, 2, 1449, 1450, 3, 2, 2, 2, 1450, 1451,
	3, 2, 2, 2, 1451, 1452, 7, 140, 2, 2, 1452, 237, 3, 2, 2, 2, 1453, 1454,
	7, 143, 2, 2, 1454, 1459, 5, 150, 76, 2, 1455, 1456, 7, 141, 2, 2, 1456,
	1458, 5, 150, 76, 2, 1457, 1455, 3, 2, 2, 2, 1458, 1461, 3, 2, 2, 2, 1459,
	1457, 3, 2, 2, 2, 1459, 1460, 3, 2, 2, 2, 1460, 1462, 3, 2, 2, 2, 1461,
	1459, 3, 2, 2, 2, 1462, 1463, 7, 144, 2, 2, 1463, 239, 3, 2, 2, 2, 1464,
	1467, 5, 150, 76, 2, 1465, 1467, 5, 194, 98, 2, 1466, 1464, 3, 2, 2, 2,
	1466, 1465, 3, 2, 2, 2, 1467, 241, 3, 2, 2, 2, 1468, 1469, 5, 294, 148,
	2, 1469, 1470, 7, 74, 2, 2, 1470, 1471, 7, 138, 2, 2, 1471, 243, 3, 2,
	2, 2, 1472, 1474, 7, 21, 2, 2, 1473, 1472, 3, 2, 2, 2, 1473, 1474, 3, 2,
	2, 2, 1474, 1475, 3, 2, 2, 2, 1475, 1487, 5, 294, 148, 2, 1476, 1477, 7,
	27, 2, 2, 1477, 1482, 5, 294, 148, 2, 1478, 1479, 7, 143, 2, 2, 1479, 1480,
	5, 232, 117, 2, 1480, 1481, 7, 144, 2, 2, 1481, 1483, 3, 2, 2, 2, 1482,
	1478, 3, 2, 2, 2, 1482, 1483, 3, 2, 2, 2, 1483, 1487, 3, 2, 2, 2, 1484,
	1485, 7, 22, 2, 2, 1485, 1487, 5, 294, 148, 2, 1486, 1473, 3, 2, 2, 2,
	1486, 1476, 3, 2, 2, 2, 1486, 1484, 3, 2, 2, 2, 1487, 245, 3, 2, 2, 2,
	1488, 1493, 5, 232, 117, 2, 1489, 1490, 7, 141, 2, 2, 1490, 1492, 5, 232,
	117, 2, 1491, 1489, 3, 2, 2, 2, 1492, 1495, 3, 2, 2, 2, 1493, 1491, 3,
	2, 2, 2, 1493, 1494, 3, 2, 2, 2, 1494, 1499, 3, 2, 2, 2, 1495, 1493, 3,
	2, 2, 2, 1496, 1499, 7, 64, 2, 2, 1497, 1499, 7, 8, 2, 2, 1498, 1488, 3,
	2, 2, 2, 1498, 1496, 3, 2, 2, 2, 1498, 1497, 3, 2, 2, 2, 1499, 247, 3,
	2, 2, 2, 1500, 1502, 7, 23, 2, 2, 1501, 1500, 3, 2, 2, 2, 1501, 1502, 3,
	2, 2, 2, 1502, 1503, 3, 2, 2, 2, 1503, 1504, 5, 234, 118, 2, 1504, 1506,
	7, 147, 2, 2, 1505, 1507, 7, 40, 2, 2, 1506, 1505, 3, 2, 2, 2, 1506, 1507,
	3, 2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 1511, 5, 474, 238, 2, 1509, 1510,
	7, 137, 2, 2, 1510, 1512, 5, 194, 98, 2, 1511, 1509, 3, 2, 2, 2, 1511,
	1512, 3, 2, 2, 2, 1512, 249, 3, 2, 2, 2, 1513, 1520, 5, 248, 125, 2, 1514,
	1520, 5, 266, 134, 2, 1515, 1520, 5, 270, 136, 2, 1516, 1520, 5, 254, 128,
	2, 1517, 1520, 5, 268, 135, 2, 1518, 1520, 5, 262, 132, 2, 1519, 1513,
	3, 2, 2, 2, 1519, 1514, 3, 2, 2, 2, 1519, 1515, 3, 2, 2, 2, 1519, 1516,
	3, 2, 2, 2, 1519, 1517, 3, 2, 2, 2, 1519, 1518, 3, 2, 2, 2, 1520, 251,
	3, 2, 2, 2, 1521, 1522, 5, 250, 126, 2, 1522, 253, 3, 2, 2, 2, 1523, 1524,
	7, 31, 2, 2, 1524, 1525, 5, 234, 118, 2, 1525, 1526, 7, 147, 2, 2, 1526,
	1527, 5, 474, 238, 2, 1527, 255, 3, 2, 2, 2, 1528, 1533, 5, 266, 134, 2,
	1529, 1530, 7, 140, 2, 2, 1530, 1532, 5, 266, 134, 2, 1531, 1529, 3, 2,
	2, 2, 1532, 1535, 3, 2, 2, 2, 1533, 1531, 3, 2, 2, 2, 1533, 1534, 3, 2,
	2, 2, 1534, 257, 3, 2, 2, 2, 1535, 1533, 3, 2, 2, 2, 1536, 1541, 5, 264,
	133, 2, 1537, 1538, 7, 140, 2, 2, 1538, 1540, 5, 264, 133, 2, 1539, 1537,
	3, 2, 2, 2, 1540, 1543, 3, 2, 2, 2, 1541, 1539, 3, 2, 2, 2, 1541, 1542,
	3, 2, 2, 2, 1542, 259, 3, 2, 2, 2, 1543, 1541, 3, 2, 2, 2, 1544, 1549,
	5, 252, 127, 2, 1545, 1546, 7, 140, 2, 2, 1546, 1548, 5, 252, 127, 2, 1547,
	1545, 3, 2, 2, 2, 1548, 1551, 3, 2, 2, 2, 1549, 1547, 3, 2, 2, 2, 1549,
	1550, 3, 2, 2, 2, 1550, 261, 3, 2, 2, 2, 1551, 1549, 3, 2, 2, 2, 1552,
	1553, 7, 73, 2, 2, 1553, 1554, 5, 234, 118, 2, 1554, 1556, 7, 147, 2, 2,
	1555, 1557, 9, 7, 2, 2, 1556, 1555, 3, 2, 2, 2, 1556, 1557, 3, 2, 2, 2,
	1557, 1558, 3, 2, 2, 2, 1558, 1561, 5, 474, 238, 2, 1559, 1560, 7, 137,
	2, 2, 1560, 1562, 5, 194, 98, 2, 1561, 1559, 3, 2, 2, 2, 1561, 1562, 3,
	2, 2, 2, 1562, 263, 3, 2, 2, 2, 1563, 1564, 5, 234, 118, 2, 1564, 1566,
	7, 147, 2, 2, 1565, 1567, 5, 290, 146, 2, 1566, 1565, 3, 2, 2, 2, 1566,
	1567, 3, 2, 2, 2, 1567, 1568, 3, 2, 2, 2, 1568, 1570, 5, 474, 238, 2, 1569,
	1571, 7, 19, 2, 2, 1570, 1569, 3, 2, 2, 2, 1570, 1571, 3, 2, 2, 2, 1571,
	1574, 3, 2, 2, 2, 1572, 1573, 7, 137, 2, 2, 1573, 1575, 5, 194, 98, 2,
	1574, 1572, 3, 2, 2, 2, 1574, 1575, 3, 2, 2, 2, 1575, 265, 3, 2, 2, 2,
	1576, 1577, 7, 88, 2, 2, 1577, 1578, 5, 234, 118, 2, 1578, 1580, 7, 147,
	2, 2, 1579, 1581, 5, 290, 146, 2, 1580, 1579, 3, 2, 2, 2, 1580, 1581, 3,
	2, 2, 2, 1581, 1582, 3, 2, 2, 2, 1582, 1584, 5, 474, 238, 2, 1583, 1585,
	7, 19, 2, 2, 1584, 1583, 3, 2, 2, 2, 1584, 1585, 3, 2, 2, 2, 1585, 1588,
	3, 2, 2, 2, 1586, 1587, 7, 137, 2, 2, 1587, 1589, 5, 194, 98, 2, 1588,
	1586, 3, 2, 2, 2, 1588, 1589, 3, 2, 2, 2, 1589, 267, 3, 2, 2, 2, 1590,
	1591, 7, 96, 2, 2, 1591, 1592, 5, 234, 118, 2, 1592, 1593, 7, 147, 2, 2,
	1593, 1594, 5, 452, 227, 2, 1594, 269, 3, 2, 2, 2, 1595, 1597, 7, 107,
	2, 2, 1596, 1595, 3, 2, 2, 2, 1596, 1597, 3, 2, 2, 2, 1597, 1598, 3, 2,
	2, 2, 1598, 1599, 5, 234, 118, 2, 1599, 1601, 7, 147, 2, 2, 1600, 1602,
	5, 290, 146, 2, 1601, 1600, 3, 2, 2, 2, 1601, 1602, 3, 2, 2, 2, 1602, 1603,
	3, 2, 2, 2, 1603, 1606, 5, 474, 238, 2, 1604, 1605, 7, 137, 2, 2, 1605,
	1607, 5, 194, 98, 2, 1606, 1604, 3, 2, 2, 2, 1606, 1607, 3, 2, 2, 2, 1607,
	271, 3, 2, 2, 2, 1608, 1609, 7, 111, 2, 2, 1609, 1613, 5, 108, 55, 2, 1610,
	1611, 7, 32, 2, 2, 1611, 1613, 5, 334, 168, 2, 1612, 1608, 3, 2, 2, 2,
	1612, 1610, 3, 2, 2, 2, 1613, 273, 3, 2, 2, 2, 1614, 1615, 5, 232, 117,
	2, 1615, 1616, 7, 147, 2, 2, 1616, 275, 3, 2, 2, 2, 1617, 1618, 7, 45,
	2, 2, 1618, 1619, 5, 284, 143, 2, 1619, 1620, 7, 140, 2, 2, 1620, 277,
	3, 2, 2, 2, 1621, 1624, 5, 398, 200, 2, 1622, 1624, 5, 348, 175, 2, 1623,
	1621, 3, 2, 2, 2, 1623, 1622, 3, 2, 2, 2, 1624, 279, 3, 2, 2, 2, 1625,
	1631, 7, 59, 2, 2, 1626, 1631, 7, 115, 2, 2, 1627, 1631, 7, 129, 2, 2,
	1628, 1631, 5, 188, 95, 2, 1629, 1631, 5, 316, 159, 2, 1630, 1625, 3, 2,
	2, 2, 1630, 1626, 3, 2, 2, 2, 1630, 1627, 3, 2, 2, 2, 1630, 1628, 3, 2,
	2, 2, 1630, 1629, 3, 2, 2, 2, 1631, 281, 3, 2, 2, 2, 1632, 1633, 5, 232,
	117, 2, 1633, 283, 3, 2, 2, 2, 1634, 1639, 5, 282, 142, 2, 1635, 1636,
	7, 141, 2, 2, 1636, 1638, 5, 282, 142, 2, 1637, 1635, 3, 2, 2, 2, 1638,
	1641, 3, 2, 2, 2, 1639, 1637, 3, 2, 2, 2, 1639, 1640, 3, 2, 2, 2, 1640,
	285, 3, 2, 2, 2, 1641, 1639, 3, 2, 2, 2, 1642, 1643, 9, 8, 2, 2, 1643,
	287, 3, 2, 2, 2, 1644, 1646, 5, 274, 138, 2, 1645, 1644, 3, 2, 2, 2, 1645,
	1646, 3, 2, 2, 2, 1646, 1648, 3, 2, 2, 2, 1647, 1649, 5, 272, 137, 2, 1648,
	1647, 3, 2, 2, 2, 1648, 1649, 3, 2, 2, 2, 1649, 1650, 3, 2, 2, 2, 1650,
	1651, 7, 49, 2, 2, 1651, 1652, 5, 410, 206, 2, 1652, 1653, 7, 26, 2, 2,
	1653, 1655, 7, 49, 2, 2, 1654, 1656, 5, 232, 117, 2, 1655, 1654, 3, 2,
	2, 2, 1655, 1656, 3, 2, 2, 2, 1656, 1657, 3, 2, 2, 2, 1657, 1658, 7, 140,
	2, 2, 1658, 289, 3, 2, 2, 2, 1659, 1660, 9, 9, 2, 2, 1660, 291, 3, 2, 2,
	2, 1661, 1662, 9, 10, 2, 2, 1662, 293, 3, 2, 2, 2, 1663, 1666, 5, 232,
	117, 2, 1664, 1666, 7, 129, 2, 2, 1665, 1663, 3, 2, 2, 2, 1665, 1664, 3,
	2, 2, 2, 1666, 1670, 3, 2, 2, 2, 1667, 1669, 5, 296, 149, 2, 1668, 1667,
	3, 2, 2, 2, 1669, 1672, 3, 2, 2, 2, 1670, 1668, 3, 2, 2, 2, 1670, 1671,
	3, 2, 2, 2, 1671, 295, 3, 2, 2, 2, 1672, 1670, 3, 2, 2, 2, 1673, 1678,
	5, 300, 151, 2, 1674, 1678, 5, 302, 152, 2, 1675, 1678, 5, 304, 153, 2,
	1676, 1678, 5, 306, 154, 2, 1677, 1673, 3, 2, 2, 2, 1677, 1674, 3, 2, 2,
	2, 1677, 1675, 3, 2, 2, 2, 1677, 1676, 3, 2, 2, 2, 1678, 297, 3, 2, 2,
	2, 1679, 1684, 5, 232, 117, 2, 1680, 1681, 7, 156, 2, 2, 1681, 1683, 5,
	476, 239, 2, 1682, 1680, 3, 2, 2, 2, 1683, 1686, 3, 2, 2, 2, 1684, 1682,
	3, 2, 2, 2, 1684, 1685, 3, 2, 2, 2, 1685, 299, 3, 2, 2, 2, 1686, 1684,
	3, 2, 2, 2, 1687, 1688, 7, 156, 2, 2, 1688, 1690, 5, 476, 239, 2, 1689,
	1687, 3, 2, 2, 2, 1690, 1691, 3, 2, 2, 2, 1691, 1689, 3, 2, 2, 2, 1691,
	1692, 3, 2, 2, 2, 1692, 301, 3, 2, 2, 2, 1693, 1694, 7, 143, 2, 2, 1694,
	1695, 5, 10, 6, 2, 1695, 1696, 7, 144, 2, 2, 1696, 303, 3, 2, 2, 2, 1697,
	1698, 7, 143, 2, 2, 1698, 1699, 5, 150, 76, 2, 1699, 1700, 7, 144, 2, 2,
	1700, 305, 3, 2, 2, 2, 1701, 1703, 5, 426, 214, 2, 1702, 1701, 3, 2, 2,
	2, 1702, 1703, 3, 2, 2, 2, 1703, 1704, 3, 2, 2, 2, 1704, 1705, 7, 164,
	2, 2, 1705, 1710, 5, 48, 25, 2, 1706, 1707, 7, 143, 2, 2, 1707, 1708, 5,
	194, 98, 2, 1708, 1709, 7, 144, 2, 2, 1709, 1711, 3, 2, 2, 2, 1710, 1706,
	3, 2, 2, 2, 1710, 1711, 3, 2, 2, 2, 1711, 307, 3, 2, 2, 2, 1712, 1713,
	7, 53, 2, 2, 1713, 1714, 5, 232, 117, 2, 1714, 1715, 7, 43, 2, 2, 1715,
	1716, 5, 310, 156, 2, 1716, 1717, 7, 140, 2, 2, 1717, 309, 3, 2, 2, 2,
	1718, 1721, 5, 394, 198, 2, 1719, 1721, 5, 96, 49, 2, 1720, 1718, 3, 2,
	2, 2, 1720, 1719, 3, 2, 2, 2, 1721, 311, 3, 2, 2, 2, 1722, 1723, 5, 234,
	118, 2, 1723, 1724, 7, 147, 2, 2, 1724, 1725, 5, 156, 79, 2, 1725, 313,
	3, 2, 2, 2, 1726, 1728, 5, 274, 138, 2, 1727, 1726, 3, 2, 2, 2, 1727, 1728,
	3, 2, 2, 2, 1728, 1729, 3, 2, 2, 2, 1729, 1731, 7, 55, 2, 2, 1730, 1732,
	5, 232, 117, 2, 1731, 1730, 3, 2, 2, 2, 1731, 1732, 3, 2, 2, 2, 1732, 1735,
	3, 2, 2, 2, 1733, 1734, 7, 110, 2, 2, 1734, 1736, 5, 108, 55, 2, 1735,
	1733, 3, 2, 2, 2, 1735, 1736, 3, 2, 2, 2, 1736, 1737, 3, 2, 2, 2, 1737,
	1738, 7, 140, 2, 2, 1738, 315, 3, 2, 2, 2, 1739, 1742, 5, 2, 2, 2, 1740,
	1742, 5, 336, 169, 2, 1741, 1739, 3, 2, 2, 2, 1741, 1740, 3, 2, 2, 2, 1742,
	317, 3, 2, 2, 2, 1743, 1750, 5, 126, 64, 2, 1744, 1750, 5, 420, 211, 2,
	1745, 1750, 5, 504, 253, 2, 1746, 1750, 5, 198, 100, 2, 1747, 1750, 5,
	484, 243, 2, 1748, 1750, 5, 370, 186, 2, 1749, 1743, 3, 2, 2, 2, 1749,
	1744, 3, 2, 2, 2, 1749, 1745, 3, 2, 2, 2, 1749, 1746, 3, 2, 2, 2, 1749,
	1747, 3, 2, 2, 2, 1749, 1748, 3, 2, 2, 2, 1750, 319, 3, 2, 2, 2, 1751,
	1753, 7, 37, 2, 2, 1752, 1751, 3, 2, 2, 2, 1752, 1753, 3, 2, 2, 2, 1753,
	1755, 3, 2, 2, 2, 1754, 1756, 5, 138, 70, 2, 1755, 1754, 3, 2, 2, 2, 1755,
	1756, 3, 2, 2, 2, 1756, 321, 3, 2, 2, 2, 1757, 1758, 7, 66, 2, 2, 1758,
	1759, 7, 16, 2, 2, 1759, 1760, 5, 232, 117, 2, 1760, 1761, 7, 43, 2, 2,
	1761, 1762, 5, 326, 164, 2, 1762, 1765, 7, 26, 2, 2, 1763, 1764, 7, 66,
	2, 2, 1764, 1766, 7, 16, 2, 2, 1765, 1763, 3, 2, 2, 2, 1765, 1766, 3, 2,
	2, 2, 1766, 1768, 3, 2, 2, 2, 1767, 1769, 5, 232, 117, 2, 1768, 1767, 3,
	2, 2, 2, 1768, 1769, 3, 2, 2, 2, 1769, 1770, 3, 2, 2, 2, 1770, 1771, 7,
	140, 2, 2, 1771, 323, 3, 2, 2, 2, 1772, 1784, 5, 456, 229, 2, 1773, 1784,
	5, 454, 228, 2, 1774, 1784, 5, 492, 247, 2, 1775, 1784, 5, 472, 237, 2,
	1776, 1784, 5, 126, 64, 2, 1777, 1784, 5, 504, 253, 2, 1778, 1784, 5, 198,
	100, 2, 1779, 1784, 5, 18, 10, 2, 1780, 1784, 5, 500, 251, 2, 1781, 1784,
	5, 228, 115, 2, 1782, 1784, 5, 226, 114, 2, 1783, 1772, 3, 2, 2, 2, 1783,
	1773, 3, 2, 2, 2, 1783, 1774, 3, 2, 2, 2, 1783, 1775, 3, 2, 2, 2, 1783,
	1776, 3, 2, 2, 2, 1783, 1777, 3, 2, 2, 2, 1783, 1778, 3, 2, 2, 2, 1783,
	1779, 3, 2, 2, 2, 1783, 1780, 3, 2, 2, 2, 1783, 1781, 3, 2, 2, 2, 1783,
	1782, 3, 2, 2, 2, 1784, 325, 3, 2, 2, 2, 1785, 1787, 5, 324, 163, 2, 1786,
	1785, 3, 2, 2, 2, 1787, 1790, 3, 2, 2, 2, 1788, 1786, 3, 2, 2, 2, 1788,
	1789, 3, 2, 2, 2, 1789, 327, 3, 2, 2, 2, 1790, 1788, 3, 2, 2, 2, 1791,
	1792, 7, 66, 2, 2, 1792, 1793, 5, 232, 117, 2, 1793, 1794, 7, 43, 2, 2,
	1794, 1795, 5, 332, 167, 2, 1795, 1797, 7, 26, 2, 2, 1796, 1798, 7, 66,
	2, 2, 1797, 1796, 3, 2, 2, 2, 1797, 1798, 3, 2, 2, 2, 1798, 1800, 3, 2,
	2, 2, 1799, 1801, 5, 232, 117, 2, 1800, 1799, 3, 2, 2, 2, 1800, 1801, 3,
	2, 2, 2, 1801, 1802, 3, 2, 2, 2, 1802, 1803, 7, 140, 2, 2, 1803, 329, 3,
	2, 2, 2, 1804, 1824, 5, 456, 229, 2, 1805, 1824, 5, 454, 228, 2, 1806,
	1824, 5, 492, 247, 2, 1807, 1824, 5, 472, 237, 2, 1808, 1824, 5, 126, 64,
	2, 1809, 1824, 5, 420, 211, 2, 1810, 1824, 5, 504, 253, 2, 1811, 1824,
	5, 198, 100, 2, 1812, 1824, 5, 18, 10, 2, 1813, 1824, 5, 90, 46, 2, 1814,
	1824, 5, 46, 24, 2, 1815, 1824, 5, 50, 26, 2, 1816, 1824, 5, 148, 75, 2,
	1817, 1824, 5, 500, 251, 2, 1818, 1824, 5, 228, 115, 2, 1819, 1824, 5,
	226, 114, 2, 1820, 1824, 5, 308, 155, 2, 1821, 1824, 5, 450, 226, 2, 1822,
	1824, 5, 484, 243, 2, 1823, 1804, 3, 2, 2, 2, 1823, 1805, 3, 2, 2, 2, 1823,
	1806, 3, 2, 2, 2, 1823, 1807, 3, 2, 2, 2, 1823, 1808, 3, 2, 2, 2, 1823,
	1809, 3, 2, 2, 2, 1823, 1810, 3, 2, 2, 2, 1823, 1811, 3, 2, 2, 2, 1823,
	1812, 3, 2, 2, 2, 1823, 1813, 3, 2, 2, 2, 1823, 1814, 3, 2, 2, 2, 1823,
	1815, 3, 2, 2, 2, 1823, 1816, 3, 2, 2, 2, 1823, 1817, 3, 2, 2, 2, 1823,
	1818, 3, 2, 2, 2, 1823, 1819, 3, 2, 2, 2, 1823, 1820, 3, 2, 2, 2, 1823,
	1821, 3, 2, 2, 2, 1823, 1822, 3, 2, 2, 2, 1824, 331, 3, 2, 2, 2, 1825,
	1827, 5, 330, 166, 2, 1826, 1825, 3, 2, 2, 2, 1827, 1830, 3, 2, 2, 2, 1828,
	1826, 3, 2, 2, 2, 1828, 1829, 3, 2, 2, 2, 1829, 333, 3, 2, 2, 2, 1830,
	1828, 3, 2, 2, 2, 1831, 1832, 5, 232, 117, 2, 1832, 1833, 7, 40, 2, 2,
	1833, 1834, 5, 150, 76, 2, 1834, 335, 3, 2, 2, 2, 1835, 1836, 5, 2, 2,
	2, 1836, 1837, 5, 232, 117, 2, 1837, 337, 3, 2, 2, 2, 1838, 1839, 5, 380,
	191, 2, 1839, 1840, 7, 104, 2, 2, 1840, 1844, 5, 52, 27, 2, 1841, 1843,
	5, 400, 201, 2, 1842, 1841, 3, 2, 2, 2, 1843, 1846, 3, 2, 2, 2, 1844, 1842,
	3, 2, 2, 2, 1844, 1845, 3, 2, 2, 2, 1845, 1847, 3, 2, 2, 2, 1846, 1844,
	3, 2, 2, 2, 1847, 1848, 7, 26, 2, 2, 1848, 1850, 7, 104, 2, 2, 1849, 1851,
	5, 232, 117, 2, 1850, 1849, 3, 2, 2, 2, 1850, 1851, 3, 2, 2, 2, 1851, 339,
	3, 2, 2, 2, 1852, 1853, 7, 67, 2, 2, 1853, 1854, 7, 143, 2, 2, 1854, 1855,
	5, 342, 172, 2, 1855, 1856, 7, 144, 2, 2, 1856, 1857, 7, 140, 2, 2, 1857,
	341, 3, 2, 2, 2, 1858, 1859, 5, 258, 130, 2, 1859, 343, 3, 2, 2, 2, 1860,
	1861, 7, 67, 2, 2, 1861, 1862, 7, 50, 2, 2, 1862, 1863, 7, 143, 2, 2, 1863,
	1864, 5, 44, 23, 2, 1864, 1865, 7, 144, 2, 2, 1865, 345, 3, 2, 2, 2, 1866,
	1876, 5, 280, 141, 2, 1867, 1876, 5, 368, 185, 2, 1868, 1869, 7, 143, 2,
	2, 1869, 1870, 5, 194, 98, 2, 1870, 1871, 7, 144, 2, 2, 1871, 1876, 3,
	2, 2, 2, 1872, 1876, 5, 24, 13, 2, 1873, 1876, 5, 16, 9, 2, 1874, 1876,
	5, 294, 148, 2, 1875, 1866, 3, 2, 2, 2, 1875, 1867, 3, 2, 2, 2, 1875, 1868,
	3, 2, 2, 2, 1875, 1872, 3, 2, 2, 2, 1875, 1873, 3, 2, 2, 2, 1875, 1874,
	3, 2, 2, 2, 1876, 347, 3, 2, 2, 2, 1877, 1881, 5, 168, 85, 2, 1878, 1881,
	5, 116, 59, 2, 1879, 1881, 5, 328, 165, 2, 1880, 1877, 3, 2, 2, 2, 1880,
	1878, 3, 2, 2, 2, 1880, 1879, 3, 2, 2, 2, 1881, 349, 3, 2, 2, 2, 1882,
	1895, 5, 456, 229, 2, 1883, 1895, 5, 454, 228, 2, 1884, 1895, 5, 492, 247,
	2, 1885, 1895, 5, 472, 237, 2, 1886, 1895, 5, 126, 64, 2, 1887, 1895, 5,
	504, 253, 2, 1888, 1895, 5, 18, 10, 2, 1889, 1895, 5, 46, 24, 2, 1890,
	1895, 5, 50, 26, 2, 1891, 1895, 5, 500, 251, 2, 1892, 1895, 5, 228, 115,
	2, 1893, 1895, 5, 226, 114, 2, 1894, 1882, 3, 2, 2, 2, 1894, 1883, 3, 2,
	2, 2, 1894, 1884, 3, 2, 2, 2, 1894, 1885, 3, 2, 2, 2, 1894, 1886, 3, 2,
	2, 2, 1894, 1887, 3, 2, 2, 2, 1894, 1888, 3, 2, 2, 2, 1894, 1889, 3, 2,
	2, 2, 1894, 1890, 3, 2, 2, 2, 1894, 1891, 3, 2, 2, 2, 1894, 1892, 3, 2,
	2, 2, 1894, 1893, 3, 2, 2, 2, 1895, 351, 3, 2, 2, 2, 1896, 1898, 5, 350,
	176, 2, 1897, 1896, 3, 2, 2, 2, 1898, 1901, 3, 2, 2, 2, 1899, 1897, 3,
	2, 2, 2, 1899, 1900, 3, 2, 2, 2, 1900, 353, 3, 2, 2, 2, 1901, 1899, 3,
	2, 2, 2, 1902, 1904, 5, 412, 207, 2, 1903, 1902, 3, 2, 2, 2, 1904, 1907,
	3, 2, 2, 2, 1905, 1903, 3, 2, 2, 2, 1905, 1906, 3, 2, 2, 2, 1906, 355,
	3, 2, 2, 2, 1907, 1905, 3, 2, 2, 2, 1908, 1913, 5, 298, 150, 2, 1909, 1910,
	7, 143, 2, 2, 1910, 1911, 5, 10, 6, 2, 1911, 1912, 7, 144, 2, 2, 1912,
	1914, 3, 2, 2, 2, 1913, 1909, 3, 2, 2, 2, 1913, 1914, 3, 2, 2, 2, 1914,
	357, 3, 2, 2, 2, 1915, 1917, 5, 274, 138, 2, 1916, 1915, 3, 2, 2, 2, 1916,
	1917, 3, 2, 2, 2, 1917, 1918, 3, 2, 2, 2, 1918, 1919, 5, 356, 179, 2, 1919,
	1920, 7, 140, 2, 2, 1920, 359, 3, 2, 2, 2, 1921, 1935, 5, 456, 229, 2,
	1922, 1935, 5, 454, 228, 2, 1923, 1935, 5, 492, 247, 2, 1924, 1935, 5,
	472, 237, 2, 1925, 1935, 5, 126, 64, 2, 1926, 1935, 5, 504, 253, 2, 1927,
	1935, 5, 198, 100, 2, 1928, 1935, 5, 18, 10, 2, 1929, 1935, 5, 46, 24,
	2, 1930, 1935, 5, 50, 26, 2, 1931, 1935, 5, 500, 251, 2, 1932, 1935, 5,
	228, 115, 2, 1933, 1935, 5, 226, 114, 2, 1934, 1921, 3, 2, 2, 2, 1934,
	1922, 3, 2, 2, 2, 1934, 1923, 3, 2, 2, 2, 1934, 1924, 3, 2, 2, 2, 1934,
	1925, 3, 2, 2, 2, 1934, 1926, 3, 2, 2, 2, 1934, 1927, 3, 2, 2, 2, 1934,
	1928, 3, 2, 2, 2, 1934, 1929, 3, 2, 2, 2, 1934, 1930, 3, 2, 2, 2, 1934,
	1931, 3, 2, 2, 2, 1934, 1932, 3, 2, 2, 2, 1934, 1933, 3, 2, 2, 2, 1935,
	361, 3, 2, 2, 2, 1936, 1938, 5, 360, 181, 2, 1937, 1936, 3, 2, 2, 2, 1938,
	1941, 3, 2, 2, 2, 1939, 1937, 3, 2, 2, 2, 1939, 1940, 3, 2, 2, 2, 1940,
	363, 3, 2, 2, 2, 1941, 1939, 3, 2, 2, 2, 1942, 1944, 5, 274, 138, 2, 1943,
	1942, 3, 2, 2, 2, 1943, 1944, 3, 2, 2, 2, 1944, 1946, 3, 2, 2, 2, 1945,
	1947, 7, 68, 2, 2, 1946, 1945, 3, 2, 2, 2, 1946, 1947, 3, 2, 2, 2, 1947,
	1948, 3, 2, 2, 2, 1948, 1953, 7, 69, 2, 2, 1949, 1950, 7, 143, 2, 2, 1950,
	1951, 5, 408, 205, 2, 1951, 1952, 7, 144, 2, 2, 1952, 1954, 3, 2, 2, 2,
	1953, 1949, 3, 2, 2, 2, 1953, 1954, 3, 2, 2, 2, 1954, 1956, 3, 2, 2, 2,
	1955, 1957, 7, 43, 2, 2, 1956, 1955, 3, 2, 2, 2, 1956, 1957, 3, 2, 2, 2,
	1957, 1958, 3, 2, 2, 2, 1958, 1959, 5, 362, 182, 2, 1959, 1960, 7, 14,
	2, 2, 1960, 1961, 5, 366, 184, 2, 1961, 1963, 7, 26, 2, 2, 1962, 1964,
	7, 68, 2, 2, 1963, 1962, 3, 2, 2, 2, 1963, 1964, 3, 2, 2, 2, 1964, 1965,
	3, 2, 2, 2, 1965, 1967, 7, 69, 2, 2, 1966, 1968, 5, 232, 117, 2, 1967,
	1966, 3, 2, 2, 2, 1967, 1968, 3, 2, 2, 2, 1968, 1969, 3, 2, 2, 2, 1969,
	1970, 7, 140, 2, 2, 1970, 365, 3, 2, 2, 2, 1971, 1973, 5, 412, 207, 2,
	1972, 1971, 3, 2, 2, 2, 1973, 1976, 3, 2, 2, 2, 1974, 1972, 3, 2, 2, 2,
	1974, 1975, 3, 2, 2, 2, 1975, 367, 3, 2, 2, 2, 1976, 1974, 3, 2, 2, 2,
	1977, 1978, 5, 474, 238, 2, 1978, 1984, 7, 164, 2, 2, 1979, 1985, 5, 16,
	9, 2, 1980, 1981, 7, 143, 2, 2, 1981, 1982, 5, 194, 98, 2, 1982, 1983,
	7, 144, 2, 2, 1983, 1985, 3, 2, 2, 2, 1984, 1979, 3, 2, 2, 2, 1984, 1980,
	3, 2, 2, 2, 1985, 369, 3, 2, 2, 2, 1986, 1990, 5, 210, 106, 2, 1987, 1990,
	5, 70, 36, 2, 1988, 1990, 5, 446, 224, 2, 1989, 1986, 3, 2, 2, 2, 1989,
	1987, 3, 2, 2, 2, 1989, 1988, 3, 2, 2, 2, 1990, 371, 3, 2, 2, 2, 1991,
	1996, 5, 294, 148, 2, 1992, 1993, 7, 141, 2, 2, 1993, 1995, 5, 294, 148,
	2, 1994, 1992, 3, 2, 2, 2, 1995, 1998, 3, 2, 2, 2, 1996, 1994, 3, 2, 2,
	2, 1996, 1997, 3, 2, 2, 2, 1997, 2002, 3, 2, 2, 2, 1998, 1996, 3, 2, 2,
	2, 1999, 2002, 7, 64, 2, 2, 2000, 2002, 7, 8, 2, 2, 2001, 1991, 3, 2, 2,
	2, 2001, 1999, 3, 2, 2, 2, 2001, 2000, 3, 2, 2, 2, 2002, 373, 3, 2, 2,
	2, 2003, 2004, 5, 372, 187, 2, 2004, 2005, 7, 147, 2, 2, 2005, 2006, 5,
	294, 148, 2, 2006, 375, 3, 2, 2, 2, 2007, 2010, 5, 378, 190, 2, 2008, 2010,
	5, 294, 148, 2, 2009, 2007, 3, 2, 2, 2, 2009, 2008, 3, 2, 2, 2, 2010, 377,
	3, 2, 2, 2, 2011, 2015, 5, 428, 215, 2, 2012, 2013, 5, 146, 74, 2, 2013,
	2014, 5, 428, 215, 2, 2014, 2016, 3, 2, 2, 2, 2015, 2012, 3, 2, 2, 2, 2015,
	2016, 3, 2, 2, 2, 2016, 379, 3, 2, 2, 2, 2017, 2018, 7, 74, 2, 2, 2018,
	2019, 5, 376, 189, 2, 2019, 381, 3, 2, 2, 2, 2020, 2022, 7, 78, 2, 2, 2021,
	2023, 5, 312, 157, 2, 2022, 2021, 3, 2, 2, 2, 2023, 2024, 3, 2, 2, 2, 2024,
	2022, 3, 2, 2, 2, 2024, 2025, 3, 2, 2, 2, 2025, 2026, 3, 2, 2, 2, 2026,
	2027, 7, 26, 2, 2, 2027, 2029, 7, 78, 2, 2, 2028, 2030, 5, 232, 117, 2,
	2029, 2028, 3, 2, 2, 2, 2029, 2030, 3, 2, 2, 2, 2030, 383, 3, 2, 2, 2,
	2031, 2033, 7, 78, 2, 2, 2032, 2034, 5, 154, 78, 2, 2033, 2032, 3, 2, 2,
	2, 2034, 2035, 3, 2, 2, 2, 2035, 2033, 3, 2, 2, 2, 2035, 2036, 3, 2, 2,
	2, 2036, 2037, 3, 2, 2, 2, 2037, 2038, 7, 26, 2, 2, 2038, 2040, 7, 78,
	2, 2, 2039, 2041, 5, 232, 117, 2, 2040, 2039, 3, 2, 2, 2, 2040, 2041, 3,
	2, 2, 2, 2041, 385, 3, 2, 2, 2, 2042, 2046, 5, 414, 208, 2, 2043, 2044,
	5, 388, 195, 2, 2044, 2045, 5, 414, 208, 2, 2045, 2047, 3, 2, 2, 2, 2046,
	2043, 3, 2, 2, 2, 2046, 2047, 3, 2, 2, 2, 2047, 387, 3, 2, 2, 2, 2048,
	2049, 9, 11, 2, 2, 2049, 389, 3, 2, 2, 2, 2050, 2052, 5, 274, 138, 2, 2051,
	2050, 3, 2, 2, 2, 2051, 2052, 3, 2, 2, 2, 2052, 2053, 3, 2, 2, 2, 2053,
	2054, 7, 81, 2, 2, 2054, 2057, 5, 194, 98, 2, 2055, 2056, 7, 86, 2, 2,
	2056, 2058, 5, 194, 98, 2, 2057, 2055, 3, 2, 2, 2, 2057, 2058, 3, 2, 2,
	2, 2058, 2059, 3, 2, 2, 2, 2059, 2060, 7, 140, 2, 2, 2060, 391, 3, 2, 2,
	2, 2061, 2063, 5, 274, 138, 2, 2062, 2061, 3, 2, 2, 2, 2062, 2063, 3, 2,
	2, 2, 2063, 2064, 3, 2, 2, 2, 2064, 2066, 7, 82, 2, 2, 2065, 2067, 5, 194,
	98, 2, 2066, 2065, 3, 2, 2, 2, 2066, 2067, 3, 2, 2, 2, 2067, 2068, 3, 2,
	2, 2, 2068, 2069, 7, 140, 2, 2, 2069, 393, 3, 2, 2, 2, 2070, 2071, 5, 294,
	148, 2, 2071, 2072, 7, 5, 2, 2, 2072, 2073, 5, 294, 148, 2, 2073, 2074,
	7, 98, 2, 2, 2074, 2075, 5, 294, 148, 2, 2075, 2076, 7, 79, 2, 2, 2076,
	395, 3, 2, 2, 2, 2077, 2081, 5, 338, 170, 2, 2078, 2081, 5, 190, 96, 2,
	2079, 2081, 5, 380, 191, 2, 2080, 2077, 3, 2, 2, 2, 2080, 2078, 3, 2, 2,
	2, 2080, 2079, 3, 2, 2, 2, 2081, 397, 3, 2, 2, 2, 2082, 2085, 5, 26, 14,
	2, 2083, 2085, 5, 322, 162, 2, 2084, 2082, 3, 2, 2, 2, 2084, 2083, 3, 2,
	2, 2, 2085, 399, 3, 2, 2, 2, 2086, 2087, 5, 232, 117, 2, 2087, 2088, 7,
	154, 2, 2, 2088, 2089, 5, 336, 169, 2, 2089, 2090, 7, 140, 2, 2, 2090,
	401, 3, 2, 2, 2, 2091, 2092, 7, 109, 2, 2, 2092, 2093, 5, 194, 98, 2, 2093,
	2094, 7, 85, 2, 2, 2094, 2095, 5, 478, 240, 2, 2095, 2096, 7, 133, 2, 2,
	2096, 2097, 5, 320, 161, 2, 2097, 2098, 5, 404, 203, 2, 2098, 2099, 7,
	140, 2, 2, 2099, 403, 3, 2, 2, 2, 2100, 2101, 5, 508, 255, 2, 2101, 2102,
	7, 110, 2, 2, 2102, 2110, 5, 86, 44, 2, 2103, 2104, 7, 141, 2, 2, 2104,
	2105, 5, 508, 255, 2, 2105, 2106, 7, 110, 2, 2, 2106, 2107, 5, 86, 44,
	2, 2107, 2109, 3, 2, 2, 2, 2108, 2103, 3, 2, 2, 2, 2109, 2112, 3, 2, 2,
	2, 2110, 2108, 3, 2, 2, 2, 2110, 2111, 3, 2, 2, 2, 2111, 405, 3, 2, 2,
	2, 2112, 2110, 3, 2, 2, 2, 2113, 2114, 7, 61, 2, 2, 2114, 2115, 5, 408,
	205, 2, 2115, 407, 3, 2, 2, 2, 2116, 2121, 5, 294, 148, 2, 2117, 2118,
	7, 141, 2, 2, 2118, 2120, 5, 294, 148, 2, 2119, 2117, 3, 2, 2, 2, 2120,
	2123, 3, 2, 2, 2, 2121, 2119, 3, 2, 2, 2, 2121, 2122, 3, 2, 2, 2, 2122,
	409, 3, 2, 2, 2, 2123, 2121, 3, 2, 2, 2, 2124, 2126, 5, 412, 207, 2, 2125,
	2124, 3, 2, 2, 2, 2126, 2129, 3, 2, 2, 2, 2127, 2125, 3, 2, 2, 2, 2127,
	2128, 3, 2, 2, 2, 2128, 411, 3, 2, 2, 2, 2129, 2127, 3, 2, 2, 2, 2130,
	2149, 5, 506, 254, 2, 2131, 2149, 5, 40, 21, 2, 2132, 2149, 5, 390, 196,
	2, 2133, 2149, 5, 418, 210, 2, 2134, 2149, 5, 502, 252, 2, 2135, 2149,
	5, 236, 119, 2, 2136, 2149, 5, 80, 41, 2, 2137, 2149, 5, 288, 145, 2, 2138,
	2149, 5, 314, 158, 2, 2139, 2149, 5, 192, 97, 2, 2140, 2149, 5, 392, 197,
	2, 2141, 2143, 5, 274, 138, 2, 2142, 2141, 3, 2, 2, 2, 2142, 2143, 3, 2,
	2, 2, 2143, 2144, 3, 2, 2, 2, 2144, 2145, 7, 59, 2, 2, 2145, 2149, 7, 140,
	2, 2, 2146, 2149, 5, 78, 40, 2, 2147, 2149, 5, 358, 180, 2, 2148, 2130,
	3, 2, 2, 2, 2148, 2131, 3, 2, 2, 2, 2148, 2132, 3, 2, 2, 2, 2148, 2133,
	3, 2, 2, 2, 2148, 2134, 3, 2, 2, 2, 2148, 2135, 3, 2, 2, 2, 2148, 2136,
	3, 2, 2, 2, 2148, 2137, 3, 2, 2, 2, 2148, 2138, 3, 2, 2, 2, 2148, 2139,
	3, 2, 2, 2, 2148, 2140, 3, 2, 2, 2, 2148, 2142, 3, 2, 2, 2, 2148, 2146,
	3, 2, 2, 2, 2148, 2147, 3, 2, 2, 2, 2149, 413, 3, 2, 2, 2, 2150, 2154,
	5, 428, 215, 2, 2151, 2152, 5, 416, 209, 2, 2152, 2153, 5, 428, 215, 2,
	2153, 2155, 3, 2, 2, 2, 2154, 2151, 3, 2, 2, 2, 2154, 2155, 3, 2, 2, 2,
	2155, 415, 3, 2, 2, 2, 2156, 2157, 9, 12, 2, 2, 2157, 417, 3, 2, 2, 2,
	2158, 2160, 5, 274, 138, 2, 2159, 2158, 3, 2, 2, 2, 2159, 2160, 3, 2, 2,
	2, 2160, 2161, 3, 2, 2, 2, 2161, 2162, 5, 478, 240, 2, 2162, 2164, 7, 133,
	2, 2, 2163, 2165, 5, 138, 70, 2, 2164, 2163, 3, 2, 2, 2, 2164, 2165, 3,
	2, 2, 2, 2165, 2166, 3, 2, 2, 2, 2166, 2167, 5, 508, 255, 2, 2167, 2168,
	7, 140, 2, 2, 2168, 419, 3, 2, 2, 2, 2169, 2170, 7, 88, 2, 2, 2170, 2171,
	5, 234, 118, 2, 2171, 2172, 7, 147, 2, 2, 2172, 2174, 5, 474, 238, 2, 2173,
	2175, 5, 422, 212, 2, 2174, 2173, 3, 2, 2, 2, 2174, 2175, 3, 2, 2, 2, 2175,
	2178, 3, 2, 2, 2, 2176, 2177, 7, 137, 2, 2, 2177, 2179, 5, 194, 98, 2,
	2178, 2176, 3, 2, 2, 2, 2178, 2179, 3, 2, 2, 2, 2179, 2180, 3, 2, 2, 2,
	2180, 2181, 7, 140, 2, 2, 2181, 421, 3, 2, 2, 2, 2182, 2183, 9, 13, 2,
	2, 2183, 423, 3, 2, 2, 2, 2184, 2189, 5, 294, 148, 2, 2185, 2186, 7, 141,
	2, 2, 2186, 2188, 5, 294, 148, 2, 2187, 2185, 3, 2, 2, 2, 2188, 2191, 3,
	2, 2, 2, 2189, 2187, 3, 2, 2, 2, 2189, 2190, 3, 2, 2, 2, 2190, 2195, 3,
	2, 2, 2, 2191, 2189, 3, 2, 2, 2, 2192, 2195, 7, 64, 2, 2, 2193, 2195, 7,
	8, 2, 2, 2194, 2184, 3, 2, 2, 2, 2194, 2192, 3, 2, 2, 2, 2194, 2193, 3,
	2, 2, 2, 2195, 425, 3, 2, 2, 2, 2196, 2205, 7, 145, 2, 2, 2197, 2202, 5,
	294, 148, 2, 2198, 2199, 7, 141, 2, 2, 2199, 2201, 5, 294, 148, 2, 2200,
	2198, 3, 2, 2, 2, 2201, 2204, 3, 2, 2, 2, 2202, 2200, 3, 2, 2, 2, 2202,
	2203, 3, 2, 2, 2, 2203, 2206, 3, 2, 2, 2, 2204, 2202, 3, 2, 2, 2, 2205,
	2197, 3, 2, 2, 2, 2205, 2206, 3, 2, 2, 2, 2206, 2209, 3, 2, 2, 2, 2207,
	2208, 7, 82, 2, 2, 2208, 2210, 5, 294, 148, 2, 2209, 2207, 3, 2, 2, 2,
	2209, 2210, 3, 2, 2, 2, 2210, 2211, 3, 2, 2, 2, 2211, 2212, 7, 146, 2,
	2, 2212, 427, 3, 2, 2, 2, 2213, 2215, 9, 14, 2, 2, 2214, 2213, 3, 2, 2,
	2, 2214, 2215, 3, 2, 2, 2, 2215, 2216, 3, 2, 2, 2, 2216, 2222, 5, 480,
	241, 2, 2217, 2218, 5, 14, 8, 2, 2218, 2219, 5, 480, 241, 2, 2219, 2221,
	3, 2, 2, 2, 2220, 2217, 3, 2, 2, 2, 2221, 2224, 3, 2, 2, 2, 2222, 2220,
	3, 2, 2, 2, 2222, 2223, 3, 2, 2, 2, 2223, 429, 3, 2, 2, 2, 2224, 2222,
	3, 2, 2, 2, 2225, 2227, 5, 274, 138, 2, 2226, 2225, 3, 2, 2, 2, 2226, 2227,
	3, 2, 2, 2, 2227, 2228, 3, 2, 2, 2, 2228, 2229, 5, 428, 215, 2, 2229, 2230,
	7, 132, 2, 2, 2230, 2232, 5, 428, 215, 2, 2231, 2233, 5, 490, 246, 2, 2232,
	2231, 3, 2, 2, 2, 2232, 2233, 3, 2, 2, 2, 2233, 2234, 3, 2, 2, 2, 2234,
	2235, 7, 140, 2, 2, 2235, 431, 3, 2, 2, 2, 2236, 2237, 7, 110, 2, 2, 2237,
	2238, 5, 86, 44, 2, 2238, 2239, 7, 135, 2, 2, 2239, 2240, 5, 442, 222,
	2, 2240, 433, 3, 2, 2, 2, 2241, 2243, 5, 274, 138, 2, 2242, 2241, 3, 2,
	2, 2, 2242, 2243, 3, 2, 2, 2, 2243, 2244, 3, 2, 2, 2, 2244, 2245, 7, 20,
	2, 2, 2245, 2246, 5, 194, 98, 2, 2246, 2248, 7, 106, 2, 2, 2247, 2249,
	5, 432, 217, 2, 2248, 2247, 3, 2, 2, 2, 2249, 2250, 3, 2, 2, 2, 2250, 2248,
	3, 2, 2, 2, 2250, 2251, 3, 2, 2, 2, 2251, 2252, 3, 2, 2, 2, 2252, 2253,
	7, 26, 2, 2, 2253, 2255, 7, 20, 2, 2, 2254, 2256, 5, 232, 117, 2, 2255,
	2254, 3, 2, 2, 2, 2255, 2256, 3, 2, 2, 2, 2256, 2257, 3, 2, 2, 2, 2257,
	2258, 7, 140, 2, 2, 2258, 435, 3, 2, 2, 2, 2259, 2261, 5, 274, 138, 2,
	2260, 2259, 3, 2, 2, 2, 2260, 2261, 3, 2, 2, 2, 2261, 2262, 3, 2, 2, 2,
	2262, 2263, 7, 38, 2, 2, 2263, 2264, 5, 108, 55, 2, 2264, 2265, 7, 106,
	2, 2, 2265, 2273, 5, 442, 222, 2, 2266, 2267, 7, 29, 2, 2, 2267, 2268,
	5, 108, 55, 2, 2268, 2269, 7, 106, 2, 2, 2269, 2270, 5, 442, 222, 2, 2270,
	2272, 3, 2, 2, 2, 2271, 2266, 3, 2, 2, 2, 2272, 2275, 3, 2, 2, 2, 2273,
	2271, 3, 2, 2, 2, 2273, 2274, 3, 2, 2, 2, 2274, 2278, 3, 2, 2, 2, 2275,
	2273, 3, 2, 2, 2, 2276, 2277, 7, 28, 2, 2, 2277, 2279, 5, 442, 222, 2,
	2278, 2276, 3, 2, 2, 2, 2278, 2279, 3, 2, 2, 2, 2279, 2280, 3, 2, 2, 2,
	2280, 2281, 7, 26, 2, 2, 2281, 2283, 7, 106, 2, 2, 2282, 2284, 5, 232,
	117, 2, 2283, 2282, 3, 2, 2, 2, 2283, 2284, 3, 2, 2, 2, 2284, 2285, 3,
	2, 2, 2, 2285, 2286, 7, 140, 2, 2, 2286, 437, 3, 2, 2, 2, 2287, 2289, 5,
	274, 138, 2, 2288, 2287, 3, 2, 2, 2, 2288, 2289, 3, 2, 2, 2, 2289, 2290,
	3, 2, 2, 2, 2290, 2292, 7, 71, 2, 2, 2291, 2293, 7, 43, 2, 2, 2292, 2291,
	3, 2, 2, 2, 2292, 2293, 3, 2, 2, 2, 2293, 2294, 3, 2, 2, 2, 2294, 2295,
	5, 352, 177, 2, 2295, 2296, 7, 14, 2, 2, 2296, 2297, 5, 354, 178, 2, 2297,
	2298, 7, 26, 2, 2, 2298, 2300, 7, 71, 2, 2, 2299, 2301, 5, 232, 117, 2,
	2300, 2299, 3, 2, 2, 2, 2300, 2301, 3, 2, 2, 2, 2301, 2302, 3, 2, 2, 2,
	2302, 2303, 7, 140, 2, 2, 2303, 439, 3, 2, 2, 2, 2304, 2314, 5, 430, 216,
	2, 2305, 2314, 5, 436, 219, 2, 2306, 2314, 5, 434, 218, 2, 2307, 2314,
	5, 438, 220, 2, 2308, 2310, 5, 274, 138, 2, 2309, 2308, 3, 2, 2, 2, 2309,
	2310, 3, 2, 2, 2, 2310, 2311, 3, 2, 2, 2, 2311, 2312, 7, 59, 2, 2, 2312,
	2314, 7, 140, 2, 2, 2313, 2304, 3, 2, 2, 2, 2313, 2305, 3, 2, 2, 2, 2313,
	2306, 3, 2, 2, 2, 2313, 2307, 3, 2, 2, 2, 2313, 2309, 3, 2, 2, 2, 2314,
	441, 3, 2, 2, 2, 2315, 2317, 5, 440, 221, 2, 2316, 2315, 3, 2, 2, 2, 2317,
	2320, 3, 2, 2, 2, 2318, 2316, 3, 2, 2, 2, 2318, 2319, 3, 2, 2, 2, 2319,
	443, 3, 2, 2, 2, 2320, 2318, 3, 2, 2, 2, 2321, 2322, 7, 91, 2, 2, 2322,
	2323, 5, 428, 215, 2, 2323, 2324, 7, 141, 2, 2, 2324, 2325, 5, 428, 215,
	2, 2325, 2329, 3, 2, 2, 2, 2326, 2327, 7, 56, 2, 2, 2327, 2329, 5, 428,
	215, 2, 2328, 2321, 3, 2, 2, 2, 2328, 2326, 3, 2, 2, 2, 2329, 445, 3, 2,
	2, 2, 2330, 2331, 7, 73, 2, 2, 2331, 2332, 5, 234, 118, 2, 2332, 2333,
	7, 147, 2, 2, 2333, 2334, 5, 474, 238, 2, 2334, 2335, 5, 444, 223, 2, 2335,
	2336, 7, 140, 2, 2, 2336, 447, 3, 2, 2, 2, 2337, 2338, 7, 46, 2, 2, 2338,
	2339, 5, 374, 188, 2, 2339, 2340, 7, 109, 2, 2, 2340, 2341, 5, 194, 98,
	2, 2341, 2342, 7, 140, 2, 2, 2342, 449, 3, 2, 2, 2, 2343, 2344, 7, 94,
	2, 2, 2344, 2345, 5, 232, 117, 2, 2345, 2346, 7, 43, 2, 2, 2346, 2347,
	5, 452, 227, 2, 2347, 2348, 7, 140, 2, 2, 2348, 451, 3, 2, 2, 2, 2349,
	2351, 5, 294, 148, 2, 2350, 2352, 5, 238, 120, 2, 2351, 2350, 3, 2, 2,
	2, 2351, 2352, 3, 2, 2, 2, 2352, 2359, 3, 2, 2, 2, 2353, 2354, 7, 100,
	2, 2, 2354, 2355, 5, 194, 98, 2, 2355, 2356, 7, 5, 2, 2, 2356, 2357, 5,
	194, 98, 2, 2357, 2358, 7, 98, 2, 2, 2358, 2360, 3, 2, 2, 2, 2359, 2353,
	3, 2, 2, 2, 2359, 2360, 3, 2, 2, 2, 2360, 453, 3, 2, 2, 2, 2361, 2362,
	5, 464, 233, 2, 2362, 2363, 7, 43, 2, 2, 2363, 2364, 5, 460, 231, 2, 2364,
	2365, 7, 14, 2, 2, 2365, 2366, 5, 470, 236, 2, 2366, 2368, 7, 26, 2, 2,
	2367, 2369, 5, 462, 232, 2, 2368, 2367, 3, 2, 2, 2, 2368, 2369, 3, 2, 2,
	2, 2369, 2371, 3, 2, 2, 2, 2370, 2372, 5, 144, 73, 2, 2371, 2370, 3, 2,
	2, 2, 2371, 2372, 3, 2, 2, 2, 2372, 2373, 3, 2, 2, 2, 2373, 2374, 7, 140,
	2, 2, 2374, 455, 3, 2, 2, 2, 2375, 2376, 5, 464, 233, 2, 2376, 2377, 7,
	140, 2, 2, 2377, 457, 3, 2, 2, 2, 2378, 2392, 5, 456, 229, 2, 2379, 2392,
	5, 454, 228, 2, 2380, 2392, 5, 492, 247, 2, 2381, 2392, 5, 472, 237, 2,
	2382, 2392, 5, 126, 64, 2, 2383, 2392, 5, 504, 253, 2, 2384, 2392, 5, 198,
	100, 2, 2385, 2392, 5, 18, 10, 2, 2386, 2392, 5, 46, 24, 2, 2387, 2392,
	5, 50, 26, 2, 2388, 2392, 5, 500, 251, 2, 2389, 2392, 5, 228, 115, 2, 2390,
	2392, 5, 226, 114, 2, 2391, 2378, 3, 2, 2, 2, 2391, 2379, 3, 2, 2, 2, 2391,
	2380, 3, 2, 2, 2, 2391, 2381, 3, 2, 2, 2, 2391, 2382, 3, 2, 2, 2, 2391,
	2383, 3, 2, 2, 2, 2391, 2384, 3, 2, 2, 2, 2391, 2385, 3, 2, 2, 2, 2391,
	2386, 3, 2, 2, 2, 2391, 2387, 3, 2, 2, 2, 2391, 2388, 3, 2, 2, 2, 2391,
	2389, 3, 2, 2, 2, 2391, 2390, 3, 2, 2, 2, 2392, 459, 3, 2, 2, 2, 2393,
	2395, 5, 458, 230, 2, 2394, 2393, 3, 2, 2, 2, 2395, 2398, 3, 2, 2, 2, 2396,
	2394, 3, 2, 2, 2, 2396, 2397, 3, 2, 2, 2, 2397, 461, 3, 2, 2, 2, 2398,
	2396, 3, 2, 2, 2, 2399, 2400, 9, 15, 2, 2, 2400, 463, 3, 2, 2, 2, 2401,
	2404, 5, 466, 234, 2, 2402, 2404, 5, 468, 235, 2, 2403, 2401, 3, 2, 2,
	2, 2403, 2402, 3, 2, 2, 2, 2404, 465, 3, 2, 2, 2, 2405, 2406, 7, 70, 2,
	2, 2406, 2411, 5, 144, 73, 2, 2407, 2408, 7, 143, 2, 2, 2408, 2409, 5,
	206, 104, 2, 2409, 2410, 7, 144, 2, 2, 2410, 2412, 3, 2, 2, 2, 2411, 2407,
	3, 2, 2, 2, 2411, 2412, 3, 2, 2, 2, 2412, 467, 3, 2, 2, 2, 2413, 2415,
	9, 16, 2, 2, 2414, 2413, 3, 2, 2, 2, 2414, 2415, 3, 2, 2, 2, 2415, 2416,
	3, 2, 2, 2, 2416, 2417, 7, 33, 2, 2, 2417, 2422, 5, 144, 73, 2, 2418, 2419,
	7, 143, 2, 2, 2419, 2420, 5, 206, 104, 2, 2420, 2421, 7, 144, 2, 2, 2421,
	2423, 3, 2, 2, 2, 2422, 2418, 3, 2, 2, 2, 2422, 2423, 3, 2, 2, 2, 2423,
	2424, 3, 2, 2, 2, 2424, 2425, 7, 82, 2, 2, 2425, 2426, 5, 474, 238, 2,
	2426, 469, 3, 2, 2, 2, 2427, 2429, 5, 412, 207, 2, 2428, 2427, 3, 2, 2,
	2, 2429, 2432, 3, 2, 2, 2, 2430, 2428, 3, 2, 2, 2, 2430, 2431, 3, 2, 2,
	2, 2431, 471, 3, 2, 2, 2, 2432, 2430, 3, 2, 2, 2, 2433, 2434, 7, 95, 2,
	2, 2434, 2435, 5, 232, 117, 2, 2435, 2436, 7, 43, 2, 2, 2436, 2437, 5,
	474, 238, 2, 2437, 2438, 7, 140, 2, 2, 2438, 473, 3, 2, 2, 2, 2439, 2441,
	5, 298, 150, 2, 2440, 2442, 5, 298, 150, 2, 2441, 2440, 3, 2, 2, 2, 2441,
	2442, 3, 2, 2, 2, 2442, 2444, 3, 2, 2, 2, 2443, 2445, 5, 132, 67, 2, 2444,
	2443, 3, 2, 2, 2, 2444, 2445, 3, 2, 2, 2, 2445, 2447, 3, 2, 2, 2, 2446,
	2448, 5, 490, 246, 2, 2447, 2446, 3, 2, 2, 2, 2447, 2448, 3, 2, 2, 2, 2448,
	475, 3, 2, 2, 2, 2449, 2454, 5, 232, 117, 2, 2450, 2454, 7, 128, 2, 2,
	2451, 2454, 7, 129, 2, 2, 2452, 2454, 7, 8, 2, 2, 2453, 2449, 3, 2, 2,
	2, 2453, 2450, 3, 2, 2, 2, 2453, 2451, 3, 2, 2, 2, 2453, 2452, 3, 2, 2,
	2, 2454, 477, 3, 2, 2, 2, 2455, 2458, 5, 294, 148, 2, 2456, 2458, 5, 16,
	9, 2, 2457, 2455, 3, 2, 2, 2, 2457, 2456, 3, 2, 2, 2, 2458, 479, 3, 2,
	2, 2, 2459, 2465, 5, 196, 99, 2, 2460, 2461, 5, 292, 147, 2, 2461, 2462,
	5, 196, 99, 2, 2462, 2464, 3, 2, 2, 2, 2463, 2460, 3, 2, 2, 2, 2464, 2467,
	3, 2, 2, 2, 2465, 2463, 3, 2, 2, 2, 2465, 2466, 3, 2, 2, 2, 2466, 481,
	3, 2, 2, 2, 2467, 2465, 3, 2, 2, 2, 2468, 2471, 5, 294, 148, 2, 2469, 2470,
	7, 99, 2, 2, 2470, 2472, 5, 294, 148, 2, 2471, 2469, 3, 2, 2, 2, 2471,
	2472, 3, 2, 2, 2, 2472, 483, 3, 2, 2, 2, 2473, 2474, 7, 96, 2, 2, 2474,
	2475, 5, 234, 118, 2, 2475, 2476, 7, 147, 2, 2, 2476, 2477, 5, 452, 227,
	2, 2477, 2478, 7, 140, 2, 2, 2478, 485, 3, 2, 2, 2, 2479, 2481, 5, 234,
	118, 2, 2480, 2482, 5, 490, 246, 2, 2481, 2480, 3, 2, 2, 2, 2481, 2482,
	3, 2, 2, 2, 2482, 2485, 3, 2, 2, 2, 2483, 2484, 7, 137, 2, 2, 2484, 2486,
	5, 194, 98, 2, 2485, 2483, 3, 2, 2, 2, 2485, 2486, 3, 2, 2, 2, 2486, 2487,
	3, 2, 2, 2, 2487, 2488, 7, 98, 2, 2, 2488, 487, 3, 2, 2, 2, 2489, 2490,
	7, 32, 2, 2, 2490, 2491, 5, 194, 98, 2, 2491, 489, 3, 2, 2, 2, 2492, 2493,
	7, 100, 2, 2, 2493, 2494, 5, 194, 98, 2, 2494, 491, 3, 2, 2, 2, 2495, 2496,
	7, 102, 2, 2, 2496, 2499, 5, 232, 117, 2, 2497, 2498, 7, 43, 2, 2, 2498,
	2500, 5, 494, 248, 2, 2499, 2497, 3, 2, 2, 2, 2499, 2500, 3, 2, 2, 2, 2500,
	2501, 3, 2, 2, 2, 2501, 2502, 7, 140, 2, 2, 2502, 493, 3, 2, 2, 2, 2503,
	2508, 5, 396, 199, 2, 2504, 2508, 5, 98, 50, 2, 2505, 2508, 5, 4, 3, 2,
	2506, 2508, 5, 204, 103, 2, 2507, 2503, 3, 2, 2, 2, 2507, 2504, 3, 2, 2,
	2, 2507, 2505, 3, 2, 2, 2, 2507, 2506, 3, 2, 2, 2, 2508, 495, 3, 2, 2,
	2, 2509, 2510, 7, 11, 2, 2, 2510, 2511, 7, 143, 2, 2, 2511, 2516, 5, 242,
	122, 2, 2512, 2513, 7, 141, 2, 2, 2513, 2515, 5, 242, 122, 2, 2514, 2512,
	3, 2, 2, 2, 2515, 2518, 3, 2, 2, 2, 2516, 2514, 3, 2, 2, 2, 2516, 2517,
	3, 2, 2, 2, 2517, 2519, 3, 2, 2, 2, 2518, 2516, 3, 2, 2, 2, 2519, 2520,
	7, 144, 2, 2, 2520, 2521, 7, 60, 2, 2, 2521, 2522, 5, 474, 238, 2, 2522,
	497, 3, 2, 2, 2, 2523, 2524, 7, 11, 2, 2, 2524, 2525, 7, 143, 2, 2, 2525,
	2530, 5, 242, 122, 2, 2526, 2527, 7, 141, 2, 2, 2527, 2529, 5, 242, 122,
	2, 2528, 2526, 3, 2, 2, 2, 2529, 2532, 3, 2, 2, 2, 2530, 2528, 3, 2, 2,
	2, 2530, 2531, 3, 2, 2, 2, 2531, 2533, 3, 2, 2, 2, 2532, 2530, 3, 2, 2,
	2, 2533, 2534, 7, 144, 2, 2, 2534, 2535, 7, 60, 2, 2, 2535, 2536, 5, 452,
	227, 2, 2536, 499, 3, 2, 2, 2, 2537, 2538, 7, 106, 2, 2, 2538, 2543, 5,
	298, 150, 2, 2539, 2540, 7, 141, 2, 2, 2540, 2542, 5, 298, 150, 2, 2541,
	2539, 3, 2, 2, 2, 2542, 2545, 3, 2, 2, 2, 2543, 2541, 3, 2, 2, 2, 2543,
	2544, 3, 2, 2, 2, 2544, 2546, 3, 2, 2, 2, 2545, 2543, 3, 2, 2, 2, 2546,
	2547, 7, 140, 2, 2, 2547, 501, 3, 2, 2, 2, 2548, 2550, 5, 274, 138, 2,
	2549, 2548, 3, 2, 2, 2, 2549, 2550, 3, 2, 2, 2, 2550, 2551, 3, 2, 2, 2,
	2551, 2552, 5, 478, 240, 2, 2552, 2553, 7, 137, 2, 2, 2553, 2554, 5, 194,
	98, 2, 2554, 2555, 7, 140, 2, 2, 2555, 503, 3, 2, 2, 2, 2556, 2558, 7,
	87, 2, 2, 2557, 2556, 3, 2, 2, 2, 2557, 2558, 3, 2, 2, 2, 2558, 2559, 3,
	2, 2, 2, 2559, 2560, 7, 107, 2, 2, 2560, 2561, 5, 234, 118, 2, 2561, 2562,
	7, 147, 2, 2, 2562, 2565, 5, 474, 238, 2, 2563, 2564, 7, 137, 2, 2, 2564,
	2566, 5, 194, 98, 2, 2565, 2563, 3, 2, 2, 2, 2565, 2566, 3, 2, 2, 2, 2566,
	2567, 3, 2, 2, 2, 2567, 2568, 7, 140, 2, 2, 2568, 505, 3, 2, 2, 2, 2569,
	2571, 5, 274, 138, 2, 2570, 2569, 3, 2, 2, 2, 2570, 2571, 3, 2, 2, 2, 2571,
	2572, 3, 2, 2, 2, 2572, 2574, 7, 108, 2, 2, 2573, 2575, 5, 406, 204, 2,
	2574, 2573, 3, 2, 2, 2, 2574, 2575, 3, 2, 2, 2, 2575, 2577, 3, 2, 2, 2,
	2576, 2578, 5, 110, 56, 2, 2577, 2576, 3, 2, 2, 2, 2577, 2578, 3, 2, 2,
	2, 2578, 2580, 3, 2, 2, 2, 2579, 2581, 5, 488, 245, 2, 2580, 2579, 3, 2,
	2, 2, 2580, 2581, 3, 2, 2, 2, 2581, 2582, 3, 2, 2, 2, 2582, 2583, 7, 140,
	2, 2, 2583, 507, 3, 2, 2, 2, 2584, 2589, 5, 510, 256, 2, 2585, 2586, 7,
	141, 2, 2, 2586, 2588, 5, 510, 256, 2, 2587, 2585, 3, 2, 2, 2, 2588, 2591,
	3, 2, 2, 2, 2589, 2587, 3, 2, 2, 2, 2589, 2590, 3, 2, 2, 2, 2590, 2594,
	3, 2, 2, 2, 2591, 2589, 3, 2, 2, 2, 2592, 2594, 7, 103, 2, 2, 2593, 2584,
	3, 2, 2, 2, 2593, 2592, 3, 2, 2, 2, 2594, 509, 3, 2, 2, 2, 2595, 2598,
	5, 194, 98, 2, 2596, 2597, 7, 6, 2, 2, 2597, 2599, 5, 194, 98, 2, 2598,
	2596, 3, 2, 2, 2, 2598, 2599, 3, 2, 2, 2, 2599, 511, 3, 2, 2, 2, 296, 519,
	523, 529, 539, 549, 558, 563, 570, 574, 579, 591, 594, 601, 607, 611, 615,
	618, 625, 630, 635, 639, 645, 649, 652, 660, 669, 684, 699, 702, 705, 712,
	718, 747, 752, 759, 761, 767, 769, 776, 779, 787, 790, 799, 806, 811, 814,
	820, 831, 839, 843, 847, 852, 860, 865, 878, 885, 893, 896, 905, 908, 911,
	916, 923, 926, 936, 940, 943, 946, 952, 956, 959, 963, 968, 971, 977, 980,
	984, 1002, 1004, 1015, 1018, 1025, 1030, 1035, 1048, 1064, 1069, 1074,
	1079, 1082, 1087, 1097, 1109, 1114, 1133, 1138, 1144, 1151, 1161, 1165,
	1168, 1192, 1197, 1202, 1205, 1208, 1215, 1220, 1229, 1234, 1240, 1244,
	1252, 1258, 1262, 1266, 1276, 1282, 1288, 1295, 1303, 1320, 1328, 1338,
	1342, 1347, 1353, 1361, 1374, 1385, 1392, 1422, 1426, 1439, 1444, 1449,
	1459, 1466, 1473, 1482, 1486, 1493, 1498, 1501, 1506, 1511, 1519, 1533,
	1541, 1549, 1556, 1561, 1566, 1570, 1574, 1580, 1584, 1588, 1596, 1601,
	1606, 1612, 1623, 1630, 1639, 1645, 1648, 1655, 1665, 1670, 1677, 1684,
	1691, 1702, 1710, 1720, 1727, 1731, 1735, 1741, 1749, 1752, 1755, 1765,
	1768, 1783, 1788, 1797, 1800, 1823, 1828, 1844, 1850, 1875, 1880, 1894,
	1899, 1905, 1913, 1916, 1934, 1939, 1943, 1946, 1953, 1956, 1963, 1967,
	1974, 1984, 1989, 1996, 2001, 2009, 2015, 2024, 2029, 2035, 2040, 2046,
	2051, 2057, 2062, 2066, 2080, 2084, 2110, 2121, 2127, 2142, 2148, 2154,
	2159, 2164, 2174, 2178, 2189, 2194, 2202, 2205, 2209, 2214, 2222, 2226,
	2232, 2242, 2250, 2255, 2260, 2273, 2278, 2283, 2288, 2292, 2300, 2309,
	2313, 2318, 2328, 2351, 2359, 2368, 2371, 2391, 2396, 2403, 2411, 2414,
	2422, 2430, 2441, 2444, 2447, 2453, 2457, 2465, 2471, 2481, 2485, 2499,
	2507, 2516, 2530, 2543, 2549, 2557, 2565, 2570, 2574, 2577, 2580, 2589,
	2593, 2598,
}
var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'\n'",
	"'\r'", "", "", "", "'**'", "'=='", "'<='", "'>='", "'=>'", "'/='", "':='",
	"'<>'", "'\"'", "';'", "','", "'&'", "'('", "')'", "'['", "']'", "':'",
	"'*'", "'/'", "'+'", "'-'", "'<'", "'>'", "'='", "'|'", "'.'", "'\\'",
	"", "", "", "", "", "", "'''",
}
var symbolicNames = []string{
	"", "ABS", "ACCESS", "ACROSS", "AFTER", "ALIAS", "ALL", "AND", "ARCHITECTURE",
	"ARRAY", "ASSERT", "ATTRIBUTE", "BEGIN", "BLOCK", "BODY", "BREAK", "BUFFER",
	"BUS", "CASE", "COMPONENT", "CONFIGURATION", "CONSTANT", "DISCONNECT",
	"DOWNTO", "END", "ENTITY", "ELSE", "ELSIF", "EXIT", "FILE", "FOR", "FUNCTION",
	"GENERATE", "GENERIC", "GROUP", "GUARDED", "IF", "IMPURE", "IN", "INERTIAL",
	"INOUT", "IS", "LABEL", "LIBRARY", "LIMIT", "LINKAGE", "LITERAL", "LOOP",
	"MAP", "MOD", "NAND", "NATURE", "NEW", "NEXT", "NOISE", "NOR", "NOT", "NULL_",
	"OF", "ON", "OPEN", "OR", "OTHERS", "OUT", "PACKAGE", "PORT", "POSTPONED",
	"PROCESS", "PROCEDURE", "PROCEDURAL", "PURE", "QUANTITY", "RANGE", "REVERSE_RANGE",
	"REJECT", "REM", "RECORD", "REFERENCE", "REGISTER", "REPORT", "RETURN",
	"ROL", "ROR", "SELECT", "SEVERITY", "SHARED", "SIGNAL", "SLA", "SLL", "SPECTRUM",
	"SRA", "SRL", "SUBNATURE", "SUBTYPE", "TERMINAL", "THEN", "THROUGH", "TO",
	"TOLERANCE", "TRANSPORT", "TYPE", "UNAFFECTED", "UNITS", "UNTIL", "USE",
	"VARIABLE", "WAIT", "WITH", "WHEN", "WHILE", "XNOR", "XOR", "BASE_LITERAL",
	"BIT_STRING_LITERAL", "BIT_STRING_LITERAL_BINARY", "BIT_STRING_LITERAL_OCTAL",
	"BIT_STRING_LITERAL_HEX", "REAL_LITERAL", "BASIC_IDENTIFIER", "EXTENDED_IDENTIFIER",
	"LETTER", "COMMENT", "TAB", "SPACE", "NEWLINE", "CR", "CHARACTER_LITERAL",
	"STRING_LITERAL", "OTHER_SPECIAL_CHARACTER", "DOUBLESTAR", "ASSIGN", "LE",
	"GE", "ARROW", "NEQ", "VARASGN", "BOX", "DBLQUOTE", "SEMI", "COMMA", "AMPERSAND",
	"LPAREN", "RPAREN", "LBRACKET", "RBRACKET", "COLON", "MUL", "DIV", "PLUS",
	"MINUS", "LOWERTHAN", "GREATERTHAN", "EQ", "BAR", "DOT", "BACKSLASH", "EXPONENT",
	"HEXDIGIT", "INTEGER", "DIGIT", "BASED_INTEGER", "EXTENDED_DIGIT", "APOSTROPHE",
}

var ruleNames = []string{
	"abstract_literal", "access_type_definition", "across_aspect", "actual_designator",
	"actual_parameter_part", "actual_part", "adding_operator", "aggregate",
	"alias_declaration", "alias_designator", "alias_indication", "allocator",
	"architecture_body", "architecture_declarative_part", "architecture_statement",
	"architecture_statement_part", "array_nature_definition", "array_type_definition",
	"assertion", "assertion_statement", "association_element", "association_list",
	"attribute_declaration", "attribute_designator", "attribute_specification",
	"base_unit_declaration", "binding_indication", "block_configuration", "block_declarative_item",
	"block_declarative_part", "block_header", "block_specification", "block_statement",
	"block_statement_part", "branch_quantity_declaration", "break_element",
	"break_list", "break_selector_clause", "break_statement", "case_statement",
	"case_statement_alternative", "choice", "choices", "component_configuration",
	"component_declaration", "component_instantiation_statement", "component_specification",
	"composite_nature_definition", "composite_type_definition", "concurrent_assertion_statement",
	"concurrent_break_statement", "concurrent_procedure_call_statement", "concurrent_signal_assignment_statement",
	"condition", "condition_clause", "conditional_signal_assignment", "conditional_waveforms",
	"configuration_declaration", "configuration_declarative_item", "configuration_declarative_part",
	"configuration_item", "configuration_specification", "constant_declaration",
	"constrained_array_definition", "constrained_nature_definition", "constraint",
	"context_clause", "context_item", "delay_mechanism", "design_file", "design_unit",
	"designator", "direction", "disconnection_specification", "discrete_range",
	"element_association", "element_declaration", "element_subnature_definition",
	"element_subtype_definition", "entity_aspect", "entity_class", "entity_class_entry",
	"entity_class_entry_list", "entity_declaration", "entity_declarative_item",
	"entity_declarative_part", "entity_designator", "entity_header", "entity_name_list",
	"entity_specification", "entity_statement", "entity_statement_part", "entity_tag",
	"enumeration_literal", "enumeration_type_definition", "exit_statement",
	"expression", "factor", "file_declaration", "file_logical_name", "file_open_information",
	"file_type_definition", "formal_parameter_list", "formal_part", "free_quantity_declaration",
	"generate_statement", "generation_scheme", "generic_clause", "generic_list",
	"generic_map_aspect", "group_constituent", "group_constituent_list", "group_declaration",
	"group_template_declaration", "guarded_signal_specification", "identifier",
	"identifier_list", "if_statement", "index_constraint", "index_specification",
	"index_subtype_definition", "instantiated_unit", "instantiation_list",
	"interface_constant_declaration", "interface_declaration", "interface_element",
	"interface_file_declaration", "interface_signal_list", "interface_port_list",
	"interface_list", "interface_quantity_declaration", "interface_port_declaration",
	"interface_signal_declaration", "interface_terminal_declaration", "interface_variable_declaration",
	"iteration_scheme", "label_colon", "library_clause", "library_unit", "literal",
	"logical_name", "logical_name_list", "logical_operator", "loop_statement",
	"signal_mode", "multiplying_operator", "name", "name_part", "selected_name",
	"selected_name_part", "function_call_or_indexed_name_part", "slice_name_part",
	"attribute_name_part", "nature_declaration", "nature_definition", "nature_element_declaration",
	"next_statement", "numeric_literal", "object_declaration", "opts", "package_body",
	"package_body_declarative_item", "package_body_declarative_part", "package_declaration",
	"package_declarative_item", "package_declarative_part", "parameter_specification",
	"physical_literal", "physical_type_definition", "port_clause", "port_list",
	"port_map_aspect", "primary", "primary_unit", "procedural_declarative_item",
	"procedural_declarative_part", "procedural_statement_part", "procedure_call",
	"procedure_call_statement", "process_declarative_item", "process_declarative_part",
	"process_statement", "process_statement_part", "qualified_expression",
	"quantity_declaration", "quantity_list", "quantity_specification", "range_decl",
	"explicit_range", "range_constraint", "record_nature_definition", "record_type_definition",
	"relation", "relational_operator", "report_statement", "return_statement",
	"scalar_nature_definition", "scalar_type_definition", "secondary_unit",
	"secondary_unit_declaration", "selected_signal_assignment", "selected_waveforms",
	"sensitivity_clause", "sensitivity_list", "sequence_of_statements", "sequential_statement",
	"shift_expression", "shift_operator", "signal_assignment_statement", "signal_declaration",
	"signal_kind", "signal_list", "signature", "simple_expression", "simple_simultaneous_statement",
	"simultaneous_alternative", "simultaneous_case_statement", "simultaneous_if_statement",
	"simultaneous_procedural_statement", "simultaneous_statement", "simultaneous_statement_part",
	"source_aspect", "source_quantity_declaration", "step_limit_specification",
	"subnature_declaration", "subnature_indication", "subprogram_body", "subprogram_declaration",
	"subprogram_declarative_item", "subprogram_declarative_part", "subprogram_kind",
	"subprogram_specification", "procedure_specification", "function_specification",
	"subprogram_statement_part", "subtype_declaration", "subtype_indication",
	"suffix", "target", "term", "terminal_aspect", "terminal_declaration",
	"through_aspect", "timeout_clause", "tolerance_aspect", "type_declaration",
	"type_definition", "unconstrained_array_definition", "unconstrained_nature_definition",
	"use_clause", "variable_assignment_statement", "variable_declaration",
	"wait_statement", "waveform", "waveform_element",
}

type vhdlParser struct {
	*antlr.BaseParser
}

// NewvhdlParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *vhdlParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewvhdlParser(input antlr.TokenStream) *vhdlParser {
	this := new(vhdlParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "vhdl.g4"

	return this
}

// vhdlParser tokens.
const (
	vhdlParserEOF                       = antlr.TokenEOF
	vhdlParserABS                       = 1
	vhdlParserACCESS                    = 2
	vhdlParserACROSS                    = 3
	vhdlParserAFTER                     = 4
	vhdlParserALIAS                     = 5
	vhdlParserALL                       = 6
	vhdlParserAND                       = 7
	vhdlParserARCHITECTURE              = 8
	vhdlParserARRAY                     = 9
	vhdlParserASSERT                    = 10
	vhdlParserATTRIBUTE                 = 11
	vhdlParserBEGIN                     = 12
	vhdlParserBLOCK                     = 13
	vhdlParserBODY                      = 14
	vhdlParserBREAK                     = 15
	vhdlParserBUFFER                    = 16
	vhdlParserBUS                       = 17
	vhdlParserCASE                      = 18
	vhdlParserCOMPONENT                 = 19
	vhdlParserCONFIGURATION             = 20
	vhdlParserCONSTANT                  = 21
	vhdlParserDISCONNECT                = 22
	vhdlParserDOWNTO                    = 23
	vhdlParserEND                       = 24
	vhdlParserENTITY                    = 25
	vhdlParserELSE                      = 26
	vhdlParserELSIF                     = 27
	vhdlParserEXIT                      = 28
	vhdlParserFILE                      = 29
	vhdlParserFOR                       = 30
	vhdlParserFUNCTION                  = 31
	vhdlParserGENERATE                  = 32
	vhdlParserGENERIC                   = 33
	vhdlParserGROUP                     = 34
	vhdlParserGUARDED                   = 35
	vhdlParserIF                        = 36
	vhdlParserIMPURE                    = 37
	vhdlParserIN                        = 38
	vhdlParserINERTIAL                  = 39
	vhdlParserINOUT                     = 40
	vhdlParserIS                        = 41
	vhdlParserLABEL                     = 42
	vhdlParserLIBRARY                   = 43
	vhdlParserLIMIT                     = 44
	vhdlParserLINKAGE                   = 45
	vhdlParserLITERAL                   = 46
	vhdlParserLOOP                      = 47
	vhdlParserMAP                       = 48
	vhdlParserMOD                       = 49
	vhdlParserNAND                      = 50
	vhdlParserNATURE                    = 51
	vhdlParserNEW                       = 52
	vhdlParserNEXT                      = 53
	vhdlParserNOISE                     = 54
	vhdlParserNOR                       = 55
	vhdlParserNOT                       = 56
	vhdlParserNULL_                     = 57
	vhdlParserOF                        = 58
	vhdlParserON                        = 59
	vhdlParserOPEN                      = 60
	vhdlParserOR                        = 61
	vhdlParserOTHERS                    = 62
	vhdlParserOUT                       = 63
	vhdlParserPACKAGE                   = 64
	vhdlParserPORT                      = 65
	vhdlParserPOSTPONED                 = 66
	vhdlParserPROCESS                   = 67
	vhdlParserPROCEDURE                 = 68
	vhdlParserPROCEDURAL                = 69
	vhdlParserPURE                      = 70
	vhdlParserQUANTITY                  = 71
	vhdlParserRANGE                     = 72
	vhdlParserREVERSE_RANGE             = 73
	vhdlParserREJECT                    = 74
	vhdlParserREM                       = 75
	vhdlParserRECORD                    = 76
	vhdlParserREFERENCE                 = 77
	vhdlParserREGISTER                  = 78
	vhdlParserREPORT                    = 79
	vhdlParserRETURN                    = 80
	vhdlParserROL                       = 81
	vhdlParserROR                       = 82
	vhdlParserSELECT                    = 83
	vhdlParserSEVERITY                  = 84
	vhdlParserSHARED                    = 85
	vhdlParserSIGNAL                    = 86
	vhdlParserSLA                       = 87
	vhdlParserSLL                       = 88
	vhdlParserSPECTRUM                  = 89
	vhdlParserSRA                       = 90
	vhdlParserSRL                       = 91
	vhdlParserSUBNATURE                 = 92
	vhdlParserSUBTYPE                   = 93
	vhdlParserTERMINAL                  = 94
	vhdlParserTHEN                      = 95
	vhdlParserTHROUGH                   = 96
	vhdlParserTO                        = 97
	vhdlParserTOLERANCE                 = 98
	vhdlParserTRANSPORT                 = 99
	vhdlParserTYPE                      = 100
	vhdlParserUNAFFECTED                = 101
	vhdlParserUNITS                     = 102
	vhdlParserUNTIL                     = 103
	vhdlParserUSE                       = 104
	vhdlParserVARIABLE                  = 105
	vhdlParserWAIT                      = 106
	vhdlParserWITH                      = 107
	vhdlParserWHEN                      = 108
	vhdlParserWHILE                     = 109
	vhdlParserXNOR                      = 110
	vhdlParserXOR                       = 111
	vhdlParserBASE_LITERAL              = 112
	vhdlParserBIT_STRING_LITERAL        = 113
	vhdlParserBIT_STRING_LITERAL_BINARY = 114
	vhdlParserBIT_STRING_LITERAL_OCTAL  = 115
	vhdlParserBIT_STRING_LITERAL_HEX    = 116
	vhdlParserREAL_LITERAL              = 117
	vhdlParserBASIC_IDENTIFIER          = 118
	vhdlParserEXTENDED_IDENTIFIER       = 119
	vhdlParserLETTER                    = 120
	vhdlParserCOMMENT                   = 121
	vhdlParserTAB                       = 122
	vhdlParserSPACE                     = 123
	vhdlParserNEWLINE                   = 124
	vhdlParserCR                        = 125
	vhdlParserCHARACTER_LITERAL         = 126
	vhdlParserSTRING_LITERAL            = 127
	vhdlParserOTHER_SPECIAL_CHARACTER   = 128
	vhdlParserDOUBLESTAR                = 129
	vhdlParserASSIGN                    = 130
	vhdlParserLE                        = 131
	vhdlParserGE                        = 132
	vhdlParserARROW                     = 133
	vhdlParserNEQ                       = 134
	vhdlParserVARASGN                   = 135
	vhdlParserBOX                       = 136
	vhdlParserDBLQUOTE                  = 137
	vhdlParserSEMI                      = 138
	vhdlParserCOMMA                     = 139
	vhdlParserAMPERSAND                 = 140
	vhdlParserLPAREN                    = 141
	vhdlParserRPAREN                    = 142
	vhdlParserLBRACKET                  = 143
	vhdlParserRBRACKET                  = 144
	vhdlParserCOLON                     = 145
	vhdlParserMUL                       = 146
	vhdlParserDIV                       = 147
	vhdlParserPLUS                      = 148
	vhdlParserMINUS                     = 149
	vhdlParserLOWERTHAN                 = 150
	vhdlParserGREATERTHAN               = 151
	vhdlParserEQ                        = 152
	vhdlParserBAR                       = 153
	vhdlParserDOT                       = 154
	vhdlParserBACKSLASH                 = 155
	vhdlParserEXPONENT                  = 156
	vhdlParserHEXDIGIT                  = 157
	vhdlParserINTEGER                   = 158
	vhdlParserDIGIT                     = 159
	vhdlParserBASED_INTEGER             = 160
	vhdlParserEXTENDED_DIGIT            = 161
	vhdlParserAPOSTROPHE                = 162
)

// vhdlParser rules.
const (
	vhdlParserRULE_abstract_literal                       = 0
	vhdlParserRULE_access_type_definition                 = 1
	vhdlParserRULE_across_aspect                          = 2
	vhdlParserRULE_actual_designator                      = 3
	vhdlParserRULE_actual_parameter_part                  = 4
	vhdlParserRULE_actual_part                            = 5
	vhdlParserRULE_adding_operator                        = 6
	vhdlParserRULE_aggregate                              = 7
	vhdlParserRULE_alias_declaration                      = 8
	vhdlParserRULE_alias_designator                       = 9
	vhdlParserRULE_alias_indication                       = 10
	vhdlParserRULE_allocator                              = 11
	vhdlParserRULE_architecture_body                      = 12
	vhdlParserRULE_architecture_declarative_part          = 13
	vhdlParserRULE_architecture_statement                 = 14
	vhdlParserRULE_architecture_statement_part            = 15
	vhdlParserRULE_array_nature_definition                = 16
	vhdlParserRULE_array_type_definition                  = 17
	vhdlParserRULE_assertion                              = 18
	vhdlParserRULE_assertion_statement                    = 19
	vhdlParserRULE_association_element                    = 20
	vhdlParserRULE_association_list                       = 21
	vhdlParserRULE_attribute_declaration                  = 22
	vhdlParserRULE_attribute_designator                   = 23
	vhdlParserRULE_attribute_specification                = 24
	vhdlParserRULE_base_unit_declaration                  = 25
	vhdlParserRULE_binding_indication                     = 26
	vhdlParserRULE_block_configuration                    = 27
	vhdlParserRULE_block_declarative_item                 = 28
	vhdlParserRULE_block_declarative_part                 = 29
	vhdlParserRULE_block_header                           = 30
	vhdlParserRULE_block_specification                    = 31
	vhdlParserRULE_block_statement                        = 32
	vhdlParserRULE_block_statement_part                   = 33
	vhdlParserRULE_branch_quantity_declaration            = 34
	vhdlParserRULE_break_element                          = 35
	vhdlParserRULE_break_list                             = 36
	vhdlParserRULE_break_selector_clause                  = 37
	vhdlParserRULE_break_statement                        = 38
	vhdlParserRULE_case_statement                         = 39
	vhdlParserRULE_case_statement_alternative             = 40
	vhdlParserRULE_choice                                 = 41
	vhdlParserRULE_choices                                = 42
	vhdlParserRULE_component_configuration                = 43
	vhdlParserRULE_component_declaration                  = 44
	vhdlParserRULE_component_instantiation_statement      = 45
	vhdlParserRULE_component_specification                = 46
	vhdlParserRULE_composite_nature_definition            = 47
	vhdlParserRULE_composite_type_definition              = 48
	vhdlParserRULE_concurrent_assertion_statement         = 49
	vhdlParserRULE_concurrent_break_statement             = 50
	vhdlParserRULE_concurrent_procedure_call_statement    = 51
	vhdlParserRULE_concurrent_signal_assignment_statement = 52
	vhdlParserRULE_condition                              = 53
	vhdlParserRULE_condition_clause                       = 54
	vhdlParserRULE_conditional_signal_assignment          = 55
	vhdlParserRULE_conditional_waveforms                  = 56
	vhdlParserRULE_configuration_declaration              = 57
	vhdlParserRULE_configuration_declarative_item         = 58
	vhdlParserRULE_configuration_declarative_part         = 59
	vhdlParserRULE_configuration_item                     = 60
	vhdlParserRULE_configuration_specification            = 61
	vhdlParserRULE_constant_declaration                   = 62
	vhdlParserRULE_constrained_array_definition           = 63
	vhdlParserRULE_constrained_nature_definition          = 64
	vhdlParserRULE_constraint                             = 65
	vhdlParserRULE_context_clause                         = 66
	vhdlParserRULE_context_item                           = 67
	vhdlParserRULE_delay_mechanism                        = 68
	vhdlParserRULE_design_file                            = 69
	vhdlParserRULE_design_unit                            = 70
	vhdlParserRULE_designator                             = 71
	vhdlParserRULE_direction                              = 72
	vhdlParserRULE_disconnection_specification            = 73
	vhdlParserRULE_discrete_range                         = 74
	vhdlParserRULE_element_association                    = 75
	vhdlParserRULE_element_declaration                    = 76
	vhdlParserRULE_element_subnature_definition           = 77
	vhdlParserRULE_element_subtype_definition             = 78
	vhdlParserRULE_entity_aspect                          = 79
	vhdlParserRULE_entity_class                           = 80
	vhdlParserRULE_entity_class_entry                     = 81
	vhdlParserRULE_entity_class_entry_list                = 82
	vhdlParserRULE_entity_declaration                     = 83
	vhdlParserRULE_entity_declarative_item                = 84
	vhdlParserRULE_entity_declarative_part                = 85
	vhdlParserRULE_entity_designator                      = 86
	vhdlParserRULE_entity_header                          = 87
	vhdlParserRULE_entity_name_list                       = 88
	vhdlParserRULE_entity_specification                   = 89
	vhdlParserRULE_entity_statement                       = 90
	vhdlParserRULE_entity_statement_part                  = 91
	vhdlParserRULE_entity_tag                             = 92
	vhdlParserRULE_enumeration_literal                    = 93
	vhdlParserRULE_enumeration_type_definition            = 94
	vhdlParserRULE_exit_statement                         = 95
	vhdlParserRULE_expression                             = 96
	vhdlParserRULE_factor                                 = 97
	vhdlParserRULE_file_declaration                       = 98
	vhdlParserRULE_file_logical_name                      = 99
	vhdlParserRULE_file_open_information                  = 100
	vhdlParserRULE_file_type_definition                   = 101
	vhdlParserRULE_formal_parameter_list                  = 102
	vhdlParserRULE_formal_part                            = 103
	vhdlParserRULE_free_quantity_declaration              = 104
	vhdlParserRULE_generate_statement                     = 105
	vhdlParserRULE_generation_scheme                      = 106
	vhdlParserRULE_generic_clause                         = 107
	vhdlParserRULE_generic_list                           = 108
	vhdlParserRULE_generic_map_aspect                     = 109
	vhdlParserRULE_group_constituent                      = 110
	vhdlParserRULE_group_constituent_list                 = 111
	vhdlParserRULE_group_declaration                      = 112
	vhdlParserRULE_group_template_declaration             = 113
	vhdlParserRULE_guarded_signal_specification           = 114
	vhdlParserRULE_identifier                             = 115
	vhdlParserRULE_identifier_list                        = 116
	vhdlParserRULE_if_statement                           = 117
	vhdlParserRULE_index_constraint                       = 118
	vhdlParserRULE_index_specification                    = 119
	vhdlParserRULE_index_subtype_definition               = 120
	vhdlParserRULE_instantiated_unit                      = 121
	vhdlParserRULE_instantiation_list                     = 122
	vhdlParserRULE_interface_constant_declaration         = 123
	vhdlParserRULE_interface_declaration                  = 124
	vhdlParserRULE_interface_element                      = 125
	vhdlParserRULE_interface_file_declaration             = 126
	vhdlParserRULE_interface_signal_list                  = 127
	vhdlParserRULE_interface_port_list                    = 128
	vhdlParserRULE_interface_list                         = 129
	vhdlParserRULE_interface_quantity_declaration         = 130
	vhdlParserRULE_interface_port_declaration             = 131
	vhdlParserRULE_interface_signal_declaration           = 132
	vhdlParserRULE_interface_terminal_declaration         = 133
	vhdlParserRULE_interface_variable_declaration         = 134
	vhdlParserRULE_iteration_scheme                       = 135
	vhdlParserRULE_label_colon                            = 136
	vhdlParserRULE_library_clause                         = 137
	vhdlParserRULE_library_unit                           = 138
	vhdlParserRULE_literal                                = 139
	vhdlParserRULE_logical_name                           = 140
	vhdlParserRULE_logical_name_list                      = 141
	vhdlParserRULE_logical_operator                       = 142
	vhdlParserRULE_loop_statement                         = 143
	vhdlParserRULE_signal_mode                            = 144
	vhdlParserRULE_multiplying_operator                   = 145
	vhdlParserRULE_name                                   = 146
	vhdlParserRULE_name_part                              = 147
	vhdlParserRULE_selected_name                          = 148
	vhdlParserRULE_selected_name_part                     = 149
	vhdlParserRULE_function_call_or_indexed_name_part     = 150
	vhdlParserRULE_slice_name_part                        = 151
	vhdlParserRULE_attribute_name_part                    = 152
	vhdlParserRULE_nature_declaration                     = 153
	vhdlParserRULE_nature_definition                      = 154
	vhdlParserRULE_nature_element_declaration             = 155
	vhdlParserRULE_next_statement                         = 156
	vhdlParserRULE_numeric_literal                        = 157
	vhdlParserRULE_object_declaration                     = 158
	vhdlParserRULE_opts                                   = 159
	vhdlParserRULE_package_body                           = 160
	vhdlParserRULE_package_body_declarative_item          = 161
	vhdlParserRULE_package_body_declarative_part          = 162
	vhdlParserRULE_package_declaration                    = 163
	vhdlParserRULE_package_declarative_item               = 164
	vhdlParserRULE_package_declarative_part               = 165
	vhdlParserRULE_parameter_specification                = 166
	vhdlParserRULE_physical_literal                       = 167
	vhdlParserRULE_physical_type_definition               = 168
	vhdlParserRULE_port_clause                            = 169
	vhdlParserRULE_port_list                              = 170
	vhdlParserRULE_port_map_aspect                        = 171
	vhdlParserRULE_primary                                = 172
	vhdlParserRULE_primary_unit                           = 173
	vhdlParserRULE_procedural_declarative_item            = 174
	vhdlParserRULE_procedural_declarative_part            = 175
	vhdlParserRULE_procedural_statement_part              = 176
	vhdlParserRULE_procedure_call                         = 177
	vhdlParserRULE_procedure_call_statement               = 178
	vhdlParserRULE_process_declarative_item               = 179
	vhdlParserRULE_process_declarative_part               = 180
	vhdlParserRULE_process_statement                      = 181
	vhdlParserRULE_process_statement_part                 = 182
	vhdlParserRULE_qualified_expression                   = 183
	vhdlParserRULE_quantity_declaration                   = 184
	vhdlParserRULE_quantity_list                          = 185
	vhdlParserRULE_quantity_specification                 = 186
	vhdlParserRULE_range_decl                             = 187
	vhdlParserRULE_explicit_range                         = 188
	vhdlParserRULE_range_constraint                       = 189
	vhdlParserRULE_record_nature_definition               = 190
	vhdlParserRULE_record_type_definition                 = 191
	vhdlParserRULE_relation                               = 192
	vhdlParserRULE_relational_operator                    = 193
	vhdlParserRULE_report_statement                       = 194
	vhdlParserRULE_return_statement                       = 195
	vhdlParserRULE_scalar_nature_definition               = 196
	vhdlParserRULE_scalar_type_definition                 = 197
	vhdlParserRULE_secondary_unit                         = 198
	vhdlParserRULE_secondary_unit_declaration             = 199
	vhdlParserRULE_selected_signal_assignment             = 200
	vhdlParserRULE_selected_waveforms                     = 201
	vhdlParserRULE_sensitivity_clause                     = 202
	vhdlParserRULE_sensitivity_list                       = 203
	vhdlParserRULE_sequence_of_statements                 = 204
	vhdlParserRULE_sequential_statement                   = 205
	vhdlParserRULE_shift_expression                       = 206
	vhdlParserRULE_shift_operator                         = 207
	vhdlParserRULE_signal_assignment_statement            = 208
	vhdlParserRULE_signal_declaration                     = 209
	vhdlParserRULE_signal_kind                            = 210
	vhdlParserRULE_signal_list                            = 211
	vhdlParserRULE_signature                              = 212
	vhdlParserRULE_simple_expression                      = 213
	vhdlParserRULE_simple_simultaneous_statement          = 214
	vhdlParserRULE_simultaneous_alternative               = 215
	vhdlParserRULE_simultaneous_case_statement            = 216
	vhdlParserRULE_simultaneous_if_statement              = 217
	vhdlParserRULE_simultaneous_procedural_statement      = 218
	vhdlParserRULE_simultaneous_statement                 = 219
	vhdlParserRULE_simultaneous_statement_part            = 220
	vhdlParserRULE_source_aspect                          = 221
	vhdlParserRULE_source_quantity_declaration            = 222
	vhdlParserRULE_step_limit_specification               = 223
	vhdlParserRULE_subnature_declaration                  = 224
	vhdlParserRULE_subnature_indication                   = 225
	vhdlParserRULE_subprogram_body                        = 226
	vhdlParserRULE_subprogram_declaration                 = 227
	vhdlParserRULE_subprogram_declarative_item            = 228
	vhdlParserRULE_subprogram_declarative_part            = 229
	vhdlParserRULE_subprogram_kind                        = 230
	vhdlParserRULE_subprogram_specification               = 231
	vhdlParserRULE_procedure_specification                = 232
	vhdlParserRULE_function_specification                 = 233
	vhdlParserRULE_subprogram_statement_part              = 234
	vhdlParserRULE_subtype_declaration                    = 235
	vhdlParserRULE_subtype_indication                     = 236
	vhdlParserRULE_suffix                                 = 237
	vhdlParserRULE_target                                 = 238
	vhdlParserRULE_term                                   = 239
	vhdlParserRULE_terminal_aspect                        = 240
	vhdlParserRULE_terminal_declaration                   = 241
	vhdlParserRULE_through_aspect                         = 242
	vhdlParserRULE_timeout_clause                         = 243
	vhdlParserRULE_tolerance_aspect                       = 244
	vhdlParserRULE_type_declaration                       = 245
	vhdlParserRULE_type_definition                        = 246
	vhdlParserRULE_unconstrained_array_definition         = 247
	vhdlParserRULE_unconstrained_nature_definition        = 248
	vhdlParserRULE_use_clause                             = 249
	vhdlParserRULE_variable_assignment_statement          = 250
	vhdlParserRULE_variable_declaration                   = 251
	vhdlParserRULE_wait_statement                         = 252
	vhdlParserRULE_waveform                               = 253
	vhdlParserRULE_waveform_element                       = 254
)

// IAbstract_literalContext is an interface to support dynamic dispatch.
type IAbstract_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_literalContext differentiates from other interfaces.
	IsAbstract_literalContext()
}

type Abstract_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_literalContext() *Abstract_literalContext {
	var p = new(Abstract_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_abstract_literal
	return p
}

func (*Abstract_literalContext) IsAbstract_literalContext() {}

func NewAbstract_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_literalContext {
	var p = new(Abstract_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_abstract_literal

	return p
}

func (s *Abstract_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_literalContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(vhdlParserINTEGER, 0)
}

func (s *Abstract_literalContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserREAL_LITERAL, 0)
}

func (s *Abstract_literalContext) BASE_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserBASE_LITERAL, 0)
}

func (s *Abstract_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Abstract_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAbstract_literal(s)
	}
}

func (s *Abstract_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAbstract_literal(s)
	}
}

func (p *vhdlParser) Abstract_literal() (localctx IAbstract_literalContext) {
	this := p
	_ = this

	localctx = NewAbstract_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, vhdlParserRULE_abstract_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserBASE_LITERAL || _la == vhdlParserREAL_LITERAL || _la == vhdlParserINTEGER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAccess_type_definitionContext is an interface to support dynamic dispatch.
type IAccess_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccess_type_definitionContext differentiates from other interfaces.
	IsAccess_type_definitionContext()
}

type Access_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccess_type_definitionContext() *Access_type_definitionContext {
	var p = new(Access_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_access_type_definition
	return p
}

func (*Access_type_definitionContext) IsAccess_type_definitionContext() {}

func NewAccess_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_type_definitionContext {
	var p = new(Access_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_access_type_definition

	return p
}

func (s *Access_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_type_definitionContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACCESS, 0)
}

func (s *Access_type_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Access_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAccess_type_definition(s)
	}
}

func (s *Access_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAccess_type_definition(s)
	}
}

func (p *vhdlParser) Access_type_definition() (localctx IAccess_type_definitionContext) {
	this := p
	_ = this

	localctx = NewAccess_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, vhdlParserRULE_access_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(512)
		p.Match(vhdlParserACCESS)
	}
	{
		p.SetState(513)
		p.Subtype_indication()
	}

	return localctx
}

// IAcross_aspectContext is an interface to support dynamic dispatch.
type IAcross_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcross_aspectContext differentiates from other interfaces.
	IsAcross_aspectContext()
}

type Across_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcross_aspectContext() *Across_aspectContext {
	var p = new(Across_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_across_aspect
	return p
}

func (*Across_aspectContext) IsAcross_aspectContext() {}

func NewAcross_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Across_aspectContext {
	var p = new(Across_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_across_aspect

	return p
}

func (s *Across_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Across_aspectContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Across_aspectContext) ACROSS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACROSS, 0)
}

func (s *Across_aspectContext) Tolerance_aspect() ITolerance_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITolerance_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITolerance_aspectContext)
}

func (s *Across_aspectContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Across_aspectContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Across_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Across_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Across_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAcross_aspect(s)
	}
}

func (s *Across_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAcross_aspect(s)
	}
}

func (p *vhdlParser) Across_aspect() (localctx IAcross_aspectContext) {
	this := p
	_ = this

	localctx = NewAcross_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, vhdlParserRULE_across_aspect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.Identifier_list()
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTOLERANCE {
		{
			p.SetState(516)
			p.Tolerance_aspect()
		}

	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(519)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(520)
			p.Expression()
		}

	}
	{
		p.SetState(523)
		p.Match(vhdlParserACROSS)
	}

	return localctx
}

// IActual_designatorContext is an interface to support dynamic dispatch.
type IActual_designatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActual_designatorContext differentiates from other interfaces.
	IsActual_designatorContext()
}

type Actual_designatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActual_designatorContext() *Actual_designatorContext {
	var p = new(Actual_designatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_actual_designator
	return p
}

func (*Actual_designatorContext) IsActual_designatorContext() {}

func NewActual_designatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Actual_designatorContext {
	var p = new(Actual_designatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_actual_designator

	return p
}

func (s *Actual_designatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Actual_designatorContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Actual_designatorContext) OPEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserOPEN, 0)
}

func (s *Actual_designatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Actual_designatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Actual_designatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterActual_designator(s)
	}
}

func (s *Actual_designatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitActual_designator(s)
	}
}

func (p *vhdlParser) Actual_designator() (localctx IActual_designatorContext) {
	this := p
	_ = this

	localctx = NewActual_designatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, vhdlParserRULE_actual_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(527)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserABS, vhdlParserNEW, vhdlParserNOT, vhdlParserNULL_, vhdlParserBASE_LITERAL, vhdlParserBIT_STRING_LITERAL, vhdlParserREAL_LITERAL, vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL, vhdlParserSTRING_LITERAL, vhdlParserLPAREN, vhdlParserPLUS, vhdlParserMINUS, vhdlParserINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(525)
			p.Expression()
		}

	case vhdlParserOPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(526)
			p.Match(vhdlParserOPEN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IActual_parameter_partContext is an interface to support dynamic dispatch.
type IActual_parameter_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActual_parameter_partContext differentiates from other interfaces.
	IsActual_parameter_partContext()
}

type Actual_parameter_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActual_parameter_partContext() *Actual_parameter_partContext {
	var p = new(Actual_parameter_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_actual_parameter_part
	return p
}

func (*Actual_parameter_partContext) IsActual_parameter_partContext() {}

func NewActual_parameter_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Actual_parameter_partContext {
	var p = new(Actual_parameter_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_actual_parameter_part

	return p
}

func (s *Actual_parameter_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Actual_parameter_partContext) Association_list() IAssociation_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociation_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssociation_listContext)
}

func (s *Actual_parameter_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Actual_parameter_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Actual_parameter_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterActual_parameter_part(s)
	}
}

func (s *Actual_parameter_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitActual_parameter_part(s)
	}
}

func (p *vhdlParser) Actual_parameter_part() (localctx IActual_parameter_partContext) {
	this := p
	_ = this

	localctx = NewActual_parameter_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, vhdlParserRULE_actual_parameter_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.Association_list()
	}

	return localctx
}

// IActual_partContext is an interface to support dynamic dispatch.
type IActual_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActual_partContext differentiates from other interfaces.
	IsActual_partContext()
}

type Actual_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActual_partContext() *Actual_partContext {
	var p = new(Actual_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_actual_part
	return p
}

func (*Actual_partContext) IsActual_partContext() {}

func NewActual_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Actual_partContext {
	var p = new(Actual_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_actual_part

	return p
}

func (s *Actual_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Actual_partContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Actual_partContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Actual_partContext) Actual_designator() IActual_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActual_designatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActual_designatorContext)
}

func (s *Actual_partContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Actual_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Actual_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Actual_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterActual_part(s)
	}
}

func (s *Actual_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitActual_part(s)
	}
}

func (p *vhdlParser) Actual_part() (localctx IActual_partContext) {
	this := p
	_ = this

	localctx = NewActual_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, vhdlParserRULE_actual_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(531)
			p.Name()
		}
		{
			p.SetState(532)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(533)
			p.Actual_designator()
		}
		{
			p.SetState(534)
			p.Match(vhdlParserRPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(536)
			p.Actual_designator()
		}

	}

	return localctx
}

// IAdding_operatorContext is an interface to support dynamic dispatch.
type IAdding_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdding_operatorContext differentiates from other interfaces.
	IsAdding_operatorContext()
}

type Adding_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdding_operatorContext() *Adding_operatorContext {
	var p = new(Adding_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_adding_operator
	return p
}

func (*Adding_operatorContext) IsAdding_operatorContext() {}

func NewAdding_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Adding_operatorContext {
	var p = new(Adding_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_adding_operator

	return p
}

func (s *Adding_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Adding_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserPLUS, 0)
}

func (s *Adding_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserMINUS, 0)
}

func (s *Adding_operatorContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(vhdlParserAMPERSAND, 0)
}

func (s *Adding_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Adding_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Adding_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAdding_operator(s)
	}
}

func (s *Adding_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAdding_operator(s)
	}
}

func (p *vhdlParser) Adding_operator() (localctx IAdding_operatorContext) {
	this := p
	_ = this

	localctx = NewAdding_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, vhdlParserRULE_adding_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(vhdlParserAMPERSAND-140))|(1<<(vhdlParserPLUS-140))|(1<<(vhdlParserMINUS-140)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAggregateContext is an interface to support dynamic dispatch.
type IAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregateContext differentiates from other interfaces.
	IsAggregateContext()
}

type AggregateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregateContext() *AggregateContext {
	var p = new(AggregateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_aggregate
	return p
}

func (*AggregateContext) IsAggregateContext() {}

func NewAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateContext {
	var p = new(AggregateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_aggregate

	return p
}

func (s *AggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *AggregateContext) AllElement_association() []IElement_associationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElement_associationContext)(nil)).Elem())
	var tst = make([]IElement_associationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElement_associationContext)
		}
	}

	return tst
}

func (s *AggregateContext) Element_association(i int) IElement_associationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_associationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElement_associationContext)
}

func (s *AggregateContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *AggregateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *AggregateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *AggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAggregate(s)
	}
}

func (s *AggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAggregate(s)
	}
}

func (p *vhdlParser) Aggregate() (localctx IAggregateContext) {
	this := p
	_ = this

	localctx = NewAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, vhdlParserRULE_aggregate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(542)
		p.Element_association()
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(543)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(544)
			p.Element_association()
		}

		p.SetState(549)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(550)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IAlias_declarationContext is an interface to support dynamic dispatch.
type IAlias_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlias_declarationContext differentiates from other interfaces.
	IsAlias_declarationContext()
}

type Alias_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_declarationContext() *Alias_declarationContext {
	var p = new(Alias_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_alias_declaration
	return p
}

func (*Alias_declarationContext) IsAlias_declarationContext() {}

func NewAlias_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_declarationContext {
	var p = new(Alias_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_alias_declaration

	return p
}

func (s *Alias_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_declarationContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(vhdlParserALIAS, 0)
}

func (s *Alias_declarationContext) Alias_designator() IAlias_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_designatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_designatorContext)
}

func (s *Alias_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Alias_declarationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Alias_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Alias_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Alias_declarationContext) Alias_indication() IAlias_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_indicationContext)
}

func (s *Alias_declarationContext) Signature() ISignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *Alias_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alias_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAlias_declaration(s)
	}
}

func (s *Alias_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAlias_declaration(s)
	}
}

func (p *vhdlParser) Alias_declaration() (localctx IAlias_declarationContext) {
	this := p
	_ = this

	localctx = NewAlias_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, vhdlParserRULE_alias_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Match(vhdlParserALIAS)
	}
	{
		p.SetState(553)
		p.Alias_designator()
	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserCOLON {
		{
			p.SetState(554)
			p.Match(vhdlParserCOLON)
		}
		{
			p.SetState(555)
			p.Alias_indication()
		}

	}
	{
		p.SetState(558)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(559)
		p.Name()
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLBRACKET {
		{
			p.SetState(560)
			p.Signature()
		}

	}
	{
		p.SetState(563)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IAlias_designatorContext is an interface to support dynamic dispatch.
type IAlias_designatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlias_designatorContext differentiates from other interfaces.
	IsAlias_designatorContext()
}

type Alias_designatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_designatorContext() *Alias_designatorContext {
	var p = new(Alias_designatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_alias_designator
	return p
}

func (*Alias_designatorContext) IsAlias_designatorContext() {}

func NewAlias_designatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_designatorContext {
	var p = new(Alias_designatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_alias_designator

	return p
}

func (s *Alias_designatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_designatorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Alias_designatorContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *Alias_designatorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *Alias_designatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_designatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alias_designatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAlias_designator(s)
	}
}

func (s *Alias_designatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAlias_designator(s)
	}
}

func (p *vhdlParser) Alias_designator() (localctx IAlias_designatorContext) {
	this := p
	_ = this

	localctx = NewAlias_designatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, vhdlParserRULE_alias_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(568)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(565)
			p.Identifier()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(566)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(567)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlias_indicationContext is an interface to support dynamic dispatch.
type IAlias_indicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlias_indicationContext differentiates from other interfaces.
	IsAlias_indicationContext()
}

type Alias_indicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_indicationContext() *Alias_indicationContext {
	var p = new(Alias_indicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_alias_indication
	return p
}

func (*Alias_indicationContext) IsAlias_indicationContext() {}

func NewAlias_indicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_indicationContext {
	var p = new(Alias_indicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_alias_indication

	return p
}

func (s *Alias_indicationContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_indicationContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Alias_indicationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Alias_indicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_indicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alias_indicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAlias_indication(s)
	}
}

func (s *Alias_indicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAlias_indication(s)
	}
}

func (p *vhdlParser) Alias_indication() (localctx IAlias_indicationContext) {
	this := p
	_ = this

	localctx = NewAlias_indicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, vhdlParserRULE_alias_indication)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(570)
			p.Subnature_indication()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(571)
			p.Subtype_indication()
		}

	}

	return localctx
}

// IAllocatorContext is an interface to support dynamic dispatch.
type IAllocatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAllocatorContext differentiates from other interfaces.
	IsAllocatorContext()
}

type AllocatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllocatorContext() *AllocatorContext {
	var p = new(AllocatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_allocator
	return p
}

func (*AllocatorContext) IsAllocatorContext() {}

func NewAllocatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllocatorContext {
	var p = new(AllocatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_allocator

	return p
}

func (s *AllocatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AllocatorContext) NEW() antlr.TerminalNode {
	return s.GetToken(vhdlParserNEW, 0)
}

func (s *AllocatorContext) Qualified_expression() IQualified_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualified_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualified_expressionContext)
}

func (s *AllocatorContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *AllocatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllocatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllocatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAllocator(s)
	}
}

func (s *AllocatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAllocator(s)
	}
}

func (p *vhdlParser) Allocator() (localctx IAllocatorContext) {
	this := p
	_ = this

	localctx = NewAllocatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, vhdlParserRULE_allocator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(vhdlParserNEW)
	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(575)
			p.Qualified_expression()
		}

	case 2:
		{
			p.SetState(576)
			p.Subtype_indication()
		}

	}

	return localctx
}

// IArchitecture_bodyContext is an interface to support dynamic dispatch.
type IArchitecture_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArchitecture_bodyContext differentiates from other interfaces.
	IsArchitecture_bodyContext()
}

type Architecture_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArchitecture_bodyContext() *Architecture_bodyContext {
	var p = new(Architecture_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_architecture_body
	return p
}

func (*Architecture_bodyContext) IsArchitecture_bodyContext() {}

func NewArchitecture_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Architecture_bodyContext {
	var p = new(Architecture_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_architecture_body

	return p
}

func (s *Architecture_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Architecture_bodyContext) AllARCHITECTURE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserARCHITECTURE)
}

func (s *Architecture_bodyContext) ARCHITECTURE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserARCHITECTURE, i)
}

func (s *Architecture_bodyContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Architecture_bodyContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Architecture_bodyContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Architecture_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Architecture_bodyContext) Architecture_declarative_part() IArchitecture_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_declarative_partContext)
}

func (s *Architecture_bodyContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Architecture_bodyContext) Architecture_statement_part() IArchitecture_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_statement_partContext)
}

func (s *Architecture_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Architecture_bodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Architecture_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Architecture_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Architecture_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArchitecture_body(s)
	}
}

func (s *Architecture_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArchitecture_body(s)
	}
}

func (p *vhdlParser) Architecture_body() (localctx IArchitecture_bodyContext) {
	this := p
	_ = this

	localctx = NewArchitecture_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, vhdlParserRULE_architecture_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(vhdlParserARCHITECTURE)
	}
	{
		p.SetState(580)
		p.Identifier()
	}
	{
		p.SetState(581)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(582)
		p.Identifier()
	}
	{
		p.SetState(583)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(584)
		p.Architecture_declarative_part()
	}
	{
		p.SetState(585)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(586)
		p.Architecture_statement_part()
	}
	{
		p.SetState(587)
		p.Match(vhdlParserEND)
	}
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserARCHITECTURE {
		{
			p.SetState(588)
			p.Match(vhdlParserARCHITECTURE)
		}

	}
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(591)
			p.Identifier()
		}

	}
	{
		p.SetState(594)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IArchitecture_declarative_partContext is an interface to support dynamic dispatch.
type IArchitecture_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArchitecture_declarative_partContext differentiates from other interfaces.
	IsArchitecture_declarative_partContext()
}

type Architecture_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArchitecture_declarative_partContext() *Architecture_declarative_partContext {
	var p = new(Architecture_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_architecture_declarative_part
	return p
}

func (*Architecture_declarative_partContext) IsArchitecture_declarative_partContext() {}

func NewArchitecture_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Architecture_declarative_partContext {
	var p = new(Architecture_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_architecture_declarative_part

	return p
}

func (s *Architecture_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Architecture_declarative_partContext) AllBlock_declarative_item() []IBlock_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem())
	var tst = make([]IBlock_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_declarative_itemContext)
		}
	}

	return tst
}

func (s *Architecture_declarative_partContext) Block_declarative_item(i int) IBlock_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarative_itemContext)
}

func (s *Architecture_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Architecture_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Architecture_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArchitecture_declarative_part(s)
	}
}

func (s *Architecture_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArchitecture_declarative_part(s)
	}
}

func (p *vhdlParser) Architecture_declarative_part() (localctx IArchitecture_declarative_partContext) {
	this := p
	_ = this

	localctx = NewArchitecture_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, vhdlParserRULE_architecture_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(599)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFOR)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(596)
			p.Block_declarative_item()
		}

		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArchitecture_statementContext is an interface to support dynamic dispatch.
type IArchitecture_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArchitecture_statementContext differentiates from other interfaces.
	IsArchitecture_statementContext()
}

type Architecture_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArchitecture_statementContext() *Architecture_statementContext {
	var p = new(Architecture_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_architecture_statement
	return p
}

func (*Architecture_statementContext) IsArchitecture_statementContext() {}

func NewArchitecture_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Architecture_statementContext {
	var p = new(Architecture_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_architecture_statement

	return p
}

func (s *Architecture_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Architecture_statementContext) Block_statement() IBlock_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_statementContext)
}

func (s *Architecture_statementContext) Process_statement() IProcess_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcess_statementContext)
}

func (s *Architecture_statementContext) Concurrent_procedure_call_statement() IConcurrent_procedure_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_procedure_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_procedure_call_statementContext)
}

func (s *Architecture_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Architecture_statementContext) Concurrent_assertion_statement() IConcurrent_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_assertion_statementContext)
}

func (s *Architecture_statementContext) Concurrent_signal_assignment_statement() IConcurrent_signal_assignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_signal_assignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_signal_assignment_statementContext)
}

func (s *Architecture_statementContext) POSTPONED() antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, 0)
}

func (s *Architecture_statementContext) Component_instantiation_statement() IComponent_instantiation_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_instantiation_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_instantiation_statementContext)
}

func (s *Architecture_statementContext) Generate_statement() IGenerate_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_statementContext)
}

func (s *Architecture_statementContext) Concurrent_break_statement() IConcurrent_break_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_break_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_break_statementContext)
}

func (s *Architecture_statementContext) Simultaneous_statement() ISimultaneous_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_statementContext)
}

func (s *Architecture_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Architecture_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Architecture_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArchitecture_statement(s)
	}
}

func (s *Architecture_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArchitecture_statement(s)
	}
}

func (p *vhdlParser) Architecture_statement() (localctx IArchitecture_statementContext) {
	this := p
	_ = this

	localctx = NewArchitecture_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, vhdlParserRULE_architecture_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(602)
			p.Block_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(603)
			p.Process_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(605)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(604)
				p.Label_colon()
			}

		}
		{
			p.SetState(607)
			p.Concurrent_procedure_call_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(609)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(608)
				p.Label_colon()
			}

		}
		{
			p.SetState(611)
			p.Concurrent_assertion_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(613)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(612)
				p.Label_colon()
			}

		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(615)
				p.Match(vhdlParserPOSTPONED)
			}

		}
		{
			p.SetState(618)
			p.Concurrent_signal_assignment_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(619)
			p.Component_instantiation_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(620)
			p.Generate_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(621)
			p.Concurrent_break_statement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(622)
			p.Simultaneous_statement()
		}

	}

	return localctx
}

// IArchitecture_statement_partContext is an interface to support dynamic dispatch.
type IArchitecture_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArchitecture_statement_partContext differentiates from other interfaces.
	IsArchitecture_statement_partContext()
}

type Architecture_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArchitecture_statement_partContext() *Architecture_statement_partContext {
	var p = new(Architecture_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_architecture_statement_part
	return p
}

func (*Architecture_statement_partContext) IsArchitecture_statement_partContext() {}

func NewArchitecture_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Architecture_statement_partContext {
	var p = new(Architecture_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_architecture_statement_part

	return p
}

func (s *Architecture_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Architecture_statement_partContext) AllArchitecture_statement() []IArchitecture_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem())
	var tst = make([]IArchitecture_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArchitecture_statementContext)
		}
	}

	return tst
}

func (s *Architecture_statement_partContext) Architecture_statement(i int) IArchitecture_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_statementContext)
}

func (s *Architecture_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Architecture_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Architecture_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArchitecture_statement_part(s)
	}
}

func (s *Architecture_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArchitecture_statement_part(s)
	}
}

func (p *vhdlParser) Architecture_statement_part() (localctx IArchitecture_statement_partContext) {
	this := p
	_ = this

	localctx = NewArchitecture_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, vhdlParserRULE_architecture_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserABS)|(1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserNEW-36))|(1<<(vhdlParserNOT-36))|(1<<(vhdlParserNULL_-36))|(1<<(vhdlParserPOSTPONED-36))|(1<<(vhdlParserPROCESS-36)))) != 0) || _la == vhdlParserPROCEDURAL || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(vhdlParserWITH-107))|(1<<(vhdlParserBASE_LITERAL-107))|(1<<(vhdlParserBIT_STRING_LITERAL-107))|(1<<(vhdlParserREAL_LITERAL-107))|(1<<(vhdlParserBASIC_IDENTIFIER-107))|(1<<(vhdlParserEXTENDED_IDENTIFIER-107))|(1<<(vhdlParserCHARACTER_LITERAL-107))|(1<<(vhdlParserSTRING_LITERAL-107)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(vhdlParserLPAREN-141))|(1<<(vhdlParserPLUS-141))|(1<<(vhdlParserMINUS-141))|(1<<(vhdlParserINTEGER-141)))) != 0) {
		{
			p.SetState(625)
			p.Architecture_statement()
		}

		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArray_nature_definitionContext is an interface to support dynamic dispatch.
type IArray_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_nature_definitionContext differentiates from other interfaces.
	IsArray_nature_definitionContext()
}

type Array_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_nature_definitionContext() *Array_nature_definitionContext {
	var p = new(Array_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_array_nature_definition
	return p
}

func (*Array_nature_definitionContext) IsArray_nature_definitionContext() {}

func NewArray_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_nature_definitionContext {
	var p = new(Array_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_array_nature_definition

	return p
}

func (s *Array_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_nature_definitionContext) Unconstrained_nature_definition() IUnconstrained_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnconstrained_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnconstrained_nature_definitionContext)
}

func (s *Array_nature_definitionContext) Constrained_nature_definition() IConstrained_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstrained_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstrained_nature_definitionContext)
}

func (s *Array_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArray_nature_definition(s)
	}
}

func (s *Array_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArray_nature_definition(s)
	}
}

func (p *vhdlParser) Array_nature_definition() (localctx IArray_nature_definitionContext) {
	this := p
	_ = this

	localctx = NewArray_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, vhdlParserRULE_array_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.Unconstrained_nature_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.Constrained_nature_definition()
		}

	}

	return localctx
}

// IArray_type_definitionContext is an interface to support dynamic dispatch.
type IArray_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_type_definitionContext differentiates from other interfaces.
	IsArray_type_definitionContext()
}

type Array_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_type_definitionContext() *Array_type_definitionContext {
	var p = new(Array_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_array_type_definition
	return p
}

func (*Array_type_definitionContext) IsArray_type_definitionContext() {}

func NewArray_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_type_definitionContext {
	var p = new(Array_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_array_type_definition

	return p
}

func (s *Array_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_type_definitionContext) Unconstrained_array_definition() IUnconstrained_array_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnconstrained_array_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnconstrained_array_definitionContext)
}

func (s *Array_type_definitionContext) Constrained_array_definition() IConstrained_array_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstrained_array_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstrained_array_definitionContext)
}

func (s *Array_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArray_type_definition(s)
	}
}

func (s *Array_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArray_type_definition(s)
	}
}

func (p *vhdlParser) Array_type_definition() (localctx IArray_type_definitionContext) {
	this := p
	_ = this

	localctx = NewArray_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, vhdlParserRULE_array_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(637)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(635)
			p.Unconstrained_array_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(636)
			p.Constrained_array_definition()
		}

	}

	return localctx
}

// IAssertionContext is an interface to support dynamic dispatch.
type IAssertionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertionContext differentiates from other interfaces.
	IsAssertionContext()
}

type AssertionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertionContext() *AssertionContext {
	var p = new(AssertionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_assertion
	return p
}

func (*AssertionContext) IsAssertionContext() {}

func NewAssertionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertionContext {
	var p = new(AssertionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_assertion

	return p
}

func (s *AssertionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertionContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(vhdlParserASSERT, 0)
}

func (s *AssertionContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *AssertionContext) REPORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserREPORT, 0)
}

func (s *AssertionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *AssertionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssertionContext) SEVERITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEVERITY, 0)
}

func (s *AssertionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAssertion(s)
	}
}

func (s *AssertionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAssertion(s)
	}
}

func (p *vhdlParser) Assertion() (localctx IAssertionContext) {
	this := p
	_ = this

	localctx = NewAssertionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, vhdlParserRULE_assertion)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Match(vhdlParserASSERT)
	}
	{
		p.SetState(640)
		p.Condition()
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserREPORT {
		{
			p.SetState(641)
			p.Match(vhdlParserREPORT)
		}
		{
			p.SetState(642)
			p.Expression()
		}

	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserSEVERITY {
		{
			p.SetState(645)
			p.Match(vhdlParserSEVERITY)
		}
		{
			p.SetState(646)
			p.Expression()
		}

	}

	return localctx
}

// IAssertion_statementContext is an interface to support dynamic dispatch.
type IAssertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertion_statementContext differentiates from other interfaces.
	IsAssertion_statementContext()
}

type Assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertion_statementContext() *Assertion_statementContext {
	var p = new(Assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_assertion_statement
	return p
}

func (*Assertion_statementContext) IsAssertion_statementContext() {}

func NewAssertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assertion_statementContext {
	var p = new(Assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_assertion_statement

	return p
}

func (s *Assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assertion_statementContext) Assertion() IAssertionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertionContext)
}

func (s *Assertion_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Assertion_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAssertion_statement(s)
	}
}

func (s *Assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAssertion_statement(s)
	}
}

func (p *vhdlParser) Assertion_statement() (localctx IAssertion_statementContext) {
	this := p
	_ = this

	localctx = NewAssertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, vhdlParserRULE_assertion_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(649)
			p.Label_colon()
		}

	}
	{
		p.SetState(652)
		p.Assertion()
	}
	{
		p.SetState(653)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IAssociation_elementContext is an interface to support dynamic dispatch.
type IAssociation_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssociation_elementContext differentiates from other interfaces.
	IsAssociation_elementContext()
}

type Association_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociation_elementContext() *Association_elementContext {
	var p = new(Association_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_association_element
	return p
}

func (*Association_elementContext) IsAssociation_elementContext() {}

func NewAssociation_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Association_elementContext {
	var p = new(Association_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_association_element

	return p
}

func (s *Association_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Association_elementContext) Actual_part() IActual_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActual_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActual_partContext)
}

func (s *Association_elementContext) Formal_part() IFormal_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_partContext)
}

func (s *Association_elementContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Association_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Association_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Association_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAssociation_element(s)
	}
}

func (s *Association_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAssociation_element(s)
	}
}

func (p *vhdlParser) Association_element() (localctx IAssociation_elementContext) {
	this := p
	_ = this

	localctx = NewAssociation_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, vhdlParserRULE_association_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(658)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(655)
			p.Formal_part()
		}
		{
			p.SetState(656)
			p.Match(vhdlParserARROW)
		}

	}
	{
		p.SetState(660)
		p.Actual_part()
	}

	return localctx
}

// IAssociation_listContext is an interface to support dynamic dispatch.
type IAssociation_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssociation_listContext differentiates from other interfaces.
	IsAssociation_listContext()
}

type Association_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociation_listContext() *Association_listContext {
	var p = new(Association_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_association_list
	return p
}

func (*Association_listContext) IsAssociation_listContext() {}

func NewAssociation_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Association_listContext {
	var p = new(Association_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_association_list

	return p
}

func (s *Association_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Association_listContext) AllAssociation_element() []IAssociation_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssociation_elementContext)(nil)).Elem())
	var tst = make([]IAssociation_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssociation_elementContext)
		}
	}

	return tst
}

func (s *Association_listContext) Association_element(i int) IAssociation_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociation_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssociation_elementContext)
}

func (s *Association_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Association_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Association_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Association_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Association_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAssociation_list(s)
	}
}

func (s *Association_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAssociation_list(s)
	}
}

func (p *vhdlParser) Association_list() (localctx IAssociation_listContext) {
	this := p
	_ = this

	localctx = NewAssociation_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, vhdlParserRULE_association_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Association_element()
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(663)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(664)
			p.Association_element()
		}

		p.SetState(669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttribute_declarationContext is an interface to support dynamic dispatch.
type IAttribute_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_declarationContext differentiates from other interfaces.
	IsAttribute_declarationContext()
}

type Attribute_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_declarationContext() *Attribute_declarationContext {
	var p = new(Attribute_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_attribute_declaration
	return p
}

func (*Attribute_declarationContext) IsAttribute_declarationContext() {}

func NewAttribute_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_declarationContext {
	var p = new(Attribute_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_attribute_declaration

	return p
}

func (s *Attribute_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_declarationContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(vhdlParserATTRIBUTE, 0)
}

func (s *Attribute_declarationContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Attribute_declarationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Attribute_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Attribute_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAttribute_declaration(s)
	}
}

func (s *Attribute_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAttribute_declaration(s)
	}
}

func (p *vhdlParser) Attribute_declaration() (localctx IAttribute_declarationContext) {
	this := p
	_ = this

	localctx = NewAttribute_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, vhdlParserRULE_attribute_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Match(vhdlParserATTRIBUTE)
	}
	{
		p.SetState(671)
		p.Label_colon()
	}
	{
		p.SetState(672)
		p.Name()
	}
	{
		p.SetState(673)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IAttribute_designatorContext is an interface to support dynamic dispatch.
type IAttribute_designatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_designatorContext differentiates from other interfaces.
	IsAttribute_designatorContext()
}

type Attribute_designatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_designatorContext() *Attribute_designatorContext {
	var p = new(Attribute_designatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_attribute_designator
	return p
}

func (*Attribute_designatorContext) IsAttribute_designatorContext() {}

func NewAttribute_designatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_designatorContext {
	var p = new(Attribute_designatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_attribute_designator

	return p
}

func (s *Attribute_designatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_designatorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Attribute_designatorContext) RANGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserRANGE, 0)
}

func (s *Attribute_designatorContext) REVERSE_RANGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserREVERSE_RANGE, 0)
}

func (s *Attribute_designatorContext) ACROSS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACROSS, 0)
}

func (s *Attribute_designatorContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(vhdlParserTHROUGH, 0)
}

func (s *Attribute_designatorContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserREFERENCE, 0)
}

func (s *Attribute_designatorContext) TOLERANCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTOLERANCE, 0)
}

func (s *Attribute_designatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_designatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_designatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAttribute_designator(s)
	}
}

func (s *Attribute_designatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAttribute_designator(s)
	}
}

func (p *vhdlParser) Attribute_designator() (localctx IAttribute_designatorContext) {
	this := p
	_ = this

	localctx = NewAttribute_designatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, vhdlParserRULE_attribute_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(682)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(675)
			p.Identifier()
		}

	case vhdlParserRANGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(676)
			p.Match(vhdlParserRANGE)
		}

	case vhdlParserREVERSE_RANGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(677)
			p.Match(vhdlParserREVERSE_RANGE)
		}

	case vhdlParserACROSS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(678)
			p.Match(vhdlParserACROSS)
		}

	case vhdlParserTHROUGH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(679)
			p.Match(vhdlParserTHROUGH)
		}

	case vhdlParserREFERENCE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(680)
			p.Match(vhdlParserREFERENCE)
		}

	case vhdlParserTOLERANCE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(681)
			p.Match(vhdlParserTOLERANCE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribute_specificationContext is an interface to support dynamic dispatch.
type IAttribute_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_specificationContext differentiates from other interfaces.
	IsAttribute_specificationContext()
}

type Attribute_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_specificationContext() *Attribute_specificationContext {
	var p = new(Attribute_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_attribute_specification
	return p
}

func (*Attribute_specificationContext) IsAttribute_specificationContext() {}

func NewAttribute_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_specificationContext {
	var p = new(Attribute_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_attribute_specification

	return p
}

func (s *Attribute_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_specificationContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(vhdlParserATTRIBUTE, 0)
}

func (s *Attribute_specificationContext) Attribute_designator() IAttribute_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_designatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_designatorContext)
}

func (s *Attribute_specificationContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Attribute_specificationContext) Entity_specification() IEntity_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_specificationContext)
}

func (s *Attribute_specificationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Attribute_specificationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Attribute_specificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Attribute_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAttribute_specification(s)
	}
}

func (s *Attribute_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAttribute_specification(s)
	}
}

func (p *vhdlParser) Attribute_specification() (localctx IAttribute_specificationContext) {
	this := p
	_ = this

	localctx = NewAttribute_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, vhdlParserRULE_attribute_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		p.Match(vhdlParserATTRIBUTE)
	}
	{
		p.SetState(685)
		p.Attribute_designator()
	}
	{
		p.SetState(686)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(687)
		p.Entity_specification()
	}
	{
		p.SetState(688)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(689)
		p.Expression()
	}
	{
		p.SetState(690)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBase_unit_declarationContext is an interface to support dynamic dispatch.
type IBase_unit_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_unit_declarationContext differentiates from other interfaces.
	IsBase_unit_declarationContext()
}

type Base_unit_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_unit_declarationContext() *Base_unit_declarationContext {
	var p = new(Base_unit_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_base_unit_declaration
	return p
}

func (*Base_unit_declarationContext) IsBase_unit_declarationContext() {}

func NewBase_unit_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_unit_declarationContext {
	var p = new(Base_unit_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_base_unit_declaration

	return p
}

func (s *Base_unit_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_unit_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Base_unit_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Base_unit_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_unit_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_unit_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBase_unit_declaration(s)
	}
}

func (s *Base_unit_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBase_unit_declaration(s)
	}
}

func (p *vhdlParser) Base_unit_declaration() (localctx IBase_unit_declarationContext) {
	this := p
	_ = this

	localctx = NewBase_unit_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, vhdlParserRULE_base_unit_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.Identifier()
	}
	{
		p.SetState(693)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBinding_indicationContext is an interface to support dynamic dispatch.
type IBinding_indicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinding_indicationContext differentiates from other interfaces.
	IsBinding_indicationContext()
}

type Binding_indicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinding_indicationContext() *Binding_indicationContext {
	var p = new(Binding_indicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_binding_indication
	return p
}

func (*Binding_indicationContext) IsBinding_indicationContext() {}

func NewBinding_indicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binding_indicationContext {
	var p = new(Binding_indicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_binding_indication

	return p
}

func (s *Binding_indicationContext) GetParser() antlr.Parser { return s.parser }

func (s *Binding_indicationContext) USE() antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, 0)
}

func (s *Binding_indicationContext) Entity_aspect() IEntity_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_aspectContext)
}

func (s *Binding_indicationContext) Generic_map_aspect() IGeneric_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_map_aspectContext)
}

func (s *Binding_indicationContext) Port_map_aspect() IPort_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_map_aspectContext)
}

func (s *Binding_indicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binding_indicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binding_indicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBinding_indication(s)
	}
}

func (s *Binding_indicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBinding_indication(s)
	}
}

func (p *vhdlParser) Binding_indication() (localctx IBinding_indicationContext) {
	this := p
	_ = this

	localctx = NewBinding_indicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, vhdlParserRULE_binding_indication)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserUSE {
		{
			p.SetState(695)
			p.Match(vhdlParserUSE)
		}
		{
			p.SetState(696)
			p.Entity_aspect()
		}

	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(699)
			p.Generic_map_aspect()
		}

	}
	p.SetState(703)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(702)
			p.Port_map_aspect()
		}

	}

	return localctx
}

// IBlock_configurationContext is an interface to support dynamic dispatch.
type IBlock_configurationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_configurationContext differentiates from other interfaces.
	IsBlock_configurationContext()
}

type Block_configurationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_configurationContext() *Block_configurationContext {
	var p = new(Block_configurationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_configuration
	return p
}

func (*Block_configurationContext) IsBlock_configurationContext() {}

func NewBlock_configurationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_configurationContext {
	var p = new(Block_configurationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_configuration

	return p
}

func (s *Block_configurationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_configurationContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserFOR)
}

func (s *Block_configurationContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, i)
}

func (s *Block_configurationContext) Block_specification() IBlock_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_specificationContext)
}

func (s *Block_configurationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Block_configurationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Block_configurationContext) AllUse_clause() []IUse_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem())
	var tst = make([]IUse_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUse_clauseContext)
		}
	}

	return tst
}

func (s *Block_configurationContext) Use_clause(i int) IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Block_configurationContext) AllConfiguration_item() []IConfiguration_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfiguration_itemContext)(nil)).Elem())
	var tst = make([]IConfiguration_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfiguration_itemContext)
		}
	}

	return tst
}

func (s *Block_configurationContext) Configuration_item(i int) IConfiguration_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_itemContext)
}

func (s *Block_configurationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_configurationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_configurationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_configuration(s)
	}
}

func (s *Block_configurationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_configuration(s)
	}
}

func (p *vhdlParser) Block_configuration() (localctx IBlock_configurationContext) {
	this := p
	_ = this

	localctx = NewBlock_configurationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, vhdlParserRULE_block_configuration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(706)
		p.Block_specification()
	}
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserUSE {
		{
			p.SetState(707)
			p.Use_clause()
		}

		p.SetState(712)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserFOR {
		{
			p.SetState(713)
			p.Configuration_item()
		}

		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(719)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(720)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(721)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBlock_declarative_itemContext is an interface to support dynamic dispatch.
type IBlock_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_declarative_itemContext differentiates from other interfaces.
	IsBlock_declarative_itemContext()
}

type Block_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_declarative_itemContext() *Block_declarative_itemContext {
	var p = new(Block_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_declarative_item
	return p
}

func (*Block_declarative_itemContext) IsBlock_declarative_itemContext() {}

func NewBlock_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_declarative_itemContext {
	var p = new(Block_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_declarative_item

	return p
}

func (s *Block_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Block_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Block_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Block_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Block_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Block_declarative_itemContext) Signal_declaration() ISignal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_declarationContext)
}

func (s *Block_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Block_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Block_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Block_declarative_itemContext) Component_declaration() IComponent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_declarationContext)
}

func (s *Block_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Block_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Block_declarative_itemContext) Configuration_specification() IConfiguration_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_specificationContext)
}

func (s *Block_declarative_itemContext) Disconnection_specification() IDisconnection_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisconnection_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisconnection_specificationContext)
}

func (s *Block_declarative_itemContext) Step_limit_specification() IStep_limit_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStep_limit_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStep_limit_specificationContext)
}

func (s *Block_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Block_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Block_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Block_declarative_itemContext) Nature_declaration() INature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INature_declarationContext)
}

func (s *Block_declarative_itemContext) Subnature_declaration() ISubnature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_declarationContext)
}

func (s *Block_declarative_itemContext) Quantity_declaration() IQuantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_declarationContext)
}

func (s *Block_declarative_itemContext) Terminal_declaration() ITerminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_declarationContext)
}

func (s *Block_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_declarative_item(s)
	}
}

func (s *Block_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_declarative_item(s)
	}
}

func (p *vhdlParser) Block_declarative_item() (localctx IBlock_declarative_itemContext) {
	this := p
	_ = this

	localctx = NewBlock_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, vhdlParserRULE_block_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(745)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(723)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(724)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(725)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(726)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(727)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(728)
			p.Signal_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(729)
			p.Variable_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(730)
			p.File_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(731)
			p.Alias_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(732)
			p.Component_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(733)
			p.Attribute_declaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(734)
			p.Attribute_specification()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(735)
			p.Configuration_specification()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(736)
			p.Disconnection_specification()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(737)
			p.Step_limit_specification()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(738)
			p.Use_clause()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(739)
			p.Group_template_declaration()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(740)
			p.Group_declaration()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(741)
			p.Nature_declaration()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(742)
			p.Subnature_declaration()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(743)
			p.Quantity_declaration()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(744)
			p.Terminal_declaration()
		}

	}

	return localctx
}

// IBlock_declarative_partContext is an interface to support dynamic dispatch.
type IBlock_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_declarative_partContext differentiates from other interfaces.
	IsBlock_declarative_partContext()
}

type Block_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_declarative_partContext() *Block_declarative_partContext {
	var p = new(Block_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_declarative_part
	return p
}

func (*Block_declarative_partContext) IsBlock_declarative_partContext() {}

func NewBlock_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_declarative_partContext {
	var p = new(Block_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_declarative_part

	return p
}

func (s *Block_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_declarative_partContext) AllBlock_declarative_item() []IBlock_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem())
	var tst = make([]IBlock_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_declarative_itemContext)
		}
	}

	return tst
}

func (s *Block_declarative_partContext) Block_declarative_item(i int) IBlock_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarative_itemContext)
}

func (s *Block_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_declarative_part(s)
	}
}

func (s *Block_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_declarative_part(s)
	}
}

func (p *vhdlParser) Block_declarative_part() (localctx IBlock_declarative_partContext) {
	this := p
	_ = this

	localctx = NewBlock_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, vhdlParserRULE_block_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(750)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFOR)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(747)
			p.Block_declarative_item()
		}

		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlock_headerContext is an interface to support dynamic dispatch.
type IBlock_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_headerContext differentiates from other interfaces.
	IsBlock_headerContext()
}

type Block_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_headerContext() *Block_headerContext {
	var p = new(Block_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_header
	return p
}

func (*Block_headerContext) IsBlock_headerContext() {}

func NewBlock_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_headerContext {
	var p = new(Block_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_header

	return p
}

func (s *Block_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_headerContext) Generic_clause() IGeneric_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_clauseContext)
}

func (s *Block_headerContext) Port_clause() IPort_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_clauseContext)
}

func (s *Block_headerContext) Generic_map_aspect() IGeneric_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_map_aspectContext)
}

func (s *Block_headerContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Block_headerContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Block_headerContext) Port_map_aspect() IPort_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_map_aspectContext)
}

func (s *Block_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_header(s)
	}
}

func (s *Block_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_header(s)
	}
}

func (p *vhdlParser) Block_header() (localctx IBlock_headerContext) {
	this := p
	_ = this

	localctx = NewBlock_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, vhdlParserRULE_block_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(759)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(753)
			p.Generic_clause()
		}
		p.SetState(757)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserGENERIC {
			{
				p.SetState(754)
				p.Generic_map_aspect()
			}
			{
				p.SetState(755)
				p.Match(vhdlParserSEMI)
			}

		}

	}
	p.SetState(767)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(761)
			p.Port_clause()
		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserPORT {
			{
				p.SetState(762)
				p.Port_map_aspect()
			}
			{
				p.SetState(763)
				p.Match(vhdlParserSEMI)
			}

		}

	}

	return localctx
}

// IBlock_specificationContext is an interface to support dynamic dispatch.
type IBlock_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_specificationContext differentiates from other interfaces.
	IsBlock_specificationContext()
}

type Block_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_specificationContext() *Block_specificationContext {
	var p = new(Block_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_specification
	return p
}

func (*Block_specificationContext) IsBlock_specificationContext() {}

func NewBlock_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_specificationContext {
	var p = new(Block_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_specification

	return p
}

func (s *Block_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_specificationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Block_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Block_specificationContext) Index_specification() IIndex_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_specificationContext)
}

func (s *Block_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Block_specificationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Block_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_specification(s)
	}
}

func (s *Block_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_specification(s)
	}
}

func (p *vhdlParser) Block_specification() (localctx IBlock_specificationContext) {
	this := p
	_ = this

	localctx = NewBlock_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, vhdlParserRULE_block_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(777)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(769)
			p.Identifier()
		}
		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserLPAREN {
			{
				p.SetState(770)
				p.Match(vhdlParserLPAREN)
			}
			{
				p.SetState(771)
				p.Index_specification()
			}
			{
				p.SetState(772)
				p.Match(vhdlParserRPAREN)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(776)
			p.Name()
		}

	}

	return localctx
}

// IBlock_statementContext is an interface to support dynamic dispatch.
type IBlock_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_statementContext differentiates from other interfaces.
	IsBlock_statementContext()
}

type Block_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_statementContext() *Block_statementContext {
	var p = new(Block_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_statement
	return p
}

func (*Block_statementContext) IsBlock_statementContext() {}

func NewBlock_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_statementContext {
	var p = new(Block_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_statement

	return p
}

func (s *Block_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Block_statementContext) AllBLOCK() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserBLOCK)
}

func (s *Block_statementContext) BLOCK(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserBLOCK, i)
}

func (s *Block_statementContext) Block_header() IBlock_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_headerContext)
}

func (s *Block_statementContext) Block_declarative_part() IBlock_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarative_partContext)
}

func (s *Block_statementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Block_statementContext) Block_statement_part() IBlock_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_statement_partContext)
}

func (s *Block_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Block_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Block_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Block_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Block_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Block_statementContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Block_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Block_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_statement(s)
	}
}

func (s *Block_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_statement(s)
	}
}

func (p *vhdlParser) Block_statement() (localctx IBlock_statementContext) {
	this := p
	_ = this

	localctx = NewBlock_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, vhdlParserRULE_block_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.Label_colon()
	}
	{
		p.SetState(780)
		p.Match(vhdlParserBLOCK)
	}
	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(781)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(782)
			p.Expression()
		}
		{
			p.SetState(783)
			p.Match(vhdlParserRPAREN)
		}

	}
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(787)
			p.Match(vhdlParserIS)
		}

	}
	{
		p.SetState(790)
		p.Block_header()
	}
	{
		p.SetState(791)
		p.Block_declarative_part()
	}
	{
		p.SetState(792)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(793)
		p.Block_statement_part()
	}
	{
		p.SetState(794)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(795)
		p.Match(vhdlParserBLOCK)
	}
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(796)
			p.Identifier()
		}

	}
	{
		p.SetState(799)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBlock_statement_partContext is an interface to support dynamic dispatch.
type IBlock_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_statement_partContext differentiates from other interfaces.
	IsBlock_statement_partContext()
}

type Block_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_statement_partContext() *Block_statement_partContext {
	var p = new(Block_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_statement_part
	return p
}

func (*Block_statement_partContext) IsBlock_statement_partContext() {}

func NewBlock_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_statement_partContext {
	var p = new(Block_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_statement_part

	return p
}

func (s *Block_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_statement_partContext) AllArchitecture_statement() []IArchitecture_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem())
	var tst = make([]IArchitecture_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArchitecture_statementContext)
		}
	}

	return tst
}

func (s *Block_statement_partContext) Architecture_statement(i int) IArchitecture_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_statementContext)
}

func (s *Block_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_statement_part(s)
	}
}

func (s *Block_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_statement_part(s)
	}
}

func (p *vhdlParser) Block_statement_part() (localctx IBlock_statement_partContext) {
	this := p
	_ = this

	localctx = NewBlock_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, vhdlParserRULE_block_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(804)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserABS)|(1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserNEW-36))|(1<<(vhdlParserNOT-36))|(1<<(vhdlParserNULL_-36))|(1<<(vhdlParserPOSTPONED-36))|(1<<(vhdlParserPROCESS-36)))) != 0) || _la == vhdlParserPROCEDURAL || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(vhdlParserWITH-107))|(1<<(vhdlParserBASE_LITERAL-107))|(1<<(vhdlParserBIT_STRING_LITERAL-107))|(1<<(vhdlParserREAL_LITERAL-107))|(1<<(vhdlParserBASIC_IDENTIFIER-107))|(1<<(vhdlParserEXTENDED_IDENTIFIER-107))|(1<<(vhdlParserCHARACTER_LITERAL-107))|(1<<(vhdlParserSTRING_LITERAL-107)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(vhdlParserLPAREN-141))|(1<<(vhdlParserPLUS-141))|(1<<(vhdlParserMINUS-141))|(1<<(vhdlParserINTEGER-141)))) != 0) {
		{
			p.SetState(801)
			p.Architecture_statement()
		}

		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBranch_quantity_declarationContext is an interface to support dynamic dispatch.
type IBranch_quantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBranch_quantity_declarationContext differentiates from other interfaces.
	IsBranch_quantity_declarationContext()
}

type Branch_quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranch_quantity_declarationContext() *Branch_quantity_declarationContext {
	var p = new(Branch_quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_branch_quantity_declaration
	return p
}

func (*Branch_quantity_declarationContext) IsBranch_quantity_declarationContext() {}

func NewBranch_quantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Branch_quantity_declarationContext {
	var p = new(Branch_quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_branch_quantity_declaration

	return p
}

func (s *Branch_quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Branch_quantity_declarationContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Branch_quantity_declarationContext) Terminal_aspect() ITerminal_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_aspectContext)
}

func (s *Branch_quantity_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Branch_quantity_declarationContext) Across_aspect() IAcross_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcross_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcross_aspectContext)
}

func (s *Branch_quantity_declarationContext) Through_aspect() IThrough_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrough_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrough_aspectContext)
}

func (s *Branch_quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Branch_quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Branch_quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBranch_quantity_declaration(s)
	}
}

func (s *Branch_quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBranch_quantity_declaration(s)
	}
}

func (p *vhdlParser) Branch_quantity_declaration() (localctx IBranch_quantity_declarationContext) {
	this := p
	_ = this

	localctx = NewBranch_quantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, vhdlParserRULE_branch_quantity_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(807)
		p.Match(vhdlParserQUANTITY)
	}
	p.SetState(809)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(808)
			p.Across_aspect()
		}

	}
	p.SetState(812)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(811)
			p.Through_aspect()
		}

	}
	{
		p.SetState(814)
		p.Terminal_aspect()
	}
	{
		p.SetState(815)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBreak_elementContext is an interface to support dynamic dispatch.
type IBreak_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_elementContext differentiates from other interfaces.
	IsBreak_elementContext()
}

type Break_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_elementContext() *Break_elementContext {
	var p = new(Break_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_break_element
	return p
}

func (*Break_elementContext) IsBreak_elementContext() {}

func NewBreak_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_elementContext {
	var p = new(Break_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_break_element

	return p
}

func (s *Break_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_elementContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Break_elementContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Break_elementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Break_elementContext) Break_selector_clause() IBreak_selector_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_selector_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_selector_clauseContext)
}

func (s *Break_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBreak_element(s)
	}
}

func (s *Break_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBreak_element(s)
	}
}

func (p *vhdlParser) Break_element() (localctx IBreak_elementContext) {
	this := p
	_ = this

	localctx = NewBreak_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, vhdlParserRULE_break_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR {
		{
			p.SetState(817)
			p.Break_selector_clause()
		}

	}
	{
		p.SetState(820)
		p.Name()
	}
	{
		p.SetState(821)
		p.Match(vhdlParserARROW)
	}
	{
		p.SetState(822)
		p.Expression()
	}

	return localctx
}

// IBreak_listContext is an interface to support dynamic dispatch.
type IBreak_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_listContext differentiates from other interfaces.
	IsBreak_listContext()
}

type Break_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_listContext() *Break_listContext {
	var p = new(Break_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_break_list
	return p
}

func (*Break_listContext) IsBreak_listContext() {}

func NewBreak_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_listContext {
	var p = new(Break_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_break_list

	return p
}

func (s *Break_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_listContext) AllBreak_element() []IBreak_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBreak_elementContext)(nil)).Elem())
	var tst = make([]IBreak_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBreak_elementContext)
		}
	}

	return tst
}

func (s *Break_listContext) Break_element(i int) IBreak_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBreak_elementContext)
}

func (s *Break_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Break_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Break_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBreak_list(s)
	}
}

func (s *Break_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBreak_list(s)
	}
}

func (p *vhdlParser) Break_list() (localctx IBreak_listContext) {
	this := p
	_ = this

	localctx = NewBreak_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, vhdlParserRULE_break_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.Break_element()
	}
	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(825)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(826)
			p.Break_element()
		}

		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBreak_selector_clauseContext is an interface to support dynamic dispatch.
type IBreak_selector_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_selector_clauseContext differentiates from other interfaces.
	IsBreak_selector_clauseContext()
}

type Break_selector_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_selector_clauseContext() *Break_selector_clauseContext {
	var p = new(Break_selector_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_break_selector_clause
	return p
}

func (*Break_selector_clauseContext) IsBreak_selector_clauseContext() {}

func NewBreak_selector_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_selector_clauseContext {
	var p = new(Break_selector_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_break_selector_clause

	return p
}

func (s *Break_selector_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_selector_clauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Break_selector_clauseContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Break_selector_clauseContext) USE() antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, 0)
}

func (s *Break_selector_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_selector_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_selector_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBreak_selector_clause(s)
	}
}

func (s *Break_selector_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBreak_selector_clause(s)
	}
}

func (p *vhdlParser) Break_selector_clause() (localctx IBreak_selector_clauseContext) {
	this := p
	_ = this

	localctx = NewBreak_selector_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, vhdlParserRULE_break_selector_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(833)
		p.Name()
	}
	{
		p.SetState(834)
		p.Match(vhdlParserUSE)
	}

	return localctx
}

// IBreak_statementContext is an interface to support dynamic dispatch.
type IBreak_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_statementContext differentiates from other interfaces.
	IsBreak_statementContext()
}

type Break_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_statementContext() *Break_statementContext {
	var p = new(Break_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_break_statement
	return p
}

func (*Break_statementContext) IsBreak_statementContext() {}

func NewBreak_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_statementContext {
	var p = new(Break_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_break_statement

	return p
}

func (s *Break_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_statementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(vhdlParserBREAK, 0)
}

func (s *Break_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Break_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Break_statementContext) Break_list() IBreak_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_listContext)
}

func (s *Break_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Break_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Break_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBreak_statement(s)
	}
}

func (s *Break_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBreak_statement(s)
	}
}

func (p *vhdlParser) Break_statement() (localctx IBreak_statementContext) {
	this := p
	_ = this

	localctx = NewBreak_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, vhdlParserRULE_break_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(836)
			p.Label_colon()
		}

	}
	{
		p.SetState(839)
		p.Match(vhdlParserBREAK)
	}
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserSTRING_LITERAL-118)))) != 0) {
		{
			p.SetState(840)
			p.Break_list()
		}

	}
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(843)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(844)
			p.Condition()
		}

	}
	{
		p.SetState(847)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ICase_statementContext is an interface to support dynamic dispatch.
type ICase_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statementContext differentiates from other interfaces.
	IsCase_statementContext()
}

type Case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statementContext() *Case_statementContext {
	var p = new(Case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_case_statement
	return p
}

func (*Case_statementContext) IsCase_statementContext() {}

func NewCase_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statementContext {
	var p = new(Case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_case_statement

	return p
}

func (s *Case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCASE)
}

func (s *Case_statementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCASE, i)
}

func (s *Case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_statementContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Case_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Case_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Case_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Case_statementContext) AllCase_statement_alternative() []ICase_statement_alternativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_statement_alternativeContext)(nil)).Elem())
	var tst = make([]ICase_statement_alternativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_statement_alternativeContext)
		}
	}

	return tst
}

func (s *Case_statementContext) Case_statement_alternative(i int) ICase_statement_alternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statement_alternativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_statement_alternativeContext)
}

func (s *Case_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterCase_statement(s)
	}
}

func (s *Case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitCase_statement(s)
	}
}

func (p *vhdlParser) Case_statement() (localctx ICase_statementContext) {
	this := p
	_ = this

	localctx = NewCase_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, vhdlParserRULE_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(849)
			p.Label_colon()
		}

	}
	{
		p.SetState(852)
		p.Match(vhdlParserCASE)
	}
	{
		p.SetState(853)
		p.Expression()
	}
	{
		p.SetState(854)
		p.Match(vhdlParserIS)
	}
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == vhdlParserWHEN {
		{
			p.SetState(855)
			p.Case_statement_alternative()
		}

		p.SetState(858)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(860)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(861)
		p.Match(vhdlParserCASE)
	}
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(862)
			p.Identifier()
		}

	}
	{
		p.SetState(865)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ICase_statement_alternativeContext is an interface to support dynamic dispatch.
type ICase_statement_alternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statement_alternativeContext differentiates from other interfaces.
	IsCase_statement_alternativeContext()
}

type Case_statement_alternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statement_alternativeContext() *Case_statement_alternativeContext {
	var p = new(Case_statement_alternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_case_statement_alternative
	return p
}

func (*Case_statement_alternativeContext) IsCase_statement_alternativeContext() {}

func NewCase_statement_alternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statement_alternativeContext {
	var p = new(Case_statement_alternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_case_statement_alternative

	return p
}

func (s *Case_statement_alternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statement_alternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Case_statement_alternativeContext) Choices() IChoicesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoicesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoicesContext)
}

func (s *Case_statement_alternativeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Case_statement_alternativeContext) Sequence_of_statements() ISequence_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_of_statementsContext)
}

func (s *Case_statement_alternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statement_alternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statement_alternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterCase_statement_alternative(s)
	}
}

func (s *Case_statement_alternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitCase_statement_alternative(s)
	}
}

func (p *vhdlParser) Case_statement_alternative() (localctx ICase_statement_alternativeContext) {
	this := p
	_ = this

	localctx = NewCase_statement_alternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, vhdlParserRULE_case_statement_alternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.Match(vhdlParserWHEN)
	}
	{
		p.SetState(868)
		p.Choices()
	}
	{
		p.SetState(869)
		p.Match(vhdlParserARROW)
	}
	{
		p.SetState(870)
		p.Sequence_of_statements()
	}

	return localctx
}

// IChoiceContext is an interface to support dynamic dispatch.
type IChoiceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoiceContext differentiates from other interfaces.
	IsChoiceContext()
}

type ChoiceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceContext() *ChoiceContext {
	var p = new(ChoiceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_choice
	return p
}

func (*ChoiceContext) IsChoiceContext() {}

func NewChoiceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceContext {
	var p = new(ChoiceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_choice

	return p
}

func (s *ChoiceContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ChoiceContext) Discrete_range() IDiscrete_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiscrete_rangeContext)
}

func (s *ChoiceContext) Simple_expression() ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *ChoiceContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *ChoiceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoiceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterChoice(s)
	}
}

func (s *ChoiceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitChoice(s)
	}
}

func (p *vhdlParser) Choice() (localctx IChoiceContext) {
	this := p
	_ = this

	localctx = NewChoiceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, vhdlParserRULE_choice)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(873)
			p.Discrete_range()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(874)
			p.Simple_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(875)
			p.Match(vhdlParserOTHERS)
		}

	}

	return localctx
}

// IChoicesContext is an interface to support dynamic dispatch.
type IChoicesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoicesContext differentiates from other interfaces.
	IsChoicesContext()
}

type ChoicesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoicesContext() *ChoicesContext {
	var p = new(ChoicesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_choices
	return p
}

func (*ChoicesContext) IsChoicesContext() {}

func NewChoicesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoicesContext {
	var p = new(ChoicesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_choices

	return p
}

func (s *ChoicesContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoicesContext) AllChoice() []IChoiceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChoiceContext)(nil)).Elem())
	var tst = make([]IChoiceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChoiceContext)
		}
	}

	return tst
}

func (s *ChoicesContext) Choice(i int) IChoiceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoiceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChoiceContext)
}

func (s *ChoicesContext) AllBAR() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserBAR)
}

func (s *ChoicesContext) BAR(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserBAR, i)
}

func (s *ChoicesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoicesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoicesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterChoices(s)
	}
}

func (s *ChoicesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitChoices(s)
	}
}

func (p *vhdlParser) Choices() (localctx IChoicesContext) {
	this := p
	_ = this

	localctx = NewChoicesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, vhdlParserRULE_choices)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(878)
		p.Choice()
	}
	p.SetState(883)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserBAR {
		{
			p.SetState(879)
			p.Match(vhdlParserBAR)
		}
		{
			p.SetState(880)
			p.Choice()
		}

		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComponent_configurationContext is an interface to support dynamic dispatch.
type IComponent_configurationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_configurationContext differentiates from other interfaces.
	IsComponent_configurationContext()
}

type Component_configurationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_configurationContext() *Component_configurationContext {
	var p = new(Component_configurationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_component_configuration
	return p
}

func (*Component_configurationContext) IsComponent_configurationContext() {}

func NewComponent_configurationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_configurationContext {
	var p = new(Component_configurationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_component_configuration

	return p
}

func (s *Component_configurationContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_configurationContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserFOR)
}

func (s *Component_configurationContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, i)
}

func (s *Component_configurationContext) Component_specification() IComponent_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_specificationContext)
}

func (s *Component_configurationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Component_configurationContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Component_configurationContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Component_configurationContext) Binding_indication() IBinding_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinding_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinding_indicationContext)
}

func (s *Component_configurationContext) Block_configuration() IBlock_configurationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_configurationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_configurationContext)
}

func (s *Component_configurationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_configurationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_configurationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComponent_configuration(s)
	}
}

func (s *Component_configurationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComponent_configuration(s)
	}
}

func (p *vhdlParser) Component_configuration() (localctx IComponent_configurationContext) {
	this := p
	_ = this

	localctx = NewComponent_configurationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, vhdlParserRULE_component_configuration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(887)
		p.Component_specification()
	}
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC || _la == vhdlParserPORT || _la == vhdlParserUSE || _la == vhdlParserSEMI {
		{
			p.SetState(888)
			p.Binding_indication()
		}
		{
			p.SetState(889)
			p.Match(vhdlParserSEMI)
		}

	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR {
		{
			p.SetState(893)
			p.Block_configuration()
		}

	}
	{
		p.SetState(896)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(897)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(898)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IComponent_declarationContext is an interface to support dynamic dispatch.
type IComponent_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_declarationContext differentiates from other interfaces.
	IsComponent_declarationContext()
}

type Component_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_declarationContext() *Component_declarationContext {
	var p = new(Component_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_component_declaration
	return p
}

func (*Component_declarationContext) IsComponent_declarationContext() {}

func NewComponent_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_declarationContext {
	var p = new(Component_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_component_declaration

	return p
}

func (s *Component_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_declarationContext) AllCOMPONENT() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMPONENT)
}

func (s *Component_declarationContext) COMPONENT(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMPONENT, i)
}

func (s *Component_declarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Component_declarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Component_declarationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Component_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Component_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Component_declarationContext) Generic_clause() IGeneric_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_clauseContext)
}

func (s *Component_declarationContext) Port_clause() IPort_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_clauseContext)
}

func (s *Component_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComponent_declaration(s)
	}
}

func (s *Component_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComponent_declaration(s)
	}
}

func (p *vhdlParser) Component_declaration() (localctx IComponent_declarationContext) {
	this := p
	_ = this

	localctx = NewComponent_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, vhdlParserRULE_component_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(900)
		p.Match(vhdlParserCOMPONENT)
	}
	{
		p.SetState(901)
		p.Identifier()
	}
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(902)
			p.Match(vhdlParserIS)
		}

	}
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(905)
			p.Generic_clause()
		}

	}
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(908)
			p.Port_clause()
		}

	}
	{
		p.SetState(911)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(912)
		p.Match(vhdlParserCOMPONENT)
	}
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(913)
			p.Identifier()
		}

	}
	{
		p.SetState(916)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IComponent_instantiation_statementContext is an interface to support dynamic dispatch.
type IComponent_instantiation_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_instantiation_statementContext differentiates from other interfaces.
	IsComponent_instantiation_statementContext()
}

type Component_instantiation_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_instantiation_statementContext() *Component_instantiation_statementContext {
	var p = new(Component_instantiation_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_component_instantiation_statement
	return p
}

func (*Component_instantiation_statementContext) IsComponent_instantiation_statementContext() {}

func NewComponent_instantiation_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_instantiation_statementContext {
	var p = new(Component_instantiation_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_component_instantiation_statement

	return p
}

func (s *Component_instantiation_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_instantiation_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Component_instantiation_statementContext) Instantiated_unit() IInstantiated_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstantiated_unitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstantiated_unitContext)
}

func (s *Component_instantiation_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Component_instantiation_statementContext) Generic_map_aspect() IGeneric_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_map_aspectContext)
}

func (s *Component_instantiation_statementContext) Port_map_aspect() IPort_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_map_aspectContext)
}

func (s *Component_instantiation_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_instantiation_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_instantiation_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComponent_instantiation_statement(s)
	}
}

func (s *Component_instantiation_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComponent_instantiation_statement(s)
	}
}

func (p *vhdlParser) Component_instantiation_statement() (localctx IComponent_instantiation_statementContext) {
	this := p
	_ = this

	localctx = NewComponent_instantiation_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, vhdlParserRULE_component_instantiation_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(918)
		p.Label_colon()
	}
	{
		p.SetState(919)
		p.Instantiated_unit()
	}
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(920)
			p.Generic_map_aspect()
		}

	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(923)
			p.Port_map_aspect()
		}

	}
	{
		p.SetState(926)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IComponent_specificationContext is an interface to support dynamic dispatch.
type IComponent_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_specificationContext differentiates from other interfaces.
	IsComponent_specificationContext()
}

type Component_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_specificationContext() *Component_specificationContext {
	var p = new(Component_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_component_specification
	return p
}

func (*Component_specificationContext) IsComponent_specificationContext() {}

func NewComponent_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_specificationContext {
	var p = new(Component_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_component_specification

	return p
}

func (s *Component_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_specificationContext) Instantiation_list() IInstantiation_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstantiation_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstantiation_listContext)
}

func (s *Component_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Component_specificationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Component_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComponent_specification(s)
	}
}

func (s *Component_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComponent_specification(s)
	}
}

func (p *vhdlParser) Component_specification() (localctx IComponent_specificationContext) {
	this := p
	_ = this

	localctx = NewComponent_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, vhdlParserRULE_component_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Instantiation_list()
	}
	{
		p.SetState(929)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(930)
		p.Name()
	}

	return localctx
}

// IComposite_nature_definitionContext is an interface to support dynamic dispatch.
type IComposite_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComposite_nature_definitionContext differentiates from other interfaces.
	IsComposite_nature_definitionContext()
}

type Composite_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComposite_nature_definitionContext() *Composite_nature_definitionContext {
	var p = new(Composite_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_composite_nature_definition
	return p
}

func (*Composite_nature_definitionContext) IsComposite_nature_definitionContext() {}

func NewComposite_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Composite_nature_definitionContext {
	var p = new(Composite_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_composite_nature_definition

	return p
}

func (s *Composite_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Composite_nature_definitionContext) Array_nature_definition() IArray_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_nature_definitionContext)
}

func (s *Composite_nature_definitionContext) Record_nature_definition() IRecord_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecord_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecord_nature_definitionContext)
}

func (s *Composite_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Composite_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Composite_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComposite_nature_definition(s)
	}
}

func (s *Composite_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComposite_nature_definition(s)
	}
}

func (p *vhdlParser) Composite_nature_definition() (localctx IComposite_nature_definitionContext) {
	this := p
	_ = this

	localctx = NewComposite_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, vhdlParserRULE_composite_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(934)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.Array_nature_definition()
		}

	case vhdlParserRECORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(933)
			p.Record_nature_definition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComposite_type_definitionContext is an interface to support dynamic dispatch.
type IComposite_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComposite_type_definitionContext differentiates from other interfaces.
	IsComposite_type_definitionContext()
}

type Composite_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComposite_type_definitionContext() *Composite_type_definitionContext {
	var p = new(Composite_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_composite_type_definition
	return p
}

func (*Composite_type_definitionContext) IsComposite_type_definitionContext() {}

func NewComposite_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Composite_type_definitionContext {
	var p = new(Composite_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_composite_type_definition

	return p
}

func (s *Composite_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Composite_type_definitionContext) Array_type_definition() IArray_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_type_definitionContext)
}

func (s *Composite_type_definitionContext) Record_type_definition() IRecord_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecord_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecord_type_definitionContext)
}

func (s *Composite_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Composite_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Composite_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComposite_type_definition(s)
	}
}

func (s *Composite_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComposite_type_definition(s)
	}
}

func (p *vhdlParser) Composite_type_definition() (localctx IComposite_type_definitionContext) {
	this := p
	_ = this

	localctx = NewComposite_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, vhdlParserRULE_composite_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(938)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(936)
			p.Array_type_definition()
		}

	case vhdlParserRECORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(937)
			p.Record_type_definition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConcurrent_assertion_statementContext is an interface to support dynamic dispatch.
type IConcurrent_assertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_assertion_statementContext differentiates from other interfaces.
	IsConcurrent_assertion_statementContext()
}

type Concurrent_assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_assertion_statementContext() *Concurrent_assertion_statementContext {
	var p = new(Concurrent_assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_concurrent_assertion_statement
	return p
}

func (*Concurrent_assertion_statementContext) IsConcurrent_assertion_statementContext() {}

func NewConcurrent_assertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_assertion_statementContext {
	var p = new(Concurrent_assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_concurrent_assertion_statement

	return p
}

func (s *Concurrent_assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_assertion_statementContext) Assertion() IAssertionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertionContext)
}

func (s *Concurrent_assertion_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Concurrent_assertion_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Concurrent_assertion_statementContext) POSTPONED() antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, 0)
}

func (s *Concurrent_assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConcurrent_assertion_statement(s)
	}
}

func (s *Concurrent_assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConcurrent_assertion_statement(s)
	}
}

func (p *vhdlParser) Concurrent_assertion_statement() (localctx IConcurrent_assertion_statementContext) {
	this := p
	_ = this

	localctx = NewConcurrent_assertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, vhdlParserRULE_concurrent_assertion_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(941)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(940)
			p.Label_colon()
		}

	}
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(943)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	{
		p.SetState(946)
		p.Assertion()
	}
	{
		p.SetState(947)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConcurrent_break_statementContext is an interface to support dynamic dispatch.
type IConcurrent_break_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_break_statementContext differentiates from other interfaces.
	IsConcurrent_break_statementContext()
}

type Concurrent_break_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_break_statementContext() *Concurrent_break_statementContext {
	var p = new(Concurrent_break_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_concurrent_break_statement
	return p
}

func (*Concurrent_break_statementContext) IsConcurrent_break_statementContext() {}

func NewConcurrent_break_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_break_statementContext {
	var p = new(Concurrent_break_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_concurrent_break_statement

	return p
}

func (s *Concurrent_break_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_break_statementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(vhdlParserBREAK, 0)
}

func (s *Concurrent_break_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Concurrent_break_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Concurrent_break_statementContext) Break_list() IBreak_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_listContext)
}

func (s *Concurrent_break_statementContext) Sensitivity_clause() ISensitivity_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISensitivity_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISensitivity_clauseContext)
}

func (s *Concurrent_break_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Concurrent_break_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Concurrent_break_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_break_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_break_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConcurrent_break_statement(s)
	}
}

func (s *Concurrent_break_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConcurrent_break_statement(s)
	}
}

func (p *vhdlParser) Concurrent_break_statement() (localctx IConcurrent_break_statementContext) {
	this := p
	_ = this

	localctx = NewConcurrent_break_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, vhdlParserRULE_concurrent_break_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(949)
			p.Label_colon()
		}

	}
	{
		p.SetState(952)
		p.Match(vhdlParserBREAK)
	}
	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserSTRING_LITERAL-118)))) != 0) {
		{
			p.SetState(953)
			p.Break_list()
		}

	}
	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserON {
		{
			p.SetState(956)
			p.Sensitivity_clause()
		}

	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(959)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(960)
			p.Condition()
		}

	}
	{
		p.SetState(963)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConcurrent_procedure_call_statementContext is an interface to support dynamic dispatch.
type IConcurrent_procedure_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_procedure_call_statementContext differentiates from other interfaces.
	IsConcurrent_procedure_call_statementContext()
}

type Concurrent_procedure_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_procedure_call_statementContext() *Concurrent_procedure_call_statementContext {
	var p = new(Concurrent_procedure_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_concurrent_procedure_call_statement
	return p
}

func (*Concurrent_procedure_call_statementContext) IsConcurrent_procedure_call_statementContext() {}

func NewConcurrent_procedure_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_procedure_call_statementContext {
	var p = new(Concurrent_procedure_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_concurrent_procedure_call_statement

	return p
}

func (s *Concurrent_procedure_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_procedure_call_statementContext) Procedure_call() IProcedure_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_callContext)
}

func (s *Concurrent_procedure_call_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Concurrent_procedure_call_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Concurrent_procedure_call_statementContext) POSTPONED() antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, 0)
}

func (s *Concurrent_procedure_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_procedure_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_procedure_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConcurrent_procedure_call_statement(s)
	}
}

func (s *Concurrent_procedure_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConcurrent_procedure_call_statement(s)
	}
}

func (p *vhdlParser) Concurrent_procedure_call_statement() (localctx IConcurrent_procedure_call_statementContext) {
	this := p
	_ = this

	localctx = NewConcurrent_procedure_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, vhdlParserRULE_concurrent_procedure_call_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(966)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(965)
			p.Label_colon()
		}

	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(968)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	{
		p.SetState(971)
		p.Procedure_call()
	}
	{
		p.SetState(972)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConcurrent_signal_assignment_statementContext is an interface to support dynamic dispatch.
type IConcurrent_signal_assignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_signal_assignment_statementContext differentiates from other interfaces.
	IsConcurrent_signal_assignment_statementContext()
}

type Concurrent_signal_assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_signal_assignment_statementContext() *Concurrent_signal_assignment_statementContext {
	var p = new(Concurrent_signal_assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_concurrent_signal_assignment_statement
	return p
}

func (*Concurrent_signal_assignment_statementContext) IsConcurrent_signal_assignment_statementContext() {
}

func NewConcurrent_signal_assignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_signal_assignment_statementContext {
	var p = new(Concurrent_signal_assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_concurrent_signal_assignment_statement

	return p
}

func (s *Concurrent_signal_assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_signal_assignment_statementContext) Conditional_signal_assignment() IConditional_signal_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_signal_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_signal_assignmentContext)
}

func (s *Concurrent_signal_assignment_statementContext) Selected_signal_assignment() ISelected_signal_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_signal_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_signal_assignmentContext)
}

func (s *Concurrent_signal_assignment_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Concurrent_signal_assignment_statementContext) POSTPONED() antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, 0)
}

func (s *Concurrent_signal_assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_signal_assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_signal_assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConcurrent_signal_assignment_statement(s)
	}
}

func (s *Concurrent_signal_assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConcurrent_signal_assignment_statement(s)
	}
}

func (p *vhdlParser) Concurrent_signal_assignment_statement() (localctx IConcurrent_signal_assignment_statementContext) {
	this := p
	_ = this

	localctx = NewConcurrent_signal_assignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, vhdlParserRULE_concurrent_signal_assignment_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(975)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(974)
			p.Label_colon()
		}

	}
	p.SetState(978)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(977)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	p.SetState(982)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserSTRING_LITERAL, vhdlParserLPAREN:
		{
			p.SetState(980)
			p.Conditional_signal_assignment()
		}

	case vhdlParserWITH:
		{
			p.SetState(981)
			p.Selected_signal_assignment()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_condition
	return p
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (p *vhdlParser) Condition() (localctx IConditionContext) {
	this := p
	_ = this

	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, vhdlParserRULE_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		p.Expression()
	}

	return localctx
}

// ICondition_clauseContext is an interface to support dynamic dispatch.
type ICondition_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCondition_clauseContext differentiates from other interfaces.
	IsCondition_clauseContext()
}

type Condition_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCondition_clauseContext() *Condition_clauseContext {
	var p = new(Condition_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_condition_clause
	return p
}

func (*Condition_clauseContext) IsCondition_clauseContext() {}

func NewCondition_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Condition_clauseContext {
	var p = new(Condition_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_condition_clause

	return p
}

func (s *Condition_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Condition_clauseContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(vhdlParserUNTIL, 0)
}

func (s *Condition_clauseContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Condition_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Condition_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Condition_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterCondition_clause(s)
	}
}

func (s *Condition_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitCondition_clause(s)
	}
}

func (p *vhdlParser) Condition_clause() (localctx ICondition_clauseContext) {
	this := p
	_ = this

	localctx = NewCondition_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, vhdlParserRULE_condition_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(986)
		p.Match(vhdlParserUNTIL)
	}
	{
		p.SetState(987)
		p.Condition()
	}

	return localctx
}

// IConditional_signal_assignmentContext is an interface to support dynamic dispatch.
type IConditional_signal_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_signal_assignmentContext differentiates from other interfaces.
	IsConditional_signal_assignmentContext()
}

type Conditional_signal_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_signal_assignmentContext() *Conditional_signal_assignmentContext {
	var p = new(Conditional_signal_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_conditional_signal_assignment
	return p
}

func (*Conditional_signal_assignmentContext) IsConditional_signal_assignmentContext() {}

func NewConditional_signal_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_signal_assignmentContext {
	var p = new(Conditional_signal_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_conditional_signal_assignment

	return p
}

func (s *Conditional_signal_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_signal_assignmentContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Conditional_signal_assignmentContext) LE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLE, 0)
}

func (s *Conditional_signal_assignmentContext) Opts() IOptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptsContext)
}

func (s *Conditional_signal_assignmentContext) Conditional_waveforms() IConditional_waveformsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_waveformsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_waveformsContext)
}

func (s *Conditional_signal_assignmentContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Conditional_signal_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_signal_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_signal_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConditional_signal_assignment(s)
	}
}

func (s *Conditional_signal_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConditional_signal_assignment(s)
	}
}

func (p *vhdlParser) Conditional_signal_assignment() (localctx IConditional_signal_assignmentContext) {
	this := p
	_ = this

	localctx = NewConditional_signal_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, vhdlParserRULE_conditional_signal_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(989)
		p.Target()
	}
	{
		p.SetState(990)
		p.Match(vhdlParserLE)
	}
	{
		p.SetState(991)
		p.Opts()
	}
	{
		p.SetState(992)
		p.Conditional_waveforms()
	}
	{
		p.SetState(993)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConditional_waveformsContext is an interface to support dynamic dispatch.
type IConditional_waveformsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_waveformsContext differentiates from other interfaces.
	IsConditional_waveformsContext()
}

type Conditional_waveformsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_waveformsContext() *Conditional_waveformsContext {
	var p = new(Conditional_waveformsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_conditional_waveforms
	return p
}

func (*Conditional_waveformsContext) IsConditional_waveformsContext() {}

func NewConditional_waveformsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_waveformsContext {
	var p = new(Conditional_waveformsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_conditional_waveforms

	return p
}

func (s *Conditional_waveformsContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_waveformsContext) Waveform() IWaveformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaveformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWaveformContext)
}

func (s *Conditional_waveformsContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Conditional_waveformsContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Conditional_waveformsContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vhdlParserELSE, 0)
}

func (s *Conditional_waveformsContext) Conditional_waveforms() IConditional_waveformsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_waveformsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_waveformsContext)
}

func (s *Conditional_waveformsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_waveformsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_waveformsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConditional_waveforms(s)
	}
}

func (s *Conditional_waveformsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConditional_waveforms(s)
	}
}

func (p *vhdlParser) Conditional_waveforms() (localctx IConditional_waveformsContext) {
	this := p
	_ = this

	localctx = NewConditional_waveformsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, vhdlParserRULE_conditional_waveforms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.Waveform()
	}
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(996)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(997)
			p.Condition()
		}
		p.SetState(1000)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserELSE {
			{
				p.SetState(998)
				p.Match(vhdlParserELSE)
			}
			{
				p.SetState(999)
				p.Conditional_waveforms()
			}

		}

	}

	return localctx
}

// IConfiguration_declarationContext is an interface to support dynamic dispatch.
type IConfiguration_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_declarationContext differentiates from other interfaces.
	IsConfiguration_declarationContext()
}

type Configuration_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_declarationContext() *Configuration_declarationContext {
	var p = new(Configuration_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_declaration
	return p
}

func (*Configuration_declarationContext) IsConfiguration_declarationContext() {}

func NewConfiguration_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_declarationContext {
	var p = new(Configuration_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_declaration

	return p
}

func (s *Configuration_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_declarationContext) AllCONFIGURATION() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCONFIGURATION)
}

func (s *Configuration_declarationContext) CONFIGURATION(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCONFIGURATION, i)
}

func (s *Configuration_declarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Configuration_declarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Configuration_declarationContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Configuration_declarationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Configuration_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Configuration_declarationContext) Configuration_declarative_part() IConfiguration_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_declarative_partContext)
}

func (s *Configuration_declarationContext) Block_configuration() IBlock_configurationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_configurationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_configurationContext)
}

func (s *Configuration_declarationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Configuration_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Configuration_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_declaration(s)
	}
}

func (s *Configuration_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_declaration(s)
	}
}

func (p *vhdlParser) Configuration_declaration() (localctx IConfiguration_declarationContext) {
	this := p
	_ = this

	localctx = NewConfiguration_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, vhdlParserRULE_configuration_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.Match(vhdlParserCONFIGURATION)
	}
	{
		p.SetState(1005)
		p.Identifier()
	}
	{
		p.SetState(1006)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(1007)
		p.Name()
	}
	{
		p.SetState(1008)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1009)
		p.Configuration_declarative_part()
	}
	{
		p.SetState(1010)
		p.Block_configuration()
	}
	{
		p.SetState(1011)
		p.Match(vhdlParserEND)
	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserCONFIGURATION {
		{
			p.SetState(1012)
			p.Match(vhdlParserCONFIGURATION)
		}

	}
	p.SetState(1016)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1015)
			p.Identifier()
		}

	}
	{
		p.SetState(1018)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConfiguration_declarative_itemContext is an interface to support dynamic dispatch.
type IConfiguration_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_declarative_itemContext differentiates from other interfaces.
	IsConfiguration_declarative_itemContext()
}

type Configuration_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_declarative_itemContext() *Configuration_declarative_itemContext {
	var p = new(Configuration_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_declarative_item
	return p
}

func (*Configuration_declarative_itemContext) IsConfiguration_declarative_itemContext() {}

func NewConfiguration_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_declarative_itemContext {
	var p = new(Configuration_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_declarative_item

	return p
}

func (s *Configuration_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Configuration_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Configuration_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Configuration_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_declarative_item(s)
	}
}

func (s *Configuration_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_declarative_item(s)
	}
}

func (p *vhdlParser) Configuration_declarative_item() (localctx IConfiguration_declarative_itemContext) {
	this := p
	_ = this

	localctx = NewConfiguration_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, vhdlParserRULE_configuration_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1023)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserUSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1020)
			p.Use_clause()
		}

	case vhdlParserATTRIBUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1021)
			p.Attribute_specification()
		}

	case vhdlParserGROUP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1022)
			p.Group_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConfiguration_declarative_partContext is an interface to support dynamic dispatch.
type IConfiguration_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_declarative_partContext differentiates from other interfaces.
	IsConfiguration_declarative_partContext()
}

type Configuration_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_declarative_partContext() *Configuration_declarative_partContext {
	var p = new(Configuration_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_declarative_part
	return p
}

func (*Configuration_declarative_partContext) IsConfiguration_declarative_partContext() {}

func NewConfiguration_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_declarative_partContext {
	var p = new(Configuration_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_declarative_part

	return p
}

func (s *Configuration_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_declarative_partContext) AllConfiguration_declarative_item() []IConfiguration_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfiguration_declarative_itemContext)(nil)).Elem())
	var tst = make([]IConfiguration_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfiguration_declarative_itemContext)
		}
	}

	return tst
}

func (s *Configuration_declarative_partContext) Configuration_declarative_item(i int) IConfiguration_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_declarative_itemContext)
}

func (s *Configuration_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_declarative_part(s)
	}
}

func (s *Configuration_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_declarative_part(s)
	}
}

func (p *vhdlParser) Configuration_declarative_part() (localctx IConfiguration_declarative_partContext) {
	this := p
	_ = this

	localctx = NewConfiguration_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, vhdlParserRULE_configuration_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserATTRIBUTE || _la == vhdlParserGROUP || _la == vhdlParserUSE {
		{
			p.SetState(1025)
			p.Configuration_declarative_item()
		}

		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConfiguration_itemContext is an interface to support dynamic dispatch.
type IConfiguration_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_itemContext differentiates from other interfaces.
	IsConfiguration_itemContext()
}

type Configuration_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_itemContext() *Configuration_itemContext {
	var p = new(Configuration_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_item
	return p
}

func (*Configuration_itemContext) IsConfiguration_itemContext() {}

func NewConfiguration_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_itemContext {
	var p = new(Configuration_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_item

	return p
}

func (s *Configuration_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_itemContext) Block_configuration() IBlock_configurationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_configurationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_configurationContext)
}

func (s *Configuration_itemContext) Component_configuration() IComponent_configurationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_configurationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_configurationContext)
}

func (s *Configuration_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_item(s)
	}
}

func (s *Configuration_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_item(s)
	}
}

func (p *vhdlParser) Configuration_item() (localctx IConfiguration_itemContext) {
	this := p
	_ = this

	localctx = NewConfiguration_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, vhdlParserRULE_configuration_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1033)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1031)
			p.Block_configuration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1032)
			p.Component_configuration()
		}

	}

	return localctx
}

// IConfiguration_specificationContext is an interface to support dynamic dispatch.
type IConfiguration_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_specificationContext differentiates from other interfaces.
	IsConfiguration_specificationContext()
}

type Configuration_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_specificationContext() *Configuration_specificationContext {
	var p = new(Configuration_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_specification
	return p
}

func (*Configuration_specificationContext) IsConfiguration_specificationContext() {}

func NewConfiguration_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_specificationContext {
	var p = new(Configuration_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_specification

	return p
}

func (s *Configuration_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_specificationContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Configuration_specificationContext) Component_specification() IComponent_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_specificationContext)
}

func (s *Configuration_specificationContext) Binding_indication() IBinding_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinding_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinding_indicationContext)
}

func (s *Configuration_specificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Configuration_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_specification(s)
	}
}

func (s *Configuration_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_specification(s)
	}
}

func (p *vhdlParser) Configuration_specification() (localctx IConfiguration_specificationContext) {
	this := p
	_ = this

	localctx = NewConfiguration_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, vhdlParserRULE_configuration_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1035)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(1036)
		p.Component_specification()
	}
	{
		p.SetState(1037)
		p.Binding_indication()
	}
	{
		p.SetState(1038)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConstant_declarationContext is an interface to support dynamic dispatch.
type IConstant_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_declarationContext differentiates from other interfaces.
	IsConstant_declarationContext()
}

type Constant_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_declarationContext() *Constant_declarationContext {
	var p = new(Constant_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_constant_declaration
	return p
}

func (*Constant_declarationContext) IsConstant_declarationContext() {}

func NewConstant_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_declarationContext {
	var p = new(Constant_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_constant_declaration

	return p
}

func (s *Constant_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_declarationContext) CONSTANT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONSTANT, 0)
}

func (s *Constant_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Constant_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Constant_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Constant_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Constant_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Constant_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Constant_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConstant_declaration(s)
	}
}

func (s *Constant_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConstant_declaration(s)
	}
}

func (p *vhdlParser) Constant_declaration() (localctx IConstant_declarationContext) {
	this := p
	_ = this

	localctx = NewConstant_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, vhdlParserRULE_constant_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		p.Match(vhdlParserCONSTANT)
	}
	{
		p.SetState(1041)
		p.Identifier_list()
	}
	{
		p.SetState(1042)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1043)
		p.Subtype_indication()
	}
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1044)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1045)
			p.Expression()
		}

	}
	{
		p.SetState(1048)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConstrained_array_definitionContext is an interface to support dynamic dispatch.
type IConstrained_array_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstrained_array_definitionContext differentiates from other interfaces.
	IsConstrained_array_definitionContext()
}

type Constrained_array_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrained_array_definitionContext() *Constrained_array_definitionContext {
	var p = new(Constrained_array_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_constrained_array_definition
	return p
}

func (*Constrained_array_definitionContext) IsConstrained_array_definitionContext() {}

func NewConstrained_array_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constrained_array_definitionContext {
	var p = new(Constrained_array_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_constrained_array_definition

	return p
}

func (s *Constrained_array_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constrained_array_definitionContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(vhdlParserARRAY, 0)
}

func (s *Constrained_array_definitionContext) Index_constraint() IIndex_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_constraintContext)
}

func (s *Constrained_array_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Constrained_array_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Constrained_array_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constrained_array_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constrained_array_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConstrained_array_definition(s)
	}
}

func (s *Constrained_array_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConstrained_array_definition(s)
	}
}

func (p *vhdlParser) Constrained_array_definition() (localctx IConstrained_array_definitionContext) {
	this := p
	_ = this

	localctx = NewConstrained_array_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, vhdlParserRULE_constrained_array_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1050)
		p.Match(vhdlParserARRAY)
	}
	{
		p.SetState(1051)
		p.Index_constraint()
	}
	{
		p.SetState(1052)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(1053)
		p.Subtype_indication()
	}

	return localctx
}

// IConstrained_nature_definitionContext is an interface to support dynamic dispatch.
type IConstrained_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstrained_nature_definitionContext differentiates from other interfaces.
	IsConstrained_nature_definitionContext()
}

type Constrained_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrained_nature_definitionContext() *Constrained_nature_definitionContext {
	var p = new(Constrained_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_constrained_nature_definition
	return p
}

func (*Constrained_nature_definitionContext) IsConstrained_nature_definitionContext() {}

func NewConstrained_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constrained_nature_definitionContext {
	var p = new(Constrained_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_constrained_nature_definition

	return p
}

func (s *Constrained_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constrained_nature_definitionContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(vhdlParserARRAY, 0)
}

func (s *Constrained_nature_definitionContext) Index_constraint() IIndex_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_constraintContext)
}

func (s *Constrained_nature_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Constrained_nature_definitionContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Constrained_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constrained_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constrained_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConstrained_nature_definition(s)
	}
}

func (s *Constrained_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConstrained_nature_definition(s)
	}
}

func (p *vhdlParser) Constrained_nature_definition() (localctx IConstrained_nature_definitionContext) {
	this := p
	_ = this

	localctx = NewConstrained_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, vhdlParserRULE_constrained_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		p.Match(vhdlParserARRAY)
	}
	{
		p.SetState(1056)
		p.Index_constraint()
	}
	{
		p.SetState(1057)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(1058)
		p.Subnature_indication()
	}

	return localctx
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_constraint
	return p
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) Range_constraint() IRange_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_constraintContext)
}

func (s *ConstraintContext) Index_constraint() IIndex_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_constraintContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (p *vhdlParser) Constraint() (localctx IConstraintContext) {
	this := p
	_ = this

	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, vhdlParserRULE_constraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1062)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserRANGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1060)
			p.Range_constraint()
		}

	case vhdlParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1061)
			p.Index_constraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IContext_clauseContext is an interface to support dynamic dispatch.
type IContext_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContext_clauseContext differentiates from other interfaces.
	IsContext_clauseContext()
}

type Context_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContext_clauseContext() *Context_clauseContext {
	var p = new(Context_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_context_clause
	return p
}

func (*Context_clauseContext) IsContext_clauseContext() {}

func NewContext_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Context_clauseContext {
	var p = new(Context_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_context_clause

	return p
}

func (s *Context_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Context_clauseContext) AllContext_item() []IContext_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IContext_itemContext)(nil)).Elem())
	var tst = make([]IContext_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IContext_itemContext)
		}
	}

	return tst
}

func (s *Context_clauseContext) Context_item(i int) IContext_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContext_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IContext_itemContext)
}

func (s *Context_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Context_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Context_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterContext_clause(s)
	}
}

func (s *Context_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitContext_clause(s)
	}
}

func (p *vhdlParser) Context_clause() (localctx IContext_clauseContext) {
	this := p
	_ = this

	localctx = NewContext_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, vhdlParserRULE_context_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserLIBRARY || _la == vhdlParserUSE {
		{
			p.SetState(1064)
			p.Context_item()
		}

		p.SetState(1069)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IContext_itemContext is an interface to support dynamic dispatch.
type IContext_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContext_itemContext differentiates from other interfaces.
	IsContext_itemContext()
}

type Context_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContext_itemContext() *Context_itemContext {
	var p = new(Context_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_context_item
	return p
}

func (*Context_itemContext) IsContext_itemContext() {}

func NewContext_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Context_itemContext {
	var p = new(Context_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_context_item

	return p
}

func (s *Context_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Context_itemContext) Library_clause() ILibrary_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_clauseContext)
}

func (s *Context_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Context_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Context_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Context_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterContext_item(s)
	}
}

func (s *Context_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitContext_item(s)
	}
}

func (p *vhdlParser) Context_item() (localctx IContext_itemContext) {
	this := p
	_ = this

	localctx = NewContext_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, vhdlParserRULE_context_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1072)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserLIBRARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1070)
			p.Library_clause()
		}

	case vhdlParserUSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1071)
			p.Use_clause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDelay_mechanismContext is an interface to support dynamic dispatch.
type IDelay_mechanismContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_mechanismContext differentiates from other interfaces.
	IsDelay_mechanismContext()
}

type Delay_mechanismContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_mechanismContext() *Delay_mechanismContext {
	var p = new(Delay_mechanismContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_delay_mechanism
	return p
}

func (*Delay_mechanismContext) IsDelay_mechanismContext() {}

func NewDelay_mechanismContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_mechanismContext {
	var p = new(Delay_mechanismContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_delay_mechanism

	return p
}

func (s *Delay_mechanismContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_mechanismContext) TRANSPORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserTRANSPORT, 0)
}

func (s *Delay_mechanismContext) INERTIAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserINERTIAL, 0)
}

func (s *Delay_mechanismContext) REJECT() antlr.TerminalNode {
	return s.GetToken(vhdlParserREJECT, 0)
}

func (s *Delay_mechanismContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Delay_mechanismContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_mechanismContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_mechanismContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDelay_mechanism(s)
	}
}

func (s *Delay_mechanismContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDelay_mechanism(s)
	}
}

func (p *vhdlParser) Delay_mechanism() (localctx IDelay_mechanismContext) {
	this := p
	_ = this

	localctx = NewDelay_mechanismContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, vhdlParserRULE_delay_mechanism)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1080)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserTRANSPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1074)
			p.Match(vhdlParserTRANSPORT)
		}

	case vhdlParserINERTIAL, vhdlParserREJECT:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserREJECT {
			{
				p.SetState(1075)
				p.Match(vhdlParserREJECT)
			}
			{
				p.SetState(1076)
				p.Expression()
			}

		}
		{
			p.SetState(1079)
			p.Match(vhdlParserINERTIAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDesign_fileContext is an interface to support dynamic dispatch.
type IDesign_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesign_fileContext differentiates from other interfaces.
	IsDesign_fileContext()
}

type Design_fileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesign_fileContext() *Design_fileContext {
	var p = new(Design_fileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_design_file
	return p
}

func (*Design_fileContext) IsDesign_fileContext() {}

func NewDesign_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Design_fileContext {
	var p = new(Design_fileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_design_file

	return p
}

func (s *Design_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Design_fileContext) EOF() antlr.TerminalNode {
	return s.GetToken(vhdlParserEOF, 0)
}

func (s *Design_fileContext) AllDesign_unit() []IDesign_unitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesign_unitContext)(nil)).Elem())
	var tst = make([]IDesign_unitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesign_unitContext)
		}
	}

	return tst
}

func (s *Design_fileContext) Design_unit(i int) IDesign_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesign_unitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesign_unitContext)
}

func (s *Design_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Design_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Design_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDesign_file(s)
	}
}

func (s *Design_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDesign_file(s)
	}
}

func (p *vhdlParser) Design_file() (localctx IDesign_fileContext) {
	this := p
	_ = this

	localctx = NewDesign_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, vhdlParserRULE_design_file)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserARCHITECTURE)|(1<<vhdlParserCONFIGURATION)|(1<<vhdlParserENTITY))) != 0) || _la == vhdlParserLIBRARY || _la == vhdlParserPACKAGE || _la == vhdlParserUSE {
		{
			p.SetState(1082)
			p.Design_unit()
		}

		p.SetState(1087)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1088)
		p.Match(vhdlParserEOF)
	}

	return localctx
}

// IDesign_unitContext is an interface to support dynamic dispatch.
type IDesign_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesign_unitContext differentiates from other interfaces.
	IsDesign_unitContext()
}

type Design_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesign_unitContext() *Design_unitContext {
	var p = new(Design_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_design_unit
	return p
}

func (*Design_unitContext) IsDesign_unitContext() {}

func NewDesign_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Design_unitContext {
	var p = new(Design_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_design_unit

	return p
}

func (s *Design_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Design_unitContext) Context_clause() IContext_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContext_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContext_clauseContext)
}

func (s *Design_unitContext) Library_unit() ILibrary_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_unitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_unitContext)
}

func (s *Design_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Design_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Design_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDesign_unit(s)
	}
}

func (s *Design_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDesign_unit(s)
	}
}

func (p *vhdlParser) Design_unit() (localctx IDesign_unitContext) {
	this := p
	_ = this

	localctx = NewDesign_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, vhdlParserRULE_design_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1090)
		p.Context_clause()
	}
	{
		p.SetState(1091)
		p.Library_unit()
	}

	return localctx
}

// IDesignatorContext is an interface to support dynamic dispatch.
type IDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignatorContext differentiates from other interfaces.
	IsDesignatorContext()
}

type DesignatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorContext() *DesignatorContext {
	var p = new(DesignatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_designator
	return p
}

func (*DesignatorContext) IsDesignatorContext() {}

func NewDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorContext {
	var p = new(DesignatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_designator

	return p
}

func (s *DesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DesignatorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *DesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDesignator(s)
	}
}

func (s *DesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDesignator(s)
	}
}

func (p *vhdlParser) Designator() (localctx IDesignatorContext) {
	this := p
	_ = this

	localctx = NewDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, vhdlParserRULE_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1095)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1093)
			p.Identifier()
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1094)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDirectionContext is an interface to support dynamic dispatch.
type IDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectionContext differentiates from other interfaces.
	IsDirectionContext()
}

type DirectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectionContext() *DirectionContext {
	var p = new(DirectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_direction
	return p
}

func (*DirectionContext) IsDirectionContext() {}

func NewDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectionContext {
	var p = new(DirectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_direction

	return p
}

func (s *DirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectionContext) TO() antlr.TerminalNode {
	return s.GetToken(vhdlParserTO, 0)
}

func (s *DirectionContext) DOWNTO() antlr.TerminalNode {
	return s.GetToken(vhdlParserDOWNTO, 0)
}

func (s *DirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDirection(s)
	}
}

func (s *DirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDirection(s)
	}
}

func (p *vhdlParser) Direction() (localctx IDirectionContext) {
	this := p
	_ = this

	localctx = NewDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, vhdlParserRULE_direction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserDOWNTO || _la == vhdlParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDisconnection_specificationContext is an interface to support dynamic dispatch.
type IDisconnection_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisconnection_specificationContext differentiates from other interfaces.
	IsDisconnection_specificationContext()
}

type Disconnection_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisconnection_specificationContext() *Disconnection_specificationContext {
	var p = new(Disconnection_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_disconnection_specification
	return p
}

func (*Disconnection_specificationContext) IsDisconnection_specificationContext() {}

func NewDisconnection_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Disconnection_specificationContext {
	var p = new(Disconnection_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_disconnection_specification

	return p
}

func (s *Disconnection_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Disconnection_specificationContext) DISCONNECT() antlr.TerminalNode {
	return s.GetToken(vhdlParserDISCONNECT, 0)
}

func (s *Disconnection_specificationContext) Guarded_signal_specification() IGuarded_signal_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGuarded_signal_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGuarded_signal_specificationContext)
}

func (s *Disconnection_specificationContext) AFTER() antlr.TerminalNode {
	return s.GetToken(vhdlParserAFTER, 0)
}

func (s *Disconnection_specificationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Disconnection_specificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Disconnection_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Disconnection_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Disconnection_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDisconnection_specification(s)
	}
}

func (s *Disconnection_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDisconnection_specification(s)
	}
}

func (p *vhdlParser) Disconnection_specification() (localctx IDisconnection_specificationContext) {
	this := p
	_ = this

	localctx = NewDisconnection_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, vhdlParserRULE_disconnection_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.Match(vhdlParserDISCONNECT)
	}
	{
		p.SetState(1100)
		p.Guarded_signal_specification()
	}
	{
		p.SetState(1101)
		p.Match(vhdlParserAFTER)
	}
	{
		p.SetState(1102)
		p.Expression()
	}
	{
		p.SetState(1103)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IDiscrete_rangeContext is an interface to support dynamic dispatch.
type IDiscrete_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDiscrete_rangeContext differentiates from other interfaces.
	IsDiscrete_rangeContext()
}

type Discrete_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiscrete_rangeContext() *Discrete_rangeContext {
	var p = new(Discrete_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_discrete_range
	return p
}

func (*Discrete_rangeContext) IsDiscrete_rangeContext() {}

func NewDiscrete_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Discrete_rangeContext {
	var p = new(Discrete_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_discrete_range

	return p
}

func (s *Discrete_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Discrete_rangeContext) Range_decl() IRange_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_declContext)
}

func (s *Discrete_rangeContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Discrete_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Discrete_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Discrete_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDiscrete_range(s)
	}
}

func (s *Discrete_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDiscrete_range(s)
	}
}

func (p *vhdlParser) Discrete_range() (localctx IDiscrete_rangeContext) {
	this := p
	_ = this

	localctx = NewDiscrete_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, vhdlParserRULE_discrete_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1105)
			p.Range_decl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1106)
			p.Subtype_indication()
		}

	}

	return localctx
}

// IElement_associationContext is an interface to support dynamic dispatch.
type IElement_associationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_associationContext differentiates from other interfaces.
	IsElement_associationContext()
}

type Element_associationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_associationContext() *Element_associationContext {
	var p = new(Element_associationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_element_association
	return p
}

func (*Element_associationContext) IsElement_associationContext() {}

func NewElement_associationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_associationContext {
	var p = new(Element_associationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_element_association

	return p
}

func (s *Element_associationContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_associationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Element_associationContext) Choices() IChoicesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoicesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoicesContext)
}

func (s *Element_associationContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Element_associationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_associationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_associationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterElement_association(s)
	}
}

func (s *Element_associationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitElement_association(s)
	}
}

func (p *vhdlParser) Element_association() (localctx IElement_associationContext) {
	this := p
	_ = this

	localctx = NewElement_associationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, vhdlParserRULE_element_association)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1112)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1109)
			p.Choices()
		}
		{
			p.SetState(1110)
			p.Match(vhdlParserARROW)
		}

	}
	{
		p.SetState(1114)
		p.Expression()
	}

	return localctx
}

// IElement_declarationContext is an interface to support dynamic dispatch.
type IElement_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_declarationContext differentiates from other interfaces.
	IsElement_declarationContext()
}

type Element_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_declarationContext() *Element_declarationContext {
	var p = new(Element_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_element_declaration
	return p
}

func (*Element_declarationContext) IsElement_declarationContext() {}

func NewElement_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_declarationContext {
	var p = new(Element_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_element_declaration

	return p
}

func (s *Element_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Element_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Element_declarationContext) Element_subtype_definition() IElement_subtype_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_subtype_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElement_subtype_definitionContext)
}

func (s *Element_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Element_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterElement_declaration(s)
	}
}

func (s *Element_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitElement_declaration(s)
	}
}

func (p *vhdlParser) Element_declaration() (localctx IElement_declarationContext) {
	this := p
	_ = this

	localctx = NewElement_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, vhdlParserRULE_element_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1116)
		p.Identifier_list()
	}
	{
		p.SetState(1117)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1118)
		p.Element_subtype_definition()
	}
	{
		p.SetState(1119)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IElement_subnature_definitionContext is an interface to support dynamic dispatch.
type IElement_subnature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_subnature_definitionContext differentiates from other interfaces.
	IsElement_subnature_definitionContext()
}

type Element_subnature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_subnature_definitionContext() *Element_subnature_definitionContext {
	var p = new(Element_subnature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_element_subnature_definition
	return p
}

func (*Element_subnature_definitionContext) IsElement_subnature_definitionContext() {}

func NewElement_subnature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_subnature_definitionContext {
	var p = new(Element_subnature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_element_subnature_definition

	return p
}

func (s *Element_subnature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_subnature_definitionContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Element_subnature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_subnature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_subnature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterElement_subnature_definition(s)
	}
}

func (s *Element_subnature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitElement_subnature_definition(s)
	}
}

func (p *vhdlParser) Element_subnature_definition() (localctx IElement_subnature_definitionContext) {
	this := p
	_ = this

	localctx = NewElement_subnature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, vhdlParserRULE_element_subnature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.Subnature_indication()
	}

	return localctx
}

// IElement_subtype_definitionContext is an interface to support dynamic dispatch.
type IElement_subtype_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_subtype_definitionContext differentiates from other interfaces.
	IsElement_subtype_definitionContext()
}

type Element_subtype_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_subtype_definitionContext() *Element_subtype_definitionContext {
	var p = new(Element_subtype_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_element_subtype_definition
	return p
}

func (*Element_subtype_definitionContext) IsElement_subtype_definitionContext() {}

func NewElement_subtype_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_subtype_definitionContext {
	var p = new(Element_subtype_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_element_subtype_definition

	return p
}

func (s *Element_subtype_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_subtype_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Element_subtype_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_subtype_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_subtype_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterElement_subtype_definition(s)
	}
}

func (s *Element_subtype_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitElement_subtype_definition(s)
	}
}

func (p *vhdlParser) Element_subtype_definition() (localctx IElement_subtype_definitionContext) {
	this := p
	_ = this

	localctx = NewElement_subtype_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, vhdlParserRULE_element_subtype_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1123)
		p.Subtype_indication()
	}

	return localctx
}

// IEntity_aspectContext is an interface to support dynamic dispatch.
type IEntity_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_aspectContext differentiates from other interfaces.
	IsEntity_aspectContext()
}

type Entity_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_aspectContext() *Entity_aspectContext {
	var p = new(Entity_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_aspect
	return p
}

func (*Entity_aspectContext) IsEntity_aspectContext() {}

func NewEntity_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_aspectContext {
	var p = new(Entity_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_aspect

	return p
}

func (s *Entity_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_aspectContext) ENTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserENTITY, 0)
}

func (s *Entity_aspectContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Entity_aspectContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Entity_aspectContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Entity_aspectContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Entity_aspectContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONFIGURATION, 0)
}

func (s *Entity_aspectContext) OPEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserOPEN, 0)
}

func (s *Entity_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_aspect(s)
	}
}

func (s *Entity_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_aspect(s)
	}
}

func (p *vhdlParser) Entity_aspect() (localctx IEntity_aspectContext) {
	this := p
	_ = this

	localctx = NewEntity_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, vhdlParserRULE_entity_aspect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1136)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserENTITY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1125)
			p.Match(vhdlParserENTITY)
		}
		{
			p.SetState(1126)
			p.Name()
		}
		p.SetState(1131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserLPAREN {
			{
				p.SetState(1127)
				p.Match(vhdlParserLPAREN)
			}
			{
				p.SetState(1128)
				p.Identifier()
			}
			{
				p.SetState(1129)
				p.Match(vhdlParserRPAREN)
			}

		}

	case vhdlParserCONFIGURATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1133)
			p.Match(vhdlParserCONFIGURATION)
		}
		{
			p.SetState(1134)
			p.Name()
		}

	case vhdlParserOPEN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1135)
			p.Match(vhdlParserOPEN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEntity_classContext is an interface to support dynamic dispatch.
type IEntity_classContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_classContext differentiates from other interfaces.
	IsEntity_classContext()
}

type Entity_classContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_classContext() *Entity_classContext {
	var p = new(Entity_classContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_class
	return p
}

func (*Entity_classContext) IsEntity_classContext() {}

func NewEntity_classContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_classContext {
	var p = new(Entity_classContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_class

	return p
}

func (s *Entity_classContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_classContext) ENTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserENTITY, 0)
}

func (s *Entity_classContext) ARCHITECTURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserARCHITECTURE, 0)
}

func (s *Entity_classContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONFIGURATION, 0)
}

func (s *Entity_classContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCEDURE, 0)
}

func (s *Entity_classContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(vhdlParserFUNCTION, 0)
}

func (s *Entity_classContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPACKAGE, 0)
}

func (s *Entity_classContext) TYPE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTYPE, 0)
}

func (s *Entity_classContext) SUBTYPE() antlr.TerminalNode {
	return s.GetToken(vhdlParserSUBTYPE, 0)
}

func (s *Entity_classContext) CONSTANT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONSTANT, 0)
}

func (s *Entity_classContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSIGNAL, 0)
}

func (s *Entity_classContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARIABLE, 0)
}

func (s *Entity_classContext) COMPONENT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMPONENT, 0)
}

func (s *Entity_classContext) LABEL() antlr.TerminalNode {
	return s.GetToken(vhdlParserLABEL, 0)
}

func (s *Entity_classContext) LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserLITERAL, 0)
}

func (s *Entity_classContext) UNITS() antlr.TerminalNode {
	return s.GetToken(vhdlParserUNITS, 0)
}

func (s *Entity_classContext) GROUP() antlr.TerminalNode {
	return s.GetToken(vhdlParserGROUP, 0)
}

func (s *Entity_classContext) FILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserFILE, 0)
}

func (s *Entity_classContext) NATURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserNATURE, 0)
}

func (s *Entity_classContext) SUBNATURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserSUBNATURE, 0)
}

func (s *Entity_classContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Entity_classContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserTERMINAL, 0)
}

func (s *Entity_classContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_classContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_classContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_class(s)
	}
}

func (s *Entity_classContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_class(s)
	}
}

func (p *vhdlParser) Entity_class() (localctx IEntity_classContext) {
	this := p
	_ = this

	localctx = NewEntity_classContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, vhdlParserRULE_entity_class)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1138)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-8)&-(0x1f+1)) == 0 && ((1<<uint((_la-8)))&((1<<(vhdlParserARCHITECTURE-8))|(1<<(vhdlParserCOMPONENT-8))|(1<<(vhdlParserCONFIGURATION-8))|(1<<(vhdlParserCONSTANT-8))|(1<<(vhdlParserENTITY-8))|(1<<(vhdlParserFILE-8))|(1<<(vhdlParserFUNCTION-8))|(1<<(vhdlParserGROUP-8)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(vhdlParserLABEL-42))|(1<<(vhdlParserLITERAL-42))|(1<<(vhdlParserNATURE-42))|(1<<(vhdlParserPACKAGE-42))|(1<<(vhdlParserPROCEDURE-42))|(1<<(vhdlParserQUANTITY-42)))) != 0) || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(vhdlParserSIGNAL-86))|(1<<(vhdlParserSUBNATURE-86))|(1<<(vhdlParserSUBTYPE-86))|(1<<(vhdlParserTERMINAL-86))|(1<<(vhdlParserTYPE-86))|(1<<(vhdlParserUNITS-86))|(1<<(vhdlParserVARIABLE-86)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEntity_class_entryContext is an interface to support dynamic dispatch.
type IEntity_class_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_class_entryContext differentiates from other interfaces.
	IsEntity_class_entryContext()
}

type Entity_class_entryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_class_entryContext() *Entity_class_entryContext {
	var p = new(Entity_class_entryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_class_entry
	return p
}

func (*Entity_class_entryContext) IsEntity_class_entryContext() {}

func NewEntity_class_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_class_entryContext {
	var p = new(Entity_class_entryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_class_entry

	return p
}

func (s *Entity_class_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_class_entryContext) Entity_class() IEntity_classContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_classContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_classContext)
}

func (s *Entity_class_entryContext) BOX() antlr.TerminalNode {
	return s.GetToken(vhdlParserBOX, 0)
}

func (s *Entity_class_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_class_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_class_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_class_entry(s)
	}
}

func (s *Entity_class_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_class_entry(s)
	}
}

func (p *vhdlParser) Entity_class_entry() (localctx IEntity_class_entryContext) {
	this := p
	_ = this

	localctx = NewEntity_class_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, vhdlParserRULE_entity_class_entry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1140)
		p.Entity_class()
	}
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBOX {
		{
			p.SetState(1141)
			p.Match(vhdlParserBOX)
		}

	}

	return localctx
}

// IEntity_class_entry_listContext is an interface to support dynamic dispatch.
type IEntity_class_entry_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_class_entry_listContext differentiates from other interfaces.
	IsEntity_class_entry_listContext()
}

type Entity_class_entry_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_class_entry_listContext() *Entity_class_entry_listContext {
	var p = new(Entity_class_entry_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_class_entry_list
	return p
}

func (*Entity_class_entry_listContext) IsEntity_class_entry_listContext() {}

func NewEntity_class_entry_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_class_entry_listContext {
	var p = new(Entity_class_entry_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_class_entry_list

	return p
}

func (s *Entity_class_entry_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_class_entry_listContext) AllEntity_class_entry() []IEntity_class_entryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntity_class_entryContext)(nil)).Elem())
	var tst = make([]IEntity_class_entryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntity_class_entryContext)
		}
	}

	return tst
}

func (s *Entity_class_entry_listContext) Entity_class_entry(i int) IEntity_class_entryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_class_entryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntity_class_entryContext)
}

func (s *Entity_class_entry_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Entity_class_entry_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Entity_class_entry_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_class_entry_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_class_entry_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_class_entry_list(s)
	}
}

func (s *Entity_class_entry_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_class_entry_list(s)
	}
}

func (p *vhdlParser) Entity_class_entry_list() (localctx IEntity_class_entry_listContext) {
	this := p
	_ = this

	localctx = NewEntity_class_entry_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, vhdlParserRULE_entity_class_entry_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1144)
		p.Entity_class_entry()
	}
	p.SetState(1149)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1145)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1146)
			p.Entity_class_entry()
		}

		p.SetState(1151)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEntity_declarationContext is an interface to support dynamic dispatch.
type IEntity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_declarationContext differentiates from other interfaces.
	IsEntity_declarationContext()
}

type Entity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_declarationContext() *Entity_declarationContext {
	var p = new(Entity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_declaration
	return p
}

func (*Entity_declarationContext) IsEntity_declarationContext() {}

func NewEntity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_declarationContext {
	var p = new(Entity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_declaration

	return p
}

func (s *Entity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_declarationContext) AllENTITY() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserENTITY)
}

func (s *Entity_declarationContext) ENTITY(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserENTITY, i)
}

func (s *Entity_declarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Entity_declarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Entity_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Entity_declarationContext) Entity_header() IEntity_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_headerContext)
}

func (s *Entity_declarationContext) Entity_declarative_part() IEntity_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_declarative_partContext)
}

func (s *Entity_declarationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Entity_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Entity_declarationContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Entity_declarationContext) Entity_statement_part() IEntity_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_statement_partContext)
}

func (s *Entity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_declaration(s)
	}
}

func (s *Entity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_declaration(s)
	}
}

func (p *vhdlParser) Entity_declaration() (localctx IEntity_declarationContext) {
	this := p
	_ = this

	localctx = NewEntity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, vhdlParserRULE_entity_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1152)
		p.Match(vhdlParserENTITY)
	}
	{
		p.SetState(1153)
		p.Identifier()
	}
	{
		p.SetState(1154)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1155)
		p.Entity_header()
	}
	{
		p.SetState(1156)
		p.Entity_declarative_part()
	}
	p.SetState(1159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBEGIN {
		{
			p.SetState(1157)
			p.Match(vhdlParserBEGIN)
		}
		{
			p.SetState(1158)
			p.Entity_statement_part()
		}

	}
	{
		p.SetState(1161)
		p.Match(vhdlParserEND)
	}
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserENTITY {
		{
			p.SetState(1162)
			p.Match(vhdlParserENTITY)
		}

	}
	p.SetState(1166)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1165)
			p.Identifier()
		}

	}
	{
		p.SetState(1168)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IEntity_declarative_itemContext is an interface to support dynamic dispatch.
type IEntity_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_declarative_itemContext differentiates from other interfaces.
	IsEntity_declarative_itemContext()
}

type Entity_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_declarative_itemContext() *Entity_declarative_itemContext {
	var p = new(Entity_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_declarative_item
	return p
}

func (*Entity_declarative_itemContext) IsEntity_declarative_itemContext() {}

func NewEntity_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_declarative_itemContext {
	var p = new(Entity_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_declarative_item

	return p
}

func (s *Entity_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Entity_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Entity_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Entity_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Entity_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Entity_declarative_itemContext) Signal_declaration() ISignal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_declarationContext)
}

func (s *Entity_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Entity_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Entity_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Entity_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Entity_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Entity_declarative_itemContext) Disconnection_specification() IDisconnection_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisconnection_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisconnection_specificationContext)
}

func (s *Entity_declarative_itemContext) Step_limit_specification() IStep_limit_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStep_limit_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStep_limit_specificationContext)
}

func (s *Entity_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Entity_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Entity_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Entity_declarative_itemContext) Nature_declaration() INature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INature_declarationContext)
}

func (s *Entity_declarative_itemContext) Subnature_declaration() ISubnature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_declarationContext)
}

func (s *Entity_declarative_itemContext) Quantity_declaration() IQuantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_declarationContext)
}

func (s *Entity_declarative_itemContext) Terminal_declaration() ITerminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_declarationContext)
}

func (s *Entity_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_declarative_item(s)
	}
}

func (s *Entity_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_declarative_item(s)
	}
}

func (p *vhdlParser) Entity_declarative_item() (localctx IEntity_declarative_itemContext) {
	this := p
	_ = this

	localctx = NewEntity_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, vhdlParserRULE_entity_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1190)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1170)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1171)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1172)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1173)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1174)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1175)
			p.Signal_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1176)
			p.Variable_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1177)
			p.File_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1178)
			p.Alias_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1179)
			p.Attribute_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1180)
			p.Attribute_specification()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1181)
			p.Disconnection_specification()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1182)
			p.Step_limit_specification()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1183)
			p.Use_clause()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1184)
			p.Group_template_declaration()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1185)
			p.Group_declaration()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1186)
			p.Nature_declaration()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1187)
			p.Subnature_declaration()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1188)
			p.Quantity_declaration()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1189)
			p.Terminal_declaration()
		}

	}

	return localctx
}

// IEntity_declarative_partContext is an interface to support dynamic dispatch.
type IEntity_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_declarative_partContext differentiates from other interfaces.
	IsEntity_declarative_partContext()
}

type Entity_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_declarative_partContext() *Entity_declarative_partContext {
	var p = new(Entity_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_declarative_part
	return p
}

func (*Entity_declarative_partContext) IsEntity_declarative_partContext() {}

func NewEntity_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_declarative_partContext {
	var p = new(Entity_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_declarative_part

	return p
}

func (s *Entity_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_declarative_partContext) AllEntity_declarative_item() []IEntity_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntity_declarative_itemContext)(nil)).Elem())
	var tst = make([]IEntity_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntity_declarative_itemContext)
		}
	}

	return tst
}

func (s *Entity_declarative_partContext) Entity_declarative_item(i int) IEntity_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntity_declarative_itemContext)
}

func (s *Entity_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_declarative_part(s)
	}
}

func (s *Entity_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_declarative_part(s)
	}
}

func (p *vhdlParser) Entity_declarative_part() (localctx IEntity_declarative_partContext) {
	this := p
	_ = this

	localctx = NewEntity_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, vhdlParserRULE_entity_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1192)
			p.Entity_declarative_item()
		}

		p.SetState(1197)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEntity_designatorContext is an interface to support dynamic dispatch.
type IEntity_designatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_designatorContext differentiates from other interfaces.
	IsEntity_designatorContext()
}

type Entity_designatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_designatorContext() *Entity_designatorContext {
	var p = new(Entity_designatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_designator
	return p
}

func (*Entity_designatorContext) IsEntity_designatorContext() {}

func NewEntity_designatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_designatorContext {
	var p = new(Entity_designatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_designator

	return p
}

func (s *Entity_designatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_designatorContext) Entity_tag() IEntity_tagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_tagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_tagContext)
}

func (s *Entity_designatorContext) Signature() ISignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *Entity_designatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_designatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_designatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_designator(s)
	}
}

func (s *Entity_designatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_designator(s)
	}
}

func (p *vhdlParser) Entity_designator() (localctx IEntity_designatorContext) {
	this := p
	_ = this

	localctx = NewEntity_designatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, vhdlParserRULE_entity_designator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1198)
		p.Entity_tag()
	}
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLBRACKET {
		{
			p.SetState(1199)
			p.Signature()
		}

	}

	return localctx
}

// IEntity_headerContext is an interface to support dynamic dispatch.
type IEntity_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_headerContext differentiates from other interfaces.
	IsEntity_headerContext()
}

type Entity_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_headerContext() *Entity_headerContext {
	var p = new(Entity_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_header
	return p
}

func (*Entity_headerContext) IsEntity_headerContext() {}

func NewEntity_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_headerContext {
	var p = new(Entity_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_header

	return p
}

func (s *Entity_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_headerContext) Generic_clause() IGeneric_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_clauseContext)
}

func (s *Entity_headerContext) Port_clause() IPort_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_clauseContext)
}

func (s *Entity_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_header(s)
	}
}

func (s *Entity_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_header(s)
	}
}

func (p *vhdlParser) Entity_header() (localctx IEntity_headerContext) {
	this := p
	_ = this

	localctx = NewEntity_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, vhdlParserRULE_entity_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(1202)
			p.Generic_clause()
		}

	}
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(1205)
			p.Port_clause()
		}

	}

	return localctx
}

// IEntity_name_listContext is an interface to support dynamic dispatch.
type IEntity_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_name_listContext differentiates from other interfaces.
	IsEntity_name_listContext()
}

type Entity_name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_name_listContext() *Entity_name_listContext {
	var p = new(Entity_name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_name_list
	return p
}

func (*Entity_name_listContext) IsEntity_name_listContext() {}

func NewEntity_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_name_listContext {
	var p = new(Entity_name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_name_list

	return p
}

func (s *Entity_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_name_listContext) AllEntity_designator() []IEntity_designatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntity_designatorContext)(nil)).Elem())
	var tst = make([]IEntity_designatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntity_designatorContext)
		}
	}

	return tst
}

func (s *Entity_name_listContext) Entity_designator(i int) IEntity_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_designatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntity_designatorContext)
}

func (s *Entity_name_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Entity_name_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Entity_name_listContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *Entity_name_listContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *Entity_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_name_list(s)
	}
}

func (s *Entity_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_name_list(s)
	}
}

func (p *vhdlParser) Entity_name_list() (localctx IEntity_name_listContext) {
	this := p
	_ = this

	localctx = NewEntity_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, vhdlParserRULE_entity_name_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1218)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL, vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1208)
			p.Entity_designator()
		}
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(1209)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(1210)
				p.Entity_designator()
			}

			p.SetState(1215)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserOTHERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1216)
			p.Match(vhdlParserOTHERS)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1217)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEntity_specificationContext is an interface to support dynamic dispatch.
type IEntity_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_specificationContext differentiates from other interfaces.
	IsEntity_specificationContext()
}

type Entity_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_specificationContext() *Entity_specificationContext {
	var p = new(Entity_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_specification
	return p
}

func (*Entity_specificationContext) IsEntity_specificationContext() {}

func NewEntity_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_specificationContext {
	var p = new(Entity_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_specification

	return p
}

func (s *Entity_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_specificationContext) Entity_name_list() IEntity_name_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_name_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_name_listContext)
}

func (s *Entity_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Entity_specificationContext) Entity_class() IEntity_classContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_classContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_classContext)
}

func (s *Entity_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_specification(s)
	}
}

func (s *Entity_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_specification(s)
	}
}

func (p *vhdlParser) Entity_specification() (localctx IEntity_specificationContext) {
	this := p
	_ = this

	localctx = NewEntity_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, vhdlParserRULE_entity_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.Entity_name_list()
	}
	{
		p.SetState(1221)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1222)
		p.Entity_class()
	}

	return localctx
}

// IEntity_statementContext is an interface to support dynamic dispatch.
type IEntity_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_statementContext differentiates from other interfaces.
	IsEntity_statementContext()
}

type Entity_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_statementContext() *Entity_statementContext {
	var p = new(Entity_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_statement
	return p
}

func (*Entity_statementContext) IsEntity_statementContext() {}

func NewEntity_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_statementContext {
	var p = new(Entity_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_statement

	return p
}

func (s *Entity_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_statementContext) Concurrent_assertion_statement() IConcurrent_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_assertion_statementContext)
}

func (s *Entity_statementContext) Process_statement() IProcess_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcess_statementContext)
}

func (s *Entity_statementContext) Concurrent_procedure_call_statement() IConcurrent_procedure_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_procedure_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_procedure_call_statementContext)
}

func (s *Entity_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_statement(s)
	}
}

func (s *Entity_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_statement(s)
	}
}

func (p *vhdlParser) Entity_statement() (localctx IEntity_statementContext) {
	this := p
	_ = this

	localctx = NewEntity_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, vhdlParserRULE_entity_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1224)
			p.Concurrent_assertion_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1225)
			p.Process_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1226)
			p.Concurrent_procedure_call_statement()
		}

	}

	return localctx
}

// IEntity_statement_partContext is an interface to support dynamic dispatch.
type IEntity_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_statement_partContext differentiates from other interfaces.
	IsEntity_statement_partContext()
}

type Entity_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_statement_partContext() *Entity_statement_partContext {
	var p = new(Entity_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_statement_part
	return p
}

func (*Entity_statement_partContext) IsEntity_statement_partContext() {}

func NewEntity_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_statement_partContext {
	var p = new(Entity_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_statement_part

	return p
}

func (s *Entity_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_statement_partContext) AllEntity_statement() []IEntity_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntity_statementContext)(nil)).Elem())
	var tst = make([]IEntity_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntity_statementContext)
		}
	}

	return tst
}

func (s *Entity_statement_partContext) Entity_statement(i int) IEntity_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntity_statementContext)
}

func (s *Entity_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_statement_part(s)
	}
}

func (s *Entity_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_statement_part(s)
	}
}

func (p *vhdlParser) Entity_statement_part() (localctx IEntity_statement_partContext) {
	this := p
	_ = this

	localctx = NewEntity_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, vhdlParserRULE_entity_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1232)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserASSERT || _la == vhdlParserPOSTPONED || _la == vhdlParserPROCESS || _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1229)
			p.Entity_statement()
		}

		p.SetState(1234)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEntity_tagContext is an interface to support dynamic dispatch.
type IEntity_tagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_tagContext differentiates from other interfaces.
	IsEntity_tagContext()
}

type Entity_tagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_tagContext() *Entity_tagContext {
	var p = new(Entity_tagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_tag
	return p
}

func (*Entity_tagContext) IsEntity_tagContext() {}

func NewEntity_tagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_tagContext {
	var p = new(Entity_tagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_tag

	return p
}

func (s *Entity_tagContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_tagContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Entity_tagContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *Entity_tagContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *Entity_tagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_tagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_tagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_tag(s)
	}
}

func (s *Entity_tagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_tag(s)
	}
}

func (p *vhdlParser) Entity_tag() (localctx IEntity_tagContext) {
	this := p
	_ = this

	localctx = NewEntity_tagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, vhdlParserRULE_entity_tag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1238)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1235)
			p.Identifier()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1236)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1237)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumeration_literalContext is an interface to support dynamic dispatch.
type IEnumeration_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeration_literalContext differentiates from other interfaces.
	IsEnumeration_literalContext()
}

type Enumeration_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeration_literalContext() *Enumeration_literalContext {
	var p = new(Enumeration_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_enumeration_literal
	return p
}

func (*Enumeration_literalContext) IsEnumeration_literalContext() {}

func NewEnumeration_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumeration_literalContext {
	var p = new(Enumeration_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_enumeration_literal

	return p
}

func (s *Enumeration_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumeration_literalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Enumeration_literalContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *Enumeration_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumeration_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enumeration_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEnumeration_literal(s)
	}
}

func (s *Enumeration_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEnumeration_literal(s)
	}
}

func (p *vhdlParser) Enumeration_literal() (localctx IEnumeration_literalContext) {
	this := p
	_ = this

	localctx = NewEnumeration_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, vhdlParserRULE_enumeration_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1242)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1240)
			p.Identifier()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1241)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumeration_type_definitionContext is an interface to support dynamic dispatch.
type IEnumeration_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeration_type_definitionContext differentiates from other interfaces.
	IsEnumeration_type_definitionContext()
}

type Enumeration_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeration_type_definitionContext() *Enumeration_type_definitionContext {
	var p = new(Enumeration_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_enumeration_type_definition
	return p
}

func (*Enumeration_type_definitionContext) IsEnumeration_type_definitionContext() {}

func NewEnumeration_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumeration_type_definitionContext {
	var p = new(Enumeration_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_enumeration_type_definition

	return p
}

func (s *Enumeration_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumeration_type_definitionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Enumeration_type_definitionContext) AllEnumeration_literal() []IEnumeration_literalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumeration_literalContext)(nil)).Elem())
	var tst = make([]IEnumeration_literalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumeration_literalContext)
		}
	}

	return tst
}

func (s *Enumeration_type_definitionContext) Enumeration_literal(i int) IEnumeration_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeration_literalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumeration_literalContext)
}

func (s *Enumeration_type_definitionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Enumeration_type_definitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Enumeration_type_definitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Enumeration_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumeration_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enumeration_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEnumeration_type_definition(s)
	}
}

func (s *Enumeration_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEnumeration_type_definition(s)
	}
}

func (p *vhdlParser) Enumeration_type_definition() (localctx IEnumeration_type_definitionContext) {
	this := p
	_ = this

	localctx = NewEnumeration_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, vhdlParserRULE_enumeration_type_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1244)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1245)
		p.Enumeration_literal()
	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1246)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1247)
			p.Enumeration_literal()
		}

		p.SetState(1252)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1253)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IExit_statementContext is an interface to support dynamic dispatch.
type IExit_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExit_statementContext differentiates from other interfaces.
	IsExit_statementContext()
}

type Exit_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExit_statementContext() *Exit_statementContext {
	var p = new(Exit_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_exit_statement
	return p
}

func (*Exit_statementContext) IsExit_statementContext() {}

func NewExit_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exit_statementContext {
	var p = new(Exit_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_exit_statement

	return p
}

func (s *Exit_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Exit_statementContext) EXIT() antlr.TerminalNode {
	return s.GetToken(vhdlParserEXIT, 0)
}

func (s *Exit_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Exit_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Exit_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Exit_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Exit_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Exit_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exit_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exit_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterExit_statement(s)
	}
}

func (s *Exit_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitExit_statement(s)
	}
}

func (p *vhdlParser) Exit_statement() (localctx IExit_statementContext) {
	this := p
	_ = this

	localctx = NewExit_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, vhdlParserRULE_exit_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1255)
			p.Label_colon()
		}

	}
	{
		p.SetState(1258)
		p.Match(vhdlParserEXIT)
	}
	p.SetState(1260)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1259)
			p.Identifier()
		}

	}
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(1262)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(1263)
			p.Condition()
		}

	}
	{
		p.SetState(1266)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *ExpressionContext) AllLogical_operator() []ILogical_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_operatorContext)(nil)).Elem())
	var tst = make([]ILogical_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_operatorContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Logical_operator(i int) ILogical_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_operatorContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *vhdlParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, vhdlParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1268)
		p.Relation()
	}
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1269)
				p.Logical_operator()
			}
			{
				p.SetState(1270)
				p.Relation()
			}

		}
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())
	}

	return localctx
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_factor
	return p
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) AllPrimary() []IPrimaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimaryContext)(nil)).Elem())
	var tst = make([]IPrimaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimaryContext)
		}
	}

	return tst
}

func (s *FactorContext) Primary(i int) IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *FactorContext) DOUBLESTAR() antlr.TerminalNode {
	return s.GetToken(vhdlParserDOUBLESTAR, 0)
}

func (s *FactorContext) ABS() antlr.TerminalNode {
	return s.GetToken(vhdlParserABS, 0)
}

func (s *FactorContext) NOT() antlr.TerminalNode {
	return s.GetToken(vhdlParserNOT, 0)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (p *vhdlParser) Factor() (localctx IFactorContext) {
	this := p
	_ = this

	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, vhdlParserRULE_factor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1286)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserNEW, vhdlParserNULL_, vhdlParserBASE_LITERAL, vhdlParserBIT_STRING_LITERAL, vhdlParserREAL_LITERAL, vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL, vhdlParserSTRING_LITERAL, vhdlParserLPAREN, vhdlParserINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1277)
			p.Primary()
		}
		p.SetState(1280)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1278)
				p.Match(vhdlParserDOUBLESTAR)
			}
			{
				p.SetState(1279)
				p.Primary()
			}

		}

	case vhdlParserABS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1282)
			p.Match(vhdlParserABS)
		}
		{
			p.SetState(1283)
			p.Primary()
		}

	case vhdlParserNOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1284)
			p.Match(vhdlParserNOT)
		}
		{
			p.SetState(1285)
			p.Primary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFile_declarationContext is an interface to support dynamic dispatch.
type IFile_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_declarationContext differentiates from other interfaces.
	IsFile_declarationContext()
}

type File_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_declarationContext() *File_declarationContext {
	var p = new(File_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_file_declaration
	return p
}

func (*File_declarationContext) IsFile_declarationContext() {}

func NewFile_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_declarationContext {
	var p = new(File_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_file_declaration

	return p
}

func (s *File_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *File_declarationContext) FILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserFILE, 0)
}

func (s *File_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *File_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *File_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *File_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *File_declarationContext) File_open_information() IFile_open_informationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_open_informationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_open_informationContext)
}

func (s *File_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFile_declaration(s)
	}
}

func (s *File_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFile_declaration(s)
	}
}

func (p *vhdlParser) File_declaration() (localctx IFile_declarationContext) {
	this := p
	_ = this

	localctx = NewFile_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, vhdlParserRULE_file_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.Match(vhdlParserFILE)
	}
	{
		p.SetState(1289)
		p.Identifier_list()
	}
	{
		p.SetState(1290)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1291)
		p.Subtype_indication()
	}
	p.SetState(1293)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS || _la == vhdlParserOPEN {
		{
			p.SetState(1292)
			p.File_open_information()
		}

	}
	{
		p.SetState(1295)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IFile_logical_nameContext is an interface to support dynamic dispatch.
type IFile_logical_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_logical_nameContext differentiates from other interfaces.
	IsFile_logical_nameContext()
}

type File_logical_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_logical_nameContext() *File_logical_nameContext {
	var p = new(File_logical_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_file_logical_name
	return p
}

func (*File_logical_nameContext) IsFile_logical_nameContext() {}

func NewFile_logical_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_logical_nameContext {
	var p = new(File_logical_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_file_logical_name

	return p
}

func (s *File_logical_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *File_logical_nameContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *File_logical_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_logical_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_logical_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFile_logical_name(s)
	}
}

func (s *File_logical_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFile_logical_name(s)
	}
}

func (p *vhdlParser) File_logical_name() (localctx IFile_logical_nameContext) {
	this := p
	_ = this

	localctx = NewFile_logical_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, vhdlParserRULE_file_logical_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1297)
		p.Expression()
	}

	return localctx
}

// IFile_open_informationContext is an interface to support dynamic dispatch.
type IFile_open_informationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_open_informationContext differentiates from other interfaces.
	IsFile_open_informationContext()
}

type File_open_informationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_open_informationContext() *File_open_informationContext {
	var p = new(File_open_informationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_file_open_information
	return p
}

func (*File_open_informationContext) IsFile_open_informationContext() {}

func NewFile_open_informationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_open_informationContext {
	var p = new(File_open_informationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_file_open_information

	return p
}

func (s *File_open_informationContext) GetParser() antlr.Parser { return s.parser }

func (s *File_open_informationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *File_open_informationContext) File_logical_name() IFile_logical_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_logical_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_logical_nameContext)
}

func (s *File_open_informationContext) OPEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserOPEN, 0)
}

func (s *File_open_informationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *File_open_informationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_open_informationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_open_informationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFile_open_information(s)
	}
}

func (s *File_open_informationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFile_open_information(s)
	}
}

func (p *vhdlParser) File_open_information() (localctx IFile_open_informationContext) {
	this := p
	_ = this

	localctx = NewFile_open_informationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, vhdlParserRULE_file_open_information)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserOPEN {
		{
			p.SetState(1299)
			p.Match(vhdlParserOPEN)
		}
		{
			p.SetState(1300)
			p.Expression()
		}

	}
	{
		p.SetState(1303)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1304)
		p.File_logical_name()
	}

	return localctx
}

// IFile_type_definitionContext is an interface to support dynamic dispatch.
type IFile_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_type_definitionContext differentiates from other interfaces.
	IsFile_type_definitionContext()
}

type File_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_type_definitionContext() *File_type_definitionContext {
	var p = new(File_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_file_type_definition
	return p
}

func (*File_type_definitionContext) IsFile_type_definitionContext() {}

func NewFile_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_type_definitionContext {
	var p = new(File_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_file_type_definition

	return p
}

func (s *File_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *File_type_definitionContext) FILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserFILE, 0)
}

func (s *File_type_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *File_type_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *File_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFile_type_definition(s)
	}
}

func (s *File_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFile_type_definition(s)
	}
}

func (p *vhdlParser) File_type_definition() (localctx IFile_type_definitionContext) {
	this := p
	_ = this

	localctx = NewFile_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, vhdlParserRULE_file_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1306)
		p.Match(vhdlParserFILE)
	}
	{
		p.SetState(1307)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(1308)
		p.Subtype_indication()
	}

	return localctx
}

// IFormal_parameter_listContext is an interface to support dynamic dispatch.
type IFormal_parameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormal_parameter_listContext differentiates from other interfaces.
	IsFormal_parameter_listContext()
}

type Formal_parameter_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormal_parameter_listContext() *Formal_parameter_listContext {
	var p = new(Formal_parameter_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_formal_parameter_list
	return p
}

func (*Formal_parameter_listContext) IsFormal_parameter_listContext() {}

func NewFormal_parameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Formal_parameter_listContext {
	var p = new(Formal_parameter_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_formal_parameter_list

	return p
}

func (s *Formal_parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Formal_parameter_listContext) Interface_list() IInterface_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_listContext)
}

func (s *Formal_parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Formal_parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Formal_parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFormal_parameter_list(s)
	}
}

func (s *Formal_parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFormal_parameter_list(s)
	}
}

func (p *vhdlParser) Formal_parameter_list() (localctx IFormal_parameter_listContext) {
	this := p
	_ = this

	localctx = NewFormal_parameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, vhdlParserRULE_formal_parameter_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1310)
		p.Interface_list()
	}

	return localctx
}

// IFormal_partContext is an interface to support dynamic dispatch.
type IFormal_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormal_partContext differentiates from other interfaces.
	IsFormal_partContext()
}

type Formal_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormal_partContext() *Formal_partContext {
	var p = new(Formal_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_formal_part
	return p
}

func (*Formal_partContext) IsFormal_partContext() {}

func NewFormal_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Formal_partContext {
	var p = new(Formal_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_formal_part

	return p
}

func (s *Formal_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Formal_partContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Formal_partContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Formal_partContext) Explicit_range() IExplicit_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicit_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicit_rangeContext)
}

func (s *Formal_partContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Formal_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Formal_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Formal_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFormal_part(s)
	}
}

func (s *Formal_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFormal_part(s)
	}
}

func (p *vhdlParser) Formal_part() (localctx IFormal_partContext) {
	this := p
	_ = this

	localctx = NewFormal_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, vhdlParserRULE_formal_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1312)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1313)
			p.Identifier()
		}
		{
			p.SetState(1314)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1315)
			p.Explicit_range()
		}
		{
			p.SetState(1316)
			p.Match(vhdlParserRPAREN)
		}

	}

	return localctx
}

// IFree_quantity_declarationContext is an interface to support dynamic dispatch.
type IFree_quantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFree_quantity_declarationContext differentiates from other interfaces.
	IsFree_quantity_declarationContext()
}

type Free_quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFree_quantity_declarationContext() *Free_quantity_declarationContext {
	var p = new(Free_quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_free_quantity_declaration
	return p
}

func (*Free_quantity_declarationContext) IsFree_quantity_declarationContext() {}

func NewFree_quantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Free_quantity_declarationContext {
	var p = new(Free_quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_free_quantity_declaration

	return p
}

func (s *Free_quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Free_quantity_declarationContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Free_quantity_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Free_quantity_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Free_quantity_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Free_quantity_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Free_quantity_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Free_quantity_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Free_quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Free_quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Free_quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFree_quantity_declaration(s)
	}
}

func (s *Free_quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFree_quantity_declaration(s)
	}
}

func (p *vhdlParser) Free_quantity_declaration() (localctx IFree_quantity_declarationContext) {
	this := p
	_ = this

	localctx = NewFree_quantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, vhdlParserRULE_free_quantity_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1320)
		p.Match(vhdlParserQUANTITY)
	}
	{
		p.SetState(1321)
		p.Identifier_list()
	}
	{
		p.SetState(1322)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1323)
		p.Subtype_indication()
	}
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1324)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1325)
			p.Expression()
		}

	}
	{
		p.SetState(1328)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGenerate_statementContext is an interface to support dynamic dispatch.
type IGenerate_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_statementContext differentiates from other interfaces.
	IsGenerate_statementContext()
}

type Generate_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_statementContext() *Generate_statementContext {
	var p = new(Generate_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generate_statement
	return p
}

func (*Generate_statementContext) IsGenerate_statementContext() {}

func NewGenerate_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_statementContext {
	var p = new(Generate_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generate_statement

	return p
}

func (s *Generate_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Generate_statementContext) Generation_scheme() IGeneration_schemeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneration_schemeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneration_schemeContext)
}

func (s *Generate_statementContext) AllGENERATE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserGENERATE)
}

func (s *Generate_statementContext) GENERATE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserGENERATE, i)
}

func (s *Generate_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Generate_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Generate_statementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Generate_statementContext) AllArchitecture_statement() []IArchitecture_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem())
	var tst = make([]IArchitecture_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArchitecture_statementContext)
		}
	}

	return tst
}

func (s *Generate_statementContext) Architecture_statement(i int) IArchitecture_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_statementContext)
}

func (s *Generate_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Generate_statementContext) AllBlock_declarative_item() []IBlock_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem())
	var tst = make([]IBlock_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_declarative_itemContext)
		}
	}

	return tst
}

func (s *Generate_statementContext) Block_declarative_item(i int) IBlock_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarative_itemContext)
}

func (s *Generate_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGenerate_statement(s)
	}
}

func (s *Generate_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGenerate_statement(s)
	}
}

func (p *vhdlParser) Generate_statement() (localctx IGenerate_statementContext) {
	this := p
	_ = this

	localctx = NewGenerate_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, vhdlParserRULE_generate_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1330)
		p.Label_colon()
	}
	{
		p.SetState(1331)
		p.Generation_scheme()
	}
	{
		p.SetState(1332)
		p.Match(vhdlParserGENERATE)
	}
	p.SetState(1340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserBEGIN)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFOR)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		p.SetState(1336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFOR)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
			{
				p.SetState(1333)
				p.Block_declarative_item()
			}

			p.SetState(1338)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1339)
			p.Match(vhdlParserBEGIN)
		}

	}
	p.SetState(1345)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserABS)|(1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserNEW-36))|(1<<(vhdlParserNOT-36))|(1<<(vhdlParserNULL_-36))|(1<<(vhdlParserPOSTPONED-36))|(1<<(vhdlParserPROCESS-36)))) != 0) || _la == vhdlParserPROCEDURAL || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(vhdlParserWITH-107))|(1<<(vhdlParserBASE_LITERAL-107))|(1<<(vhdlParserBIT_STRING_LITERAL-107))|(1<<(vhdlParserREAL_LITERAL-107))|(1<<(vhdlParserBASIC_IDENTIFIER-107))|(1<<(vhdlParserEXTENDED_IDENTIFIER-107))|(1<<(vhdlParserCHARACTER_LITERAL-107))|(1<<(vhdlParserSTRING_LITERAL-107)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(vhdlParserLPAREN-141))|(1<<(vhdlParserPLUS-141))|(1<<(vhdlParserMINUS-141))|(1<<(vhdlParserINTEGER-141)))) != 0) {
		{
			p.SetState(1342)
			p.Architecture_statement()
		}

		p.SetState(1347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1348)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(1349)
		p.Match(vhdlParserGENERATE)
	}
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1350)
			p.Identifier()
		}

	}
	{
		p.SetState(1353)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGeneration_schemeContext is an interface to support dynamic dispatch.
type IGeneration_schemeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneration_schemeContext differentiates from other interfaces.
	IsGeneration_schemeContext()
}

type Generation_schemeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneration_schemeContext() *Generation_schemeContext {
	var p = new(Generation_schemeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generation_scheme
	return p
}

func (*Generation_schemeContext) IsGeneration_schemeContext() {}

func NewGeneration_schemeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generation_schemeContext {
	var p = new(Generation_schemeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generation_scheme

	return p
}

func (s *Generation_schemeContext) GetParser() antlr.Parser { return s.parser }

func (s *Generation_schemeContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Generation_schemeContext) Parameter_specification() IParameter_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_specificationContext)
}

func (s *Generation_schemeContext) IF() antlr.TerminalNode {
	return s.GetToken(vhdlParserIF, 0)
}

func (s *Generation_schemeContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Generation_schemeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generation_schemeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generation_schemeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGeneration_scheme(s)
	}
}

func (s *Generation_schemeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGeneration_scheme(s)
	}
}

func (p *vhdlParser) Generation_scheme() (localctx IGeneration_schemeContext) {
	this := p
	_ = this

	localctx = NewGeneration_schemeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, vhdlParserRULE_generation_scheme)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1359)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1355)
			p.Match(vhdlParserFOR)
		}
		{
			p.SetState(1356)
			p.Parameter_specification()
		}

	case vhdlParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1357)
			p.Match(vhdlParserIF)
		}
		{
			p.SetState(1358)
			p.Condition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGeneric_clauseContext is an interface to support dynamic dispatch.
type IGeneric_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneric_clauseContext differentiates from other interfaces.
	IsGeneric_clauseContext()
}

type Generic_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneric_clauseContext() *Generic_clauseContext {
	var p = new(Generic_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generic_clause
	return p
}

func (*Generic_clauseContext) IsGeneric_clauseContext() {}

func NewGeneric_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generic_clauseContext {
	var p = new(Generic_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generic_clause

	return p
}

func (s *Generic_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Generic_clauseContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(vhdlParserGENERIC, 0)
}

func (s *Generic_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Generic_clauseContext) Generic_list() IGeneric_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_listContext)
}

func (s *Generic_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Generic_clauseContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Generic_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generic_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generic_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGeneric_clause(s)
	}
}

func (s *Generic_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGeneric_clause(s)
	}
}

func (p *vhdlParser) Generic_clause() (localctx IGeneric_clauseContext) {
	this := p
	_ = this

	localctx = NewGeneric_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, vhdlParserRULE_generic_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1361)
		p.Match(vhdlParserGENERIC)
	}
	{
		p.SetState(1362)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1363)
		p.Generic_list()
	}
	{
		p.SetState(1364)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(1365)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGeneric_listContext is an interface to support dynamic dispatch.
type IGeneric_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneric_listContext differentiates from other interfaces.
	IsGeneric_listContext()
}

type Generic_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneric_listContext() *Generic_listContext {
	var p = new(Generic_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generic_list
	return p
}

func (*Generic_listContext) IsGeneric_listContext() {}

func NewGeneric_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generic_listContext {
	var p = new(Generic_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generic_list

	return p
}

func (s *Generic_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Generic_listContext) AllInterface_constant_declaration() []IInterface_constant_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_constant_declarationContext)(nil)).Elem())
	var tst = make([]IInterface_constant_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_constant_declarationContext)
		}
	}

	return tst
}

func (s *Generic_listContext) Interface_constant_declaration(i int) IInterface_constant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_constant_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_constant_declarationContext)
}

func (s *Generic_listContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Generic_listContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Generic_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generic_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generic_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGeneric_list(s)
	}
}

func (s *Generic_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGeneric_list(s)
	}
}

func (p *vhdlParser) Generic_list() (localctx IGeneric_listContext) {
	this := p
	_ = this

	localctx = NewGeneric_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, vhdlParserRULE_generic_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1367)
		p.Interface_constant_declaration()
	}
	p.SetState(1372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserSEMI {
		{
			p.SetState(1368)
			p.Match(vhdlParserSEMI)
		}
		{
			p.SetState(1369)
			p.Interface_constant_declaration()
		}

		p.SetState(1374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGeneric_map_aspectContext is an interface to support dynamic dispatch.
type IGeneric_map_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneric_map_aspectContext differentiates from other interfaces.
	IsGeneric_map_aspectContext()
}

type Generic_map_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneric_map_aspectContext() *Generic_map_aspectContext {
	var p = new(Generic_map_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generic_map_aspect
	return p
}

func (*Generic_map_aspectContext) IsGeneric_map_aspectContext() {}

func NewGeneric_map_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generic_map_aspectContext {
	var p = new(Generic_map_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generic_map_aspect

	return p
}

func (s *Generic_map_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Generic_map_aspectContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(vhdlParserGENERIC, 0)
}

func (s *Generic_map_aspectContext) MAP() antlr.TerminalNode {
	return s.GetToken(vhdlParserMAP, 0)
}

func (s *Generic_map_aspectContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Generic_map_aspectContext) Association_list() IAssociation_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociation_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssociation_listContext)
}

func (s *Generic_map_aspectContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Generic_map_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generic_map_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generic_map_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGeneric_map_aspect(s)
	}
}

func (s *Generic_map_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGeneric_map_aspect(s)
	}
}

func (p *vhdlParser) Generic_map_aspect() (localctx IGeneric_map_aspectContext) {
	this := p
	_ = this

	localctx = NewGeneric_map_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, vhdlParserRULE_generic_map_aspect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1375)
		p.Match(vhdlParserGENERIC)
	}
	{
		p.SetState(1376)
		p.Match(vhdlParserMAP)
	}
	{
		p.SetState(1377)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1378)
		p.Association_list()
	}
	{
		p.SetState(1379)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IGroup_constituentContext is an interface to support dynamic dispatch.
type IGroup_constituentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_constituentContext differentiates from other interfaces.
	IsGroup_constituentContext()
}

type Group_constituentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_constituentContext() *Group_constituentContext {
	var p = new(Group_constituentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_group_constituent
	return p
}

func (*Group_constituentContext) IsGroup_constituentContext() {}

func NewGroup_constituentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_constituentContext {
	var p = new(Group_constituentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_group_constituent

	return p
}

func (s *Group_constituentContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_constituentContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Group_constituentContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *Group_constituentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_constituentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_constituentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGroup_constituent(s)
	}
}

func (s *Group_constituentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGroup_constituent(s)
	}
}

func (p *vhdlParser) Group_constituent() (localctx IGroup_constituentContext) {
	this := p
	_ = this

	localctx = NewGroup_constituentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, vhdlParserRULE_group_constituent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1383)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1381)
			p.Name()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1382)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGroup_constituent_listContext is an interface to support dynamic dispatch.
type IGroup_constituent_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_constituent_listContext differentiates from other interfaces.
	IsGroup_constituent_listContext()
}

type Group_constituent_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_constituent_listContext() *Group_constituent_listContext {
	var p = new(Group_constituent_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_group_constituent_list
	return p
}

func (*Group_constituent_listContext) IsGroup_constituent_listContext() {}

func NewGroup_constituent_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_constituent_listContext {
	var p = new(Group_constituent_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_group_constituent_list

	return p
}

func (s *Group_constituent_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_constituent_listContext) AllGroup_constituent() []IGroup_constituentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroup_constituentContext)(nil)).Elem())
	var tst = make([]IGroup_constituentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroup_constituentContext)
		}
	}

	return tst
}

func (s *Group_constituent_listContext) Group_constituent(i int) IGroup_constituentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_constituentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroup_constituentContext)
}

func (s *Group_constituent_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Group_constituent_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Group_constituent_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_constituent_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_constituent_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGroup_constituent_list(s)
	}
}

func (s *Group_constituent_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGroup_constituent_list(s)
	}
}

func (p *vhdlParser) Group_constituent_list() (localctx IGroup_constituent_listContext) {
	this := p
	_ = this

	localctx = NewGroup_constituent_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, vhdlParserRULE_group_constituent_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1385)
		p.Group_constituent()
	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1386)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1387)
			p.Group_constituent()
		}

		p.SetState(1392)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGroup_declarationContext is an interface to support dynamic dispatch.
type IGroup_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_declarationContext differentiates from other interfaces.
	IsGroup_declarationContext()
}

type Group_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_declarationContext() *Group_declarationContext {
	var p = new(Group_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_group_declaration
	return p
}

func (*Group_declarationContext) IsGroup_declarationContext() {}

func NewGroup_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_declarationContext {
	var p = new(Group_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_group_declaration

	return p
}

func (s *Group_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_declarationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(vhdlParserGROUP, 0)
}

func (s *Group_declarationContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Group_declarationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Group_declarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Group_declarationContext) Group_constituent_list() IGroup_constituent_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_constituent_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_constituent_listContext)
}

func (s *Group_declarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Group_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Group_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGroup_declaration(s)
	}
}

func (s *Group_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGroup_declaration(s)
	}
}

func (p *vhdlParser) Group_declaration() (localctx IGroup_declarationContext) {
	this := p
	_ = this

	localctx = NewGroup_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, vhdlParserRULE_group_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1393)
		p.Match(vhdlParserGROUP)
	}
	{
		p.SetState(1394)
		p.Label_colon()
	}
	{
		p.SetState(1395)
		p.Name()
	}
	{
		p.SetState(1396)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1397)
		p.Group_constituent_list()
	}
	{
		p.SetState(1398)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(1399)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGroup_template_declarationContext is an interface to support dynamic dispatch.
type IGroup_template_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_template_declarationContext differentiates from other interfaces.
	IsGroup_template_declarationContext()
}

type Group_template_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_template_declarationContext() *Group_template_declarationContext {
	var p = new(Group_template_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_group_template_declaration
	return p
}

func (*Group_template_declarationContext) IsGroup_template_declarationContext() {}

func NewGroup_template_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_template_declarationContext {
	var p = new(Group_template_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_group_template_declaration

	return p
}

func (s *Group_template_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_template_declarationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(vhdlParserGROUP, 0)
}

func (s *Group_template_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Group_template_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Group_template_declarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Group_template_declarationContext) Entity_class_entry_list() IEntity_class_entry_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_class_entry_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_class_entry_listContext)
}

func (s *Group_template_declarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Group_template_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Group_template_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_template_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_template_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGroup_template_declaration(s)
	}
}

func (s *Group_template_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGroup_template_declaration(s)
	}
}

func (p *vhdlParser) Group_template_declaration() (localctx IGroup_template_declarationContext) {
	this := p
	_ = this

	localctx = NewGroup_template_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, vhdlParserRULE_group_template_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1401)
		p.Match(vhdlParserGROUP)
	}
	{
		p.SetState(1402)
		p.Identifier()
	}
	{
		p.SetState(1403)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1404)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1405)
		p.Entity_class_entry_list()
	}
	{
		p.SetState(1406)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(1407)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGuarded_signal_specificationContext is an interface to support dynamic dispatch.
type IGuarded_signal_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGuarded_signal_specificationContext differentiates from other interfaces.
	IsGuarded_signal_specificationContext()
}

type Guarded_signal_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGuarded_signal_specificationContext() *Guarded_signal_specificationContext {
	var p = new(Guarded_signal_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_guarded_signal_specification
	return p
}

func (*Guarded_signal_specificationContext) IsGuarded_signal_specificationContext() {}

func NewGuarded_signal_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Guarded_signal_specificationContext {
	var p = new(Guarded_signal_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_guarded_signal_specification

	return p
}

func (s *Guarded_signal_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Guarded_signal_specificationContext) Signal_list() ISignal_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_listContext)
}

func (s *Guarded_signal_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Guarded_signal_specificationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Guarded_signal_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Guarded_signal_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Guarded_signal_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGuarded_signal_specification(s)
	}
}

func (s *Guarded_signal_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGuarded_signal_specification(s)
	}
}

func (p *vhdlParser) Guarded_signal_specification() (localctx IGuarded_signal_specificationContext) {
	this := p
	_ = this

	localctx = NewGuarded_signal_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, vhdlParserRULE_guarded_signal_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1409)
		p.Signal_list()
	}
	{
		p.SetState(1410)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1411)
		p.Name()
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) BASIC_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(vhdlParserBASIC_IDENTIFIER, 0)
}

func (s *IdentifierContext) EXTENDED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(vhdlParserEXTENDED_IDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *vhdlParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, vhdlParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifier_listContext is an interface to support dynamic dispatch.
type IIdentifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifier_listContext differentiates from other interfaces.
	IsIdentifier_listContext()
}

type Identifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_listContext() *Identifier_listContext {
	var p = new(Identifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_identifier_list
	return p
}

func (*Identifier_listContext) IsIdentifier_listContext() {}

func NewIdentifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_listContext {
	var p = new(Identifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_identifier_list

	return p
}

func (s *Identifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_listContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Identifier_listContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Identifier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Identifier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Identifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Identifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIdentifier_list(s)
	}
}

func (s *Identifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIdentifier_list(s)
	}
}

func (p *vhdlParser) Identifier_list() (localctx IIdentifier_listContext) {
	this := p
	_ = this

	localctx = NewIdentifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, vhdlParserRULE_identifier_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1415)
		p.Identifier()
	}
	p.SetState(1420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1416)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1417)
			p.Identifier()
		}

		p.SetState(1422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIf_statementContext is an interface to support dynamic dispatch.
type IIf_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_statementContext differentiates from other interfaces.
	IsIf_statementContext()
}

type If_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_statementContext() *If_statementContext {
	var p = new(If_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_if_statement
	return p
}

func (*If_statementContext) IsIf_statementContext() {}

func NewIf_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_statementContext {
	var p = new(If_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_if_statement

	return p
}

func (s *If_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_statementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserIF)
}

func (s *If_statementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserIF, i)
}

func (s *If_statementContext) AllCondition() []IConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionContext)(nil)).Elem())
	var tst = make([]IConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionContext)
		}
	}

	return tst
}

func (s *If_statementContext) Condition(i int) IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *If_statementContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserTHEN)
}

func (s *If_statementContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserTHEN, i)
}

func (s *If_statementContext) AllSequence_of_statements() []ISequence_of_statementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_of_statementsContext)(nil)).Elem())
	var tst = make([]ISequence_of_statementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_of_statementsContext)
		}
	}

	return tst
}

func (s *If_statementContext) Sequence_of_statements(i int) ISequence_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_of_statementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_of_statementsContext)
}

func (s *If_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *If_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *If_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *If_statementContext) AllELSIF() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserELSIF)
}

func (s *If_statementContext) ELSIF(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserELSIF, i)
}

func (s *If_statementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vhdlParserELSE, 0)
}

func (s *If_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *If_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIf_statement(s)
	}
}

func (s *If_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIf_statement(s)
	}
}

func (p *vhdlParser) If_statement() (localctx IIf_statementContext) {
	this := p
	_ = this

	localctx = NewIf_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, vhdlParserRULE_if_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1423)
			p.Label_colon()
		}

	}
	{
		p.SetState(1426)
		p.Match(vhdlParserIF)
	}
	{
		p.SetState(1427)
		p.Condition()
	}
	{
		p.SetState(1428)
		p.Match(vhdlParserTHEN)
	}
	{
		p.SetState(1429)
		p.Sequence_of_statements()
	}
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserELSIF {
		{
			p.SetState(1430)
			p.Match(vhdlParserELSIF)
		}
		{
			p.SetState(1431)
			p.Condition()
		}
		{
			p.SetState(1432)
			p.Match(vhdlParserTHEN)
		}
		{
			p.SetState(1433)
			p.Sequence_of_statements()
		}

		p.SetState(1439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserELSE {
		{
			p.SetState(1440)
			p.Match(vhdlParserELSE)
		}
		{
			p.SetState(1441)
			p.Sequence_of_statements()
		}

	}
	{
		p.SetState(1444)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(1445)
		p.Match(vhdlParserIF)
	}
	p.SetState(1447)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1446)
			p.Identifier()
		}

	}
	{
		p.SetState(1449)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IIndex_constraintContext is an interface to support dynamic dispatch.
type IIndex_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndex_constraintContext differentiates from other interfaces.
	IsIndex_constraintContext()
}

type Index_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_constraintContext() *Index_constraintContext {
	var p = new(Index_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_index_constraint
	return p
}

func (*Index_constraintContext) IsIndex_constraintContext() {}

func NewIndex_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_constraintContext {
	var p = new(Index_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_index_constraint

	return p
}

func (s *Index_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_constraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Index_constraintContext) AllDiscrete_range() []IDiscrete_rangeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem())
	var tst = make([]IDiscrete_rangeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDiscrete_rangeContext)
		}
	}

	return tst
}

func (s *Index_constraintContext) Discrete_range(i int) IDiscrete_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDiscrete_rangeContext)
}

func (s *Index_constraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Index_constraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Index_constraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Index_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIndex_constraint(s)
	}
}

func (s *Index_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIndex_constraint(s)
	}
}

func (p *vhdlParser) Index_constraint() (localctx IIndex_constraintContext) {
	this := p
	_ = this

	localctx = NewIndex_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, vhdlParserRULE_index_constraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1451)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1452)
		p.Discrete_range()
	}
	p.SetState(1457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1453)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1454)
			p.Discrete_range()
		}

		p.SetState(1459)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1460)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IIndex_specificationContext is an interface to support dynamic dispatch.
type IIndex_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndex_specificationContext differentiates from other interfaces.
	IsIndex_specificationContext()
}

type Index_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_specificationContext() *Index_specificationContext {
	var p = new(Index_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_index_specification
	return p
}

func (*Index_specificationContext) IsIndex_specificationContext() {}

func NewIndex_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_specificationContext {
	var p = new(Index_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_index_specification

	return p
}

func (s *Index_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_specificationContext) Discrete_range() IDiscrete_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiscrete_rangeContext)
}

func (s *Index_specificationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Index_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIndex_specification(s)
	}
}

func (s *Index_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIndex_specification(s)
	}
}

func (p *vhdlParser) Index_specification() (localctx IIndex_specificationContext) {
	this := p
	_ = this

	localctx = NewIndex_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, vhdlParserRULE_index_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1462)
			p.Discrete_range()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1463)
			p.Expression()
		}

	}

	return localctx
}

// IIndex_subtype_definitionContext is an interface to support dynamic dispatch.
type IIndex_subtype_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndex_subtype_definitionContext differentiates from other interfaces.
	IsIndex_subtype_definitionContext()
}

type Index_subtype_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_subtype_definitionContext() *Index_subtype_definitionContext {
	var p = new(Index_subtype_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_index_subtype_definition
	return p
}

func (*Index_subtype_definitionContext) IsIndex_subtype_definitionContext() {}

func NewIndex_subtype_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_subtype_definitionContext {
	var p = new(Index_subtype_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_index_subtype_definition

	return p
}

func (s *Index_subtype_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_subtype_definitionContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Index_subtype_definitionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserRANGE, 0)
}

func (s *Index_subtype_definitionContext) BOX() antlr.TerminalNode {
	return s.GetToken(vhdlParserBOX, 0)
}

func (s *Index_subtype_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_subtype_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_subtype_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIndex_subtype_definition(s)
	}
}

func (s *Index_subtype_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIndex_subtype_definition(s)
	}
}

func (p *vhdlParser) Index_subtype_definition() (localctx IIndex_subtype_definitionContext) {
	this := p
	_ = this

	localctx = NewIndex_subtype_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, vhdlParserRULE_index_subtype_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1466)
		p.Name()
	}
	{
		p.SetState(1467)
		p.Match(vhdlParserRANGE)
	}
	{
		p.SetState(1468)
		p.Match(vhdlParserBOX)
	}

	return localctx
}

// IInstantiated_unitContext is an interface to support dynamic dispatch.
type IInstantiated_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstantiated_unitContext differentiates from other interfaces.
	IsInstantiated_unitContext()
}

type Instantiated_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstantiated_unitContext() *Instantiated_unitContext {
	var p = new(Instantiated_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_instantiated_unit
	return p
}

func (*Instantiated_unitContext) IsInstantiated_unitContext() {}

func NewInstantiated_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instantiated_unitContext {
	var p = new(Instantiated_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_instantiated_unit

	return p
}

func (s *Instantiated_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Instantiated_unitContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Instantiated_unitContext) COMPONENT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMPONENT, 0)
}

func (s *Instantiated_unitContext) ENTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserENTITY, 0)
}

func (s *Instantiated_unitContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Instantiated_unitContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Instantiated_unitContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Instantiated_unitContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONFIGURATION, 0)
}

func (s *Instantiated_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instantiated_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instantiated_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInstantiated_unit(s)
	}
}

func (s *Instantiated_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInstantiated_unit(s)
	}
}

func (p *vhdlParser) Instantiated_unit() (localctx IInstantiated_unitContext) {
	this := p
	_ = this

	localctx = NewInstantiated_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, vhdlParserRULE_instantiated_unit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1484)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserCOMPONENT, vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1471)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserCOMPONENT {
			{
				p.SetState(1470)
				p.Match(vhdlParserCOMPONENT)
			}

		}
		{
			p.SetState(1473)
			p.Name()
		}

	case vhdlParserENTITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1474)
			p.Match(vhdlParserENTITY)
		}
		{
			p.SetState(1475)
			p.Name()
		}
		p.SetState(1480)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserLPAREN {
			{
				p.SetState(1476)
				p.Match(vhdlParserLPAREN)
			}
			{
				p.SetState(1477)
				p.Identifier()
			}
			{
				p.SetState(1478)
				p.Match(vhdlParserRPAREN)
			}

		}

	case vhdlParserCONFIGURATION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1482)
			p.Match(vhdlParserCONFIGURATION)
		}
		{
			p.SetState(1483)
			p.Name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInstantiation_listContext is an interface to support dynamic dispatch.
type IInstantiation_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstantiation_listContext differentiates from other interfaces.
	IsInstantiation_listContext()
}

type Instantiation_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstantiation_listContext() *Instantiation_listContext {
	var p = new(Instantiation_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_instantiation_list
	return p
}

func (*Instantiation_listContext) IsInstantiation_listContext() {}

func NewInstantiation_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instantiation_listContext {
	var p = new(Instantiation_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_instantiation_list

	return p
}

func (s *Instantiation_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Instantiation_listContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Instantiation_listContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Instantiation_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Instantiation_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Instantiation_listContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *Instantiation_listContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *Instantiation_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instantiation_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instantiation_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInstantiation_list(s)
	}
}

func (s *Instantiation_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInstantiation_list(s)
	}
}

func (p *vhdlParser) Instantiation_list() (localctx IInstantiation_listContext) {
	this := p
	_ = this

	localctx = NewInstantiation_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, vhdlParserRULE_instantiation_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1496)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1486)
			p.Identifier()
		}
		p.SetState(1491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(1487)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(1488)
				p.Identifier()
			}

			p.SetState(1493)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserOTHERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1494)
			p.Match(vhdlParserOTHERS)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1495)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterface_constant_declarationContext is an interface to support dynamic dispatch.
type IInterface_constant_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_constant_declarationContext differentiates from other interfaces.
	IsInterface_constant_declarationContext()
}

type Interface_constant_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_constant_declarationContext() *Interface_constant_declarationContext {
	var p = new(Interface_constant_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_constant_declaration
	return p
}

func (*Interface_constant_declarationContext) IsInterface_constant_declarationContext() {}

func NewInterface_constant_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_constant_declarationContext {
	var p = new(Interface_constant_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_constant_declaration

	return p
}

func (s *Interface_constant_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_constant_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_constant_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_constant_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_constant_declarationContext) CONSTANT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONSTANT, 0)
}

func (s *Interface_constant_declarationContext) IN() antlr.TerminalNode {
	return s.GetToken(vhdlParserIN, 0)
}

func (s *Interface_constant_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_constant_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_constant_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_constant_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_constant_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_constant_declaration(s)
	}
}

func (s *Interface_constant_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_constant_declaration(s)
	}
}

func (p *vhdlParser) Interface_constant_declaration() (localctx IInterface_constant_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_constant_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, vhdlParserRULE_interface_constant_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1499)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserCONSTANT {
		{
			p.SetState(1498)
			p.Match(vhdlParserCONSTANT)
		}

	}
	{
		p.SetState(1501)
		p.Identifier_list()
	}
	{
		p.SetState(1502)
		p.Match(vhdlParserCOLON)
	}
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIN {
		{
			p.SetState(1503)
			p.Match(vhdlParserIN)
		}

	}
	{
		p.SetState(1506)
		p.Subtype_indication()
	}
	p.SetState(1509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1507)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1508)
			p.Expression()
		}

	}

	return localctx
}

// IInterface_declarationContext is an interface to support dynamic dispatch.
type IInterface_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_declarationContext differentiates from other interfaces.
	IsInterface_declarationContext()
}

type Interface_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_declarationContext() *Interface_declarationContext {
	var p = new(Interface_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_declaration
	return p
}

func (*Interface_declarationContext) IsInterface_declarationContext() {}

func NewInterface_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_declarationContext {
	var p = new(Interface_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_declaration

	return p
}

func (s *Interface_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_declarationContext) Interface_constant_declaration() IInterface_constant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_constant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_constant_declarationContext)
}

func (s *Interface_declarationContext) Interface_signal_declaration() IInterface_signal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_signal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_signal_declarationContext)
}

func (s *Interface_declarationContext) Interface_variable_declaration() IInterface_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_variable_declarationContext)
}

func (s *Interface_declarationContext) Interface_file_declaration() IInterface_file_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_file_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_file_declarationContext)
}

func (s *Interface_declarationContext) Interface_terminal_declaration() IInterface_terminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_terminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_terminal_declarationContext)
}

func (s *Interface_declarationContext) Interface_quantity_declaration() IInterface_quantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_quantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_quantity_declarationContext)
}

func (s *Interface_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_declaration(s)
	}
}

func (s *Interface_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_declaration(s)
	}
}

func (p *vhdlParser) Interface_declaration() (localctx IInterface_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, vhdlParserRULE_interface_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1517)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1511)
			p.Interface_constant_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1512)
			p.Interface_signal_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1513)
			p.Interface_variable_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1514)
			p.Interface_file_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1515)
			p.Interface_terminal_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1516)
			p.Interface_quantity_declaration()
		}

	}

	return localctx
}

// IInterface_elementContext is an interface to support dynamic dispatch.
type IInterface_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_elementContext differentiates from other interfaces.
	IsInterface_elementContext()
}

type Interface_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_elementContext() *Interface_elementContext {
	var p = new(Interface_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_element
	return p
}

func (*Interface_elementContext) IsInterface_elementContext() {}

func NewInterface_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_elementContext {
	var p = new(Interface_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_element

	return p
}

func (s *Interface_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_elementContext) Interface_declaration() IInterface_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declarationContext)
}

func (s *Interface_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_element(s)
	}
}

func (s *Interface_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_element(s)
	}
}

func (p *vhdlParser) Interface_element() (localctx IInterface_elementContext) {
	this := p
	_ = this

	localctx = NewInterface_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, vhdlParserRULE_interface_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.Interface_declaration()
	}

	return localctx
}

// IInterface_file_declarationContext is an interface to support dynamic dispatch.
type IInterface_file_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_file_declarationContext differentiates from other interfaces.
	IsInterface_file_declarationContext()
}

type Interface_file_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_file_declarationContext() *Interface_file_declarationContext {
	var p = new(Interface_file_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_file_declaration
	return p
}

func (*Interface_file_declarationContext) IsInterface_file_declarationContext() {}

func NewInterface_file_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_file_declarationContext {
	var p = new(Interface_file_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_file_declaration

	return p
}

func (s *Interface_file_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_file_declarationContext) FILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserFILE, 0)
}

func (s *Interface_file_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_file_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_file_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_file_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_file_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_file_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_file_declaration(s)
	}
}

func (s *Interface_file_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_file_declaration(s)
	}
}

func (p *vhdlParser) Interface_file_declaration() (localctx IInterface_file_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_file_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, vhdlParserRULE_interface_file_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.Match(vhdlParserFILE)
	}
	{
		p.SetState(1522)
		p.Identifier_list()
	}
	{
		p.SetState(1523)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1524)
		p.Subtype_indication()
	}

	return localctx
}

// IInterface_signal_listContext is an interface to support dynamic dispatch.
type IInterface_signal_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_signal_listContext differentiates from other interfaces.
	IsInterface_signal_listContext()
}

type Interface_signal_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_signal_listContext() *Interface_signal_listContext {
	var p = new(Interface_signal_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_signal_list
	return p
}

func (*Interface_signal_listContext) IsInterface_signal_listContext() {}

func NewInterface_signal_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_signal_listContext {
	var p = new(Interface_signal_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_signal_list

	return p
}

func (s *Interface_signal_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_signal_listContext) AllInterface_signal_declaration() []IInterface_signal_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_signal_declarationContext)(nil)).Elem())
	var tst = make([]IInterface_signal_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_signal_declarationContext)
		}
	}

	return tst
}

func (s *Interface_signal_listContext) Interface_signal_declaration(i int) IInterface_signal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_signal_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_signal_declarationContext)
}

func (s *Interface_signal_listContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Interface_signal_listContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Interface_signal_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_signal_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_signal_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_signal_list(s)
	}
}

func (s *Interface_signal_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_signal_list(s)
	}
}

func (p *vhdlParser) Interface_signal_list() (localctx IInterface_signal_listContext) {
	this := p
	_ = this

	localctx = NewInterface_signal_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, vhdlParserRULE_interface_signal_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1526)
		p.Interface_signal_declaration()
	}
	p.SetState(1531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserSEMI {
		{
			p.SetState(1527)
			p.Match(vhdlParserSEMI)
		}
		{
			p.SetState(1528)
			p.Interface_signal_declaration()
		}

		p.SetState(1533)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterface_port_listContext is an interface to support dynamic dispatch.
type IInterface_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_port_listContext differentiates from other interfaces.
	IsInterface_port_listContext()
}

type Interface_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_port_listContext() *Interface_port_listContext {
	var p = new(Interface_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_port_list
	return p
}

func (*Interface_port_listContext) IsInterface_port_listContext() {}

func NewInterface_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_port_listContext {
	var p = new(Interface_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_port_list

	return p
}

func (s *Interface_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_port_listContext) AllInterface_port_declaration() []IInterface_port_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_port_declarationContext)(nil)).Elem())
	var tst = make([]IInterface_port_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_port_declarationContext)
		}
	}

	return tst
}

func (s *Interface_port_listContext) Interface_port_declaration(i int) IInterface_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_port_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_port_declarationContext)
}

func (s *Interface_port_listContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Interface_port_listContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Interface_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_port_list(s)
	}
}

func (s *Interface_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_port_list(s)
	}
}

func (p *vhdlParser) Interface_port_list() (localctx IInterface_port_listContext) {
	this := p
	_ = this

	localctx = NewInterface_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, vhdlParserRULE_interface_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1534)
		p.Interface_port_declaration()
	}
	p.SetState(1539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserSEMI {
		{
			p.SetState(1535)
			p.Match(vhdlParserSEMI)
		}
		{
			p.SetState(1536)
			p.Interface_port_declaration()
		}

		p.SetState(1541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterface_listContext is an interface to support dynamic dispatch.
type IInterface_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_listContext differentiates from other interfaces.
	IsInterface_listContext()
}

type Interface_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_listContext() *Interface_listContext {
	var p = new(Interface_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_list
	return p
}

func (*Interface_listContext) IsInterface_listContext() {}

func NewInterface_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_listContext {
	var p = new(Interface_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_list

	return p
}

func (s *Interface_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_listContext) AllInterface_element() []IInterface_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_elementContext)(nil)).Elem())
	var tst = make([]IInterface_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_elementContext)
		}
	}

	return tst
}

func (s *Interface_listContext) Interface_element(i int) IInterface_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_elementContext)
}

func (s *Interface_listContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Interface_listContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Interface_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_list(s)
	}
}

func (s *Interface_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_list(s)
	}
}

func (p *vhdlParser) Interface_list() (localctx IInterface_listContext) {
	this := p
	_ = this

	localctx = NewInterface_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, vhdlParserRULE_interface_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1542)
		p.Interface_element()
	}
	p.SetState(1547)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserSEMI {
		{
			p.SetState(1543)
			p.Match(vhdlParserSEMI)
		}
		{
			p.SetState(1544)
			p.Interface_element()
		}

		p.SetState(1549)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterface_quantity_declarationContext is an interface to support dynamic dispatch.
type IInterface_quantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_quantity_declarationContext differentiates from other interfaces.
	IsInterface_quantity_declarationContext()
}

type Interface_quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_quantity_declarationContext() *Interface_quantity_declarationContext {
	var p = new(Interface_quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_quantity_declaration
	return p
}

func (*Interface_quantity_declarationContext) IsInterface_quantity_declarationContext() {}

func NewInterface_quantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_quantity_declarationContext {
	var p = new(Interface_quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_quantity_declaration

	return p
}

func (s *Interface_quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_quantity_declarationContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Interface_quantity_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_quantity_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_quantity_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_quantity_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_quantity_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_quantity_declarationContext) IN() antlr.TerminalNode {
	return s.GetToken(vhdlParserIN, 0)
}

func (s *Interface_quantity_declarationContext) OUT() antlr.TerminalNode {
	return s.GetToken(vhdlParserOUT, 0)
}

func (s *Interface_quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_quantity_declaration(s)
	}
}

func (s *Interface_quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_quantity_declaration(s)
	}
}

func (p *vhdlParser) Interface_quantity_declaration() (localctx IInterface_quantity_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_quantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, vhdlParserRULE_interface_quantity_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1550)
		p.Match(vhdlParserQUANTITY)
	}
	{
		p.SetState(1551)
		p.Identifier_list()
	}
	{
		p.SetState(1552)
		p.Match(vhdlParserCOLON)
	}
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIN || _la == vhdlParserOUT {
		{
			p.SetState(1553)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vhdlParserIN || _la == vhdlParserOUT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1556)
		p.Subtype_indication()
	}
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1557)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1558)
			p.Expression()
		}

	}

	return localctx
}

// IInterface_port_declarationContext is an interface to support dynamic dispatch.
type IInterface_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_port_declarationContext differentiates from other interfaces.
	IsInterface_port_declarationContext()
}

type Interface_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_port_declarationContext() *Interface_port_declarationContext {
	var p = new(Interface_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_port_declaration
	return p
}

func (*Interface_port_declarationContext) IsInterface_port_declarationContext() {}

func NewInterface_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_port_declarationContext {
	var p = new(Interface_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_port_declaration

	return p
}

func (s *Interface_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_port_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_port_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_port_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_port_declarationContext) Signal_mode() ISignal_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_modeContext)
}

func (s *Interface_port_declarationContext) BUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserBUS, 0)
}

func (s *Interface_port_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_port_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_port_declaration(s)
	}
}

func (s *Interface_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_port_declaration(s)
	}
}

func (p *vhdlParser) Interface_port_declaration() (localctx IInterface_port_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, vhdlParserRULE_interface_port_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1561)
		p.Identifier_list()
	}
	{
		p.SetState(1562)
		p.Match(vhdlParserCOLON)
	}
	p.SetState(1564)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUFFER || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(vhdlParserIN-38))|(1<<(vhdlParserINOUT-38))|(1<<(vhdlParserLINKAGE-38))|(1<<(vhdlParserOUT-38)))) != 0) {
		{
			p.SetState(1563)
			p.Signal_mode()
		}

	}
	{
		p.SetState(1566)
		p.Subtype_indication()
	}
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUS {
		{
			p.SetState(1567)
			p.Match(vhdlParserBUS)
		}

	}
	p.SetState(1572)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1570)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1571)
			p.Expression()
		}

	}

	return localctx
}

// IInterface_signal_declarationContext is an interface to support dynamic dispatch.
type IInterface_signal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_signal_declarationContext differentiates from other interfaces.
	IsInterface_signal_declarationContext()
}

type Interface_signal_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_signal_declarationContext() *Interface_signal_declarationContext {
	var p = new(Interface_signal_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_signal_declaration
	return p
}

func (*Interface_signal_declarationContext) IsInterface_signal_declarationContext() {}

func NewInterface_signal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_signal_declarationContext {
	var p = new(Interface_signal_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_signal_declaration

	return p
}

func (s *Interface_signal_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_signal_declarationContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSIGNAL, 0)
}

func (s *Interface_signal_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_signal_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_signal_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_signal_declarationContext) Signal_mode() ISignal_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_modeContext)
}

func (s *Interface_signal_declarationContext) BUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserBUS, 0)
}

func (s *Interface_signal_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_signal_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_signal_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_signal_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_signal_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_signal_declaration(s)
	}
}

func (s *Interface_signal_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_signal_declaration(s)
	}
}

func (p *vhdlParser) Interface_signal_declaration() (localctx IInterface_signal_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_signal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, vhdlParserRULE_interface_signal_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1574)
		p.Match(vhdlParserSIGNAL)
	}
	{
		p.SetState(1575)
		p.Identifier_list()
	}
	{
		p.SetState(1576)
		p.Match(vhdlParserCOLON)
	}
	p.SetState(1578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUFFER || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(vhdlParserIN-38))|(1<<(vhdlParserINOUT-38))|(1<<(vhdlParserLINKAGE-38))|(1<<(vhdlParserOUT-38)))) != 0) {
		{
			p.SetState(1577)
			p.Signal_mode()
		}

	}
	{
		p.SetState(1580)
		p.Subtype_indication()
	}
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUS {
		{
			p.SetState(1581)
			p.Match(vhdlParserBUS)
		}

	}
	p.SetState(1586)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1584)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1585)
			p.Expression()
		}

	}

	return localctx
}

// IInterface_terminal_declarationContext is an interface to support dynamic dispatch.
type IInterface_terminal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_terminal_declarationContext differentiates from other interfaces.
	IsInterface_terminal_declarationContext()
}

type Interface_terminal_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_terminal_declarationContext() *Interface_terminal_declarationContext {
	var p = new(Interface_terminal_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_terminal_declaration
	return p
}

func (*Interface_terminal_declarationContext) IsInterface_terminal_declarationContext() {}

func NewInterface_terminal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_terminal_declarationContext {
	var p = new(Interface_terminal_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_terminal_declaration

	return p
}

func (s *Interface_terminal_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_terminal_declarationContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserTERMINAL, 0)
}

func (s *Interface_terminal_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_terminal_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_terminal_declarationContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Interface_terminal_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_terminal_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_terminal_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_terminal_declaration(s)
	}
}

func (s *Interface_terminal_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_terminal_declaration(s)
	}
}

func (p *vhdlParser) Interface_terminal_declaration() (localctx IInterface_terminal_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_terminal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, vhdlParserRULE_interface_terminal_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1588)
		p.Match(vhdlParserTERMINAL)
	}
	{
		p.SetState(1589)
		p.Identifier_list()
	}
	{
		p.SetState(1590)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1591)
		p.Subnature_indication()
	}

	return localctx
}

// IInterface_variable_declarationContext is an interface to support dynamic dispatch.
type IInterface_variable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_variable_declarationContext differentiates from other interfaces.
	IsInterface_variable_declarationContext()
}

type Interface_variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_variable_declarationContext() *Interface_variable_declarationContext {
	var p = new(Interface_variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_variable_declaration
	return p
}

func (*Interface_variable_declarationContext) IsInterface_variable_declarationContext() {}

func NewInterface_variable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_variable_declarationContext {
	var p = new(Interface_variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_variable_declaration

	return p
}

func (s *Interface_variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_variable_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_variable_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_variable_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_variable_declarationContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARIABLE, 0)
}

func (s *Interface_variable_declarationContext) Signal_mode() ISignal_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_modeContext)
}

func (s *Interface_variable_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_variable_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_variable_declaration(s)
	}
}

func (s *Interface_variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_variable_declaration(s)
	}
}

func (p *vhdlParser) Interface_variable_declaration() (localctx IInterface_variable_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_variable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, vhdlParserRULE_interface_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1594)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARIABLE {
		{
			p.SetState(1593)
			p.Match(vhdlParserVARIABLE)
		}

	}
	{
		p.SetState(1596)
		p.Identifier_list()
	}
	{
		p.SetState(1597)
		p.Match(vhdlParserCOLON)
	}
	p.SetState(1599)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUFFER || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(vhdlParserIN-38))|(1<<(vhdlParserINOUT-38))|(1<<(vhdlParserLINKAGE-38))|(1<<(vhdlParserOUT-38)))) != 0) {
		{
			p.SetState(1598)
			p.Signal_mode()
		}

	}
	{
		p.SetState(1601)
		p.Subtype_indication()
	}
	p.SetState(1604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1602)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1603)
			p.Expression()
		}

	}

	return localctx
}

// IIteration_schemeContext is an interface to support dynamic dispatch.
type IIteration_schemeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteration_schemeContext differentiates from other interfaces.
	IsIteration_schemeContext()
}

type Iteration_schemeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteration_schemeContext() *Iteration_schemeContext {
	var p = new(Iteration_schemeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_iteration_scheme
	return p
}

func (*Iteration_schemeContext) IsIteration_schemeContext() {}

func NewIteration_schemeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Iteration_schemeContext {
	var p = new(Iteration_schemeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_iteration_scheme

	return p
}

func (s *Iteration_schemeContext) GetParser() antlr.Parser { return s.parser }

func (s *Iteration_schemeContext) WHILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHILE, 0)
}

func (s *Iteration_schemeContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Iteration_schemeContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Iteration_schemeContext) Parameter_specification() IParameter_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_specificationContext)
}

func (s *Iteration_schemeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Iteration_schemeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Iteration_schemeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIteration_scheme(s)
	}
}

func (s *Iteration_schemeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIteration_scheme(s)
	}
}

func (p *vhdlParser) Iteration_scheme() (localctx IIteration_schemeContext) {
	this := p
	_ = this

	localctx = NewIteration_schemeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, vhdlParserRULE_iteration_scheme)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1610)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserWHILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1606)
			p.Match(vhdlParserWHILE)
		}
		{
			p.SetState(1607)
			p.Condition()
		}

	case vhdlParserFOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1608)
			p.Match(vhdlParserFOR)
		}
		{
			p.SetState(1609)
			p.Parameter_specification()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILabel_colonContext is an interface to support dynamic dispatch.
type ILabel_colonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabel_colonContext differentiates from other interfaces.
	IsLabel_colonContext()
}

type Label_colonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabel_colonContext() *Label_colonContext {
	var p = new(Label_colonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_label_colon
	return p
}

func (*Label_colonContext) IsLabel_colonContext() {}

func NewLabel_colonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Label_colonContext {
	var p = new(Label_colonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_label_colon

	return p
}

func (s *Label_colonContext) GetParser() antlr.Parser { return s.parser }

func (s *Label_colonContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Label_colonContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Label_colonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Label_colonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Label_colonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLabel_colon(s)
	}
}

func (s *Label_colonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLabel_colon(s)
	}
}

func (p *vhdlParser) Label_colon() (localctx ILabel_colonContext) {
	this := p
	_ = this

	localctx = NewLabel_colonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, vhdlParserRULE_label_colon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1612)
		p.Identifier()
	}
	{
		p.SetState(1613)
		p.Match(vhdlParserCOLON)
	}

	return localctx
}

// ILibrary_clauseContext is an interface to support dynamic dispatch.
type ILibrary_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_clauseContext differentiates from other interfaces.
	IsLibrary_clauseContext()
}

type Library_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_clauseContext() *Library_clauseContext {
	var p = new(Library_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_library_clause
	return p
}

func (*Library_clauseContext) IsLibrary_clauseContext() {}

func NewLibrary_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_clauseContext {
	var p = new(Library_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_library_clause

	return p
}

func (s *Library_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_clauseContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(vhdlParserLIBRARY, 0)
}

func (s *Library_clauseContext) Logical_name_list() ILogical_name_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_name_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_name_listContext)
}

func (s *Library_clauseContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Library_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLibrary_clause(s)
	}
}

func (s *Library_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLibrary_clause(s)
	}
}

func (p *vhdlParser) Library_clause() (localctx ILibrary_clauseContext) {
	this := p
	_ = this

	localctx = NewLibrary_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, vhdlParserRULE_library_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		p.Match(vhdlParserLIBRARY)
	}
	{
		p.SetState(1616)
		p.Logical_name_list()
	}
	{
		p.SetState(1617)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ILibrary_unitContext is an interface to support dynamic dispatch.
type ILibrary_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_unitContext differentiates from other interfaces.
	IsLibrary_unitContext()
}

type Library_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_unitContext() *Library_unitContext {
	var p = new(Library_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_library_unit
	return p
}

func (*Library_unitContext) IsLibrary_unitContext() {}

func NewLibrary_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_unitContext {
	var p = new(Library_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_library_unit

	return p
}

func (s *Library_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_unitContext) Secondary_unit() ISecondary_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecondary_unitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISecondary_unitContext)
}

func (s *Library_unitContext) Primary_unit() IPrimary_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_unitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_unitContext)
}

func (s *Library_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLibrary_unit(s)
	}
}

func (s *Library_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLibrary_unit(s)
	}
}

func (p *vhdlParser) Library_unit() (localctx ILibrary_unitContext) {
	this := p
	_ = this

	localctx = NewLibrary_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, vhdlParserRULE_library_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1621)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1619)
			p.Secondary_unit()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1620)
			p.Primary_unit()
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NULL_() antlr.TerminalNode {
	return s.GetToken(vhdlParserNULL_, 0)
}

func (s *LiteralContext) BIT_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserBIT_STRING_LITERAL, 0)
}

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) Enumeration_literal() IEnumeration_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeration_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeration_literalContext)
}

func (s *LiteralContext) Numeric_literal() INumeric_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeric_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeric_literalContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *vhdlParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, vhdlParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1628)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserNULL_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1623)
			p.Match(vhdlParserNULL_)
		}

	case vhdlParserBIT_STRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1624)
			p.Match(vhdlParserBIT_STRING_LITERAL)
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1625)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1626)
			p.Enumeration_literal()
		}

	case vhdlParserBASE_LITERAL, vhdlParserREAL_LITERAL, vhdlParserINTEGER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1627)
			p.Numeric_literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILogical_nameContext is an interface to support dynamic dispatch.
type ILogical_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_nameContext differentiates from other interfaces.
	IsLogical_nameContext()
}

type Logical_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_nameContext() *Logical_nameContext {
	var p = new(Logical_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_logical_name
	return p
}

func (*Logical_nameContext) IsLogical_nameContext() {}

func NewLogical_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_nameContext {
	var p = new(Logical_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_logical_name

	return p
}

func (s *Logical_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Logical_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLogical_name(s)
	}
}

func (s *Logical_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLogical_name(s)
	}
}

func (p *vhdlParser) Logical_name() (localctx ILogical_nameContext) {
	this := p
	_ = this

	localctx = NewLogical_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, vhdlParserRULE_logical_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1630)
		p.Identifier()
	}

	return localctx
}

// ILogical_name_listContext is an interface to support dynamic dispatch.
type ILogical_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_name_listContext differentiates from other interfaces.
	IsLogical_name_listContext()
}

type Logical_name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_name_listContext() *Logical_name_listContext {
	var p = new(Logical_name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_logical_name_list
	return p
}

func (*Logical_name_listContext) IsLogical_name_listContext() {}

func NewLogical_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_name_listContext {
	var p = new(Logical_name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_logical_name_list

	return p
}

func (s *Logical_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_name_listContext) AllLogical_name() []ILogical_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_nameContext)(nil)).Elem())
	var tst = make([]ILogical_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_nameContext)
		}
	}

	return tst
}

func (s *Logical_name_listContext) Logical_name(i int) ILogical_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_nameContext)
}

func (s *Logical_name_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Logical_name_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Logical_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLogical_name_list(s)
	}
}

func (s *Logical_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLogical_name_list(s)
	}
}

func (p *vhdlParser) Logical_name_list() (localctx ILogical_name_listContext) {
	this := p
	_ = this

	localctx = NewLogical_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, vhdlParserRULE_logical_name_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1632)
		p.Logical_name()
	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1633)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1634)
			p.Logical_name()
		}

		p.SetState(1639)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILogical_operatorContext is an interface to support dynamic dispatch.
type ILogical_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_operatorContext differentiates from other interfaces.
	IsLogical_operatorContext()
}

type Logical_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_operatorContext() *Logical_operatorContext {
	var p = new(Logical_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_logical_operator
	return p
}

func (*Logical_operatorContext) IsLogical_operatorContext() {}

func NewLogical_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_operatorContext {
	var p = new(Logical_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_logical_operator

	return p
}

func (s *Logical_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_operatorContext) AND() antlr.TerminalNode {
	return s.GetToken(vhdlParserAND, 0)
}

func (s *Logical_operatorContext) OR() antlr.TerminalNode {
	return s.GetToken(vhdlParserOR, 0)
}

func (s *Logical_operatorContext) NAND() antlr.TerminalNode {
	return s.GetToken(vhdlParserNAND, 0)
}

func (s *Logical_operatorContext) NOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserNOR, 0)
}

func (s *Logical_operatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserXOR, 0)
}

func (s *Logical_operatorContext) XNOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserXNOR, 0)
}

func (s *Logical_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLogical_operator(s)
	}
}

func (s *Logical_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLogical_operator(s)
	}
}

func (p *vhdlParser) Logical_operator() (localctx ILogical_operatorContext) {
	this := p
	_ = this

	localctx = NewLogical_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, vhdlParserRULE_logical_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1640)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserAND || (((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(vhdlParserNAND-50))|(1<<(vhdlParserNOR-50))|(1<<(vhdlParserOR-50)))) != 0) || _la == vhdlParserXNOR || _la == vhdlParserXOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILoop_statementContext is an interface to support dynamic dispatch.
type ILoop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_statementContext differentiates from other interfaces.
	IsLoop_statementContext()
}

type Loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_statementContext() *Loop_statementContext {
	var p = new(Loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_loop_statement
	return p
}

func (*Loop_statementContext) IsLoop_statementContext() {}

func NewLoop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_statementContext {
	var p = new(Loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_loop_statement

	return p
}

func (s *Loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_statementContext) AllLOOP() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserLOOP)
}

func (s *Loop_statementContext) LOOP(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserLOOP, i)
}

func (s *Loop_statementContext) Sequence_of_statements() ISequence_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_of_statementsContext)
}

func (s *Loop_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Loop_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Loop_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Loop_statementContext) Iteration_scheme() IIteration_schemeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteration_schemeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteration_schemeContext)
}

func (s *Loop_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLoop_statement(s)
	}
}

func (s *Loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLoop_statement(s)
	}
}

func (p *vhdlParser) Loop_statement() (localctx ILoop_statementContext) {
	this := p
	_ = this

	localctx = NewLoop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, vhdlParserRULE_loop_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1643)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1642)
			p.Label_colon()
		}

	}
	p.SetState(1646)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR || _la == vhdlParserWHILE {
		{
			p.SetState(1645)
			p.Iteration_scheme()
		}

	}
	{
		p.SetState(1648)
		p.Match(vhdlParserLOOP)
	}
	{
		p.SetState(1649)
		p.Sequence_of_statements()
	}
	{
		p.SetState(1650)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(1651)
		p.Match(vhdlParserLOOP)
	}
	p.SetState(1653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1652)
			p.Identifier()
		}

	}
	{
		p.SetState(1655)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISignal_modeContext is an interface to support dynamic dispatch.
type ISignal_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_modeContext differentiates from other interfaces.
	IsSignal_modeContext()
}

type Signal_modeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_modeContext() *Signal_modeContext {
	var p = new(Signal_modeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_mode
	return p
}

func (*Signal_modeContext) IsSignal_modeContext() {}

func NewSignal_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_modeContext {
	var p = new(Signal_modeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_mode

	return p
}

func (s *Signal_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_modeContext) IN() antlr.TerminalNode {
	return s.GetToken(vhdlParserIN, 0)
}

func (s *Signal_modeContext) OUT() antlr.TerminalNode {
	return s.GetToken(vhdlParserOUT, 0)
}

func (s *Signal_modeContext) INOUT() antlr.TerminalNode {
	return s.GetToken(vhdlParserINOUT, 0)
}

func (s *Signal_modeContext) BUFFER() antlr.TerminalNode {
	return s.GetToken(vhdlParserBUFFER, 0)
}

func (s *Signal_modeContext) LINKAGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLINKAGE, 0)
}

func (s *Signal_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_mode(s)
	}
}

func (s *Signal_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_mode(s)
	}
}

func (p *vhdlParser) Signal_mode() (localctx ISignal_modeContext) {
	this := p
	_ = this

	localctx = NewSignal_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, vhdlParserRULE_signal_mode)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1657)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserBUFFER || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(vhdlParserIN-38))|(1<<(vhdlParserINOUT-38))|(1<<(vhdlParserLINKAGE-38))|(1<<(vhdlParserOUT-38)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMultiplying_operatorContext is an interface to support dynamic dispatch.
type IMultiplying_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplying_operatorContext differentiates from other interfaces.
	IsMultiplying_operatorContext()
}

type Multiplying_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplying_operatorContext() *Multiplying_operatorContext {
	var p = new(Multiplying_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_multiplying_operator
	return p
}

func (*Multiplying_operatorContext) IsMultiplying_operatorContext() {}

func NewMultiplying_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiplying_operatorContext {
	var p = new(Multiplying_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_multiplying_operator

	return p
}

func (s *Multiplying_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiplying_operatorContext) MUL() antlr.TerminalNode {
	return s.GetToken(vhdlParserMUL, 0)
}

func (s *Multiplying_operatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(vhdlParserDIV, 0)
}

func (s *Multiplying_operatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(vhdlParserMOD, 0)
}

func (s *Multiplying_operatorContext) REM() antlr.TerminalNode {
	return s.GetToken(vhdlParserREM, 0)
}

func (s *Multiplying_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiplying_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiplying_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterMultiplying_operator(s)
	}
}

func (s *Multiplying_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitMultiplying_operator(s)
	}
}

func (p *vhdlParser) Multiplying_operator() (localctx IMultiplying_operatorContext) {
	this := p
	_ = this

	localctx = NewMultiplying_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, vhdlParserRULE_multiplying_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1659)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserMOD || _la == vhdlParserREM || _la == vhdlParserMUL || _la == vhdlParserDIV) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *NameContext) AllName_part() []IName_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_partContext)(nil)).Elem())
	var tst = make([]IName_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_partContext)
		}
	}

	return tst
}

func (s *NameContext) Name_part(i int) IName_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_partContext)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitName(s)
	}
}

func (p *vhdlParser) Name() (localctx INameContext) {
	this := p
	_ = this

	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, vhdlParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1663)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		{
			p.SetState(1661)
			p.Identifier()
		}

	case vhdlParserSTRING_LITERAL:
		{
			p.SetState(1662)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1668)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1665)
				p.Name_part()
			}

		}
		p.SetState(1670)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())
	}

	return localctx
}

// IName_partContext is an interface to support dynamic dispatch.
type IName_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_partContext differentiates from other interfaces.
	IsName_partContext()
}

type Name_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_partContext() *Name_partContext {
	var p = new(Name_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_name_part
	return p
}

func (*Name_partContext) IsName_partContext() {}

func NewName_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_partContext {
	var p = new(Name_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_name_part

	return p
}

func (s *Name_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_partContext) Selected_name_part() ISelected_name_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_name_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_name_partContext)
}

func (s *Name_partContext) Function_call_or_indexed_name_part() IFunction_call_or_indexed_name_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_call_or_indexed_name_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_call_or_indexed_name_partContext)
}

func (s *Name_partContext) Slice_name_part() ISlice_name_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISlice_name_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISlice_name_partContext)
}

func (s *Name_partContext) Attribute_name_part() IAttribute_name_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_name_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_name_partContext)
}

func (s *Name_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterName_part(s)
	}
}

func (s *Name_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitName_part(s)
	}
}

func (p *vhdlParser) Name_part() (localctx IName_partContext) {
	this := p
	_ = this

	localctx = NewName_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, vhdlParserRULE_name_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1675)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1671)
			p.Selected_name_part()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1672)
			p.Function_call_or_indexed_name_part()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1673)
			p.Slice_name_part()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1674)
			p.Attribute_name_part()
		}

	}

	return localctx
}

// ISelected_nameContext is an interface to support dynamic dispatch.
type ISelected_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelected_nameContext differentiates from other interfaces.
	IsSelected_nameContext()
}

type Selected_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelected_nameContext() *Selected_nameContext {
	var p = new(Selected_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_selected_name
	return p
}

func (*Selected_nameContext) IsSelected_nameContext() {}

func NewSelected_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selected_nameContext {
	var p = new(Selected_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_selected_name

	return p
}

func (s *Selected_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Selected_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Selected_nameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserDOT)
}

func (s *Selected_nameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserDOT, i)
}

func (s *Selected_nameContext) AllSuffix() []ISuffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuffixContext)(nil)).Elem())
	var tst = make([]ISuffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuffixContext)
		}
	}

	return tst
}

func (s *Selected_nameContext) Suffix(i int) ISuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuffixContext)
}

func (s *Selected_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selected_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selected_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSelected_name(s)
	}
}

func (s *Selected_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSelected_name(s)
	}
}

func (p *vhdlParser) Selected_name() (localctx ISelected_nameContext) {
	this := p
	_ = this

	localctx = NewSelected_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, vhdlParserRULE_selected_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.Identifier()
	}
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserDOT {
		{
			p.SetState(1678)
			p.Match(vhdlParserDOT)
		}
		{
			p.SetState(1679)
			p.Suffix()
		}

		p.SetState(1684)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelected_name_partContext is an interface to support dynamic dispatch.
type ISelected_name_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelected_name_partContext differentiates from other interfaces.
	IsSelected_name_partContext()
}

type Selected_name_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelected_name_partContext() *Selected_name_partContext {
	var p = new(Selected_name_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_selected_name_part
	return p
}

func (*Selected_name_partContext) IsSelected_name_partContext() {}

func NewSelected_name_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selected_name_partContext {
	var p = new(Selected_name_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_selected_name_part

	return p
}

func (s *Selected_name_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Selected_name_partContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserDOT)
}

func (s *Selected_name_partContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserDOT, i)
}

func (s *Selected_name_partContext) AllSuffix() []ISuffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuffixContext)(nil)).Elem())
	var tst = make([]ISuffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuffixContext)
		}
	}

	return tst
}

func (s *Selected_name_partContext) Suffix(i int) ISuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuffixContext)
}

func (s *Selected_name_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selected_name_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selected_name_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSelected_name_part(s)
	}
}

func (s *Selected_name_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSelected_name_part(s)
	}
}

func (p *vhdlParser) Selected_name_part() (localctx ISelected_name_partContext) {
	this := p
	_ = this

	localctx = NewSelected_name_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, vhdlParserRULE_selected_name_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1687)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1685)
				p.Match(vhdlParserDOT)
			}
			{
				p.SetState(1686)
				p.Suffix()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1689)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())
	}

	return localctx
}

// IFunction_call_or_indexed_name_partContext is an interface to support dynamic dispatch.
type IFunction_call_or_indexed_name_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_call_or_indexed_name_partContext differentiates from other interfaces.
	IsFunction_call_or_indexed_name_partContext()
}

type Function_call_or_indexed_name_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_or_indexed_name_partContext() *Function_call_or_indexed_name_partContext {
	var p = new(Function_call_or_indexed_name_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_function_call_or_indexed_name_part
	return p
}

func (*Function_call_or_indexed_name_partContext) IsFunction_call_or_indexed_name_partContext() {}

func NewFunction_call_or_indexed_name_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_or_indexed_name_partContext {
	var p = new(Function_call_or_indexed_name_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_function_call_or_indexed_name_part

	return p
}

func (s *Function_call_or_indexed_name_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_or_indexed_name_partContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Function_call_or_indexed_name_partContext) Actual_parameter_part() IActual_parameter_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActual_parameter_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActual_parameter_partContext)
}

func (s *Function_call_or_indexed_name_partContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Function_call_or_indexed_name_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_or_indexed_name_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_call_or_indexed_name_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFunction_call_or_indexed_name_part(s)
	}
}

func (s *Function_call_or_indexed_name_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFunction_call_or_indexed_name_part(s)
	}
}

func (p *vhdlParser) Function_call_or_indexed_name_part() (localctx IFunction_call_or_indexed_name_partContext) {
	this := p
	_ = this

	localctx = NewFunction_call_or_indexed_name_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, vhdlParserRULE_function_call_or_indexed_name_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1691)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1692)
		p.Actual_parameter_part()
	}
	{
		p.SetState(1693)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// ISlice_name_partContext is an interface to support dynamic dispatch.
type ISlice_name_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSlice_name_partContext differentiates from other interfaces.
	IsSlice_name_partContext()
}

type Slice_name_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlice_name_partContext() *Slice_name_partContext {
	var p = new(Slice_name_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_slice_name_part
	return p
}

func (*Slice_name_partContext) IsSlice_name_partContext() {}

func NewSlice_name_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Slice_name_partContext {
	var p = new(Slice_name_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_slice_name_part

	return p
}

func (s *Slice_name_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Slice_name_partContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Slice_name_partContext) Discrete_range() IDiscrete_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiscrete_rangeContext)
}

func (s *Slice_name_partContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Slice_name_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Slice_name_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Slice_name_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSlice_name_part(s)
	}
}

func (s *Slice_name_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSlice_name_part(s)
	}
}

func (p *vhdlParser) Slice_name_part() (localctx ISlice_name_partContext) {
	this := p
	_ = this

	localctx = NewSlice_name_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, vhdlParserRULE_slice_name_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1695)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1696)
		p.Discrete_range()
	}
	{
		p.SetState(1697)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IAttribute_name_partContext is an interface to support dynamic dispatch.
type IAttribute_name_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_name_partContext differentiates from other interfaces.
	IsAttribute_name_partContext()
}

type Attribute_name_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_name_partContext() *Attribute_name_partContext {
	var p = new(Attribute_name_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_attribute_name_part
	return p
}

func (*Attribute_name_partContext) IsAttribute_name_partContext() {}

func NewAttribute_name_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_name_partContext {
	var p = new(Attribute_name_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_attribute_name_part

	return p
}

func (s *Attribute_name_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_name_partContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(vhdlParserAPOSTROPHE, 0)
}

func (s *Attribute_name_partContext) Attribute_designator() IAttribute_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_designatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_designatorContext)
}

func (s *Attribute_name_partContext) Signature() ISignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *Attribute_name_partContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Attribute_name_partContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Attribute_name_partContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Attribute_name_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_name_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_name_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAttribute_name_part(s)
	}
}

func (s *Attribute_name_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAttribute_name_part(s)
	}
}

func (p *vhdlParser) Attribute_name_part() (localctx IAttribute_name_partContext) {
	this := p
	_ = this

	localctx = NewAttribute_name_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, vhdlParserRULE_attribute_name_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1700)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLBRACKET {
		{
			p.SetState(1699)
			p.Signature()
		}

	}
	{
		p.SetState(1702)
		p.Match(vhdlParserAPOSTROPHE)
	}
	{
		p.SetState(1703)
		p.Attribute_designator()
	}
	p.SetState(1708)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1704)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1705)
			p.Expression()
		}
		{
			p.SetState(1706)
			p.Match(vhdlParserRPAREN)
		}

	}

	return localctx
}

// INature_declarationContext is an interface to support dynamic dispatch.
type INature_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNature_declarationContext differentiates from other interfaces.
	IsNature_declarationContext()
}

type Nature_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNature_declarationContext() *Nature_declarationContext {
	var p = new(Nature_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_nature_declaration
	return p
}

func (*Nature_declarationContext) IsNature_declarationContext() {}

func NewNature_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nature_declarationContext {
	var p = new(Nature_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_nature_declaration

	return p
}

func (s *Nature_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Nature_declarationContext) NATURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserNATURE, 0)
}

func (s *Nature_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Nature_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Nature_declarationContext) Nature_definition() INature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INature_definitionContext)
}

func (s *Nature_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Nature_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nature_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nature_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNature_declaration(s)
	}
}

func (s *Nature_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNature_declaration(s)
	}
}

func (p *vhdlParser) Nature_declaration() (localctx INature_declarationContext) {
	this := p
	_ = this

	localctx = NewNature_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, vhdlParserRULE_nature_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1710)
		p.Match(vhdlParserNATURE)
	}
	{
		p.SetState(1711)
		p.Identifier()
	}
	{
		p.SetState(1712)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1713)
		p.Nature_definition()
	}
	{
		p.SetState(1714)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// INature_definitionContext is an interface to support dynamic dispatch.
type INature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNature_definitionContext differentiates from other interfaces.
	IsNature_definitionContext()
}

type Nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNature_definitionContext() *Nature_definitionContext {
	var p = new(Nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_nature_definition
	return p
}

func (*Nature_definitionContext) IsNature_definitionContext() {}

func NewNature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nature_definitionContext {
	var p = new(Nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_nature_definition

	return p
}

func (s *Nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Nature_definitionContext) Scalar_nature_definition() IScalar_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScalar_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScalar_nature_definitionContext)
}

func (s *Nature_definitionContext) Composite_nature_definition() IComposite_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComposite_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComposite_nature_definitionContext)
}

func (s *Nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNature_definition(s)
	}
}

func (s *Nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNature_definition(s)
	}
}

func (p *vhdlParser) Nature_definition() (localctx INature_definitionContext) {
	this := p
	_ = this

	localctx = NewNature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, vhdlParserRULE_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1718)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1716)
			p.Scalar_nature_definition()
		}

	case vhdlParserARRAY, vhdlParserRECORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1717)
			p.Composite_nature_definition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INature_element_declarationContext is an interface to support dynamic dispatch.
type INature_element_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNature_element_declarationContext differentiates from other interfaces.
	IsNature_element_declarationContext()
}

type Nature_element_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNature_element_declarationContext() *Nature_element_declarationContext {
	var p = new(Nature_element_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_nature_element_declaration
	return p
}

func (*Nature_element_declarationContext) IsNature_element_declarationContext() {}

func NewNature_element_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nature_element_declarationContext {
	var p = new(Nature_element_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_nature_element_declaration

	return p
}

func (s *Nature_element_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Nature_element_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Nature_element_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Nature_element_declarationContext) Element_subnature_definition() IElement_subnature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_subnature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElement_subnature_definitionContext)
}

func (s *Nature_element_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nature_element_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nature_element_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNature_element_declaration(s)
	}
}

func (s *Nature_element_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNature_element_declaration(s)
	}
}

func (p *vhdlParser) Nature_element_declaration() (localctx INature_element_declarationContext) {
	this := p
	_ = this

	localctx = NewNature_element_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, vhdlParserRULE_nature_element_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1720)
		p.Identifier_list()
	}
	{
		p.SetState(1721)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1722)
		p.Element_subnature_definition()
	}

	return localctx
}

// INext_statementContext is an interface to support dynamic dispatch.
type INext_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNext_statementContext differentiates from other interfaces.
	IsNext_statementContext()
}

type Next_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNext_statementContext() *Next_statementContext {
	var p = new(Next_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_next_statement
	return p
}

func (*Next_statementContext) IsNext_statementContext() {}

func NewNext_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Next_statementContext {
	var p = new(Next_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_next_statement

	return p
}

func (s *Next_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Next_statementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(vhdlParserNEXT, 0)
}

func (s *Next_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Next_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Next_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Next_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Next_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Next_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Next_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Next_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNext_statement(s)
	}
}

func (s *Next_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNext_statement(s)
	}
}

func (p *vhdlParser) Next_statement() (localctx INext_statementContext) {
	this := p
	_ = this

	localctx = NewNext_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, vhdlParserRULE_next_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1724)
			p.Label_colon()
		}

	}
	{
		p.SetState(1727)
		p.Match(vhdlParserNEXT)
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1728)
			p.Identifier()
		}

	}
	p.SetState(1733)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(1731)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(1732)
			p.Condition()
		}

	}
	{
		p.SetState(1735)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// INumeric_literalContext is an interface to support dynamic dispatch.
type INumeric_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeric_literalContext differentiates from other interfaces.
	IsNumeric_literalContext()
}

type Numeric_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_literalContext() *Numeric_literalContext {
	var p = new(Numeric_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_numeric_literal
	return p
}

func (*Numeric_literalContext) IsNumeric_literalContext() {}

func NewNumeric_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_literalContext {
	var p = new(Numeric_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_numeric_literal

	return p
}

func (s *Numeric_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Numeric_literalContext) Abstract_literal() IAbstract_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_literalContext)
}

func (s *Numeric_literalContext) Physical_literal() IPhysical_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPhysical_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPhysical_literalContext)
}

func (s *Numeric_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Numeric_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNumeric_literal(s)
	}
}

func (s *Numeric_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNumeric_literal(s)
	}
}

func (p *vhdlParser) Numeric_literal() (localctx INumeric_literalContext) {
	this := p
	_ = this

	localctx = NewNumeric_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, vhdlParserRULE_numeric_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1739)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1737)
			p.Abstract_literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1738)
			p.Physical_literal()
		}

	}

	return localctx
}

// IObject_declarationContext is an interface to support dynamic dispatch.
type IObject_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_declarationContext differentiates from other interfaces.
	IsObject_declarationContext()
}

type Object_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_declarationContext() *Object_declarationContext {
	var p = new(Object_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_object_declaration
	return p
}

func (*Object_declarationContext) IsObject_declarationContext() {}

func NewObject_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_declarationContext {
	var p = new(Object_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_object_declaration

	return p
}

func (s *Object_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_declarationContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Object_declarationContext) Signal_declaration() ISignal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_declarationContext)
}

func (s *Object_declarationContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Object_declarationContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Object_declarationContext) Terminal_declaration() ITerminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_declarationContext)
}

func (s *Object_declarationContext) Quantity_declaration() IQuantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_declarationContext)
}

func (s *Object_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterObject_declaration(s)
	}
}

func (s *Object_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitObject_declaration(s)
	}
}

func (p *vhdlParser) Object_declaration() (localctx IObject_declarationContext) {
	this := p
	_ = this

	localctx = NewObject_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, vhdlParserRULE_object_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1747)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserCONSTANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1741)
			p.Constant_declaration()
		}

	case vhdlParserSIGNAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1742)
			p.Signal_declaration()
		}

	case vhdlParserSHARED, vhdlParserVARIABLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1743)
			p.Variable_declaration()
		}

	case vhdlParserFILE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1744)
			p.File_declaration()
		}

	case vhdlParserTERMINAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1745)
			p.Terminal_declaration()
		}

	case vhdlParserQUANTITY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1746)
			p.Quantity_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOptsContext is an interface to support dynamic dispatch.
type IOptsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptsContext differentiates from other interfaces.
	IsOptsContext()
}

type OptsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptsContext() *OptsContext {
	var p = new(OptsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_opts
	return p
}

func (*OptsContext) IsOptsContext() {}

func NewOptsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptsContext {
	var p = new(OptsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_opts

	return p
}

func (s *OptsContext) GetParser() antlr.Parser { return s.parser }

func (s *OptsContext) GUARDED() antlr.TerminalNode {
	return s.GetToken(vhdlParserGUARDED, 0)
}

func (s *OptsContext) Delay_mechanism() IDelay_mechanismContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_mechanismContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_mechanismContext)
}

func (s *OptsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterOpts(s)
	}
}

func (s *OptsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitOpts(s)
	}
}

func (p *vhdlParser) Opts() (localctx IOptsContext) {
	this := p
	_ = this

	localctx = NewOptsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, vhdlParserRULE_opts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1750)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGUARDED {
		{
			p.SetState(1749)
			p.Match(vhdlParserGUARDED)
		}

	}
	p.SetState(1753)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserINERTIAL || _la == vhdlParserREJECT || _la == vhdlParserTRANSPORT {
		{
			p.SetState(1752)
			p.Delay_mechanism()
		}

	}

	return localctx
}

// IPackage_bodyContext is an interface to support dynamic dispatch.
type IPackage_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_bodyContext differentiates from other interfaces.
	IsPackage_bodyContext()
}

type Package_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_bodyContext() *Package_bodyContext {
	var p = new(Package_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_body
	return p
}

func (*Package_bodyContext) IsPackage_bodyContext() {}

func NewPackage_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_bodyContext {
	var p = new(Package_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_body

	return p
}

func (s *Package_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_bodyContext) AllPACKAGE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPACKAGE)
}

func (s *Package_bodyContext) PACKAGE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPACKAGE, i)
}

func (s *Package_bodyContext) AllBODY() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserBODY)
}

func (s *Package_bodyContext) BODY(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserBODY, i)
}

func (s *Package_bodyContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Package_bodyContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Package_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Package_bodyContext) Package_body_declarative_part() IPackage_body_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_body_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_body_declarative_partContext)
}

func (s *Package_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Package_bodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Package_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_body(s)
	}
}

func (s *Package_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_body(s)
	}
}

func (p *vhdlParser) Package_body() (localctx IPackage_bodyContext) {
	this := p
	_ = this

	localctx = NewPackage_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, vhdlParserRULE_package_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1755)
		p.Match(vhdlParserPACKAGE)
	}
	{
		p.SetState(1756)
		p.Match(vhdlParserBODY)
	}
	{
		p.SetState(1757)
		p.Identifier()
	}
	{
		p.SetState(1758)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1759)
		p.Package_body_declarative_part()
	}
	{
		p.SetState(1760)
		p.Match(vhdlParserEND)
	}
	p.SetState(1763)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPACKAGE {
		{
			p.SetState(1761)
			p.Match(vhdlParserPACKAGE)
		}
		{
			p.SetState(1762)
			p.Match(vhdlParserBODY)
		}

	}
	p.SetState(1766)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1765)
			p.Identifier()
		}

	}
	{
		p.SetState(1768)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IPackage_body_declarative_itemContext is an interface to support dynamic dispatch.
type IPackage_body_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_body_declarative_itemContext differentiates from other interfaces.
	IsPackage_body_declarative_itemContext()
}

type Package_body_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_body_declarative_itemContext() *Package_body_declarative_itemContext {
	var p = new(Package_body_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_body_declarative_item
	return p
}

func (*Package_body_declarative_itemContext) IsPackage_body_declarative_itemContext() {}

func NewPackage_body_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_body_declarative_itemContext {
	var p = new(Package_body_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_body_declarative_item

	return p
}

func (s *Package_body_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_body_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Package_body_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Package_body_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Package_body_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Package_body_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Package_body_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Package_body_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Package_body_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Package_body_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Package_body_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Package_body_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Package_body_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_body_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_body_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_body_declarative_item(s)
	}
}

func (s *Package_body_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_body_declarative_item(s)
	}
}

func (p *vhdlParser) Package_body_declarative_item() (localctx IPackage_body_declarative_itemContext) {
	this := p
	_ = this

	localctx = NewPackage_body_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, vhdlParserRULE_package_body_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1781)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1770)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1771)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1772)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1773)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1774)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1775)
			p.Variable_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1776)
			p.File_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1777)
			p.Alias_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1778)
			p.Use_clause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1779)
			p.Group_template_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1780)
			p.Group_declaration()
		}

	}

	return localctx
}

// IPackage_body_declarative_partContext is an interface to support dynamic dispatch.
type IPackage_body_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_body_declarative_partContext differentiates from other interfaces.
	IsPackage_body_declarative_partContext()
}

type Package_body_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_body_declarative_partContext() *Package_body_declarative_partContext {
	var p = new(Package_body_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_body_declarative_part
	return p
}

func (*Package_body_declarative_partContext) IsPackage_body_declarative_partContext() {}

func NewPackage_body_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_body_declarative_partContext {
	var p = new(Package_body_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_body_declarative_part

	return p
}

func (s *Package_body_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_body_declarative_partContext) AllPackage_body_declarative_item() []IPackage_body_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_body_declarative_itemContext)(nil)).Elem())
	var tst = make([]IPackage_body_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_body_declarative_itemContext)
		}
	}

	return tst
}

func (s *Package_body_declarative_partContext) Package_body_declarative_item(i int) IPackage_body_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_body_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_body_declarative_itemContext)
}

func (s *Package_body_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_body_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_body_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_body_declarative_part(s)
	}
}

func (s *Package_body_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_body_declarative_part(s)
	}
}

func (p *vhdlParser) Package_body_declarative_part() (localctx IPackage_body_declarative_partContext) {
	this := p
	_ = this

	localctx = NewPackage_body_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, vhdlParserRULE_package_body_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || _la == vhdlParserGROUP || _la == vhdlParserIMPURE || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSUBTYPE-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1783)
			p.Package_body_declarative_item()
		}

		p.SetState(1788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPackage_declarationContext is an interface to support dynamic dispatch.
type IPackage_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_declarationContext differentiates from other interfaces.
	IsPackage_declarationContext()
}

type Package_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_declarationContext() *Package_declarationContext {
	var p = new(Package_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_declaration
	return p
}

func (*Package_declarationContext) IsPackage_declarationContext() {}

func NewPackage_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_declarationContext {
	var p = new(Package_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_declaration

	return p
}

func (s *Package_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_declarationContext) AllPACKAGE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPACKAGE)
}

func (s *Package_declarationContext) PACKAGE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPACKAGE, i)
}

func (s *Package_declarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Package_declarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Package_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Package_declarationContext) Package_declarative_part() IPackage_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_declarative_partContext)
}

func (s *Package_declarationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Package_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Package_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_declaration(s)
	}
}

func (s *Package_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_declaration(s)
	}
}

func (p *vhdlParser) Package_declaration() (localctx IPackage_declarationContext) {
	this := p
	_ = this

	localctx = NewPackage_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, vhdlParserRULE_package_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1789)
		p.Match(vhdlParserPACKAGE)
	}
	{
		p.SetState(1790)
		p.Identifier()
	}
	{
		p.SetState(1791)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1792)
		p.Package_declarative_part()
	}
	{
		p.SetState(1793)
		p.Match(vhdlParserEND)
	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPACKAGE {
		{
			p.SetState(1794)
			p.Match(vhdlParserPACKAGE)
		}

	}
	p.SetState(1798)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1797)
			p.Identifier()
		}

	}
	{
		p.SetState(1800)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IPackage_declarative_itemContext is an interface to support dynamic dispatch.
type IPackage_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_declarative_itemContext differentiates from other interfaces.
	IsPackage_declarative_itemContext()
}

type Package_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_declarative_itemContext() *Package_declarative_itemContext {
	var p = new(Package_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_declarative_item
	return p
}

func (*Package_declarative_itemContext) IsPackage_declarative_itemContext() {}

func NewPackage_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_declarative_itemContext {
	var p = new(Package_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_declarative_item

	return p
}

func (s *Package_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Package_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Package_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Package_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Package_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Package_declarative_itemContext) Signal_declaration() ISignal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_declarationContext)
}

func (s *Package_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Package_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Package_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Package_declarative_itemContext) Component_declaration() IComponent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_declarationContext)
}

func (s *Package_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Package_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Package_declarative_itemContext) Disconnection_specification() IDisconnection_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisconnection_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisconnection_specificationContext)
}

func (s *Package_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Package_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Package_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Package_declarative_itemContext) Nature_declaration() INature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INature_declarationContext)
}

func (s *Package_declarative_itemContext) Subnature_declaration() ISubnature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_declarationContext)
}

func (s *Package_declarative_itemContext) Terminal_declaration() ITerminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_declarationContext)
}

func (s *Package_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_declarative_item(s)
	}
}

func (s *Package_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_declarative_item(s)
	}
}

func (p *vhdlParser) Package_declarative_item() (localctx IPackage_declarative_itemContext) {
	this := p
	_ = this

	localctx = NewPackage_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, vhdlParserRULE_package_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1821)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 189, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1802)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1803)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1804)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1805)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1806)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1807)
			p.Signal_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1808)
			p.Variable_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1809)
			p.File_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1810)
			p.Alias_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1811)
			p.Component_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1812)
			p.Attribute_declaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1813)
			p.Attribute_specification()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1814)
			p.Disconnection_specification()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1815)
			p.Use_clause()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1816)
			p.Group_template_declaration()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1817)
			p.Group_declaration()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1818)
			p.Nature_declaration()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1819)
			p.Subnature_declaration()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1820)
			p.Terminal_declaration()
		}

	}

	return localctx
}

// IPackage_declarative_partContext is an interface to support dynamic dispatch.
type IPackage_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_declarative_partContext differentiates from other interfaces.
	IsPackage_declarative_partContext()
}

type Package_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_declarative_partContext() *Package_declarative_partContext {
	var p = new(Package_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_declarative_part
	return p
}

func (*Package_declarative_partContext) IsPackage_declarative_partContext() {}

func NewPackage_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_declarative_partContext {
	var p = new(Package_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_declarative_part

	return p
}

func (s *Package_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_declarative_partContext) AllPackage_declarative_item() []IPackage_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_declarative_itemContext)(nil)).Elem())
	var tst = make([]IPackage_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_declarative_itemContext)
		}
	}

	return tst
}

func (s *Package_declarative_partContext) Package_declarative_item(i int) IPackage_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_declarative_itemContext)
}

func (s *Package_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_declarative_part(s)
	}
}

func (s *Package_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_declarative_part(s)
	}
}

func (p *vhdlParser) Package_declarative_part() (localctx IPackage_declarative_partContext) {
	this := p
	_ = this

	localctx = NewPackage_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, vhdlParserRULE_package_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1826)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1823)
			p.Package_declarative_item()
		}

		p.SetState(1828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParameter_specificationContext is an interface to support dynamic dispatch.
type IParameter_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_specificationContext differentiates from other interfaces.
	IsParameter_specificationContext()
}

type Parameter_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_specificationContext() *Parameter_specificationContext {
	var p = new(Parameter_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_parameter_specification
	return p
}

func (*Parameter_specificationContext) IsParameter_specificationContext() {}

func NewParameter_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_specificationContext {
	var p = new(Parameter_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_parameter_specification

	return p
}

func (s *Parameter_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_specificationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Parameter_specificationContext) IN() antlr.TerminalNode {
	return s.GetToken(vhdlParserIN, 0)
}

func (s *Parameter_specificationContext) Discrete_range() IDiscrete_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiscrete_rangeContext)
}

func (s *Parameter_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterParameter_specification(s)
	}
}

func (s *Parameter_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitParameter_specification(s)
	}
}

func (p *vhdlParser) Parameter_specification() (localctx IParameter_specificationContext) {
	this := p
	_ = this

	localctx = NewParameter_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, vhdlParserRULE_parameter_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1829)
		p.Identifier()
	}
	{
		p.SetState(1830)
		p.Match(vhdlParserIN)
	}
	{
		p.SetState(1831)
		p.Discrete_range()
	}

	return localctx
}

// IPhysical_literalContext is an interface to support dynamic dispatch.
type IPhysical_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPhysical_literalContext differentiates from other interfaces.
	IsPhysical_literalContext()
}

type Physical_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPhysical_literalContext() *Physical_literalContext {
	var p = new(Physical_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_physical_literal
	return p
}

func (*Physical_literalContext) IsPhysical_literalContext() {}

func NewPhysical_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Physical_literalContext {
	var p = new(Physical_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_physical_literal

	return p
}

func (s *Physical_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Physical_literalContext) Abstract_literal() IAbstract_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_literalContext)
}

func (s *Physical_literalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Physical_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Physical_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Physical_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPhysical_literal(s)
	}
}

func (s *Physical_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPhysical_literal(s)
	}
}

func (p *vhdlParser) Physical_literal() (localctx IPhysical_literalContext) {
	this := p
	_ = this

	localctx = NewPhysical_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, vhdlParserRULE_physical_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1833)
		p.Abstract_literal()
	}

	{
		p.SetState(1834)
		p.Identifier()
	}

	return localctx
}

// IPhysical_type_definitionContext is an interface to support dynamic dispatch.
type IPhysical_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPhysical_type_definitionContext differentiates from other interfaces.
	IsPhysical_type_definitionContext()
}

type Physical_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPhysical_type_definitionContext() *Physical_type_definitionContext {
	var p = new(Physical_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_physical_type_definition
	return p
}

func (*Physical_type_definitionContext) IsPhysical_type_definitionContext() {}

func NewPhysical_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Physical_type_definitionContext {
	var p = new(Physical_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_physical_type_definition

	return p
}

func (s *Physical_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Physical_type_definitionContext) Range_constraint() IRange_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_constraintContext)
}

func (s *Physical_type_definitionContext) AllUNITS() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserUNITS)
}

func (s *Physical_type_definitionContext) UNITS(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserUNITS, i)
}

func (s *Physical_type_definitionContext) Base_unit_declaration() IBase_unit_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_unit_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_unit_declarationContext)
}

func (s *Physical_type_definitionContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Physical_type_definitionContext) AllSecondary_unit_declaration() []ISecondary_unit_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISecondary_unit_declarationContext)(nil)).Elem())
	var tst = make([]ISecondary_unit_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISecondary_unit_declarationContext)
		}
	}

	return tst
}

func (s *Physical_type_definitionContext) Secondary_unit_declaration(i int) ISecondary_unit_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecondary_unit_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISecondary_unit_declarationContext)
}

func (s *Physical_type_definitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Physical_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Physical_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Physical_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPhysical_type_definition(s)
	}
}

func (s *Physical_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPhysical_type_definition(s)
	}
}

func (p *vhdlParser) Physical_type_definition() (localctx IPhysical_type_definitionContext) {
	this := p
	_ = this

	localctx = NewPhysical_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, vhdlParserRULE_physical_type_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1836)
		p.Range_constraint()
	}
	{
		p.SetState(1837)
		p.Match(vhdlParserUNITS)
	}
	{
		p.SetState(1838)
		p.Base_unit_declaration()
	}
	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1839)
			p.Secondary_unit_declaration()
		}

		p.SetState(1844)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1845)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(1846)
		p.Match(vhdlParserUNITS)
	}
	p.SetState(1848)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1847)
			p.Identifier()
		}

	}

	return localctx
}

// IPort_clauseContext is an interface to support dynamic dispatch.
type IPort_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_clauseContext differentiates from other interfaces.
	IsPort_clauseContext()
}

type Port_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_clauseContext() *Port_clauseContext {
	var p = new(Port_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_port_clause
	return p
}

func (*Port_clauseContext) IsPort_clauseContext() {}

func NewPort_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_clauseContext {
	var p = new(Port_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_port_clause

	return p
}

func (s *Port_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_clauseContext) PORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserPORT, 0)
}

func (s *Port_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Port_clauseContext) Port_list() IPort_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_listContext)
}

func (s *Port_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Port_clauseContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Port_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPort_clause(s)
	}
}

func (s *Port_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPort_clause(s)
	}
}

func (p *vhdlParser) Port_clause() (localctx IPort_clauseContext) {
	this := p
	_ = this

	localctx = NewPort_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, vhdlParserRULE_port_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1850)
		p.Match(vhdlParserPORT)
	}
	{
		p.SetState(1851)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1852)
		p.Port_list()
	}
	{
		p.SetState(1853)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(1854)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IPort_listContext is an interface to support dynamic dispatch.
type IPort_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_listContext differentiates from other interfaces.
	IsPort_listContext()
}

type Port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_listContext() *Port_listContext {
	var p = new(Port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_port_list
	return p
}

func (*Port_listContext) IsPort_listContext() {}

func NewPort_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_listContext {
	var p = new(Port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_port_list

	return p
}

func (s *Port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_listContext) Interface_port_list() IInterface_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_port_listContext)
}

func (s *Port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPort_list(s)
	}
}

func (s *Port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPort_list(s)
	}
}

func (p *vhdlParser) Port_list() (localctx IPort_listContext) {
	this := p
	_ = this

	localctx = NewPort_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, vhdlParserRULE_port_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1856)
		p.Interface_port_list()
	}

	return localctx
}

// IPort_map_aspectContext is an interface to support dynamic dispatch.
type IPort_map_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_map_aspectContext differentiates from other interfaces.
	IsPort_map_aspectContext()
}

type Port_map_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_map_aspectContext() *Port_map_aspectContext {
	var p = new(Port_map_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_port_map_aspect
	return p
}

func (*Port_map_aspectContext) IsPort_map_aspectContext() {}

func NewPort_map_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_map_aspectContext {
	var p = new(Port_map_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_port_map_aspect

	return p
}

func (s *Port_map_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_map_aspectContext) PORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserPORT, 0)
}

func (s *Port_map_aspectContext) MAP() antlr.TerminalNode {
	return s.GetToken(vhdlParserMAP, 0)
}

func (s *Port_map_aspectContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Port_map_aspectContext) Association_list() IAssociation_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociation_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssociation_listContext)
}

func (s *Port_map_aspectContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Port_map_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_map_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_map_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPort_map_aspect(s)
	}
}

func (s *Port_map_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPort_map_aspect(s)
	}
}

func (p *vhdlParser) Port_map_aspect() (localctx IPort_map_aspectContext) {
	this := p
	_ = this

	localctx = NewPort_map_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, vhdlParserRULE_port_map_aspect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1858)
		p.Match(vhdlParserPORT)
	}
	{
		p.SetState(1859)
		p.Match(vhdlParserMAP)
	}
	{
		p.SetState(1860)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1861)
		p.Association_list()
	}
	{
		p.SetState(1862)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryContext) Qualified_expression() IQualified_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualified_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualified_expressionContext)
}

func (s *PrimaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *PrimaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *PrimaryContext) Allocator() IAllocatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAllocatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAllocatorContext)
}

func (s *PrimaryContext) Aggregate() IAggregateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *PrimaryContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *vhdlParser) Primary() (localctx IPrimaryContext) {
	this := p
	_ = this

	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, vhdlParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1873)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1864)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1865)
			p.Qualified_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1866)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1867)
			p.Expression()
		}
		{
			p.SetState(1868)
			p.Match(vhdlParserRPAREN)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1870)
			p.Allocator()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1871)
			p.Aggregate()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1872)
			p.Name()
		}

	}

	return localctx
}

// IPrimary_unitContext is an interface to support dynamic dispatch.
type IPrimary_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_unitContext differentiates from other interfaces.
	IsPrimary_unitContext()
}

type Primary_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_unitContext() *Primary_unitContext {
	var p = new(Primary_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_primary_unit
	return p
}

func (*Primary_unitContext) IsPrimary_unitContext() {}

func NewPrimary_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_unitContext {
	var p = new(Primary_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_primary_unit

	return p
}

func (s *Primary_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_unitContext) Entity_declaration() IEntity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_declarationContext)
}

func (s *Primary_unitContext) Configuration_declaration() IConfiguration_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_declarationContext)
}

func (s *Primary_unitContext) Package_declaration() IPackage_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_declarationContext)
}

func (s *Primary_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPrimary_unit(s)
	}
}

func (s *Primary_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPrimary_unit(s)
	}
}

func (p *vhdlParser) Primary_unit() (localctx IPrimary_unitContext) {
	this := p
	_ = this

	localctx = NewPrimary_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, vhdlParserRULE_primary_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1878)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserENTITY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1875)
			p.Entity_declaration()
		}

	case vhdlParserCONFIGURATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1876)
			p.Configuration_declaration()
		}

	case vhdlParserPACKAGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1877)
			p.Package_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedural_declarative_itemContext is an interface to support dynamic dispatch.
type IProcedural_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_declarative_itemContext differentiates from other interfaces.
	IsProcedural_declarative_itemContext()
}

type Procedural_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_declarative_itemContext() *Procedural_declarative_itemContext {
	var p = new(Procedural_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedural_declarative_item
	return p
}

func (*Procedural_declarative_itemContext) IsProcedural_declarative_itemContext() {}

func NewProcedural_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_declarative_itemContext {
	var p = new(Procedural_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedural_declarative_item

	return p
}

func (s *Procedural_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Procedural_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Procedural_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Procedural_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Procedural_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Procedural_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Procedural_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Procedural_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Procedural_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Procedural_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Procedural_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Procedural_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Procedural_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedural_declarative_item(s)
	}
}

func (s *Procedural_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedural_declarative_item(s)
	}
}

func (p *vhdlParser) Procedural_declarative_item() (localctx IProcedural_declarative_itemContext) {
	this := p
	_ = this

	localctx = NewProcedural_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, vhdlParserRULE_procedural_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1892)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1880)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1881)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1882)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1883)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1884)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1885)
			p.Variable_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1886)
			p.Alias_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1887)
			p.Attribute_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1888)
			p.Attribute_specification()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1889)
			p.Use_clause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1890)
			p.Group_template_declaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1891)
			p.Group_declaration()
		}

	}

	return localctx
}

// IProcedural_declarative_partContext is an interface to support dynamic dispatch.
type IProcedural_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_declarative_partContext differentiates from other interfaces.
	IsProcedural_declarative_partContext()
}

type Procedural_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_declarative_partContext() *Procedural_declarative_partContext {
	var p = new(Procedural_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedural_declarative_part
	return p
}

func (*Procedural_declarative_partContext) IsProcedural_declarative_partContext() {}

func NewProcedural_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_declarative_partContext {
	var p = new(Procedural_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedural_declarative_part

	return p
}

func (s *Procedural_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_declarative_partContext) AllProcedural_declarative_item() []IProcedural_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedural_declarative_itemContext)(nil)).Elem())
	var tst = make([]IProcedural_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedural_declarative_itemContext)
		}
	}

	return tst
}

func (s *Procedural_declarative_partContext) Procedural_declarative_item(i int) IProcedural_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedural_declarative_itemContext)
}

func (s *Procedural_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedural_declarative_part(s)
	}
}

func (s *Procedural_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedural_declarative_part(s)
	}
}

func (p *vhdlParser) Procedural_declarative_part() (localctx IProcedural_declarative_partContext) {
	this := p
	_ = this

	localctx = NewProcedural_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, vhdlParserRULE_procedural_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserFUNCTION))) != 0) || _la == vhdlParserGROUP || _la == vhdlParserIMPURE || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSUBTYPE-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1894)
			p.Procedural_declarative_item()
		}

		p.SetState(1899)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedural_statement_partContext is an interface to support dynamic dispatch.
type IProcedural_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_statement_partContext differentiates from other interfaces.
	IsProcedural_statement_partContext()
}

type Procedural_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_statement_partContext() *Procedural_statement_partContext {
	var p = new(Procedural_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedural_statement_part
	return p
}

func (*Procedural_statement_partContext) IsProcedural_statement_partContext() {}

func NewProcedural_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_statement_partContext {
	var p = new(Procedural_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedural_statement_part

	return p
}

func (s *Procedural_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_statement_partContext) AllSequential_statement() []ISequential_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem())
	var tst = make([]ISequential_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequential_statementContext)
		}
	}

	return tst
}

func (s *Procedural_statement_partContext) Sequential_statement(i int) ISequential_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequential_statementContext)
}

func (s *Procedural_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedural_statement_part(s)
	}
}

func (s *Procedural_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedural_statement_part(s)
	}
}

func (p *vhdlParser) Procedural_statement_part() (localctx IProcedural_statement_partContext) {
	this := p
	_ = this

	localctx = NewProcedural_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, vhdlParserRULE_procedural_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE)|(1<<vhdlParserEXIT)|(1<<vhdlParserFOR))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserLOOP-36))|(1<<(vhdlParserNEXT-36))|(1<<(vhdlParserNULL_-36)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(vhdlParserREPORT-79))|(1<<(vhdlParserRETURN-79))|(1<<(vhdlParserWAIT-79))|(1<<(vhdlParserWHILE-79)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserSTRING_LITERAL-118))|(1<<(vhdlParserLPAREN-118)))) != 0) {
		{
			p.SetState(1900)
			p.Sequential_statement()
		}

		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedure_callContext is an interface to support dynamic dispatch.
type IProcedure_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedure_callContext differentiates from other interfaces.
	IsProcedure_callContext()
}

type Procedure_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_callContext() *Procedure_callContext {
	var p = new(Procedure_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedure_call
	return p
}

func (*Procedure_callContext) IsProcedure_callContext() {}

func NewProcedure_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_callContext {
	var p = new(Procedure_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedure_call

	return p
}

func (s *Procedure_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_callContext) Selected_name() ISelected_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_nameContext)
}

func (s *Procedure_callContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Procedure_callContext) Actual_parameter_part() IActual_parameter_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActual_parameter_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActual_parameter_partContext)
}

func (s *Procedure_callContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Procedure_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedure_call(s)
	}
}

func (s *Procedure_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedure_call(s)
	}
}

func (p *vhdlParser) Procedure_call() (localctx IProcedure_callContext) {
	this := p
	_ = this

	localctx = NewProcedure_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, vhdlParserRULE_procedure_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1906)
		p.Selected_name()
	}
	p.SetState(1911)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(1907)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1908)
			p.Actual_parameter_part()
		}
		{
			p.SetState(1909)
			p.Match(vhdlParserRPAREN)
		}

	}

	return localctx
}

// IProcedure_call_statementContext is an interface to support dynamic dispatch.
type IProcedure_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedure_call_statementContext differentiates from other interfaces.
	IsProcedure_call_statementContext()
}

type Procedure_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_call_statementContext() *Procedure_call_statementContext {
	var p = new(Procedure_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedure_call_statement
	return p
}

func (*Procedure_call_statementContext) IsProcedure_call_statementContext() {}

func NewProcedure_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_call_statementContext {
	var p = new(Procedure_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedure_call_statement

	return p
}

func (s *Procedure_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_call_statementContext) Procedure_call() IProcedure_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_callContext)
}

func (s *Procedure_call_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Procedure_call_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Procedure_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedure_call_statement(s)
	}
}

func (s *Procedure_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedure_call_statement(s)
	}
}

func (p *vhdlParser) Procedure_call_statement() (localctx IProcedure_call_statementContext) {
	this := p
	_ = this

	localctx = NewProcedure_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, vhdlParserRULE_procedure_call_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1914)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1913)
			p.Label_colon()
		}

	}
	{
		p.SetState(1916)
		p.Procedure_call()
	}
	{
		p.SetState(1917)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IProcess_declarative_itemContext is an interface to support dynamic dispatch.
type IProcess_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcess_declarative_itemContext differentiates from other interfaces.
	IsProcess_declarative_itemContext()
}

type Process_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_declarative_itemContext() *Process_declarative_itemContext {
	var p = new(Process_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_process_declarative_item
	return p
}

func (*Process_declarative_itemContext) IsProcess_declarative_itemContext() {}

func NewProcess_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_declarative_itemContext {
	var p = new(Process_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_process_declarative_item

	return p
}

func (s *Process_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Process_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Process_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Process_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Process_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Process_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Process_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Process_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Process_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Process_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Process_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Process_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Process_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Process_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Process_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcess_declarative_item(s)
	}
}

func (s *Process_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcess_declarative_item(s)
	}
}

func (p *vhdlParser) Process_declarative_item() (localctx IProcess_declarative_itemContext) {
	this := p
	_ = this

	localctx = NewProcess_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, vhdlParserRULE_process_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1932)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1919)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1920)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1921)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1922)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1923)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1924)
			p.Variable_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1925)
			p.File_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1926)
			p.Alias_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1927)
			p.Attribute_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1928)
			p.Attribute_specification()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1929)
			p.Use_clause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1930)
			p.Group_template_declaration()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1931)
			p.Group_declaration()
		}

	}

	return localctx
}

// IProcess_declarative_partContext is an interface to support dynamic dispatch.
type IProcess_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcess_declarative_partContext differentiates from other interfaces.
	IsProcess_declarative_partContext()
}

type Process_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_declarative_partContext() *Process_declarative_partContext {
	var p = new(Process_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_process_declarative_part
	return p
}

func (*Process_declarative_partContext) IsProcess_declarative_partContext() {}

func NewProcess_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_declarative_partContext {
	var p = new(Process_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_process_declarative_part

	return p
}

func (s *Process_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_declarative_partContext) AllProcess_declarative_item() []IProcess_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcess_declarative_itemContext)(nil)).Elem())
	var tst = make([]IProcess_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcess_declarative_itemContext)
		}
	}

	return tst
}

func (s *Process_declarative_partContext) Process_declarative_item(i int) IProcess_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcess_declarative_itemContext)
}

func (s *Process_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Process_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcess_declarative_part(s)
	}
}

func (s *Process_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcess_declarative_part(s)
	}
}

func (p *vhdlParser) Process_declarative_part() (localctx IProcess_declarative_partContext) {
	this := p
	_ = this

	localctx = NewProcess_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, vhdlParserRULE_process_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1937)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || _la == vhdlParserGROUP || _la == vhdlParserIMPURE || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSUBTYPE-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1934)
			p.Process_declarative_item()
		}

		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcess_statementContext is an interface to support dynamic dispatch.
type IProcess_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcess_statementContext differentiates from other interfaces.
	IsProcess_statementContext()
}

type Process_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_statementContext() *Process_statementContext {
	var p = new(Process_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_process_statement
	return p
}

func (*Process_statementContext) IsProcess_statementContext() {}

func NewProcess_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_statementContext {
	var p = new(Process_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_process_statement

	return p
}

func (s *Process_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_statementContext) AllPROCESS() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPROCESS)
}

func (s *Process_statementContext) PROCESS(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCESS, i)
}

func (s *Process_statementContext) Process_declarative_part() IProcess_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcess_declarative_partContext)
}

func (s *Process_statementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Process_statementContext) Process_statement_part() IProcess_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcess_statement_partContext)
}

func (s *Process_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Process_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Process_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Process_statementContext) AllPOSTPONED() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPOSTPONED)
}

func (s *Process_statementContext) POSTPONED(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, i)
}

func (s *Process_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Process_statementContext) Sensitivity_list() ISensitivity_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISensitivity_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISensitivity_listContext)
}

func (s *Process_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Process_statementContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Process_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Process_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Process_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcess_statement(s)
	}
}

func (s *Process_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcess_statement(s)
	}
}

func (p *vhdlParser) Process_statement() (localctx IProcess_statementContext) {
	this := p
	_ = this

	localctx = NewProcess_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, vhdlParserRULE_process_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1941)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1940)
			p.Label_colon()
		}

	}
	p.SetState(1944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(1943)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	{
		p.SetState(1946)
		p.Match(vhdlParserPROCESS)
	}
	p.SetState(1951)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(1947)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1948)
			p.Sensitivity_list()
		}
		{
			p.SetState(1949)
			p.Match(vhdlParserRPAREN)
		}

	}
	p.SetState(1954)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(1953)
			p.Match(vhdlParserIS)
		}

	}
	{
		p.SetState(1956)
		p.Process_declarative_part()
	}
	{
		p.SetState(1957)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(1958)
		p.Process_statement_part()
	}
	{
		p.SetState(1959)
		p.Match(vhdlParserEND)
	}
	p.SetState(1961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(1960)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	{
		p.SetState(1963)
		p.Match(vhdlParserPROCESS)
	}
	p.SetState(1965)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1964)
			p.Identifier()
		}

	}
	{
		p.SetState(1967)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IProcess_statement_partContext is an interface to support dynamic dispatch.
type IProcess_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcess_statement_partContext differentiates from other interfaces.
	IsProcess_statement_partContext()
}

type Process_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_statement_partContext() *Process_statement_partContext {
	var p = new(Process_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_process_statement_part
	return p
}

func (*Process_statement_partContext) IsProcess_statement_partContext() {}

func NewProcess_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_statement_partContext {
	var p = new(Process_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_process_statement_part

	return p
}

func (s *Process_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_statement_partContext) AllSequential_statement() []ISequential_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem())
	var tst = make([]ISequential_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequential_statementContext)
		}
	}

	return tst
}

func (s *Process_statement_partContext) Sequential_statement(i int) ISequential_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequential_statementContext)
}

func (s *Process_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Process_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcess_statement_part(s)
	}
}

func (s *Process_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcess_statement_part(s)
	}
}

func (p *vhdlParser) Process_statement_part() (localctx IProcess_statement_partContext) {
	this := p
	_ = this

	localctx = NewProcess_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, vhdlParserRULE_process_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1972)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE)|(1<<vhdlParserEXIT)|(1<<vhdlParserFOR))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserLOOP-36))|(1<<(vhdlParserNEXT-36))|(1<<(vhdlParserNULL_-36)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(vhdlParserREPORT-79))|(1<<(vhdlParserRETURN-79))|(1<<(vhdlParserWAIT-79))|(1<<(vhdlParserWHILE-79)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserSTRING_LITERAL-118))|(1<<(vhdlParserLPAREN-118)))) != 0) {
		{
			p.SetState(1969)
			p.Sequential_statement()
		}

		p.SetState(1974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IQualified_expressionContext is an interface to support dynamic dispatch.
type IQualified_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualified_expressionContext differentiates from other interfaces.
	IsQualified_expressionContext()
}

type Qualified_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualified_expressionContext() *Qualified_expressionContext {
	var p = new(Qualified_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_qualified_expression
	return p
}

func (*Qualified_expressionContext) IsQualified_expressionContext() {}

func NewQualified_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualified_expressionContext {
	var p = new(Qualified_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_qualified_expression

	return p
}

func (s *Qualified_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualified_expressionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Qualified_expressionContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(vhdlParserAPOSTROPHE, 0)
}

func (s *Qualified_expressionContext) Aggregate() IAggregateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *Qualified_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Qualified_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Qualified_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Qualified_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualified_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qualified_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterQualified_expression(s)
	}
}

func (s *Qualified_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitQualified_expression(s)
	}
}

func (p *vhdlParser) Qualified_expression() (localctx IQualified_expressionContext) {
	this := p
	_ = this

	localctx = NewQualified_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, vhdlParserRULE_qualified_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1975)
		p.Subtype_indication()
	}
	{
		p.SetState(1976)
		p.Match(vhdlParserAPOSTROPHE)
	}
	p.SetState(1982)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1977)
			p.Aggregate()
		}

	case 2:
		{
			p.SetState(1978)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1979)
			p.Expression()
		}
		{
			p.SetState(1980)
			p.Match(vhdlParserRPAREN)
		}

	}

	return localctx
}

// IQuantity_declarationContext is an interface to support dynamic dispatch.
type IQuantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantity_declarationContext differentiates from other interfaces.
	IsQuantity_declarationContext()
}

type Quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantity_declarationContext() *Quantity_declarationContext {
	var p = new(Quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_quantity_declaration
	return p
}

func (*Quantity_declarationContext) IsQuantity_declarationContext() {}

func NewQuantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quantity_declarationContext {
	var p = new(Quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_quantity_declaration

	return p
}

func (s *Quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Quantity_declarationContext) Free_quantity_declaration() IFree_quantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFree_quantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFree_quantity_declarationContext)
}

func (s *Quantity_declarationContext) Branch_quantity_declaration() IBranch_quantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBranch_quantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBranch_quantity_declarationContext)
}

func (s *Quantity_declarationContext) Source_quantity_declaration() ISource_quantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISource_quantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISource_quantity_declarationContext)
}

func (s *Quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterQuantity_declaration(s)
	}
}

func (s *Quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitQuantity_declaration(s)
	}
}

func (p *vhdlParser) Quantity_declaration() (localctx IQuantity_declarationContext) {
	this := p
	_ = this

	localctx = NewQuantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, vhdlParserRULE_quantity_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1987)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1984)
			p.Free_quantity_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1985)
			p.Branch_quantity_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1986)
			p.Source_quantity_declaration()
		}

	}

	return localctx
}

// IQuantity_listContext is an interface to support dynamic dispatch.
type IQuantity_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantity_listContext differentiates from other interfaces.
	IsQuantity_listContext()
}

type Quantity_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantity_listContext() *Quantity_listContext {
	var p = new(Quantity_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_quantity_list
	return p
}

func (*Quantity_listContext) IsQuantity_listContext() {}

func NewQuantity_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quantity_listContext {
	var p = new(Quantity_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_quantity_list

	return p
}

func (s *Quantity_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Quantity_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Quantity_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Quantity_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Quantity_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Quantity_listContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *Quantity_listContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *Quantity_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quantity_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quantity_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterQuantity_list(s)
	}
}

func (s *Quantity_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitQuantity_list(s)
	}
}

func (p *vhdlParser) Quantity_list() (localctx IQuantity_listContext) {
	this := p
	_ = this

	localctx = NewQuantity_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, vhdlParserRULE_quantity_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1999)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1989)
			p.Name()
		}
		p.SetState(1994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(1990)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(1991)
				p.Name()
			}

			p.SetState(1996)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserOTHERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1997)
			p.Match(vhdlParserOTHERS)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1998)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuantity_specificationContext is an interface to support dynamic dispatch.
type IQuantity_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantity_specificationContext differentiates from other interfaces.
	IsQuantity_specificationContext()
}

type Quantity_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantity_specificationContext() *Quantity_specificationContext {
	var p = new(Quantity_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_quantity_specification
	return p
}

func (*Quantity_specificationContext) IsQuantity_specificationContext() {}

func NewQuantity_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quantity_specificationContext {
	var p = new(Quantity_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_quantity_specification

	return p
}

func (s *Quantity_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Quantity_specificationContext) Quantity_list() IQuantity_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_listContext)
}

func (s *Quantity_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Quantity_specificationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Quantity_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quantity_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quantity_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterQuantity_specification(s)
	}
}

func (s *Quantity_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitQuantity_specification(s)
	}
}

func (p *vhdlParser) Quantity_specification() (localctx IQuantity_specificationContext) {
	this := p
	_ = this

	localctx = NewQuantity_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, vhdlParserRULE_quantity_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2001)
		p.Quantity_list()
	}
	{
		p.SetState(2002)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2003)
		p.Name()
	}

	return localctx
}

// IRange_declContext is an interface to support dynamic dispatch.
type IRange_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_declContext differentiates from other interfaces.
	IsRange_declContext()
}

type Range_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_declContext() *Range_declContext {
	var p = new(Range_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_range_decl
	return p
}

func (*Range_declContext) IsRange_declContext() {}

func NewRange_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_declContext {
	var p = new(Range_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_range_decl

	return p
}

func (s *Range_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_declContext) Explicit_range() IExplicit_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicit_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicit_rangeContext)
}

func (s *Range_declContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Range_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRange_decl(s)
	}
}

func (s *Range_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRange_decl(s)
	}
}

func (p *vhdlParser) Range_decl() (localctx IRange_declContext) {
	this := p
	_ = this

	localctx = NewRange_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, vhdlParserRULE_range_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2007)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2005)
			p.Explicit_range()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2006)
			p.Name()
		}

	}

	return localctx
}

// IExplicit_rangeContext is an interface to support dynamic dispatch.
type IExplicit_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicit_rangeContext differentiates from other interfaces.
	IsExplicit_rangeContext()
}

type Explicit_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicit_rangeContext() *Explicit_rangeContext {
	var p = new(Explicit_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_explicit_range
	return p
}

func (*Explicit_rangeContext) IsExplicit_rangeContext() {}

func NewExplicit_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Explicit_rangeContext {
	var p = new(Explicit_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_explicit_range

	return p
}

func (s *Explicit_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Explicit_rangeContext) AllSimple_expression() []ISimple_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_expressionContext)
		}
	}

	return tst
}

func (s *Explicit_rangeContext) Simple_expression(i int) ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *Explicit_rangeContext) Direction() IDirectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirectionContext)
}

func (s *Explicit_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Explicit_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Explicit_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterExplicit_range(s)
	}
}

func (s *Explicit_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitExplicit_range(s)
	}
}

func (p *vhdlParser) Explicit_range() (localctx IExplicit_rangeContext) {
	this := p
	_ = this

	localctx = NewExplicit_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, vhdlParserRULE_explicit_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2009)
		p.Simple_expression()
	}
	p.SetState(2013)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2010)
			p.Direction()
		}
		{
			p.SetState(2011)
			p.Simple_expression()
		}

	}

	return localctx
}

// IRange_constraintContext is an interface to support dynamic dispatch.
type IRange_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_constraintContext differentiates from other interfaces.
	IsRange_constraintContext()
}

type Range_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_constraintContext() *Range_constraintContext {
	var p = new(Range_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_range_constraint
	return p
}

func (*Range_constraintContext) IsRange_constraintContext() {}

func NewRange_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_constraintContext {
	var p = new(Range_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_range_constraint

	return p
}

func (s *Range_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_constraintContext) RANGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserRANGE, 0)
}

func (s *Range_constraintContext) Range_decl() IRange_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_declContext)
}

func (s *Range_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRange_constraint(s)
	}
}

func (s *Range_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRange_constraint(s)
	}
}

func (p *vhdlParser) Range_constraint() (localctx IRange_constraintContext) {
	this := p
	_ = this

	localctx = NewRange_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, vhdlParserRULE_range_constraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2015)
		p.Match(vhdlParserRANGE)
	}
	{
		p.SetState(2016)
		p.Range_decl()
	}

	return localctx
}

// IRecord_nature_definitionContext is an interface to support dynamic dispatch.
type IRecord_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecord_nature_definitionContext differentiates from other interfaces.
	IsRecord_nature_definitionContext()
}

type Record_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecord_nature_definitionContext() *Record_nature_definitionContext {
	var p = new(Record_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_record_nature_definition
	return p
}

func (*Record_nature_definitionContext) IsRecord_nature_definitionContext() {}

func NewRecord_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Record_nature_definitionContext {
	var p = new(Record_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_record_nature_definition

	return p
}

func (s *Record_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Record_nature_definitionContext) AllRECORD() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserRECORD)
}

func (s *Record_nature_definitionContext) RECORD(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserRECORD, i)
}

func (s *Record_nature_definitionContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Record_nature_definitionContext) AllNature_element_declaration() []INature_element_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INature_element_declarationContext)(nil)).Elem())
	var tst = make([]INature_element_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INature_element_declarationContext)
		}
	}

	return tst
}

func (s *Record_nature_definitionContext) Nature_element_declaration(i int) INature_element_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_element_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INature_element_declarationContext)
}

func (s *Record_nature_definitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Record_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Record_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Record_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRecord_nature_definition(s)
	}
}

func (s *Record_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRecord_nature_definition(s)
	}
}

func (p *vhdlParser) Record_nature_definition() (localctx IRecord_nature_definitionContext) {
	this := p
	_ = this

	localctx = NewRecord_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, vhdlParserRULE_record_nature_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2018)
		p.Match(vhdlParserRECORD)
	}
	p.SetState(2020)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2019)
			p.Nature_element_declaration()
		}

		p.SetState(2022)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2024)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2025)
		p.Match(vhdlParserRECORD)
	}
	p.SetState(2027)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2026)
			p.Identifier()
		}

	}

	return localctx
}

// IRecord_type_definitionContext is an interface to support dynamic dispatch.
type IRecord_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecord_type_definitionContext differentiates from other interfaces.
	IsRecord_type_definitionContext()
}

type Record_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecord_type_definitionContext() *Record_type_definitionContext {
	var p = new(Record_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_record_type_definition
	return p
}

func (*Record_type_definitionContext) IsRecord_type_definitionContext() {}

func NewRecord_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Record_type_definitionContext {
	var p = new(Record_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_record_type_definition

	return p
}

func (s *Record_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Record_type_definitionContext) AllRECORD() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserRECORD)
}

func (s *Record_type_definitionContext) RECORD(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserRECORD, i)
}

func (s *Record_type_definitionContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Record_type_definitionContext) AllElement_declaration() []IElement_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElement_declarationContext)(nil)).Elem())
	var tst = make([]IElement_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElement_declarationContext)
		}
	}

	return tst
}

func (s *Record_type_definitionContext) Element_declaration(i int) IElement_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElement_declarationContext)
}

func (s *Record_type_definitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Record_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Record_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Record_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRecord_type_definition(s)
	}
}

func (s *Record_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRecord_type_definition(s)
	}
}

func (p *vhdlParser) Record_type_definition() (localctx IRecord_type_definitionContext) {
	this := p
	_ = this

	localctx = NewRecord_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, vhdlParserRULE_record_type_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2029)
		p.Match(vhdlParserRECORD)
	}
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2030)
			p.Element_declaration()
		}

		p.SetState(2033)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2035)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2036)
		p.Match(vhdlParserRECORD)
	}
	p.SetState(2038)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2037)
			p.Identifier()
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) AllShift_expression() []IShift_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem())
	var tst = make([]IShift_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_expressionContext)
		}
	}

	return tst
}

func (s *RelationContext) Shift_expression(i int) IShift_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_expressionContext)
}

func (s *RelationContext) Relational_operator() IRelational_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelational_operatorContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (p *vhdlParser) Relation() (localctx IRelationContext) {
	this := p
	_ = this

	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, vhdlParserRULE_relation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2040)
		p.Shift_expression()
	}
	p.SetState(2044)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2041)
			p.Relational_operator()
		}
		{
			p.SetState(2042)
			p.Shift_expression()
		}

	}

	return localctx
}

// IRelational_operatorContext is an interface to support dynamic dispatch.
type IRelational_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelational_operatorContext differentiates from other interfaces.
	IsRelational_operatorContext()
}

type Relational_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelational_operatorContext() *Relational_operatorContext {
	var p = new(Relational_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_relational_operator
	return p
}

func (*Relational_operatorContext) IsRelational_operatorContext() {}

func NewRelational_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relational_operatorContext {
	var p = new(Relational_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_relational_operator

	return p
}

func (s *Relational_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Relational_operatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(vhdlParserEQ, 0)
}

func (s *Relational_operatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(vhdlParserNEQ, 0)
}

func (s *Relational_operatorContext) LOWERTHAN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLOWERTHAN, 0)
}

func (s *Relational_operatorContext) LE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLE, 0)
}

func (s *Relational_operatorContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(vhdlParserGREATERTHAN, 0)
}

func (s *Relational_operatorContext) GE() antlr.TerminalNode {
	return s.GetToken(vhdlParserGE, 0)
}

func (s *Relational_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relational_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relational_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRelational_operator(s)
	}
}

func (s *Relational_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRelational_operator(s)
	}
}

func (p *vhdlParser) Relational_operator() (localctx IRelational_operatorContext) {
	this := p
	_ = this

	localctx = NewRelational_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, vhdlParserRULE_relational_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2046)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(vhdlParserLE-131))|(1<<(vhdlParserGE-131))|(1<<(vhdlParserNEQ-131))|(1<<(vhdlParserLOWERTHAN-131))|(1<<(vhdlParserGREATERTHAN-131))|(1<<(vhdlParserEQ-131)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReport_statementContext is an interface to support dynamic dispatch.
type IReport_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReport_statementContext differentiates from other interfaces.
	IsReport_statementContext()
}

type Report_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReport_statementContext() *Report_statementContext {
	var p = new(Report_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_report_statement
	return p
}

func (*Report_statementContext) IsReport_statementContext() {}

func NewReport_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Report_statementContext {
	var p = new(Report_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_report_statement

	return p
}

func (s *Report_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Report_statementContext) REPORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserREPORT, 0)
}

func (s *Report_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Report_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Report_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Report_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Report_statementContext) SEVERITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEVERITY, 0)
}

func (s *Report_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Report_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Report_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterReport_statement(s)
	}
}

func (s *Report_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitReport_statement(s)
	}
}

func (p *vhdlParser) Report_statement() (localctx IReport_statementContext) {
	this := p
	_ = this

	localctx = NewReport_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, vhdlParserRULE_report_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2048)
			p.Label_colon()
		}

	}
	{
		p.SetState(2051)
		p.Match(vhdlParserREPORT)
	}
	{
		p.SetState(2052)
		p.Expression()
	}
	p.SetState(2055)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserSEVERITY {
		{
			p.SetState(2053)
			p.Match(vhdlParserSEVERITY)
		}
		{
			p.SetState(2054)
			p.Expression()
		}

	}
	{
		p.SetState(2057)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IReturn_statementContext is an interface to support dynamic dispatch.
type IReturn_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_statementContext differentiates from other interfaces.
	IsReturn_statementContext()
}

type Return_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_statementContext() *Return_statementContext {
	var p = new(Return_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_return_statement
	return p
}

func (*Return_statementContext) IsReturn_statementContext() {}

func NewReturn_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_statementContext {
	var p = new(Return_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_return_statement

	return p
}

func (s *Return_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_statementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRETURN, 0)
}

func (s *Return_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Return_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Return_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Return_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterReturn_statement(s)
	}
}

func (s *Return_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitReturn_statement(s)
	}
}

func (p *vhdlParser) Return_statement() (localctx IReturn_statementContext) {
	this := p
	_ = this

	localctx = NewReturn_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, vhdlParserRULE_return_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2060)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2059)
			p.Label_colon()
		}

	}
	{
		p.SetState(2062)
		p.Match(vhdlParserRETURN)
	}
	p.SetState(2064)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserABS || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(vhdlParserNEW-52))|(1<<(vhdlParserNOT-52))|(1<<(vhdlParserNULL_-52)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(vhdlParserBASE_LITERAL-112))|(1<<(vhdlParserBIT_STRING_LITERAL-112))|(1<<(vhdlParserREAL_LITERAL-112))|(1<<(vhdlParserBASIC_IDENTIFIER-112))|(1<<(vhdlParserEXTENDED_IDENTIFIER-112))|(1<<(vhdlParserCHARACTER_LITERAL-112))|(1<<(vhdlParserSTRING_LITERAL-112))|(1<<(vhdlParserLPAREN-112)))) != 0) || (((_la-148)&-(0x1f+1)) == 0 && ((1<<uint((_la-148)))&((1<<(vhdlParserPLUS-148))|(1<<(vhdlParserMINUS-148))|(1<<(vhdlParserINTEGER-148)))) != 0) {
		{
			p.SetState(2063)
			p.Expression()
		}

	}
	{
		p.SetState(2066)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IScalar_nature_definitionContext is an interface to support dynamic dispatch.
type IScalar_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalar_nature_definitionContext differentiates from other interfaces.
	IsScalar_nature_definitionContext()
}

type Scalar_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalar_nature_definitionContext() *Scalar_nature_definitionContext {
	var p = new(Scalar_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_scalar_nature_definition
	return p
}

func (*Scalar_nature_definitionContext) IsScalar_nature_definitionContext() {}

func NewScalar_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scalar_nature_definitionContext {
	var p = new(Scalar_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_scalar_nature_definition

	return p
}

func (s *Scalar_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Scalar_nature_definitionContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Scalar_nature_definitionContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Scalar_nature_definitionContext) ACROSS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACROSS, 0)
}

func (s *Scalar_nature_definitionContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(vhdlParserTHROUGH, 0)
}

func (s *Scalar_nature_definitionContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserREFERENCE, 0)
}

func (s *Scalar_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scalar_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scalar_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterScalar_nature_definition(s)
	}
}

func (s *Scalar_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitScalar_nature_definition(s)
	}
}

func (p *vhdlParser) Scalar_nature_definition() (localctx IScalar_nature_definitionContext) {
	this := p
	_ = this

	localctx = NewScalar_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, vhdlParserRULE_scalar_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2068)
		p.Name()
	}
	{
		p.SetState(2069)
		p.Match(vhdlParserACROSS)
	}
	{
		p.SetState(2070)
		p.Name()
	}
	{
		p.SetState(2071)
		p.Match(vhdlParserTHROUGH)
	}
	{
		p.SetState(2072)
		p.Name()
	}
	{
		p.SetState(2073)
		p.Match(vhdlParserREFERENCE)
	}

	return localctx
}

// IScalar_type_definitionContext is an interface to support dynamic dispatch.
type IScalar_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalar_type_definitionContext differentiates from other interfaces.
	IsScalar_type_definitionContext()
}

type Scalar_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalar_type_definitionContext() *Scalar_type_definitionContext {
	var p = new(Scalar_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_scalar_type_definition
	return p
}

func (*Scalar_type_definitionContext) IsScalar_type_definitionContext() {}

func NewScalar_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scalar_type_definitionContext {
	var p = new(Scalar_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_scalar_type_definition

	return p
}

func (s *Scalar_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Scalar_type_definitionContext) Physical_type_definition() IPhysical_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPhysical_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPhysical_type_definitionContext)
}

func (s *Scalar_type_definitionContext) Enumeration_type_definition() IEnumeration_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeration_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeration_type_definitionContext)
}

func (s *Scalar_type_definitionContext) Range_constraint() IRange_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_constraintContext)
}

func (s *Scalar_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scalar_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scalar_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterScalar_type_definition(s)
	}
}

func (s *Scalar_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitScalar_type_definition(s)
	}
}

func (p *vhdlParser) Scalar_type_definition() (localctx IScalar_type_definitionContext) {
	this := p
	_ = this

	localctx = NewScalar_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, vhdlParserRULE_scalar_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2078)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2075)
			p.Physical_type_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2076)
			p.Enumeration_type_definition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2077)
			p.Range_constraint()
		}

	}

	return localctx
}

// ISecondary_unitContext is an interface to support dynamic dispatch.
type ISecondary_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecondary_unitContext differentiates from other interfaces.
	IsSecondary_unitContext()
}

type Secondary_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondary_unitContext() *Secondary_unitContext {
	var p = new(Secondary_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_secondary_unit
	return p
}

func (*Secondary_unitContext) IsSecondary_unitContext() {}

func NewSecondary_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Secondary_unitContext {
	var p = new(Secondary_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_secondary_unit

	return p
}

func (s *Secondary_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Secondary_unitContext) Architecture_body() IArchitecture_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_bodyContext)
}

func (s *Secondary_unitContext) Package_body() IPackage_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_bodyContext)
}

func (s *Secondary_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Secondary_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Secondary_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSecondary_unit(s)
	}
}

func (s *Secondary_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSecondary_unit(s)
	}
}

func (p *vhdlParser) Secondary_unit() (localctx ISecondary_unitContext) {
	this := p
	_ = this

	localctx = NewSecondary_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, vhdlParserRULE_secondary_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2082)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserARCHITECTURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2080)
			p.Architecture_body()
		}

	case vhdlParserPACKAGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2081)
			p.Package_body()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISecondary_unit_declarationContext is an interface to support dynamic dispatch.
type ISecondary_unit_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecondary_unit_declarationContext differentiates from other interfaces.
	IsSecondary_unit_declarationContext()
}

type Secondary_unit_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondary_unit_declarationContext() *Secondary_unit_declarationContext {
	var p = new(Secondary_unit_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_secondary_unit_declaration
	return p
}

func (*Secondary_unit_declarationContext) IsSecondary_unit_declarationContext() {}

func NewSecondary_unit_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Secondary_unit_declarationContext {
	var p = new(Secondary_unit_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_secondary_unit_declaration

	return p
}

func (s *Secondary_unit_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Secondary_unit_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Secondary_unit_declarationContext) EQ() antlr.TerminalNode {
	return s.GetToken(vhdlParserEQ, 0)
}

func (s *Secondary_unit_declarationContext) Physical_literal() IPhysical_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPhysical_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPhysical_literalContext)
}

func (s *Secondary_unit_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Secondary_unit_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Secondary_unit_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Secondary_unit_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSecondary_unit_declaration(s)
	}
}

func (s *Secondary_unit_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSecondary_unit_declaration(s)
	}
}

func (p *vhdlParser) Secondary_unit_declaration() (localctx ISecondary_unit_declarationContext) {
	this := p
	_ = this

	localctx = NewSecondary_unit_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, vhdlParserRULE_secondary_unit_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2084)
		p.Identifier()
	}
	{
		p.SetState(2085)
		p.Match(vhdlParserEQ)
	}
	{
		p.SetState(2086)
		p.Physical_literal()
	}
	{
		p.SetState(2087)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISelected_signal_assignmentContext is an interface to support dynamic dispatch.
type ISelected_signal_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelected_signal_assignmentContext differentiates from other interfaces.
	IsSelected_signal_assignmentContext()
}

type Selected_signal_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelected_signal_assignmentContext() *Selected_signal_assignmentContext {
	var p = new(Selected_signal_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_selected_signal_assignment
	return p
}

func (*Selected_signal_assignmentContext) IsSelected_signal_assignmentContext() {}

func NewSelected_signal_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selected_signal_assignmentContext {
	var p = new(Selected_signal_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_selected_signal_assignment

	return p
}

func (s *Selected_signal_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Selected_signal_assignmentContext) WITH() antlr.TerminalNode {
	return s.GetToken(vhdlParserWITH, 0)
}

func (s *Selected_signal_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Selected_signal_assignmentContext) SELECT() antlr.TerminalNode {
	return s.GetToken(vhdlParserSELECT, 0)
}

func (s *Selected_signal_assignmentContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Selected_signal_assignmentContext) LE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLE, 0)
}

func (s *Selected_signal_assignmentContext) Opts() IOptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptsContext)
}

func (s *Selected_signal_assignmentContext) Selected_waveforms() ISelected_waveformsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_waveformsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_waveformsContext)
}

func (s *Selected_signal_assignmentContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Selected_signal_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selected_signal_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selected_signal_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSelected_signal_assignment(s)
	}
}

func (s *Selected_signal_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSelected_signal_assignment(s)
	}
}

func (p *vhdlParser) Selected_signal_assignment() (localctx ISelected_signal_assignmentContext) {
	this := p
	_ = this

	localctx = NewSelected_signal_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, vhdlParserRULE_selected_signal_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2089)
		p.Match(vhdlParserWITH)
	}
	{
		p.SetState(2090)
		p.Expression()
	}
	{
		p.SetState(2091)
		p.Match(vhdlParserSELECT)
	}
	{
		p.SetState(2092)
		p.Target()
	}
	{
		p.SetState(2093)
		p.Match(vhdlParserLE)
	}
	{
		p.SetState(2094)
		p.Opts()
	}
	{
		p.SetState(2095)
		p.Selected_waveforms()
	}
	{
		p.SetState(2096)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISelected_waveformsContext is an interface to support dynamic dispatch.
type ISelected_waveformsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelected_waveformsContext differentiates from other interfaces.
	IsSelected_waveformsContext()
}

type Selected_waveformsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelected_waveformsContext() *Selected_waveformsContext {
	var p = new(Selected_waveformsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_selected_waveforms
	return p
}

func (*Selected_waveformsContext) IsSelected_waveformsContext() {}

func NewSelected_waveformsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selected_waveformsContext {
	var p = new(Selected_waveformsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_selected_waveforms

	return p
}

func (s *Selected_waveformsContext) GetParser() antlr.Parser { return s.parser }

func (s *Selected_waveformsContext) AllWaveform() []IWaveformContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWaveformContext)(nil)).Elem())
	var tst = make([]IWaveformContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWaveformContext)
		}
	}

	return tst
}

func (s *Selected_waveformsContext) Waveform(i int) IWaveformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaveformContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWaveformContext)
}

func (s *Selected_waveformsContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserWHEN)
}

func (s *Selected_waveformsContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, i)
}

func (s *Selected_waveformsContext) AllChoices() []IChoicesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChoicesContext)(nil)).Elem())
	var tst = make([]IChoicesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChoicesContext)
		}
	}

	return tst
}

func (s *Selected_waveformsContext) Choices(i int) IChoicesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoicesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChoicesContext)
}

func (s *Selected_waveformsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Selected_waveformsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Selected_waveformsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selected_waveformsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selected_waveformsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSelected_waveforms(s)
	}
}

func (s *Selected_waveformsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSelected_waveforms(s)
	}
}

func (p *vhdlParser) Selected_waveforms() (localctx ISelected_waveformsContext) {
	this := p
	_ = this

	localctx = NewSelected_waveformsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, vhdlParserRULE_selected_waveforms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2098)
		p.Waveform()
	}
	{
		p.SetState(2099)
		p.Match(vhdlParserWHEN)
	}
	{
		p.SetState(2100)
		p.Choices()
	}
	p.SetState(2108)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2101)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2102)
			p.Waveform()
		}
		{
			p.SetState(2103)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(2104)
			p.Choices()
		}

		p.SetState(2110)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISensitivity_clauseContext is an interface to support dynamic dispatch.
type ISensitivity_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSensitivity_clauseContext differentiates from other interfaces.
	IsSensitivity_clauseContext()
}

type Sensitivity_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySensitivity_clauseContext() *Sensitivity_clauseContext {
	var p = new(Sensitivity_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_sensitivity_clause
	return p
}

func (*Sensitivity_clauseContext) IsSensitivity_clauseContext() {}

func NewSensitivity_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sensitivity_clauseContext {
	var p = new(Sensitivity_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_sensitivity_clause

	return p
}

func (s *Sensitivity_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Sensitivity_clauseContext) ON() antlr.TerminalNode {
	return s.GetToken(vhdlParserON, 0)
}

func (s *Sensitivity_clauseContext) Sensitivity_list() ISensitivity_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISensitivity_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISensitivity_listContext)
}

func (s *Sensitivity_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sensitivity_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sensitivity_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSensitivity_clause(s)
	}
}

func (s *Sensitivity_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSensitivity_clause(s)
	}
}

func (p *vhdlParser) Sensitivity_clause() (localctx ISensitivity_clauseContext) {
	this := p
	_ = this

	localctx = NewSensitivity_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, vhdlParserRULE_sensitivity_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2111)
		p.Match(vhdlParserON)
	}
	{
		p.SetState(2112)
		p.Sensitivity_list()
	}

	return localctx
}

// ISensitivity_listContext is an interface to support dynamic dispatch.
type ISensitivity_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSensitivity_listContext differentiates from other interfaces.
	IsSensitivity_listContext()
}

type Sensitivity_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySensitivity_listContext() *Sensitivity_listContext {
	var p = new(Sensitivity_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_sensitivity_list
	return p
}

func (*Sensitivity_listContext) IsSensitivity_listContext() {}

func NewSensitivity_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sensitivity_listContext {
	var p = new(Sensitivity_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_sensitivity_list

	return p
}

func (s *Sensitivity_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sensitivity_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Sensitivity_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Sensitivity_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Sensitivity_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Sensitivity_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sensitivity_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sensitivity_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSensitivity_list(s)
	}
}

func (s *Sensitivity_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSensitivity_list(s)
	}
}

func (p *vhdlParser) Sensitivity_list() (localctx ISensitivity_listContext) {
	this := p
	_ = this

	localctx = NewSensitivity_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, vhdlParserRULE_sensitivity_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2114)
		p.Name()
	}
	p.SetState(2119)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2115)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2116)
			p.Name()
		}

		p.SetState(2121)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISequence_of_statementsContext is an interface to support dynamic dispatch.
type ISequence_of_statementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_of_statementsContext differentiates from other interfaces.
	IsSequence_of_statementsContext()
}

type Sequence_of_statementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_of_statementsContext() *Sequence_of_statementsContext {
	var p = new(Sequence_of_statementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_sequence_of_statements
	return p
}

func (*Sequence_of_statementsContext) IsSequence_of_statementsContext() {}

func NewSequence_of_statementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_of_statementsContext {
	var p = new(Sequence_of_statementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_sequence_of_statements

	return p
}

func (s *Sequence_of_statementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_of_statementsContext) AllSequential_statement() []ISequential_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem())
	var tst = make([]ISequential_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequential_statementContext)
		}
	}

	return tst
}

func (s *Sequence_of_statementsContext) Sequential_statement(i int) ISequential_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequential_statementContext)
}

func (s *Sequence_of_statementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_of_statementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_of_statementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSequence_of_statements(s)
	}
}

func (s *Sequence_of_statementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSequence_of_statements(s)
	}
}

func (p *vhdlParser) Sequence_of_statements() (localctx ISequence_of_statementsContext) {
	this := p
	_ = this

	localctx = NewSequence_of_statementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, vhdlParserRULE_sequence_of_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE)|(1<<vhdlParserEXIT)|(1<<vhdlParserFOR))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserLOOP-36))|(1<<(vhdlParserNEXT-36))|(1<<(vhdlParserNULL_-36)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(vhdlParserREPORT-79))|(1<<(vhdlParserRETURN-79))|(1<<(vhdlParserWAIT-79))|(1<<(vhdlParserWHILE-79)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserSTRING_LITERAL-118))|(1<<(vhdlParserLPAREN-118)))) != 0) {
		{
			p.SetState(2122)
			p.Sequential_statement()
		}

		p.SetState(2127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISequential_statementContext is an interface to support dynamic dispatch.
type ISequential_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequential_statementContext differentiates from other interfaces.
	IsSequential_statementContext()
}

type Sequential_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequential_statementContext() *Sequential_statementContext {
	var p = new(Sequential_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_sequential_statement
	return p
}

func (*Sequential_statementContext) IsSequential_statementContext() {}

func NewSequential_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequential_statementContext {
	var p = new(Sequential_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_sequential_statement

	return p
}

func (s *Sequential_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequential_statementContext) Wait_statement() IWait_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWait_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWait_statementContext)
}

func (s *Sequential_statementContext) Assertion_statement() IAssertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertion_statementContext)
}

func (s *Sequential_statementContext) Report_statement() IReport_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReport_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReport_statementContext)
}

func (s *Sequential_statementContext) Signal_assignment_statement() ISignal_assignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_assignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_assignment_statementContext)
}

func (s *Sequential_statementContext) Variable_assignment_statement() IVariable_assignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignment_statementContext)
}

func (s *Sequential_statementContext) If_statement() IIf_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_statementContext)
}

func (s *Sequential_statementContext) Case_statement() ICase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_statementContext)
}

func (s *Sequential_statementContext) Loop_statement() ILoop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_statementContext)
}

func (s *Sequential_statementContext) Next_statement() INext_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INext_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INext_statementContext)
}

func (s *Sequential_statementContext) Exit_statement() IExit_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExit_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExit_statementContext)
}

func (s *Sequential_statementContext) Return_statement() IReturn_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_statementContext)
}

func (s *Sequential_statementContext) NULL_() antlr.TerminalNode {
	return s.GetToken(vhdlParserNULL_, 0)
}

func (s *Sequential_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Sequential_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Sequential_statementContext) Break_statement() IBreak_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_statementContext)
}

func (s *Sequential_statementContext) Procedure_call_statement() IProcedure_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_call_statementContext)
}

func (s *Sequential_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequential_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequential_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSequential_statement(s)
	}
}

func (s *Sequential_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSequential_statement(s)
	}
}

func (p *vhdlParser) Sequential_statement() (localctx ISequential_statementContext) {
	this := p
	_ = this

	localctx = NewSequential_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, vhdlParserRULE_sequential_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2146)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2128)
			p.Wait_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2129)
			p.Assertion_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2130)
			p.Report_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2131)
			p.Signal_assignment_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2132)
			p.Variable_assignment_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2133)
			p.If_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2134)
			p.Case_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2135)
			p.Loop_statement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2136)
			p.Next_statement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2137)
			p.Exit_statement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2138)
			p.Return_statement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		p.SetState(2140)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
			{
				p.SetState(2139)
				p.Label_colon()
			}

		}
		{
			p.SetState(2142)
			p.Match(vhdlParserNULL_)
		}
		{
			p.SetState(2143)
			p.Match(vhdlParserSEMI)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2144)
			p.Break_statement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2145)
			p.Procedure_call_statement()
		}

	}

	return localctx
}

// IShift_expressionContext is an interface to support dynamic dispatch.
type IShift_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_expressionContext differentiates from other interfaces.
	IsShift_expressionContext()
}

type Shift_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_expressionContext() *Shift_expressionContext {
	var p = new(Shift_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_shift_expression
	return p
}

func (*Shift_expressionContext) IsShift_expressionContext() {}

func NewShift_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_expressionContext {
	var p = new(Shift_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_shift_expression

	return p
}

func (s *Shift_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_expressionContext) AllSimple_expression() []ISimple_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_expressionContext)
		}
	}

	return tst
}

func (s *Shift_expressionContext) Simple_expression(i int) ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *Shift_expressionContext) Shift_operator() IShift_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_operatorContext)
}

func (s *Shift_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterShift_expression(s)
	}
}

func (s *Shift_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitShift_expression(s)
	}
}

func (p *vhdlParser) Shift_expression() (localctx IShift_expressionContext) {
	this := p
	_ = this

	localctx = NewShift_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, vhdlParserRULE_shift_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2148)
		p.Simple_expression()
	}
	p.SetState(2152)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2149)
			p.Shift_operator()
		}
		{
			p.SetState(2150)
			p.Simple_expression()
		}

	}

	return localctx
}

// IShift_operatorContext is an interface to support dynamic dispatch.
type IShift_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_operatorContext differentiates from other interfaces.
	IsShift_operatorContext()
}

type Shift_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_operatorContext() *Shift_operatorContext {
	var p = new(Shift_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_shift_operator
	return p
}

func (*Shift_operatorContext) IsShift_operatorContext() {}

func NewShift_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_operatorContext {
	var p = new(Shift_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_shift_operator

	return p
}

func (s *Shift_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_operatorContext) SLL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSLL, 0)
}

func (s *Shift_operatorContext) SRL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSRL, 0)
}

func (s *Shift_operatorContext) SLA() antlr.TerminalNode {
	return s.GetToken(vhdlParserSLA, 0)
}

func (s *Shift_operatorContext) SRA() antlr.TerminalNode {
	return s.GetToken(vhdlParserSRA, 0)
}

func (s *Shift_operatorContext) ROL() antlr.TerminalNode {
	return s.GetToken(vhdlParserROL, 0)
}

func (s *Shift_operatorContext) ROR() antlr.TerminalNode {
	return s.GetToken(vhdlParserROR, 0)
}

func (s *Shift_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterShift_operator(s)
	}
}

func (s *Shift_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitShift_operator(s)
	}
}

func (p *vhdlParser) Shift_operator() (localctx IShift_operatorContext) {
	this := p
	_ = this

	localctx = NewShift_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, vhdlParserRULE_shift_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2154)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(vhdlParserROL-81))|(1<<(vhdlParserROR-81))|(1<<(vhdlParserSLA-81))|(1<<(vhdlParserSLL-81))|(1<<(vhdlParserSRA-81))|(1<<(vhdlParserSRL-81)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISignal_assignment_statementContext is an interface to support dynamic dispatch.
type ISignal_assignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_assignment_statementContext differentiates from other interfaces.
	IsSignal_assignment_statementContext()
}

type Signal_assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_assignment_statementContext() *Signal_assignment_statementContext {
	var p = new(Signal_assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_assignment_statement
	return p
}

func (*Signal_assignment_statementContext) IsSignal_assignment_statementContext() {}

func NewSignal_assignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_assignment_statementContext {
	var p = new(Signal_assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_assignment_statement

	return p
}

func (s *Signal_assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_assignment_statementContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Signal_assignment_statementContext) LE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLE, 0)
}

func (s *Signal_assignment_statementContext) Waveform() IWaveformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaveformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWaveformContext)
}

func (s *Signal_assignment_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Signal_assignment_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Signal_assignment_statementContext) Delay_mechanism() IDelay_mechanismContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_mechanismContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_mechanismContext)
}

func (s *Signal_assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_assignment_statement(s)
	}
}

func (s *Signal_assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_assignment_statement(s)
	}
}

func (p *vhdlParser) Signal_assignment_statement() (localctx ISignal_assignment_statementContext) {
	this := p
	_ = this

	localctx = NewSignal_assignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, vhdlParserRULE_signal_assignment_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2157)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2156)
			p.Label_colon()
		}

	}
	{
		p.SetState(2159)
		p.Target()
	}
	{
		p.SetState(2160)
		p.Match(vhdlParserLE)
	}
	p.SetState(2162)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserINERTIAL || _la == vhdlParserREJECT || _la == vhdlParserTRANSPORT {
		{
			p.SetState(2161)
			p.Delay_mechanism()
		}

	}
	{
		p.SetState(2164)
		p.Waveform()
	}
	{
		p.SetState(2165)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISignal_declarationContext is an interface to support dynamic dispatch.
type ISignal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_declarationContext differentiates from other interfaces.
	IsSignal_declarationContext()
}

type Signal_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_declarationContext() *Signal_declarationContext {
	var p = new(Signal_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_declaration
	return p
}

func (*Signal_declarationContext) IsSignal_declarationContext() {}

func NewSignal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_declarationContext {
	var p = new(Signal_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_declaration

	return p
}

func (s *Signal_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_declarationContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSIGNAL, 0)
}

func (s *Signal_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Signal_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Signal_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Signal_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Signal_declarationContext) Signal_kind() ISignal_kindContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_kindContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_kindContext)
}

func (s *Signal_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Signal_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Signal_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_declaration(s)
	}
}

func (s *Signal_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_declaration(s)
	}
}

func (p *vhdlParser) Signal_declaration() (localctx ISignal_declarationContext) {
	this := p
	_ = this

	localctx = NewSignal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, vhdlParserRULE_signal_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2167)
		p.Match(vhdlParserSIGNAL)
	}
	{
		p.SetState(2168)
		p.Identifier_list()
	}
	{
		p.SetState(2169)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2170)
		p.Subtype_indication()
	}
	p.SetState(2172)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUS || _la == vhdlParserREGISTER {
		{
			p.SetState(2171)
			p.Signal_kind()
		}

	}
	p.SetState(2176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(2174)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(2175)
			p.Expression()
		}

	}
	{
		p.SetState(2178)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISignal_kindContext is an interface to support dynamic dispatch.
type ISignal_kindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_kindContext differentiates from other interfaces.
	IsSignal_kindContext()
}

type Signal_kindContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_kindContext() *Signal_kindContext {
	var p = new(Signal_kindContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_kind
	return p
}

func (*Signal_kindContext) IsSignal_kindContext() {}

func NewSignal_kindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_kindContext {
	var p = new(Signal_kindContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_kind

	return p
}

func (s *Signal_kindContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_kindContext) REGISTER() antlr.TerminalNode {
	return s.GetToken(vhdlParserREGISTER, 0)
}

func (s *Signal_kindContext) BUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserBUS, 0)
}

func (s *Signal_kindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_kindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_kindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_kind(s)
	}
}

func (s *Signal_kindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_kind(s)
	}
}

func (p *vhdlParser) Signal_kind() (localctx ISignal_kindContext) {
	this := p
	_ = this

	localctx = NewSignal_kindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, vhdlParserRULE_signal_kind)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2180)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserBUS || _la == vhdlParserREGISTER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISignal_listContext is an interface to support dynamic dispatch.
type ISignal_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_listContext differentiates from other interfaces.
	IsSignal_listContext()
}

type Signal_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_listContext() *Signal_listContext {
	var p = new(Signal_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_list
	return p
}

func (*Signal_listContext) IsSignal_listContext() {}

func NewSignal_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_listContext {
	var p = new(Signal_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_list

	return p
}

func (s *Signal_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Signal_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Signal_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Signal_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Signal_listContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *Signal_listContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *Signal_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_list(s)
	}
}

func (s *Signal_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_list(s)
	}
}

func (p *vhdlParser) Signal_list() (localctx ISignal_listContext) {
	this := p
	_ = this

	localctx = NewSignal_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, vhdlParserRULE_signal_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2192)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2182)
			p.Name()
		}
		p.SetState(2187)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(2183)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(2184)
				p.Name()
			}

			p.SetState(2189)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserOTHERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2190)
			p.Match(vhdlParserOTHERS)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2191)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISignatureContext is an interface to support dynamic dispatch.
type ISignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignatureContext differentiates from other interfaces.
	IsSignatureContext()
}

type SignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignatureContext() *SignatureContext {
	var p = new(SignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signature
	return p
}

func (*SignatureContext) IsSignatureContext() {}

func NewSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignatureContext {
	var p = new(SignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signature

	return p
}

func (s *SignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *SignatureContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(vhdlParserLBRACKET, 0)
}

func (s *SignatureContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(vhdlParserRBRACKET, 0)
}

func (s *SignatureContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *SignatureContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *SignatureContext) RETURN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRETURN, 0)
}

func (s *SignatureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *SignatureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *SignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignature(s)
	}
}

func (s *SignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignature(s)
	}
}

func (p *vhdlParser) Signature() (localctx ISignatureContext) {
	this := p
	_ = this

	localctx = NewSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, vhdlParserRULE_signature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2194)
		p.Match(vhdlParserLBRACKET)
	}
	p.SetState(2203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserSTRING_LITERAL-118)))) != 0 {
		{
			p.SetState(2195)
			p.Name()
		}
		p.SetState(2200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(2196)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(2197)
				p.Name()
			}

			p.SetState(2202)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserRETURN {
		{
			p.SetState(2205)
			p.Match(vhdlParserRETURN)
		}
		{
			p.SetState(2206)
			p.Name()
		}

	}
	{
		p.SetState(2209)
		p.Match(vhdlParserRBRACKET)
	}

	return localctx
}

// ISimple_expressionContext is an interface to support dynamic dispatch.
type ISimple_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_expressionContext differentiates from other interfaces.
	IsSimple_expressionContext()
}

type Simple_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_expressionContext() *Simple_expressionContext {
	var p = new(Simple_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simple_expression
	return p
}

func (*Simple_expressionContext) IsSimple_expressionContext() {}

func NewSimple_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_expressionContext {
	var p = new(Simple_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simple_expression

	return p
}

func (s *Simple_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_expressionContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Simple_expressionContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Simple_expressionContext) AllAdding_operator() []IAdding_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdding_operatorContext)(nil)).Elem())
	var tst = make([]IAdding_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdding_operatorContext)
		}
	}

	return tst
}

func (s *Simple_expressionContext) Adding_operator(i int) IAdding_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdding_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdding_operatorContext)
}

func (s *Simple_expressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserPLUS, 0)
}

func (s *Simple_expressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserMINUS, 0)
}

func (s *Simple_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimple_expression(s)
	}
}

func (s *Simple_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimple_expression(s)
	}
}

func (p *vhdlParser) Simple_expression() (localctx ISimple_expressionContext) {
	this := p
	_ = this

	localctx = NewSimple_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, vhdlParserRULE_simple_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2212)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPLUS || _la == vhdlParserMINUS {
		{
			p.SetState(2211)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vhdlParserPLUS || _la == vhdlParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2214)
		p.Term()
	}
	p.SetState(2220)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2215)
				p.Adding_operator()
			}
			{
				p.SetState(2216)
				p.Term()
			}

		}
		p.SetState(2222)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())
	}

	return localctx
}

// ISimple_simultaneous_statementContext is an interface to support dynamic dispatch.
type ISimple_simultaneous_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_simultaneous_statementContext differentiates from other interfaces.
	IsSimple_simultaneous_statementContext()
}

type Simple_simultaneous_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_simultaneous_statementContext() *Simple_simultaneous_statementContext {
	var p = new(Simple_simultaneous_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simple_simultaneous_statement
	return p
}

func (*Simple_simultaneous_statementContext) IsSimple_simultaneous_statementContext() {}

func NewSimple_simultaneous_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_simultaneous_statementContext {
	var p = new(Simple_simultaneous_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simple_simultaneous_statement

	return p
}

func (s *Simple_simultaneous_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_simultaneous_statementContext) AllSimple_expression() []ISimple_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_expressionContext)
		}
	}

	return tst
}

func (s *Simple_simultaneous_statementContext) Simple_expression(i int) ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *Simple_simultaneous_statementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserASSIGN, 0)
}

func (s *Simple_simultaneous_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simple_simultaneous_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simple_simultaneous_statementContext) Tolerance_aspect() ITolerance_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITolerance_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITolerance_aspectContext)
}

func (s *Simple_simultaneous_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_simultaneous_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_simultaneous_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimple_simultaneous_statement(s)
	}
}

func (s *Simple_simultaneous_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimple_simultaneous_statement(s)
	}
}

func (p *vhdlParser) Simple_simultaneous_statement() (localctx ISimple_simultaneous_statementContext) {
	this := p
	_ = this

	localctx = NewSimple_simultaneous_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, vhdlParserRULE_simple_simultaneous_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2224)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2223)
			p.Label_colon()
		}

	}
	{
		p.SetState(2226)
		p.Simple_expression()
	}
	{
		p.SetState(2227)
		p.Match(vhdlParserASSIGN)
	}
	{
		p.SetState(2228)
		p.Simple_expression()
	}
	p.SetState(2230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTOLERANCE {
		{
			p.SetState(2229)
			p.Tolerance_aspect()
		}

	}
	{
		p.SetState(2232)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISimultaneous_alternativeContext is an interface to support dynamic dispatch.
type ISimultaneous_alternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_alternativeContext differentiates from other interfaces.
	IsSimultaneous_alternativeContext()
}

type Simultaneous_alternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_alternativeContext() *Simultaneous_alternativeContext {
	var p = new(Simultaneous_alternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_alternative
	return p
}

func (*Simultaneous_alternativeContext) IsSimultaneous_alternativeContext() {}

func NewSimultaneous_alternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_alternativeContext {
	var p = new(Simultaneous_alternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_alternative

	return p
}

func (s *Simultaneous_alternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_alternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Simultaneous_alternativeContext) Choices() IChoicesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoicesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoicesContext)
}

func (s *Simultaneous_alternativeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Simultaneous_alternativeContext) Simultaneous_statement_part() ISimultaneous_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_statement_partContext)
}

func (s *Simultaneous_alternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_alternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_alternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_alternative(s)
	}
}

func (s *Simultaneous_alternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_alternative(s)
	}
}

func (p *vhdlParser) Simultaneous_alternative() (localctx ISimultaneous_alternativeContext) {
	this := p
	_ = this

	localctx = NewSimultaneous_alternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, vhdlParserRULE_simultaneous_alternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2234)
		p.Match(vhdlParserWHEN)
	}
	{
		p.SetState(2235)
		p.Choices()
	}
	{
		p.SetState(2236)
		p.Match(vhdlParserARROW)
	}
	{
		p.SetState(2237)
		p.Simultaneous_statement_part()
	}

	return localctx
}

// ISimultaneous_case_statementContext is an interface to support dynamic dispatch.
type ISimultaneous_case_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_case_statementContext differentiates from other interfaces.
	IsSimultaneous_case_statementContext()
}

type Simultaneous_case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_case_statementContext() *Simultaneous_case_statementContext {
	var p = new(Simultaneous_case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_case_statement
	return p
}

func (*Simultaneous_case_statementContext) IsSimultaneous_case_statementContext() {}

func NewSimultaneous_case_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_case_statementContext {
	var p = new(Simultaneous_case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_case_statement

	return p
}

func (s *Simultaneous_case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_case_statementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCASE)
}

func (s *Simultaneous_case_statementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCASE, i)
}

func (s *Simultaneous_case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Simultaneous_case_statementContext) USE() antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, 0)
}

func (s *Simultaneous_case_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Simultaneous_case_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simultaneous_case_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simultaneous_case_statementContext) AllSimultaneous_alternative() []ISimultaneous_alternativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimultaneous_alternativeContext)(nil)).Elem())
	var tst = make([]ISimultaneous_alternativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimultaneous_alternativeContext)
		}
	}

	return tst
}

func (s *Simultaneous_case_statementContext) Simultaneous_alternative(i int) ISimultaneous_alternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_alternativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_alternativeContext)
}

func (s *Simultaneous_case_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Simultaneous_case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_case_statement(s)
	}
}

func (s *Simultaneous_case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_case_statement(s)
	}
}

func (p *vhdlParser) Simultaneous_case_statement() (localctx ISimultaneous_case_statementContext) {
	this := p
	_ = this

	localctx = NewSimultaneous_case_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, vhdlParserRULE_simultaneous_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2240)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2239)
			p.Label_colon()
		}

	}
	{
		p.SetState(2242)
		p.Match(vhdlParserCASE)
	}
	{
		p.SetState(2243)
		p.Expression()
	}
	{
		p.SetState(2244)
		p.Match(vhdlParserUSE)
	}
	p.SetState(2246)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == vhdlParserWHEN {
		{
			p.SetState(2245)
			p.Simultaneous_alternative()
		}

		p.SetState(2248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2250)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2251)
		p.Match(vhdlParserCASE)
	}
	p.SetState(2253)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2252)
			p.Identifier()
		}

	}
	{
		p.SetState(2255)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISimultaneous_if_statementContext is an interface to support dynamic dispatch.
type ISimultaneous_if_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_if_statementContext differentiates from other interfaces.
	IsSimultaneous_if_statementContext()
}

type Simultaneous_if_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_if_statementContext() *Simultaneous_if_statementContext {
	var p = new(Simultaneous_if_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_if_statement
	return p
}

func (*Simultaneous_if_statementContext) IsSimultaneous_if_statementContext() {}

func NewSimultaneous_if_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_if_statementContext {
	var p = new(Simultaneous_if_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_if_statement

	return p
}

func (s *Simultaneous_if_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_if_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(vhdlParserIF, 0)
}

func (s *Simultaneous_if_statementContext) AllCondition() []IConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionContext)(nil)).Elem())
	var tst = make([]IConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionContext)
		}
	}

	return tst
}

func (s *Simultaneous_if_statementContext) Condition(i int) IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Simultaneous_if_statementContext) AllUSE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserUSE)
}

func (s *Simultaneous_if_statementContext) USE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, i)
}

func (s *Simultaneous_if_statementContext) AllSimultaneous_statement_part() []ISimultaneous_statement_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimultaneous_statement_partContext)(nil)).Elem())
	var tst = make([]ISimultaneous_statement_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimultaneous_statement_partContext)
		}
	}

	return tst
}

func (s *Simultaneous_if_statementContext) Simultaneous_statement_part(i int) ISimultaneous_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_statement_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_statement_partContext)
}

func (s *Simultaneous_if_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Simultaneous_if_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simultaneous_if_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simultaneous_if_statementContext) AllELSIF() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserELSIF)
}

func (s *Simultaneous_if_statementContext) ELSIF(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserELSIF, i)
}

func (s *Simultaneous_if_statementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vhdlParserELSE, 0)
}

func (s *Simultaneous_if_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Simultaneous_if_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_if_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_if_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_if_statement(s)
	}
}

func (s *Simultaneous_if_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_if_statement(s)
	}
}

func (p *vhdlParser) Simultaneous_if_statement() (localctx ISimultaneous_if_statementContext) {
	this := p
	_ = this

	localctx = NewSimultaneous_if_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, vhdlParserRULE_simultaneous_if_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2257)
			p.Label_colon()
		}

	}
	{
		p.SetState(2260)
		p.Match(vhdlParserIF)
	}
	{
		p.SetState(2261)
		p.Condition()
	}
	{
		p.SetState(2262)
		p.Match(vhdlParserUSE)
	}
	{
		p.SetState(2263)
		p.Simultaneous_statement_part()
	}
	p.SetState(2271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserELSIF {
		{
			p.SetState(2264)
			p.Match(vhdlParserELSIF)
		}
		{
			p.SetState(2265)
			p.Condition()
		}
		{
			p.SetState(2266)
			p.Match(vhdlParserUSE)
		}
		{
			p.SetState(2267)
			p.Simultaneous_statement_part()
		}

		p.SetState(2273)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2276)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserELSE {
		{
			p.SetState(2274)
			p.Match(vhdlParserELSE)
		}
		{
			p.SetState(2275)
			p.Simultaneous_statement_part()
		}

	}
	{
		p.SetState(2278)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2279)
		p.Match(vhdlParserUSE)
	}
	p.SetState(2281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2280)
			p.Identifier()
		}

	}
	{
		p.SetState(2283)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISimultaneous_procedural_statementContext is an interface to support dynamic dispatch.
type ISimultaneous_procedural_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_procedural_statementContext differentiates from other interfaces.
	IsSimultaneous_procedural_statementContext()
}

type Simultaneous_procedural_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_procedural_statementContext() *Simultaneous_procedural_statementContext {
	var p = new(Simultaneous_procedural_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_procedural_statement
	return p
}

func (*Simultaneous_procedural_statementContext) IsSimultaneous_procedural_statementContext() {}

func NewSimultaneous_procedural_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_procedural_statementContext {
	var p = new(Simultaneous_procedural_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_procedural_statement

	return p
}

func (s *Simultaneous_procedural_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_procedural_statementContext) AllPROCEDURAL() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPROCEDURAL)
}

func (s *Simultaneous_procedural_statementContext) PROCEDURAL(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCEDURAL, i)
}

func (s *Simultaneous_procedural_statementContext) Procedural_declarative_part() IProcedural_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_declarative_partContext)
}

func (s *Simultaneous_procedural_statementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Simultaneous_procedural_statementContext) Procedural_statement_part() IProcedural_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_statement_partContext)
}

func (s *Simultaneous_procedural_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Simultaneous_procedural_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simultaneous_procedural_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simultaneous_procedural_statementContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Simultaneous_procedural_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Simultaneous_procedural_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_procedural_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_procedural_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_procedural_statement(s)
	}
}

func (s *Simultaneous_procedural_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_procedural_statement(s)
	}
}

func (p *vhdlParser) Simultaneous_procedural_statement() (localctx ISimultaneous_procedural_statementContext) {
	this := p
	_ = this

	localctx = NewSimultaneous_procedural_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, vhdlParserRULE_simultaneous_procedural_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2286)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2285)
			p.Label_colon()
		}

	}
	{
		p.SetState(2288)
		p.Match(vhdlParserPROCEDURAL)
	}
	p.SetState(2290)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(2289)
			p.Match(vhdlParserIS)
		}

	}
	{
		p.SetState(2292)
		p.Procedural_declarative_part()
	}
	{
		p.SetState(2293)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(2294)
		p.Procedural_statement_part()
	}
	{
		p.SetState(2295)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2296)
		p.Match(vhdlParserPROCEDURAL)
	}
	p.SetState(2298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2297)
			p.Identifier()
		}

	}
	{
		p.SetState(2300)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISimultaneous_statementContext is an interface to support dynamic dispatch.
type ISimultaneous_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_statementContext differentiates from other interfaces.
	IsSimultaneous_statementContext()
}

type Simultaneous_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_statementContext() *Simultaneous_statementContext {
	var p = new(Simultaneous_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_statement
	return p
}

func (*Simultaneous_statementContext) IsSimultaneous_statementContext() {}

func NewSimultaneous_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_statementContext {
	var p = new(Simultaneous_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_statement

	return p
}

func (s *Simultaneous_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_statementContext) Simple_simultaneous_statement() ISimple_simultaneous_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_simultaneous_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_simultaneous_statementContext)
}

func (s *Simultaneous_statementContext) Simultaneous_if_statement() ISimultaneous_if_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_if_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_if_statementContext)
}

func (s *Simultaneous_statementContext) Simultaneous_case_statement() ISimultaneous_case_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_case_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_case_statementContext)
}

func (s *Simultaneous_statementContext) Simultaneous_procedural_statement() ISimultaneous_procedural_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_procedural_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_procedural_statementContext)
}

func (s *Simultaneous_statementContext) NULL_() antlr.TerminalNode {
	return s.GetToken(vhdlParserNULL_, 0)
}

func (s *Simultaneous_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simultaneous_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simultaneous_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_statement(s)
	}
}

func (s *Simultaneous_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_statement(s)
	}
}

func (p *vhdlParser) Simultaneous_statement() (localctx ISimultaneous_statementContext) {
	this := p
	_ = this

	localctx = NewSimultaneous_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, vhdlParserRULE_simultaneous_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2311)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 256, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2302)
			p.Simple_simultaneous_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2303)
			p.Simultaneous_if_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2304)
			p.Simultaneous_case_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2305)
			p.Simultaneous_procedural_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(2307)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
			{
				p.SetState(2306)
				p.Label_colon()
			}

		}
		{
			p.SetState(2309)
			p.Match(vhdlParserNULL_)
		}
		{
			p.SetState(2310)
			p.Match(vhdlParserSEMI)
		}

	}

	return localctx
}

// ISimultaneous_statement_partContext is an interface to support dynamic dispatch.
type ISimultaneous_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_statement_partContext differentiates from other interfaces.
	IsSimultaneous_statement_partContext()
}

type Simultaneous_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_statement_partContext() *Simultaneous_statement_partContext {
	var p = new(Simultaneous_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_statement_part
	return p
}

func (*Simultaneous_statement_partContext) IsSimultaneous_statement_partContext() {}

func NewSimultaneous_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_statement_partContext {
	var p = new(Simultaneous_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_statement_part

	return p
}

func (s *Simultaneous_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_statement_partContext) AllSimultaneous_statement() []ISimultaneous_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimultaneous_statementContext)(nil)).Elem())
	var tst = make([]ISimultaneous_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimultaneous_statementContext)
		}
	}

	return tst
}

func (s *Simultaneous_statement_partContext) Simultaneous_statement(i int) ISimultaneous_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_statementContext)
}

func (s *Simultaneous_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_statement_part(s)
	}
}

func (s *Simultaneous_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_statement_part(s)
	}
}

func (p *vhdlParser) Simultaneous_statement_part() (localctx ISimultaneous_statement_partContext) {
	this := p
	_ = this

	localctx = NewSimultaneous_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, vhdlParserRULE_simultaneous_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2316)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserABS || _la == vhdlParserCASE || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserNEW-36))|(1<<(vhdlParserNOT-36))|(1<<(vhdlParserNULL_-36)))) != 0) || _la == vhdlParserPROCEDURAL || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(vhdlParserBASE_LITERAL-112))|(1<<(vhdlParserBIT_STRING_LITERAL-112))|(1<<(vhdlParserREAL_LITERAL-112))|(1<<(vhdlParserBASIC_IDENTIFIER-112))|(1<<(vhdlParserEXTENDED_IDENTIFIER-112))|(1<<(vhdlParserCHARACTER_LITERAL-112))|(1<<(vhdlParserSTRING_LITERAL-112))|(1<<(vhdlParserLPAREN-112)))) != 0) || (((_la-148)&-(0x1f+1)) == 0 && ((1<<uint((_la-148)))&((1<<(vhdlParserPLUS-148))|(1<<(vhdlParserMINUS-148))|(1<<(vhdlParserINTEGER-148)))) != 0) {
		{
			p.SetState(2313)
			p.Simultaneous_statement()
		}

		p.SetState(2318)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISource_aspectContext is an interface to support dynamic dispatch.
type ISource_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSource_aspectContext differentiates from other interfaces.
	IsSource_aspectContext()
}

type Source_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySource_aspectContext() *Source_aspectContext {
	var p = new(Source_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_source_aspect
	return p
}

func (*Source_aspectContext) IsSource_aspectContext() {}

func NewSource_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Source_aspectContext {
	var p = new(Source_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_source_aspect

	return p
}

func (s *Source_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Source_aspectContext) SPECTRUM() antlr.TerminalNode {
	return s.GetToken(vhdlParserSPECTRUM, 0)
}

func (s *Source_aspectContext) AllSimple_expression() []ISimple_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_expressionContext)
		}
	}

	return tst
}

func (s *Source_aspectContext) Simple_expression(i int) ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *Source_aspectContext) COMMA() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, 0)
}

func (s *Source_aspectContext) NOISE() antlr.TerminalNode {
	return s.GetToken(vhdlParserNOISE, 0)
}

func (s *Source_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Source_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Source_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSource_aspect(s)
	}
}

func (s *Source_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSource_aspect(s)
	}
}

func (p *vhdlParser) Source_aspect() (localctx ISource_aspectContext) {
	this := p
	_ = this

	localctx = NewSource_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, vhdlParserRULE_source_aspect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2326)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserSPECTRUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2319)
			p.Match(vhdlParserSPECTRUM)
		}
		{
			p.SetState(2320)
			p.Simple_expression()
		}
		{
			p.SetState(2321)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2322)
			p.Simple_expression()
		}

	case vhdlParserNOISE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2324)
			p.Match(vhdlParserNOISE)
		}
		{
			p.SetState(2325)
			p.Simple_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISource_quantity_declarationContext is an interface to support dynamic dispatch.
type ISource_quantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSource_quantity_declarationContext differentiates from other interfaces.
	IsSource_quantity_declarationContext()
}

type Source_quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySource_quantity_declarationContext() *Source_quantity_declarationContext {
	var p = new(Source_quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_source_quantity_declaration
	return p
}

func (*Source_quantity_declarationContext) IsSource_quantity_declarationContext() {}

func NewSource_quantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Source_quantity_declarationContext {
	var p = new(Source_quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_source_quantity_declaration

	return p
}

func (s *Source_quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Source_quantity_declarationContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Source_quantity_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Source_quantity_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Source_quantity_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Source_quantity_declarationContext) Source_aspect() ISource_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISource_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISource_aspectContext)
}

func (s *Source_quantity_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Source_quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Source_quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Source_quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSource_quantity_declaration(s)
	}
}

func (s *Source_quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSource_quantity_declaration(s)
	}
}

func (p *vhdlParser) Source_quantity_declaration() (localctx ISource_quantity_declarationContext) {
	this := p
	_ = this

	localctx = NewSource_quantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, vhdlParserRULE_source_quantity_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2328)
		p.Match(vhdlParserQUANTITY)
	}
	{
		p.SetState(2329)
		p.Identifier_list()
	}
	{
		p.SetState(2330)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2331)
		p.Subtype_indication()
	}
	{
		p.SetState(2332)
		p.Source_aspect()
	}
	{
		p.SetState(2333)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IStep_limit_specificationContext is an interface to support dynamic dispatch.
type IStep_limit_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStep_limit_specificationContext differentiates from other interfaces.
	IsStep_limit_specificationContext()
}

type Step_limit_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStep_limit_specificationContext() *Step_limit_specificationContext {
	var p = new(Step_limit_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_step_limit_specification
	return p
}

func (*Step_limit_specificationContext) IsStep_limit_specificationContext() {}

func NewStep_limit_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Step_limit_specificationContext {
	var p = new(Step_limit_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_step_limit_specification

	return p
}

func (s *Step_limit_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Step_limit_specificationContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(vhdlParserLIMIT, 0)
}

func (s *Step_limit_specificationContext) Quantity_specification() IQuantity_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_specificationContext)
}

func (s *Step_limit_specificationContext) WITH() antlr.TerminalNode {
	return s.GetToken(vhdlParserWITH, 0)
}

func (s *Step_limit_specificationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Step_limit_specificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Step_limit_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Step_limit_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Step_limit_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterStep_limit_specification(s)
	}
}

func (s *Step_limit_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitStep_limit_specification(s)
	}
}

func (p *vhdlParser) Step_limit_specification() (localctx IStep_limit_specificationContext) {
	this := p
	_ = this

	localctx = NewStep_limit_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, vhdlParserRULE_step_limit_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2335)
		p.Match(vhdlParserLIMIT)
	}
	{
		p.SetState(2336)
		p.Quantity_specification()
	}
	{
		p.SetState(2337)
		p.Match(vhdlParserWITH)
	}
	{
		p.SetState(2338)
		p.Expression()
	}
	{
		p.SetState(2339)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubnature_declarationContext is an interface to support dynamic dispatch.
type ISubnature_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubnature_declarationContext differentiates from other interfaces.
	IsSubnature_declarationContext()
}

type Subnature_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubnature_declarationContext() *Subnature_declarationContext {
	var p = new(Subnature_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subnature_declaration
	return p
}

func (*Subnature_declarationContext) IsSubnature_declarationContext() {}

func NewSubnature_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subnature_declarationContext {
	var p = new(Subnature_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subnature_declaration

	return p
}

func (s *Subnature_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subnature_declarationContext) SUBNATURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserSUBNATURE, 0)
}

func (s *Subnature_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Subnature_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Subnature_declarationContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Subnature_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Subnature_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subnature_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subnature_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubnature_declaration(s)
	}
}

func (s *Subnature_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubnature_declaration(s)
	}
}

func (p *vhdlParser) Subnature_declaration() (localctx ISubnature_declarationContext) {
	this := p
	_ = this

	localctx = NewSubnature_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, vhdlParserRULE_subnature_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2341)
		p.Match(vhdlParserSUBNATURE)
	}
	{
		p.SetState(2342)
		p.Identifier()
	}
	{
		p.SetState(2343)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(2344)
		p.Subnature_indication()
	}
	{
		p.SetState(2345)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubnature_indicationContext is an interface to support dynamic dispatch.
type ISubnature_indicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubnature_indicationContext differentiates from other interfaces.
	IsSubnature_indicationContext()
}

type Subnature_indicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubnature_indicationContext() *Subnature_indicationContext {
	var p = new(Subnature_indicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subnature_indication
	return p
}

func (*Subnature_indicationContext) IsSubnature_indicationContext() {}

func NewSubnature_indicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subnature_indicationContext {
	var p = new(Subnature_indicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subnature_indication

	return p
}

func (s *Subnature_indicationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subnature_indicationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Subnature_indicationContext) Index_constraint() IIndex_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_constraintContext)
}

func (s *Subnature_indicationContext) TOLERANCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTOLERANCE, 0)
}

func (s *Subnature_indicationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Subnature_indicationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Subnature_indicationContext) ACROSS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACROSS, 0)
}

func (s *Subnature_indicationContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(vhdlParserTHROUGH, 0)
}

func (s *Subnature_indicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subnature_indicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subnature_indicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubnature_indication(s)
	}
}

func (s *Subnature_indicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubnature_indication(s)
	}
}

func (p *vhdlParser) Subnature_indication() (localctx ISubnature_indicationContext) {
	this := p
	_ = this

	localctx = NewSubnature_indicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, vhdlParserRULE_subnature_indication)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2347)
		p.Name()
	}
	p.SetState(2349)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(2348)
			p.Index_constraint()
		}

	}
	p.SetState(2357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTOLERANCE {
		{
			p.SetState(2351)
			p.Match(vhdlParserTOLERANCE)
		}
		{
			p.SetState(2352)
			p.Expression()
		}
		{
			p.SetState(2353)
			p.Match(vhdlParserACROSS)
		}
		{
			p.SetState(2354)
			p.Expression()
		}
		{
			p.SetState(2355)
			p.Match(vhdlParserTHROUGH)
		}

	}

	return localctx
}

// ISubprogram_bodyContext is an interface to support dynamic dispatch.
type ISubprogram_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_bodyContext differentiates from other interfaces.
	IsSubprogram_bodyContext()
}

type Subprogram_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_bodyContext() *Subprogram_bodyContext {
	var p = new(Subprogram_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_body
	return p
}

func (*Subprogram_bodyContext) IsSubprogram_bodyContext() {}

func NewSubprogram_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_bodyContext {
	var p = new(Subprogram_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_body

	return p
}

func (s *Subprogram_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_bodyContext) Subprogram_specification() ISubprogram_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_specificationContext)
}

func (s *Subprogram_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Subprogram_bodyContext) Subprogram_declarative_part() ISubprogram_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarative_partContext)
}

func (s *Subprogram_bodyContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Subprogram_bodyContext) Subprogram_statement_part() ISubprogram_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_statement_partContext)
}

func (s *Subprogram_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Subprogram_bodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Subprogram_bodyContext) Subprogram_kind() ISubprogram_kindContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_kindContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_kindContext)
}

func (s *Subprogram_bodyContext) Designator() IDesignatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *Subprogram_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_body(s)
	}
}

func (s *Subprogram_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_body(s)
	}
}

func (p *vhdlParser) Subprogram_body() (localctx ISubprogram_bodyContext) {
	this := p
	_ = this

	localctx = NewSubprogram_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, vhdlParserRULE_subprogram_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2359)
		p.Subprogram_specification()
	}
	{
		p.SetState(2360)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(2361)
		p.Subprogram_declarative_part()
	}
	{
		p.SetState(2362)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(2363)
		p.Subprogram_statement_part()
	}
	{
		p.SetState(2364)
		p.Match(vhdlParserEND)
	}
	p.SetState(2366)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFUNCTION || _la == vhdlParserPROCEDURE {
		{
			p.SetState(2365)
			p.Subprogram_kind()
		}

	}
	p.SetState(2369)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserSTRING_LITERAL-118)))) != 0 {
		{
			p.SetState(2368)
			p.Designator()
		}

	}
	{
		p.SetState(2371)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubprogram_declarationContext is an interface to support dynamic dispatch.
type ISubprogram_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_declarationContext differentiates from other interfaces.
	IsSubprogram_declarationContext()
}

type Subprogram_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_declarationContext() *Subprogram_declarationContext {
	var p = new(Subprogram_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_declaration
	return p
}

func (*Subprogram_declarationContext) IsSubprogram_declarationContext() {}

func NewSubprogram_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_declarationContext {
	var p = new(Subprogram_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_declaration

	return p
}

func (s *Subprogram_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_declarationContext) Subprogram_specification() ISubprogram_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_specificationContext)
}

func (s *Subprogram_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Subprogram_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_declaration(s)
	}
}

func (s *Subprogram_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_declaration(s)
	}
}

func (p *vhdlParser) Subprogram_declaration() (localctx ISubprogram_declarationContext) {
	this := p
	_ = this

	localctx = NewSubprogram_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, vhdlParserRULE_subprogram_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2373)
		p.Subprogram_specification()
	}
	{
		p.SetState(2374)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubprogram_declarative_itemContext is an interface to support dynamic dispatch.
type ISubprogram_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_declarative_itemContext differentiates from other interfaces.
	IsSubprogram_declarative_itemContext()
}

type Subprogram_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_declarative_itemContext() *Subprogram_declarative_itemContext {
	var p = new(Subprogram_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_declarative_item
	return p
}

func (*Subprogram_declarative_itemContext) IsSubprogram_declarative_itemContext() {}

func NewSubprogram_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_declarative_itemContext {
	var p = new(Subprogram_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_declarative_item

	return p
}

func (s *Subprogram_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Subprogram_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Subprogram_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Subprogram_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Subprogram_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Subprogram_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_declarative_item(s)
	}
}

func (s *Subprogram_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_declarative_item(s)
	}
}

func (p *vhdlParser) Subprogram_declarative_item() (localctx ISubprogram_declarative_itemContext) {
	this := p
	_ = this

	localctx = NewSubprogram_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, vhdlParserRULE_subprogram_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2389)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2376)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2377)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2378)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2379)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2380)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2381)
			p.Variable_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2382)
			p.File_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2383)
			p.Alias_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2384)
			p.Attribute_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2385)
			p.Attribute_specification()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2386)
			p.Use_clause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2387)
			p.Group_template_declaration()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2388)
			p.Group_declaration()
		}

	}

	return localctx
}

// ISubprogram_declarative_partContext is an interface to support dynamic dispatch.
type ISubprogram_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_declarative_partContext differentiates from other interfaces.
	IsSubprogram_declarative_partContext()
}

type Subprogram_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_declarative_partContext() *Subprogram_declarative_partContext {
	var p = new(Subprogram_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_declarative_part
	return p
}

func (*Subprogram_declarative_partContext) IsSubprogram_declarative_partContext() {}

func NewSubprogram_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_declarative_partContext {
	var p = new(Subprogram_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_declarative_part

	return p
}

func (s *Subprogram_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_declarative_partContext) AllSubprogram_declarative_item() []ISubprogram_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubprogram_declarative_itemContext)(nil)).Elem())
	var tst = make([]ISubprogram_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubprogram_declarative_itemContext)
		}
	}

	return tst
}

func (s *Subprogram_declarative_partContext) Subprogram_declarative_item(i int) ISubprogram_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarative_itemContext)
}

func (s *Subprogram_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_declarative_part(s)
	}
}

func (s *Subprogram_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_declarative_part(s)
	}
}

func (p *vhdlParser) Subprogram_declarative_part() (localctx ISubprogram_declarative_partContext) {
	this := p
	_ = this

	localctx = NewSubprogram_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, vhdlParserRULE_subprogram_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2394)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || _la == vhdlParserGROUP || _la == vhdlParserIMPURE || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSUBTYPE-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(2391)
			p.Subprogram_declarative_item()
		}

		p.SetState(2396)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubprogram_kindContext is an interface to support dynamic dispatch.
type ISubprogram_kindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_kindContext differentiates from other interfaces.
	IsSubprogram_kindContext()
}

type Subprogram_kindContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_kindContext() *Subprogram_kindContext {
	var p = new(Subprogram_kindContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_kind
	return p
}

func (*Subprogram_kindContext) IsSubprogram_kindContext() {}

func NewSubprogram_kindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_kindContext {
	var p = new(Subprogram_kindContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_kind

	return p
}

func (s *Subprogram_kindContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_kindContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCEDURE, 0)
}

func (s *Subprogram_kindContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(vhdlParserFUNCTION, 0)
}

func (s *Subprogram_kindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_kindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_kindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_kind(s)
	}
}

func (s *Subprogram_kindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_kind(s)
	}
}

func (p *vhdlParser) Subprogram_kind() (localctx ISubprogram_kindContext) {
	this := p
	_ = this

	localctx = NewSubprogram_kindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, vhdlParserRULE_subprogram_kind)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2397)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserFUNCTION || _la == vhdlParserPROCEDURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISubprogram_specificationContext is an interface to support dynamic dispatch.
type ISubprogram_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_specificationContext differentiates from other interfaces.
	IsSubprogram_specificationContext()
}

type Subprogram_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_specificationContext() *Subprogram_specificationContext {
	var p = new(Subprogram_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_specification
	return p
}

func (*Subprogram_specificationContext) IsSubprogram_specificationContext() {}

func NewSubprogram_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_specificationContext {
	var p = new(Subprogram_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_specification

	return p
}

func (s *Subprogram_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_specificationContext) Procedure_specification() IProcedure_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_specificationContext)
}

func (s *Subprogram_specificationContext) Function_specification() IFunction_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_specificationContext)
}

func (s *Subprogram_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_specification(s)
	}
}

func (s *Subprogram_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_specification(s)
	}
}

func (p *vhdlParser) Subprogram_specification() (localctx ISubprogram_specificationContext) {
	this := p
	_ = this

	localctx = NewSubprogram_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, vhdlParserRULE_subprogram_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2401)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserPROCEDURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2399)
			p.Procedure_specification()
		}

	case vhdlParserFUNCTION, vhdlParserIMPURE, vhdlParserPURE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2400)
			p.Function_specification()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedure_specificationContext is an interface to support dynamic dispatch.
type IProcedure_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedure_specificationContext differentiates from other interfaces.
	IsProcedure_specificationContext()
}

type Procedure_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_specificationContext() *Procedure_specificationContext {
	var p = new(Procedure_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedure_specification
	return p
}

func (*Procedure_specificationContext) IsProcedure_specificationContext() {}

func NewProcedure_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_specificationContext {
	var p = new(Procedure_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedure_specification

	return p
}

func (s *Procedure_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_specificationContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCEDURE, 0)
}

func (s *Procedure_specificationContext) Designator() IDesignatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *Procedure_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Procedure_specificationContext) Formal_parameter_list() IFormal_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_parameter_listContext)
}

func (s *Procedure_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Procedure_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedure_specification(s)
	}
}

func (s *Procedure_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedure_specification(s)
	}
}

func (p *vhdlParser) Procedure_specification() (localctx IProcedure_specificationContext) {
	this := p
	_ = this

	localctx = NewProcedure_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, vhdlParserRULE_procedure_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2403)
		p.Match(vhdlParserPROCEDURE)
	}
	{
		p.SetState(2404)
		p.Designator()
	}
	p.SetState(2409)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(2405)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(2406)
			p.Formal_parameter_list()
		}
		{
			p.SetState(2407)
			p.Match(vhdlParserRPAREN)
		}

	}

	return localctx
}

// IFunction_specificationContext is an interface to support dynamic dispatch.
type IFunction_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_specificationContext differentiates from other interfaces.
	IsFunction_specificationContext()
}

type Function_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_specificationContext() *Function_specificationContext {
	var p = new(Function_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_function_specification
	return p
}

func (*Function_specificationContext) IsFunction_specificationContext() {}

func NewFunction_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_specificationContext {
	var p = new(Function_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_function_specification

	return p
}

func (s *Function_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_specificationContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(vhdlParserFUNCTION, 0)
}

func (s *Function_specificationContext) Designator() IDesignatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *Function_specificationContext) RETURN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRETURN, 0)
}

func (s *Function_specificationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Function_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Function_specificationContext) Formal_parameter_list() IFormal_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_parameter_listContext)
}

func (s *Function_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Function_specificationContext) PURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPURE, 0)
}

func (s *Function_specificationContext) IMPURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserIMPURE, 0)
}

func (s *Function_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFunction_specification(s)
	}
}

func (s *Function_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFunction_specification(s)
	}
}

func (p *vhdlParser) Function_specification() (localctx IFunction_specificationContext) {
	this := p
	_ = this

	localctx = NewFunction_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, vhdlParserRULE_function_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIMPURE || _la == vhdlParserPURE {
		{
			p.SetState(2411)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vhdlParserIMPURE || _la == vhdlParserPURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2414)
		p.Match(vhdlParserFUNCTION)
	}
	{
		p.SetState(2415)
		p.Designator()
	}
	p.SetState(2420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(2416)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(2417)
			p.Formal_parameter_list()
		}
		{
			p.SetState(2418)
			p.Match(vhdlParserRPAREN)
		}

	}
	{
		p.SetState(2422)
		p.Match(vhdlParserRETURN)
	}
	{
		p.SetState(2423)
		p.Subtype_indication()
	}

	return localctx
}

// ISubprogram_statement_partContext is an interface to support dynamic dispatch.
type ISubprogram_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_statement_partContext differentiates from other interfaces.
	IsSubprogram_statement_partContext()
}

type Subprogram_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_statement_partContext() *Subprogram_statement_partContext {
	var p = new(Subprogram_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_statement_part
	return p
}

func (*Subprogram_statement_partContext) IsSubprogram_statement_partContext() {}

func NewSubprogram_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_statement_partContext {
	var p = new(Subprogram_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_statement_part

	return p
}

func (s *Subprogram_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_statement_partContext) AllSequential_statement() []ISequential_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem())
	var tst = make([]ISequential_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequential_statementContext)
		}
	}

	return tst
}

func (s *Subprogram_statement_partContext) Sequential_statement(i int) ISequential_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequential_statementContext)
}

func (s *Subprogram_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_statement_part(s)
	}
}

func (s *Subprogram_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_statement_part(s)
	}
}

func (p *vhdlParser) Subprogram_statement_part() (localctx ISubprogram_statement_partContext) {
	this := p
	_ = this

	localctx = NewSubprogram_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, vhdlParserRULE_subprogram_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE)|(1<<vhdlParserEXIT)|(1<<vhdlParserFOR))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserLOOP-36))|(1<<(vhdlParserNEXT-36))|(1<<(vhdlParserNULL_-36)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(vhdlParserREPORT-79))|(1<<(vhdlParserRETURN-79))|(1<<(vhdlParserWAIT-79))|(1<<(vhdlParserWHILE-79)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserSTRING_LITERAL-118))|(1<<(vhdlParserLPAREN-118)))) != 0) {
		{
			p.SetState(2425)
			p.Sequential_statement()
		}

		p.SetState(2430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubtype_declarationContext is an interface to support dynamic dispatch.
type ISubtype_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtype_declarationContext differentiates from other interfaces.
	IsSubtype_declarationContext()
}

type Subtype_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtype_declarationContext() *Subtype_declarationContext {
	var p = new(Subtype_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subtype_declaration
	return p
}

func (*Subtype_declarationContext) IsSubtype_declarationContext() {}

func NewSubtype_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subtype_declarationContext {
	var p = new(Subtype_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subtype_declaration

	return p
}

func (s *Subtype_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subtype_declarationContext) SUBTYPE() antlr.TerminalNode {
	return s.GetToken(vhdlParserSUBTYPE, 0)
}

func (s *Subtype_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Subtype_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Subtype_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Subtype_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Subtype_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subtype_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subtype_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubtype_declaration(s)
	}
}

func (s *Subtype_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubtype_declaration(s)
	}
}

func (p *vhdlParser) Subtype_declaration() (localctx ISubtype_declarationContext) {
	this := p
	_ = this

	localctx = NewSubtype_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, vhdlParserRULE_subtype_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2431)
		p.Match(vhdlParserSUBTYPE)
	}
	{
		p.SetState(2432)
		p.Identifier()
	}
	{
		p.SetState(2433)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(2434)
		p.Subtype_indication()
	}
	{
		p.SetState(2435)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubtype_indicationContext is an interface to support dynamic dispatch.
type ISubtype_indicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtype_indicationContext differentiates from other interfaces.
	IsSubtype_indicationContext()
}

type Subtype_indicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtype_indicationContext() *Subtype_indicationContext {
	var p = new(Subtype_indicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subtype_indication
	return p
}

func (*Subtype_indicationContext) IsSubtype_indicationContext() {}

func NewSubtype_indicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subtype_indicationContext {
	var p = new(Subtype_indicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subtype_indication

	return p
}

func (s *Subtype_indicationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subtype_indicationContext) AllSelected_name() []ISelected_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem())
	var tst = make([]ISelected_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelected_nameContext)
		}
	}

	return tst
}

func (s *Subtype_indicationContext) Selected_name(i int) ISelected_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelected_nameContext)
}

func (s *Subtype_indicationContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *Subtype_indicationContext) Tolerance_aspect() ITolerance_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITolerance_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITolerance_aspectContext)
}

func (s *Subtype_indicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subtype_indicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subtype_indicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubtype_indication(s)
	}
}

func (s *Subtype_indicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubtype_indication(s)
	}
}

func (p *vhdlParser) Subtype_indication() (localctx ISubtype_indicationContext) {
	this := p
	_ = this

	localctx = NewSubtype_indicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, vhdlParserRULE_subtype_indication)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2437)
		p.Selected_name()
	}
	p.SetState(2439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2438)
			p.Selected_name()
		}

	}
	p.SetState(2442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserRANGE || _la == vhdlParserLPAREN {
		{
			p.SetState(2441)
			p.Constraint()
		}

	}
	p.SetState(2445)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 272, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2444)
			p.Tolerance_aspect()
		}

	}

	return localctx
}

// ISuffixContext is an interface to support dynamic dispatch.
type ISuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuffixContext differentiates from other interfaces.
	IsSuffixContext()
}

type SuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuffixContext() *SuffixContext {
	var p = new(SuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_suffix
	return p
}

func (*SuffixContext) IsSuffixContext() {}

func NewSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuffixContext {
	var p = new(SuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_suffix

	return p
}

func (s *SuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *SuffixContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SuffixContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *SuffixContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *SuffixContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *SuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSuffix(s)
	}
}

func (s *SuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSuffix(s)
	}
}

func (p *vhdlParser) Suffix() (localctx ISuffixContext) {
	this := p
	_ = this

	localctx = NewSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, vhdlParserRULE_suffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2451)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2447)
			p.Identifier()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2448)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2449)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2450)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_target
	return p
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TargetContext) Aggregate() IAggregateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTarget(s)
	}
}

func (s *TargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTarget(s)
	}
}

func (p *vhdlParser) Target() (localctx ITargetContext) {
	this := p
	_ = this

	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, vhdlParserRULE_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2455)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2453)
			p.Name()
		}

	case vhdlParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2454)
			p.Aggregate()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) AllFactor() []IFactorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFactorContext)(nil)).Elem())
	var tst = make([]IFactorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFactorContext)
		}
	}

	return tst
}

func (s *TermContext) Factor(i int) IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *TermContext) AllMultiplying_operator() []IMultiplying_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplying_operatorContext)(nil)).Elem())
	var tst = make([]IMultiplying_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplying_operatorContext)
		}
	}

	return tst
}

func (s *TermContext) Multiplying_operator(i int) IMultiplying_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplying_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplying_operatorContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *vhdlParser) Term() (localctx ITermContext) {
	this := p
	_ = this

	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, vhdlParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2457)
		p.Factor()
	}
	p.SetState(2463)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 275, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2458)
				p.Multiplying_operator()
			}
			{
				p.SetState(2459)
				p.Factor()
			}

		}
		p.SetState(2465)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 275, p.GetParserRuleContext())
	}

	return localctx
}

// ITerminal_aspectContext is an interface to support dynamic dispatch.
type ITerminal_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminal_aspectContext differentiates from other interfaces.
	IsTerminal_aspectContext()
}

type Terminal_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminal_aspectContext() *Terminal_aspectContext {
	var p = new(Terminal_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_terminal_aspect
	return p
}

func (*Terminal_aspectContext) IsTerminal_aspectContext() {}

func NewTerminal_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Terminal_aspectContext {
	var p = new(Terminal_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_terminal_aspect

	return p
}

func (s *Terminal_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Terminal_aspectContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Terminal_aspectContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Terminal_aspectContext) TO() antlr.TerminalNode {
	return s.GetToken(vhdlParserTO, 0)
}

func (s *Terminal_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Terminal_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Terminal_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTerminal_aspect(s)
	}
}

func (s *Terminal_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTerminal_aspect(s)
	}
}

func (p *vhdlParser) Terminal_aspect() (localctx ITerminal_aspectContext) {
	this := p
	_ = this

	localctx = NewTerminal_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, vhdlParserRULE_terminal_aspect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2466)
		p.Name()
	}
	p.SetState(2469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTO {
		{
			p.SetState(2467)
			p.Match(vhdlParserTO)
		}
		{
			p.SetState(2468)
			p.Name()
		}

	}

	return localctx
}

// ITerminal_declarationContext is an interface to support dynamic dispatch.
type ITerminal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminal_declarationContext differentiates from other interfaces.
	IsTerminal_declarationContext()
}

type Terminal_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminal_declarationContext() *Terminal_declarationContext {
	var p = new(Terminal_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_terminal_declaration
	return p
}

func (*Terminal_declarationContext) IsTerminal_declarationContext() {}

func NewTerminal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Terminal_declarationContext {
	var p = new(Terminal_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_terminal_declaration

	return p
}

func (s *Terminal_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Terminal_declarationContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserTERMINAL, 0)
}

func (s *Terminal_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Terminal_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Terminal_declarationContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Terminal_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Terminal_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Terminal_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Terminal_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTerminal_declaration(s)
	}
}

func (s *Terminal_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTerminal_declaration(s)
	}
}

func (p *vhdlParser) Terminal_declaration() (localctx ITerminal_declarationContext) {
	this := p
	_ = this

	localctx = NewTerminal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, vhdlParserRULE_terminal_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2471)
		p.Match(vhdlParserTERMINAL)
	}
	{
		p.SetState(2472)
		p.Identifier_list()
	}
	{
		p.SetState(2473)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2474)
		p.Subnature_indication()
	}
	{
		p.SetState(2475)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IThrough_aspectContext is an interface to support dynamic dispatch.
type IThrough_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrough_aspectContext differentiates from other interfaces.
	IsThrough_aspectContext()
}

type Through_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrough_aspectContext() *Through_aspectContext {
	var p = new(Through_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_through_aspect
	return p
}

func (*Through_aspectContext) IsThrough_aspectContext() {}

func NewThrough_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Through_aspectContext {
	var p = new(Through_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_through_aspect

	return p
}

func (s *Through_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Through_aspectContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Through_aspectContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(vhdlParserTHROUGH, 0)
}

func (s *Through_aspectContext) Tolerance_aspect() ITolerance_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITolerance_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITolerance_aspectContext)
}

func (s *Through_aspectContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Through_aspectContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Through_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Through_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Through_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterThrough_aspect(s)
	}
}

func (s *Through_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitThrough_aspect(s)
	}
}

func (p *vhdlParser) Through_aspect() (localctx IThrough_aspectContext) {
	this := p
	_ = this

	localctx = NewThrough_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, vhdlParserRULE_through_aspect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2477)
		p.Identifier_list()
	}
	p.SetState(2479)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTOLERANCE {
		{
			p.SetState(2478)
			p.Tolerance_aspect()
		}

	}
	p.SetState(2483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(2481)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(2482)
			p.Expression()
		}

	}
	{
		p.SetState(2485)
		p.Match(vhdlParserTHROUGH)
	}

	return localctx
}

// ITimeout_clauseContext is an interface to support dynamic dispatch.
type ITimeout_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeout_clauseContext differentiates from other interfaces.
	IsTimeout_clauseContext()
}

type Timeout_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeout_clauseContext() *Timeout_clauseContext {
	var p = new(Timeout_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_timeout_clause
	return p
}

func (*Timeout_clauseContext) IsTimeout_clauseContext() {}

func NewTimeout_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timeout_clauseContext {
	var p = new(Timeout_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_timeout_clause

	return p
}

func (s *Timeout_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Timeout_clauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Timeout_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Timeout_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timeout_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timeout_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTimeout_clause(s)
	}
}

func (s *Timeout_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTimeout_clause(s)
	}
}

func (p *vhdlParser) Timeout_clause() (localctx ITimeout_clauseContext) {
	this := p
	_ = this

	localctx = NewTimeout_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, vhdlParserRULE_timeout_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2487)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(2488)
		p.Expression()
	}

	return localctx
}

// ITolerance_aspectContext is an interface to support dynamic dispatch.
type ITolerance_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTolerance_aspectContext differentiates from other interfaces.
	IsTolerance_aspectContext()
}

type Tolerance_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTolerance_aspectContext() *Tolerance_aspectContext {
	var p = new(Tolerance_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_tolerance_aspect
	return p
}

func (*Tolerance_aspectContext) IsTolerance_aspectContext() {}

func NewTolerance_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tolerance_aspectContext {
	var p = new(Tolerance_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_tolerance_aspect

	return p
}

func (s *Tolerance_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Tolerance_aspectContext) TOLERANCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTOLERANCE, 0)
}

func (s *Tolerance_aspectContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Tolerance_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tolerance_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tolerance_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTolerance_aspect(s)
	}
}

func (s *Tolerance_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTolerance_aspect(s)
	}
}

func (p *vhdlParser) Tolerance_aspect() (localctx ITolerance_aspectContext) {
	this := p
	_ = this

	localctx = NewTolerance_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, vhdlParserRULE_tolerance_aspect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2490)
		p.Match(vhdlParserTOLERANCE)
	}
	{
		p.SetState(2491)
		p.Expression()
	}

	return localctx
}

// IType_declarationContext is an interface to support dynamic dispatch.
type IType_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_declarationContext differentiates from other interfaces.
	IsType_declarationContext()
}

type Type_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declarationContext() *Type_declarationContext {
	var p = new(Type_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_type_declaration
	return p
}

func (*Type_declarationContext) IsType_declarationContext() {}

func NewType_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declarationContext {
	var p = new(Type_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_type_declaration

	return p
}

func (s *Type_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTYPE, 0)
}

func (s *Type_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Type_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Type_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Type_declarationContext) Type_definition() IType_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_definitionContext)
}

func (s *Type_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterType_declaration(s)
	}
}

func (s *Type_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitType_declaration(s)
	}
}

func (p *vhdlParser) Type_declaration() (localctx IType_declarationContext) {
	this := p
	_ = this

	localctx = NewType_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, vhdlParserRULE_type_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2493)
		p.Match(vhdlParserTYPE)
	}
	{
		p.SetState(2494)
		p.Identifier()
	}
	p.SetState(2497)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(2495)
			p.Match(vhdlParserIS)
		}
		{
			p.SetState(2496)
			p.Type_definition()
		}

	}
	{
		p.SetState(2499)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IType_definitionContext is an interface to support dynamic dispatch.
type IType_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_definitionContext differentiates from other interfaces.
	IsType_definitionContext()
}

type Type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_definitionContext() *Type_definitionContext {
	var p = new(Type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_type_definition
	return p
}

func (*Type_definitionContext) IsType_definitionContext() {}

func NewType_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_definitionContext {
	var p = new(Type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_type_definition

	return p
}

func (s *Type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_definitionContext) Scalar_type_definition() IScalar_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScalar_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScalar_type_definitionContext)
}

func (s *Type_definitionContext) Composite_type_definition() IComposite_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComposite_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComposite_type_definitionContext)
}

func (s *Type_definitionContext) Access_type_definition() IAccess_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_type_definitionContext)
}

func (s *Type_definitionContext) File_type_definition() IFile_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_type_definitionContext)
}

func (s *Type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterType_definition(s)
	}
}

func (s *Type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitType_definition(s)
	}
}

func (p *vhdlParser) Type_definition() (localctx IType_definitionContext) {
	this := p
	_ = this

	localctx = NewType_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, vhdlParserRULE_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2505)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserRANGE, vhdlParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2501)
			p.Scalar_type_definition()
		}

	case vhdlParserARRAY, vhdlParserRECORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2502)
			p.Composite_type_definition()
		}

	case vhdlParserACCESS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2503)
			p.Access_type_definition()
		}

	case vhdlParserFILE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2504)
			p.File_type_definition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnconstrained_array_definitionContext is an interface to support dynamic dispatch.
type IUnconstrained_array_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnconstrained_array_definitionContext differentiates from other interfaces.
	IsUnconstrained_array_definitionContext()
}

type Unconstrained_array_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnconstrained_array_definitionContext() *Unconstrained_array_definitionContext {
	var p = new(Unconstrained_array_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_unconstrained_array_definition
	return p
}

func (*Unconstrained_array_definitionContext) IsUnconstrained_array_definitionContext() {}

func NewUnconstrained_array_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unconstrained_array_definitionContext {
	var p = new(Unconstrained_array_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_unconstrained_array_definition

	return p
}

func (s *Unconstrained_array_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unconstrained_array_definitionContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(vhdlParserARRAY, 0)
}

func (s *Unconstrained_array_definitionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Unconstrained_array_definitionContext) AllIndex_subtype_definition() []IIndex_subtype_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndex_subtype_definitionContext)(nil)).Elem())
	var tst = make([]IIndex_subtype_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndex_subtype_definitionContext)
		}
	}

	return tst
}

func (s *Unconstrained_array_definitionContext) Index_subtype_definition(i int) IIndex_subtype_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_subtype_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndex_subtype_definitionContext)
}

func (s *Unconstrained_array_definitionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Unconstrained_array_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Unconstrained_array_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Unconstrained_array_definitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Unconstrained_array_definitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Unconstrained_array_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unconstrained_array_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unconstrained_array_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterUnconstrained_array_definition(s)
	}
}

func (s *Unconstrained_array_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitUnconstrained_array_definition(s)
	}
}

func (p *vhdlParser) Unconstrained_array_definition() (localctx IUnconstrained_array_definitionContext) {
	this := p
	_ = this

	localctx = NewUnconstrained_array_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, vhdlParserRULE_unconstrained_array_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2507)
		p.Match(vhdlParserARRAY)
	}
	{
		p.SetState(2508)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(2509)
		p.Index_subtype_definition()
	}
	p.SetState(2514)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2510)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2511)
			p.Index_subtype_definition()
		}

		p.SetState(2516)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2517)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(2518)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(2519)
		p.Subtype_indication()
	}

	return localctx
}

// IUnconstrained_nature_definitionContext is an interface to support dynamic dispatch.
type IUnconstrained_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnconstrained_nature_definitionContext differentiates from other interfaces.
	IsUnconstrained_nature_definitionContext()
}

type Unconstrained_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnconstrained_nature_definitionContext() *Unconstrained_nature_definitionContext {
	var p = new(Unconstrained_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_unconstrained_nature_definition
	return p
}

func (*Unconstrained_nature_definitionContext) IsUnconstrained_nature_definitionContext() {}

func NewUnconstrained_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unconstrained_nature_definitionContext {
	var p = new(Unconstrained_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_unconstrained_nature_definition

	return p
}

func (s *Unconstrained_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unconstrained_nature_definitionContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(vhdlParserARRAY, 0)
}

func (s *Unconstrained_nature_definitionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Unconstrained_nature_definitionContext) AllIndex_subtype_definition() []IIndex_subtype_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndex_subtype_definitionContext)(nil)).Elem())
	var tst = make([]IIndex_subtype_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndex_subtype_definitionContext)
		}
	}

	return tst
}

func (s *Unconstrained_nature_definitionContext) Index_subtype_definition(i int) IIndex_subtype_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_subtype_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndex_subtype_definitionContext)
}

func (s *Unconstrained_nature_definitionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Unconstrained_nature_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Unconstrained_nature_definitionContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Unconstrained_nature_definitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Unconstrained_nature_definitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Unconstrained_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unconstrained_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unconstrained_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterUnconstrained_nature_definition(s)
	}
}

func (s *Unconstrained_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitUnconstrained_nature_definition(s)
	}
}

func (p *vhdlParser) Unconstrained_nature_definition() (localctx IUnconstrained_nature_definitionContext) {
	this := p
	_ = this

	localctx = NewUnconstrained_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, vhdlParserRULE_unconstrained_nature_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2521)
		p.Match(vhdlParserARRAY)
	}
	{
		p.SetState(2522)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(2523)
		p.Index_subtype_definition()
	}
	p.SetState(2528)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2524)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2525)
			p.Index_subtype_definition()
		}

		p.SetState(2530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2531)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(2532)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(2533)
		p.Subnature_indication()
	}

	return localctx
}

// IUse_clauseContext is an interface to support dynamic dispatch.
type IUse_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUse_clauseContext differentiates from other interfaces.
	IsUse_clauseContext()
}

type Use_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_clauseContext() *Use_clauseContext {
	var p = new(Use_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_use_clause
	return p
}

func (*Use_clauseContext) IsUse_clauseContext() {}

func NewUse_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_clauseContext {
	var p = new(Use_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_use_clause

	return p
}

func (s *Use_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_clauseContext) USE() antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, 0)
}

func (s *Use_clauseContext) AllSelected_name() []ISelected_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem())
	var tst = make([]ISelected_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelected_nameContext)
		}
	}

	return tst
}

func (s *Use_clauseContext) Selected_name(i int) ISelected_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelected_nameContext)
}

func (s *Use_clauseContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Use_clauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Use_clauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Use_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterUse_clause(s)
	}
}

func (s *Use_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitUse_clause(s)
	}
}

func (p *vhdlParser) Use_clause() (localctx IUse_clauseContext) {
	this := p
	_ = this

	localctx = NewUse_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, vhdlParserRULE_use_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2535)
		p.Match(vhdlParserUSE)
	}
	{
		p.SetState(2536)
		p.Selected_name()
	}
	p.SetState(2541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2537)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2538)
			p.Selected_name()
		}

		p.SetState(2543)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2544)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IVariable_assignment_statementContext is an interface to support dynamic dispatch.
type IVariable_assignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_assignment_statementContext differentiates from other interfaces.
	IsVariable_assignment_statementContext()
}

type Variable_assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_assignment_statementContext() *Variable_assignment_statementContext {
	var p = new(Variable_assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_variable_assignment_statement
	return p
}

func (*Variable_assignment_statementContext) IsVariable_assignment_statementContext() {}

func NewVariable_assignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_assignment_statementContext {
	var p = new(Variable_assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_variable_assignment_statement

	return p
}

func (s *Variable_assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_assignment_statementContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Variable_assignment_statementContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Variable_assignment_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_assignment_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Variable_assignment_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Variable_assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterVariable_assignment_statement(s)
	}
}

func (s *Variable_assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitVariable_assignment_statement(s)
	}
}

func (p *vhdlParser) Variable_assignment_statement() (localctx IVariable_assignment_statementContext) {
	this := p
	_ = this

	localctx = NewVariable_assignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, vhdlParserRULE_variable_assignment_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2547)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2546)
			p.Label_colon()
		}

	}
	{
		p.SetState(2549)
		p.Target()
	}
	{
		p.SetState(2550)
		p.Match(vhdlParserVARASGN)
	}
	{
		p.SetState(2551)
		p.Expression()
	}
	{
		p.SetState(2552)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IVariable_declarationContext is an interface to support dynamic dispatch.
type IVariable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_declarationContext differentiates from other interfaces.
	IsVariable_declarationContext()
}

type Variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_declarationContext() *Variable_declarationContext {
	var p = new(Variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_variable_declaration
	return p
}

func (*Variable_declarationContext) IsVariable_declarationContext() {}

func NewVariable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_declarationContext {
	var p = new(Variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_variable_declaration

	return p
}

func (s *Variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_declarationContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARIABLE, 0)
}

func (s *Variable_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Variable_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Variable_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Variable_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Variable_declarationContext) SHARED() antlr.TerminalNode {
	return s.GetToken(vhdlParserSHARED, 0)
}

func (s *Variable_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Variable_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterVariable_declaration(s)
	}
}

func (s *Variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitVariable_declaration(s)
	}
}

func (p *vhdlParser) Variable_declaration() (localctx IVariable_declarationContext) {
	this := p
	_ = this

	localctx = NewVariable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, vhdlParserRULE_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2555)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserSHARED {
		{
			p.SetState(2554)
			p.Match(vhdlParserSHARED)
		}

	}
	{
		p.SetState(2557)
		p.Match(vhdlParserVARIABLE)
	}
	{
		p.SetState(2558)
		p.Identifier_list()
	}
	{
		p.SetState(2559)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2560)
		p.Subtype_indication()
	}
	p.SetState(2563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(2561)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(2562)
			p.Expression()
		}

	}
	{
		p.SetState(2565)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IWait_statementContext is an interface to support dynamic dispatch.
type IWait_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWait_statementContext differentiates from other interfaces.
	IsWait_statementContext()
}

type Wait_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWait_statementContext() *Wait_statementContext {
	var p = new(Wait_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_wait_statement
	return p
}

func (*Wait_statementContext) IsWait_statementContext() {}

func NewWait_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wait_statementContext {
	var p = new(Wait_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_wait_statement

	return p
}

func (s *Wait_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Wait_statementContext) WAIT() antlr.TerminalNode {
	return s.GetToken(vhdlParserWAIT, 0)
}

func (s *Wait_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Wait_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Wait_statementContext) Sensitivity_clause() ISensitivity_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISensitivity_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISensitivity_clauseContext)
}

func (s *Wait_statementContext) Condition_clause() ICondition_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICondition_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICondition_clauseContext)
}

func (s *Wait_statementContext) Timeout_clause() ITimeout_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeout_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeout_clauseContext)
}

func (s *Wait_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wait_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wait_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterWait_statement(s)
	}
}

func (s *Wait_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitWait_statement(s)
	}
}

func (p *vhdlParser) Wait_statement() (localctx IWait_statementContext) {
	this := p
	_ = this

	localctx = NewWait_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, vhdlParserRULE_wait_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2567)
			p.Label_colon()
		}

	}
	{
		p.SetState(2570)
		p.Match(vhdlParserWAIT)
	}
	p.SetState(2572)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserON {
		{
			p.SetState(2571)
			p.Sensitivity_clause()
		}

	}
	p.SetState(2575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserUNTIL {
		{
			p.SetState(2574)
			p.Condition_clause()
		}

	}
	p.SetState(2578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR {
		{
			p.SetState(2577)
			p.Timeout_clause()
		}

	}
	{
		p.SetState(2580)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IWaveformContext is an interface to support dynamic dispatch.
type IWaveformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWaveformContext differentiates from other interfaces.
	IsWaveformContext()
}

type WaveformContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaveformContext() *WaveformContext {
	var p = new(WaveformContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_waveform
	return p
}

func (*WaveformContext) IsWaveformContext() {}

func NewWaveformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaveformContext {
	var p = new(WaveformContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_waveform

	return p
}

func (s *WaveformContext) GetParser() antlr.Parser { return s.parser }

func (s *WaveformContext) AllWaveform_element() []IWaveform_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWaveform_elementContext)(nil)).Elem())
	var tst = make([]IWaveform_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWaveform_elementContext)
		}
	}

	return tst
}

func (s *WaveformContext) Waveform_element(i int) IWaveform_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaveform_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWaveform_elementContext)
}

func (s *WaveformContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *WaveformContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *WaveformContext) UNAFFECTED() antlr.TerminalNode {
	return s.GetToken(vhdlParserUNAFFECTED, 0)
}

func (s *WaveformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaveformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaveformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterWaveform(s)
	}
}

func (s *WaveformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitWaveform(s)
	}
}

func (p *vhdlParser) Waveform() (localctx IWaveformContext) {
	this := p
	_ = this

	localctx = NewWaveformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, vhdlParserRULE_waveform)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2591)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserABS, vhdlParserNEW, vhdlParserNOT, vhdlParserNULL_, vhdlParserBASE_LITERAL, vhdlParserBIT_STRING_LITERAL, vhdlParserREAL_LITERAL, vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL, vhdlParserSTRING_LITERAL, vhdlParserLPAREN, vhdlParserPLUS, vhdlParserMINUS, vhdlParserINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2582)
			p.Waveform_element()
		}
		p.SetState(2587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(2583)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(2584)
				p.Waveform_element()
			}

			p.SetState(2589)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserUNAFFECTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2590)
			p.Match(vhdlParserUNAFFECTED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWaveform_elementContext is an interface to support dynamic dispatch.
type IWaveform_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWaveform_elementContext differentiates from other interfaces.
	IsWaveform_elementContext()
}

type Waveform_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaveform_elementContext() *Waveform_elementContext {
	var p = new(Waveform_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_waveform_element
	return p
}

func (*Waveform_elementContext) IsWaveform_elementContext() {}

func NewWaveform_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Waveform_elementContext {
	var p = new(Waveform_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_waveform_element

	return p
}

func (s *Waveform_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Waveform_elementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Waveform_elementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Waveform_elementContext) AFTER() antlr.TerminalNode {
	return s.GetToken(vhdlParserAFTER, 0)
}

func (s *Waveform_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Waveform_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Waveform_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterWaveform_element(s)
	}
}

func (s *Waveform_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitWaveform_element(s)
	}
}

func (p *vhdlParser) Waveform_element() (localctx IWaveform_elementContext) {
	this := p
	_ = this

	localctx = NewWaveform_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, vhdlParserRULE_waveform_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2593)
		p.Expression()
	}
	p.SetState(2596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserAFTER {
		{
			p.SetState(2594)
			p.Match(vhdlParserAFTER)
		}
		{
			p.SetState(2595)
			p.Expression()
		}

	}

	return localctx
}
