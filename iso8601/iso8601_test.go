// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package iso8601_test contains tests for the iso8601 grammar.
// The tests should be run with the -timeout flag, to ensure the parser doesn't
// get stuck.
//
// Do not edit this file, it is generated by make.go
//
package iso8601_test

import (
	"bramp.net/antlr4/internal"
	"bramp.net/antlr4/iso8601"

	"fmt"
	"github.com/antlr/antlr4/runtime/Go/antlr"
	"path/filepath"
	"testing"
)

const MAX_TOKENS = 1000000

var examples = []string{
	"grammars-v4/iso8601/examples/b-1-1-cd-b.txt",
	"grammars-v4/iso8601/examples/b-1-1-cd-e.txt",
	"grammars-v4/iso8601/examples/b-1-1-cm.txt",
	"grammars-v4/iso8601/examples/b-1-1-cw-b.txt",
	"grammars-v4/iso8601/examples/b-1-1-cw-e.txt",
	"grammars-v4/iso8601/examples/b-1-1-cy.txt",
	"grammars-v4/iso8601/examples/b-1-1-ecd1-b.txt",
	"grammars-v4/iso8601/examples/b-1-1-ecd1-e.txt",
	"grammars-v4/iso8601/examples/b-1-1-ecd2-b.txt",
	"grammars-v4/iso8601/examples/b-1-1-ecd2-e.txt",
	"grammars-v4/iso8601/examples/b-1-1-od-b.txt",
	"grammars-v4/iso8601/examples/b-1-1-od-e.txt",
	"grammars-v4/iso8601/examples/b-1-1-wd-b.txt",
	"grammars-v4/iso8601/examples/b-1-1-wd-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-beginofday-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-beginofday-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-beginofdayhm-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-beginofdayhm-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-ltdf-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-ltdf-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-lth.txt",
	"grammars-v4/iso8601/examples/b-1-2-lthm-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-lthm-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-lthms-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-lthms-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-lttzh1-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-lttzh1-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-lttzh2-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-lttzh2-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-lttzhm1-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-lttzhm1-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-lttzhm2-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-lttzhm2-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-utch.txt",
	"grammars-v4/iso8601/examples/b-1-2-utchm-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-utchm-e.txt",
	"grammars-v4/iso8601/examples/b-1-2-utchms-b.txt",
	"grammars-v4/iso8601/examples/b-1-2-utchms-e.txt",
	"grammars-v4/iso8601/examples/b-1-3-cdlt-b.txt",
	"grammars-v4/iso8601/examples/b-1-3-cdlt-e.txt",
	"grammars-v4/iso8601/examples/b-1-3-odutc-b.txt",
	"grammars-v4/iso8601/examples/b-1-3-odutc-e.txt",
	"grammars-v4/iso8601/examples/b-1-3-wdlt-b.txt",
	"grammars-v4/iso8601/examples/b-1-3-wdlt-e.txt",
	"grammars-v4/iso8601/examples/b-1-4-dct1.txt",
	"grammars-v4/iso8601/examples/b-1-4-dct2.txt",
	"grammars-v4/iso8601/examples/b-1-4-dct3.txt",
	"grammars-v4/iso8601/examples/b-1-4-dcymd1-b.txt",
	"grammars-v4/iso8601/examples/b-1-4-dcymd1-e.txt",
	"grammars-v4/iso8601/examples/b-1-4-dcymd2.txt",
	"grammars-v4/iso8601/examples/b-1-4-de-b.txt",
	"grammars-v4/iso8601/examples/b-1-4-de-e.txt",
	"grammars-v4/iso8601/examples/b-1-4-sd-b.txt",
	"grammars-v4/iso8601/examples/b-1-4-sd-e.txt",
	"grammars-v4/iso8601/examples/b-1-4-se1-b.txt",
	"grammars-v4/iso8601/examples/b-1-4-se1-e.txt",
	"grammars-v4/iso8601/examples/b-1-4-se2-b.txt",
	"grammars-v4/iso8601/examples/b-1-4-se2-e.txt",
	"grammars-v4/iso8601/examples/b-1-5-rde-b.txt",
	"grammars-v4/iso8601/examples/b-1-5-rde-e.txt",
	"grammars-v4/iso8601/examples/b-1-5-t1.txt",
	"grammars-v4/iso8601/examples/b-1-5-t2.txt",
	"grammars-v4/iso8601/examples/b-1-5-t3.txt",
	"grammars-v4/iso8601/examples/b-1-5-ymd1-b.txt",
	"grammars-v4/iso8601/examples/b-1-5-ymd1-e.txt",
	"grammars-v4/iso8601/examples/b-1-5-ymd2.txt",
}

type exampleListener struct {
	*iso8601.Baseiso8601Listener
}

func (l *exampleListener) EnterEveryRule(ctx antlr.ParserRuleContext) {
	fmt.Println(ctx.GetText())
}
func Example() {
	// Setup the input
	is := antlr.NewInputStream("...some text to parse...")

	// Create the Lexer
	lexer := iso8601.Newiso8601Lexer(is)
	stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)

	// Create the Parser
	p := iso8601.Newiso8601Parser(stream)
	p.BuildParseTrees = true
	p.AddErrorListener(antlr.NewDiagnosticErrorListener(true))

	// Finally walk the tree
	tree := p.Iso()
	antlr.ParseTreeWalkerDefault.Walk(&exampleListener{}, tree)
}

func newCharStream(filename string) (antlr.CharStream, error) {
	var input antlr.CharStream
	input, err := antlr.NewFileStream(filepath.Join("..", filename))
	if err != nil {
		return nil, err
	}

	return input, nil
}

func TestIso8601Lexer(t *testing.T) {
	for _, file := range examples {
		input, err := newCharStream(file)
		if err != nil {
			t.Errorf("Failed to open example file: %s", err)
		}

		// Create the Lexer
		lexer := iso8601.Newiso8601Lexer(input)

		// Try and read all tokens
		i := 0
		for ; i < MAX_TOKENS; i++ {
			tok := lexer.NextToken()
			if tok.GetTokenType() == antlr.TokenEOF {
				break
			}
		}

		// If we read too many tokens, then perhaps there is a problem with the lexer.
		if i >= MAX_TOKENS {
			t.Errorf("Newiso8601Lexer(%q) read %d tokens without finding EOF", file, i)
		}
	}
}

func TestIso8601Parser(t *testing.T) {
	// TODO(bramp): Run this test with and without p.BuildParseTrees

	for _, file := range examples {
		input, err := newCharStream(file)
		if err != nil {
			t.Errorf("Failed to open example file: %s", err)
		}

		// Create the Lexer
		lexer := iso8601.Newiso8601Lexer(input)
		stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)

		// Create the Parser
		p := iso8601.Newiso8601Parser(stream)
		p.BuildParseTrees = true
		p.AddErrorListener(internal.NewTestingErrorListener(t, file))

		// Finally test
		p.Iso()

		// TODO(bramp): If there is a "file.tree", then compare the output
		// TODO(bramp): If there is a "file.errors", then check the error
	}
}
