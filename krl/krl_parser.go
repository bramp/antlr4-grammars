// Code generated from krl.g4 by ANTLR 4.9.3. DO NOT EDIT.

package krl // krl
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 112, 803,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 3, 2, 3, 2,
	5, 2, 131, 10, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 7, 3, 138, 10, 3, 12, 3,
	14, 3, 141, 11, 3, 3, 4, 3, 4, 5, 4, 145, 10, 4, 3, 5, 3, 5, 5, 5, 149,
	10, 5, 3, 6, 5, 6, 152, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 7, 3, 7, 3, 8, 5, 8, 164, 10, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8,
	3, 8, 3, 8, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 5, 10, 179, 10, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 7, 10, 185, 10, 10, 12, 10, 14, 10, 188, 11, 10, 3,
	11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 7, 12, 208, 10, 12, 12,
	12, 14, 12, 211, 11, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14,
	5, 14, 220, 10, 14, 3, 15, 5, 15, 223, 10, 15, 3, 15, 3, 15, 3, 15, 3,
	15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15, 235, 10, 15, 12, 15,
	14, 15, 238, 11, 15, 3, 16, 5, 16, 241, 10, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 7, 16, 248, 10, 16, 12, 16, 14, 16, 251, 11, 16, 3, 17, 3, 17,
	3, 18, 5, 18, 256, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 263,
	10, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 270, 10, 19, 3, 20, 5,
	20, 273, 10, 20, 3, 20, 5, 20, 276, 10, 20, 3, 20, 5, 20, 279, 10, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 285, 10, 20, 3, 20, 5, 20, 288, 10,
	20, 3, 21, 3, 21, 7, 21, 292, 10, 21, 12, 21, 14, 21, 295, 11, 21, 3, 22,
	3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 304, 10, 23, 3, 23, 3,
	23, 3, 23, 3, 24, 3, 24, 3, 24, 7, 24, 312, 10, 24, 12, 24, 14, 24, 315,
	11, 24, 3, 25, 3, 25, 3, 25, 3, 26, 3, 26, 3, 26, 3, 26, 7, 26, 324, 10,
	26, 12, 26, 14, 26, 327, 11, 26, 5, 26, 329, 10, 26, 3, 26, 3, 26, 3, 27,
	3, 27, 5, 27, 335, 10, 27, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 351, 10, 29,
	12, 29, 14, 29, 354, 11, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 5, 30, 365, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 7,
	31, 371, 10, 31, 12, 31, 14, 31, 374, 11, 31, 5, 31, 376, 10, 31, 3, 31,
	3, 31, 3, 32, 3, 32, 5, 32, 382, 10, 32, 3, 33, 3, 33, 3, 33, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 5, 35,
	398, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 406, 10,
	36, 5, 36, 408, 10, 36, 5, 36, 410, 10, 36, 5, 36, 412, 10, 36, 5, 36,
	414, 10, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 38, 7, 38, 421, 10, 38, 12,
	38, 14, 38, 424, 11, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 438, 10, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 457, 10, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 501, 10, 39, 3,
	39, 3, 39, 3, 39, 5, 39, 506, 10, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 517, 10, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 531,
	10, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 538, 10, 39, 5, 39, 540,
	10, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 547, 10, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 5, 39, 554, 10, 39, 3, 39, 5, 39, 557, 10, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 568,
	10, 39, 3, 39, 5, 39, 571, 10, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39,
	588, 10, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5,
	39, 598, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 7, 40, 606,
	10, 40, 12, 40, 14, 40, 609, 11, 40, 3, 40, 3, 40, 5, 40, 613, 10, 40,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 620, 10, 41, 3, 42, 7, 42, 623,
	10, 42, 12, 42, 14, 42, 626, 11, 42, 3, 42, 3, 42, 3, 42, 6, 42, 631, 10,
	42, 13, 42, 14, 42, 632, 3, 42, 3, 42, 3, 42, 5, 42, 638, 10, 42, 3, 43,
	3, 43, 3, 43, 3, 43, 7, 43, 644, 10, 43, 12, 43, 14, 43, 647, 11, 43, 3,
	43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45, 7, 45, 657, 10, 45,
	12, 45, 14, 45, 660, 11, 45, 3, 46, 3, 46, 3, 46, 7, 46, 665, 10, 46, 12,
	46, 14, 46, 668, 11, 46, 3, 47, 3, 47, 3, 47, 3, 47, 7, 47, 674, 10, 47,
	12, 47, 14, 47, 677, 11, 47, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 7, 49,
	684, 10, 49, 12, 49, 14, 49, 687, 11, 49, 3, 50, 3, 50, 3, 50, 7, 50, 692,
	10, 50, 12, 50, 14, 50, 695, 11, 50, 3, 51, 3, 51, 3, 51, 7, 51, 700, 10,
	51, 12, 51, 14, 51, 703, 11, 51, 3, 52, 3, 52, 3, 52, 7, 52, 708, 10, 52,
	12, 52, 14, 52, 711, 11, 52, 3, 53, 3, 53, 3, 53, 7, 53, 716, 10, 53, 12,
	53, 14, 53, 719, 11, 53, 3, 54, 3, 54, 3, 54, 7, 54, 724, 10, 54, 12, 54,
	14, 54, 727, 11, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55, 734, 10,
	55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 741, 10, 56, 3, 57, 3, 57,
	3, 57, 3, 57, 7, 57, 747, 10, 57, 12, 57, 14, 57, 750, 11, 57, 3, 57, 5,
	57, 753, 10, 57, 3, 57, 5, 57, 756, 10, 57, 3, 58, 3, 58, 3, 58, 3, 58,
	3, 59, 3, 59, 3, 59, 5, 59, 765, 10, 59, 3, 59, 5, 59, 768, 10, 59, 3,
	59, 3, 59, 3, 59, 5, 59, 773, 10, 59, 3, 59, 5, 59, 776, 10, 59, 5, 59,
	778, 10, 59, 3, 60, 3, 60, 3, 61, 3, 61, 3, 62, 3, 62, 5, 62, 786, 10,
	62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63,
	5, 63, 798, 10, 63, 3, 64, 3, 64, 3, 64, 3, 64, 2, 2, 65, 2, 4, 6, 8, 10,
	12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
	48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
	84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
	116, 118, 120, 122, 124, 126, 2, 12, 3, 2, 85, 86, 4, 2, 35, 36, 38, 38,
	3, 2, 43, 44, 3, 2, 14, 19, 4, 2, 31, 31, 83, 83, 4, 2, 32, 32, 103, 103,
	4, 2, 26, 26, 29, 29, 3, 2, 20, 21, 3, 2, 22, 23, 6, 2, 33, 33, 42, 42,
	75, 75, 88, 88, 2, 864, 2, 130, 3, 2, 2, 2, 4, 134, 3, 2, 2, 2, 6, 144,
	3, 2, 2, 2, 8, 148, 3, 2, 2, 2, 10, 151, 3, 2, 2, 2, 12, 160, 3, 2, 2,
	2, 14, 163, 3, 2, 2, 2, 16, 173, 3, 2, 2, 2, 18, 175, 3, 2, 2, 2, 20, 189,
	3, 2, 2, 2, 22, 209, 3, 2, 2, 2, 24, 212, 3, 2, 2, 2, 26, 219, 3, 2, 2,
	2, 28, 222, 3, 2, 2, 2, 30, 240, 3, 2, 2, 2, 32, 252, 3, 2, 2, 2, 34, 255,
	3, 2, 2, 2, 36, 264, 3, 2, 2, 2, 38, 272, 3, 2, 2, 2, 40, 293, 3, 2, 2,
	2, 42, 296, 3, 2, 2, 2, 44, 299, 3, 2, 2, 2, 46, 308, 3, 2, 2, 2, 48, 316,
	3, 2, 2, 2, 50, 319, 3, 2, 2, 2, 52, 332, 3, 2, 2, 2, 54, 336, 3, 2, 2,
	2, 56, 352, 3, 2, 2, 2, 58, 364, 3, 2, 2, 2, 60, 366, 3, 2, 2, 2, 62, 379,
	3, 2, 2, 2, 64, 383, 3, 2, 2, 2, 66, 386, 3, 2, 2, 2, 68, 395, 3, 2, 2,
	2, 70, 399, 3, 2, 2, 2, 72, 417, 3, 2, 2, 2, 74, 422, 3, 2, 2, 2, 76, 597,
	3, 2, 2, 2, 78, 599, 3, 2, 2, 2, 80, 614, 3, 2, 2, 2, 82, 624, 3, 2, 2,
	2, 84, 639, 3, 2, 2, 2, 86, 650, 3, 2, 2, 2, 88, 653, 3, 2, 2, 2, 90, 661,
	3, 2, 2, 2, 92, 669, 3, 2, 2, 2, 94, 678, 3, 2, 2, 2, 96, 680, 3, 2, 2,
	2, 98, 688, 3, 2, 2, 2, 100, 696, 3, 2, 2, 2, 102, 704, 3, 2, 2, 2, 104,
	712, 3, 2, 2, 2, 106, 720, 3, 2, 2, 2, 108, 733, 3, 2, 2, 2, 110, 740,
	3, 2, 2, 2, 112, 755, 3, 2, 2, 2, 114, 757, 3, 2, 2, 2, 116, 777, 3, 2,
	2, 2, 118, 779, 3, 2, 2, 2, 120, 781, 3, 2, 2, 2, 122, 783, 3, 2, 2, 2,
	124, 797, 3, 2, 2, 2, 126, 799, 3, 2, 2, 2, 128, 131, 5, 18, 10, 2, 129,
	131, 5, 4, 3, 2, 130, 128, 3, 2, 2, 2, 130, 129, 3, 2, 2, 2, 131, 132,
	3, 2, 2, 2, 132, 133, 7, 2, 2, 3, 133, 3, 3, 2, 2, 2, 134, 139, 5, 6, 4,
	2, 135, 138, 5, 8, 5, 2, 136, 138, 7, 106, 2, 2, 137, 135, 3, 2, 2, 2,
	137, 136, 3, 2, 2, 2, 138, 141, 3, 2, 2, 2, 139, 137, 3, 2, 2, 2, 139,
	140, 3, 2, 2, 2, 140, 5, 3, 2, 2, 2, 141, 139, 3, 2, 2, 2, 142, 145, 5,
	10, 6, 2, 143, 145, 5, 14, 8, 2, 144, 142, 3, 2, 2, 2, 144, 143, 3, 2,
	2, 2, 145, 7, 3, 2, 2, 2, 146, 149, 5, 10, 6, 2, 147, 149, 5, 14, 8, 2,
	148, 146, 3, 2, 2, 2, 148, 147, 3, 2, 2, 2, 149, 9, 3, 2, 2, 2, 150, 152,
	7, 69, 2, 2, 151, 150, 3, 2, 2, 2, 151, 152, 3, 2, 2, 2, 152, 153, 3, 2,
	2, 2, 153, 154, 7, 49, 2, 2, 154, 155, 5, 12, 7, 2, 155, 156, 5, 50, 26,
	2, 156, 157, 7, 106, 2, 2, 157, 158, 5, 54, 28, 2, 158, 159, 7, 55, 2,
	2, 159, 11, 3, 2, 2, 2, 160, 161, 7, 112, 2, 2, 161, 13, 3, 2, 2, 2, 162,
	164, 7, 69, 2, 2, 163, 162, 3, 2, 2, 2, 163, 164, 3, 2, 2, 2, 164, 165,
	3, 2, 2, 2, 165, 166, 7, 52, 2, 2, 166, 167, 5, 116, 59, 2, 167, 168, 5,
	16, 9, 2, 168, 169, 5, 50, 26, 2, 169, 170, 7, 106, 2, 2, 170, 171, 5,
	54, 28, 2, 171, 172, 7, 57, 2, 2, 172, 15, 3, 2, 2, 2, 173, 174, 7, 112,
	2, 2, 174, 17, 3, 2, 2, 2, 175, 176, 7, 51, 2, 2, 176, 178, 5, 20, 11,
	2, 177, 179, 7, 87, 2, 2, 178, 177, 3, 2, 2, 2, 178, 179, 3, 2, 2, 2, 179,
	180, 3, 2, 2, 2, 180, 181, 7, 106, 2, 2, 181, 182, 5, 22, 12, 2, 182, 186,
	7, 56, 2, 2, 183, 185, 7, 106, 2, 2, 184, 183, 3, 2, 2, 2, 185, 188, 3,
	2, 2, 2, 186, 184, 3, 2, 2, 2, 186, 187, 3, 2, 2, 2, 187, 19, 3, 2, 2,
	2, 188, 186, 3, 2, 2, 2, 189, 190, 7, 112, 2, 2, 190, 21, 3, 2, 2, 2, 191,
	208, 7, 106, 2, 2, 192, 193, 5, 58, 30, 2, 193, 194, 7, 106, 2, 2, 194,
	208, 3, 2, 2, 2, 195, 196, 5, 26, 14, 2, 196, 197, 7, 106, 2, 2, 197, 208,
	3, 2, 2, 2, 198, 199, 5, 38, 20, 2, 199, 200, 7, 106, 2, 2, 200, 208, 3,
	2, 2, 2, 201, 202, 5, 24, 13, 2, 202, 203, 7, 106, 2, 2, 203, 208, 3, 2,
	2, 2, 204, 205, 5, 66, 34, 2, 205, 206, 7, 106, 2, 2, 206, 208, 3, 2, 2,
	2, 207, 191, 3, 2, 2, 2, 207, 192, 3, 2, 2, 2, 207, 195, 3, 2, 2, 2, 207,
	198, 3, 2, 2, 2, 207, 201, 3, 2, 2, 2, 207, 204, 3, 2, 2, 2, 208, 211,
	3, 2, 2, 2, 209, 207, 3, 2, 2, 2, 209, 210, 3, 2, 2, 2, 210, 23, 3, 2,
	2, 2, 211, 209, 3, 2, 2, 2, 212, 213, 7, 112, 2, 2, 213, 214, 5, 70, 36,
	2, 214, 215, 7, 3, 2, 2, 215, 216, 5, 110, 56, 2, 216, 25, 3, 2, 2, 2,
	217, 220, 5, 28, 15, 2, 218, 220, 5, 30, 16, 2, 219, 217, 3, 2, 2, 2, 219,
	218, 3, 2, 2, 2, 220, 27, 3, 2, 2, 2, 221, 223, 7, 69, 2, 2, 222, 221,
	3, 2, 2, 2, 222, 223, 3, 2, 2, 2, 223, 224, 3, 2, 2, 2, 224, 225, 7, 93,
	2, 2, 225, 226, 5, 118, 60, 2, 226, 227, 5, 116, 59, 2, 227, 228, 5, 68,
	35, 2, 228, 236, 5, 40, 21, 2, 229, 230, 7, 4, 2, 2, 230, 231, 5, 116,
	59, 2, 231, 232, 5, 68, 35, 2, 232, 233, 5, 40, 21, 2, 233, 235, 3, 2,
	2, 2, 234, 229, 3, 2, 2, 2, 235, 238, 3, 2, 2, 2, 236, 234, 3, 2, 2, 2,
	236, 237, 3, 2, 2, 2, 237, 29, 3, 2, 2, 2, 238, 236, 3, 2, 2, 2, 239, 241,
	7, 69, 2, 2, 240, 239, 3, 2, 2, 2, 240, 241, 3, 2, 2, 2, 241, 242, 3, 2,
	2, 2, 242, 243, 7, 63, 2, 2, 243, 244, 5, 118, 60, 2, 244, 249, 5, 32,
	17, 2, 245, 246, 7, 4, 2, 2, 246, 248, 5, 32, 17, 2, 247, 245, 3, 2, 2,
	2, 248, 251, 3, 2, 2, 2, 249, 247, 3, 2, 2, 2, 249, 250, 3, 2, 2, 2, 250,
	31, 3, 2, 2, 2, 251, 249, 3, 2, 2, 2, 252, 253, 7, 112, 2, 2, 253, 33,
	3, 2, 2, 2, 254, 256, 7, 48, 2, 2, 255, 254, 3, 2, 2, 2, 255, 256, 3, 2,
	2, 2, 256, 262, 3, 2, 2, 2, 257, 258, 5, 116, 59, 2, 258, 259, 5, 68, 35,
	2, 259, 260, 5, 40, 21, 2, 260, 263, 3, 2, 2, 2, 261, 263, 5, 36, 19, 2,
	262, 257, 3, 2, 2, 2, 262, 261, 3, 2, 2, 2, 263, 35, 3, 2, 2, 2, 264, 265,
	7, 92, 2, 2, 265, 266, 7, 112, 2, 2, 266, 269, 5, 112, 57, 2, 267, 268,
	7, 96, 2, 2, 268, 270, 5, 112, 57, 2, 269, 267, 3, 2, 2, 2, 269, 270, 3,
	2, 2, 2, 270, 37, 3, 2, 2, 2, 271, 273, 7, 48, 2, 2, 272, 271, 3, 2, 2,
	2, 272, 273, 3, 2, 2, 2, 273, 275, 3, 2, 2, 2, 274, 276, 7, 69, 2, 2, 275,
	274, 3, 2, 2, 2, 275, 276, 3, 2, 2, 2, 276, 278, 3, 2, 2, 2, 277, 279,
	7, 45, 2, 2, 278, 277, 3, 2, 2, 2, 278, 279, 3, 2, 2, 2, 279, 287, 3, 2,
	2, 2, 280, 281, 5, 116, 59, 2, 281, 284, 5, 68, 35, 2, 282, 285, 5, 40,
	21, 2, 283, 285, 5, 42, 22, 2, 284, 282, 3, 2, 2, 2, 284, 283, 3, 2, 2,
	2, 285, 288, 3, 2, 2, 2, 286, 288, 5, 36, 19, 2, 287, 280, 3, 2, 2, 2,
	287, 286, 3, 2, 2, 2, 288, 39, 3, 2, 2, 2, 289, 290, 7, 4, 2, 2, 290, 292,
	5, 68, 35, 2, 291, 289, 3, 2, 2, 2, 292, 295, 3, 2, 2, 2, 293, 291, 3,
	2, 2, 2, 293, 294, 3, 2, 2, 2, 294, 41, 3, 2, 2, 2, 295, 293, 3, 2, 2,
	2, 296, 297, 7, 3, 2, 2, 297, 298, 5, 110, 56, 2, 298, 43, 3, 2, 2, 2,
	299, 303, 7, 5, 2, 2, 300, 301, 5, 118, 60, 2, 301, 302, 7, 6, 2, 2, 302,
	304, 3, 2, 2, 2, 303, 300, 3, 2, 2, 2, 303, 304, 3, 2, 2, 2, 304, 305,
	3, 2, 2, 2, 305, 306, 5, 46, 24, 2, 306, 307, 7, 7, 2, 2, 307, 45, 3, 2,
	2, 2, 308, 313, 5, 48, 25, 2, 309, 310, 7, 4, 2, 2, 310, 312, 5, 48, 25,
	2, 311, 309, 3, 2, 2, 2, 312, 315, 3, 2, 2, 2, 313, 311, 3, 2, 2, 2, 313,
	314, 3, 2, 2, 2, 314, 47, 3, 2, 2, 2, 315, 313, 3, 2, 2, 2, 316, 317, 5,
	68, 35, 2, 317, 318, 5, 110, 56, 2, 318, 49, 3, 2, 2, 2, 319, 328, 7, 8,
	2, 2, 320, 325, 5, 52, 27, 2, 321, 322, 7, 4, 2, 2, 322, 324, 5, 52, 27,
	2, 323, 321, 3, 2, 2, 2, 324, 327, 3, 2, 2, 2, 325, 323, 3, 2, 2, 2, 325,
	326, 3, 2, 2, 2, 326, 329, 3, 2, 2, 2, 327, 325, 3, 2, 2, 2, 328, 320,
	3, 2, 2, 2, 328, 329, 3, 2, 2, 2, 329, 330, 3, 2, 2, 2, 330, 331, 7, 9,
	2, 2, 331, 51, 3, 2, 2, 2, 332, 334, 5, 68, 35, 2, 333, 335, 5, 64, 33,
	2, 334, 333, 3, 2, 2, 2, 334, 335, 3, 2, 2, 2, 335, 53, 3, 2, 2, 2, 336,
	337, 5, 56, 29, 2, 337, 338, 5, 72, 37, 2, 338, 55, 3, 2, 2, 2, 339, 340,
	5, 58, 30, 2, 340, 341, 7, 106, 2, 2, 341, 351, 3, 2, 2, 2, 342, 343, 5,
	34, 18, 2, 343, 344, 7, 106, 2, 2, 344, 351, 3, 2, 2, 2, 345, 346, 7, 106,
	2, 2, 346, 351, 7, 106, 2, 2, 347, 348, 5, 66, 34, 2, 348, 349, 7, 106,
	2, 2, 349, 351, 3, 2, 2, 2, 350, 339, 3, 2, 2, 2, 350, 342, 3, 2, 2, 2,
	350, 345, 3, 2, 2, 2, 350, 347, 3, 2, 2, 2, 351, 354, 3, 2, 2, 2, 352,
	350, 3, 2, 2, 2, 352, 353, 3, 2, 2, 2, 353, 57, 3, 2, 2, 2, 354, 352, 3,
	2, 2, 2, 355, 356, 7, 65, 2, 2, 356, 357, 5, 12, 7, 2, 357, 358, 5, 60,
	31, 2, 358, 365, 3, 2, 2, 2, 359, 360, 7, 66, 2, 2, 360, 361, 5, 116, 59,
	2, 361, 362, 5, 16, 9, 2, 362, 363, 5, 60, 31, 2, 363, 365, 3, 2, 2, 2,
	364, 355, 3, 2, 2, 2, 364, 359, 3, 2, 2, 2, 365, 59, 3, 2, 2, 2, 366, 375,
	7, 8, 2, 2, 367, 372, 5, 62, 32, 2, 368, 369, 7, 4, 2, 2, 369, 371, 5,
	62, 32, 2, 370, 368, 3, 2, 2, 2, 371, 374, 3, 2, 2, 2, 372, 370, 3, 2,
	2, 2, 372, 373, 3, 2, 2, 2, 373, 376, 3, 2, 2, 2, 374, 372, 3, 2, 2, 2,
	375, 367, 3, 2, 2, 2, 375, 376, 3, 2, 2, 2, 376, 377, 3, 2, 2, 2, 377,
	378, 7, 9, 2, 2, 378, 61, 3, 2, 2, 2, 379, 381, 5, 116, 59, 2, 380, 382,
	5, 64, 33, 2, 381, 380, 3, 2, 2, 2, 381, 382, 3, 2, 2, 2, 382, 63, 3, 2,
	2, 2, 383, 384, 7, 6, 2, 2, 384, 385, 7, 112, 2, 2, 385, 65, 3, 2, 2, 2,
	386, 387, 7, 73, 2, 2, 387, 388, 5, 116, 59, 2, 388, 389, 5, 68, 35, 2,
	389, 390, 7, 76, 2, 2, 390, 391, 7, 10, 2, 2, 391, 392, 5, 20, 11, 2, 392,
	393, 7, 11, 2, 2, 393, 394, 5, 68, 35, 2, 394, 67, 3, 2, 2, 2, 395, 397,
	7, 112, 2, 2, 396, 398, 5, 70, 36, 2, 397, 396, 3, 2, 2, 2, 397, 398, 3,
	2, 2, 2, 398, 69, 3, 2, 2, 2, 399, 413, 7, 12, 2, 2, 400, 411, 5, 92, 47,
	2, 401, 409, 7, 4, 2, 2, 402, 407, 5, 92, 47, 2, 403, 405, 7, 4, 2, 2,
	404, 406, 5, 92, 47, 2, 405, 404, 3, 2, 2, 2, 405, 406, 3, 2, 2, 2, 406,
	408, 3, 2, 2, 2, 407, 403, 3, 2, 2, 2, 407, 408, 3, 2, 2, 2, 408, 410,
	3, 2, 2, 2, 409, 402, 3, 2, 2, 2, 409, 410, 3, 2, 2, 2, 410, 412, 3, 2,
	2, 2, 411, 401, 3, 2, 2, 2, 411, 412, 3, 2, 2, 2, 412, 414, 3, 2, 2, 2,
	413, 400, 3, 2, 2, 2, 413, 414, 3, 2, 2, 2, 414, 415, 3, 2, 2, 2, 415,
	416, 7, 13, 2, 2, 416, 71, 3, 2, 2, 2, 417, 418, 5, 74, 38, 2, 418, 73,
	3, 2, 2, 2, 419, 421, 5, 76, 39, 2, 420, 419, 3, 2, 2, 2, 421, 424, 3,
	2, 2, 2, 422, 420, 3, 2, 2, 2, 422, 423, 3, 2, 2, 2, 423, 75, 3, 2, 2,
	2, 424, 422, 3, 2, 2, 2, 425, 426, 7, 46, 2, 2, 426, 598, 7, 106, 2, 2,
	427, 428, 7, 64, 2, 2, 428, 598, 7, 106, 2, 2, 429, 430, 7, 68, 2, 2, 430,
	431, 7, 112, 2, 2, 431, 432, 7, 3, 2, 2, 432, 433, 5, 92, 47, 2, 433, 434,
	7, 96, 2, 2, 434, 437, 5, 92, 47, 2, 435, 436, 7, 112, 2, 2, 436, 438,
	5, 92, 47, 2, 437, 435, 3, 2, 2, 2, 437, 438, 3, 2, 2, 2, 438, 439, 3,
	2, 2, 2, 439, 440, 7, 106, 2, 2, 440, 441, 5, 74, 38, 2, 441, 442, 7, 58,
	2, 2, 442, 598, 3, 2, 2, 2, 443, 444, 7, 70, 2, 2, 444, 445, 7, 112, 2,
	2, 445, 598, 7, 106, 2, 2, 446, 447, 7, 71, 2, 2, 447, 598, 7, 106, 2,
	2, 448, 449, 7, 72, 2, 2, 449, 450, 5, 92, 47, 2, 450, 451, 7, 95, 2, 2,
	451, 452, 7, 106, 2, 2, 452, 456, 5, 74, 38, 2, 453, 454, 7, 54, 2, 2,
	454, 455, 7, 106, 2, 2, 455, 457, 5, 74, 38, 2, 456, 453, 3, 2, 2, 2, 456,
	457, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 459, 7, 59, 2, 2, 459, 460,
	7, 106, 2, 2, 460, 598, 3, 2, 2, 2, 461, 462, 7, 79, 2, 2, 462, 463, 7,
	106, 2, 2, 463, 464, 5, 74, 38, 2, 464, 465, 7, 60, 2, 2, 465, 466, 7,
	106, 2, 2, 466, 598, 3, 2, 2, 2, 467, 468, 7, 89, 2, 2, 468, 469, 7, 106,
	2, 2, 469, 470, 5, 74, 38, 2, 470, 471, 7, 99, 2, 2, 471, 472, 5, 92, 47,
	2, 472, 473, 7, 106, 2, 2, 473, 598, 3, 2, 2, 2, 474, 475, 7, 94, 2, 2,
	475, 476, 5, 92, 47, 2, 476, 477, 7, 106, 2, 2, 477, 478, 5, 82, 42, 2,
	478, 479, 7, 61, 2, 2, 479, 480, 7, 106, 2, 2, 480, 598, 3, 2, 2, 2, 481,
	482, 7, 100, 2, 2, 482, 483, 7, 68, 2, 2, 483, 484, 5, 92, 47, 2, 484,
	485, 7, 106, 2, 2, 485, 598, 3, 2, 2, 2, 486, 487, 7, 100, 2, 2, 487, 488,
	7, 91, 2, 2, 488, 489, 5, 92, 47, 2, 489, 490, 7, 106, 2, 2, 490, 598,
	3, 2, 2, 2, 491, 492, 7, 102, 2, 2, 492, 493, 5, 92, 47, 2, 493, 494, 7,
	106, 2, 2, 494, 495, 5, 74, 38, 2, 495, 496, 7, 62, 2, 2, 496, 497, 7,
	106, 2, 2, 497, 598, 3, 2, 2, 2, 498, 500, 7, 90, 2, 2, 499, 501, 5, 90,
	46, 2, 500, 499, 3, 2, 2, 2, 500, 501, 3, 2, 2, 2, 501, 502, 3, 2, 2, 2,
	502, 598, 7, 106, 2, 2, 503, 505, 7, 34, 2, 2, 504, 506, 7, 112, 2, 2,
	505, 504, 3, 2, 2, 2, 505, 506, 3, 2, 2, 2, 506, 507, 3, 2, 2, 2, 507,
	598, 7, 106, 2, 2, 508, 509, 5, 90, 46, 2, 509, 510, 7, 106, 2, 2, 510,
	598, 3, 2, 2, 2, 511, 512, 7, 112, 2, 2, 512, 513, 7, 6, 2, 2, 513, 598,
	7, 106, 2, 2, 514, 598, 7, 106, 2, 2, 515, 517, 7, 69, 2, 2, 516, 515,
	3, 2, 2, 2, 516, 517, 3, 2, 2, 2, 517, 518, 3, 2, 2, 2, 518, 519, 7, 74,
	2, 2, 519, 520, 7, 48, 2, 2, 520, 521, 5, 112, 57, 2, 521, 522, 7, 101,
	2, 2, 522, 523, 5, 92, 47, 2, 523, 524, 7, 53, 2, 2, 524, 525, 5, 90, 46,
	2, 525, 526, 7, 106, 2, 2, 526, 598, 3, 2, 2, 2, 527, 528, 7, 74, 2, 2,
	528, 530, 7, 112, 2, 2, 529, 531, 5, 112, 57, 2, 530, 529, 3, 2, 2, 2,
	530, 531, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 598, 7, 106, 2, 2, 533,
	534, 9, 2, 2, 2, 534, 539, 5, 106, 54, 2, 535, 537, 7, 37, 2, 2, 536, 538,
	9, 3, 2, 2, 537, 536, 3, 2, 2, 2, 537, 538, 3, 2, 2, 2, 538, 540, 3, 2,
	2, 2, 539, 535, 3, 2, 2, 2, 539, 540, 3, 2, 2, 2, 540, 541, 3, 2, 2, 2,
	541, 542, 7, 106, 2, 2, 542, 598, 3, 2, 2, 2, 543, 544, 7, 78, 2, 2, 544,
	546, 5, 106, 54, 2, 545, 547, 9, 3, 2, 2, 546, 545, 3, 2, 2, 2, 546, 547,
	3, 2, 2, 2, 547, 548, 3, 2, 2, 2, 548, 549, 7, 106, 2, 2, 549, 598, 3,
	2, 2, 2, 550, 551, 7, 77, 2, 2, 551, 553, 5, 106, 54, 2, 552, 554, 9, 3,
	2, 2, 553, 552, 3, 2, 2, 2, 553, 554, 3, 2, 2, 2, 554, 556, 3, 2, 2, 2,
	555, 557, 5, 126, 64, 2, 556, 555, 3, 2, 2, 2, 556, 557, 3, 2, 2, 2, 557,
	558, 3, 2, 2, 2, 558, 559, 7, 106, 2, 2, 559, 598, 3, 2, 2, 2, 560, 561,
	9, 4, 2, 2, 561, 562, 5, 106, 54, 2, 562, 563, 7, 4, 2, 2, 563, 567, 5,
	106, 54, 2, 564, 565, 7, 4, 2, 2, 565, 566, 7, 112, 2, 2, 566, 568, 5,
	112, 57, 2, 567, 564, 3, 2, 2, 2, 567, 568, 3, 2, 2, 2, 568, 570, 3, 2,
	2, 2, 569, 571, 9, 3, 2, 2, 570, 569, 3, 2, 2, 2, 570, 571, 3, 2, 2, 2,
	571, 572, 3, 2, 2, 2, 572, 573, 7, 106, 2, 2, 573, 598, 3, 2, 2, 2, 574,
	575, 7, 97, 2, 2, 575, 576, 7, 101, 2, 2, 576, 577, 7, 112, 2, 2, 577,
	578, 7, 3, 2, 2, 578, 579, 5, 92, 47, 2, 579, 580, 7, 47, 2, 2, 580, 581,
	7, 3, 2, 2, 581, 582, 5, 92, 47, 2, 582, 583, 7, 53, 2, 2, 583, 587, 5,
	90, 46, 2, 584, 585, 7, 84, 2, 2, 585, 586, 7, 3, 2, 2, 586, 588, 5, 92,
	47, 2, 587, 584, 3, 2, 2, 2, 587, 588, 3, 2, 2, 2, 588, 589, 3, 2, 2, 2,
	589, 590, 7, 106, 2, 2, 590, 598, 3, 2, 2, 2, 591, 592, 5, 80, 41, 2, 592,
	593, 7, 106, 2, 2, 593, 598, 3, 2, 2, 2, 594, 595, 5, 78, 40, 2, 595, 596,
	7, 106, 2, 2, 596, 598, 3, 2, 2, 2, 597, 425, 3, 2, 2, 2, 597, 427, 3,
	2, 2, 2, 597, 429, 3, 2, 2, 2, 597, 443, 3, 2, 2, 2, 597, 446, 3, 2, 2,
	2, 597, 448, 3, 2, 2, 2, 597, 461, 3, 2, 2, 2, 597, 467, 3, 2, 2, 2, 597,
	474, 3, 2, 2, 2, 597, 481, 3, 2, 2, 2, 597, 486, 3, 2, 2, 2, 597, 491,
	3, 2, 2, 2, 597, 498, 3, 2, 2, 2, 597, 503, 3, 2, 2, 2, 597, 508, 3, 2,
	2, 2, 597, 511, 3, 2, 2, 2, 597, 514, 3, 2, 2, 2, 597, 516, 3, 2, 2, 2,
	597, 527, 3, 2, 2, 2, 597, 533, 3, 2, 2, 2, 597, 543, 3, 2, 2, 2, 597,
	550, 3, 2, 2, 2, 597, 560, 3, 2, 2, 2, 597, 574, 3, 2, 2, 2, 597, 591,
	3, 2, 2, 2, 597, 594, 3, 2, 2, 2, 598, 77, 3, 2, 2, 2, 599, 612, 7, 28,
	2, 2, 600, 601, 7, 112, 2, 2, 601, 607, 5, 90, 46, 2, 602, 603, 7, 112,
	2, 2, 603, 604, 7, 3, 2, 2, 604, 606, 5, 124, 63, 2, 605, 602, 3, 2, 2,
	2, 606, 609, 3, 2, 2, 2, 607, 605, 3, 2, 2, 2, 607, 608, 3, 2, 2, 2, 608,
	613, 3, 2, 2, 2, 609, 607, 3, 2, 2, 2, 610, 611, 7, 112, 2, 2, 611, 613,
	7, 112, 2, 2, 612, 600, 3, 2, 2, 2, 612, 610, 3, 2, 2, 2, 613, 79, 3, 2,
	2, 2, 614, 619, 7, 27, 2, 2, 615, 616, 7, 112, 2, 2, 616, 620, 5, 90, 46,
	2, 617, 618, 7, 112, 2, 2, 618, 620, 7, 112, 2, 2, 619, 615, 3, 2, 2, 2,
	619, 617, 3, 2, 2, 2, 620, 81, 3, 2, 2, 2, 621, 623, 7, 106, 2, 2, 622,
	621, 3, 2, 2, 2, 623, 626, 3, 2, 2, 2, 624, 622, 3, 2, 2, 2, 624, 625,
	3, 2, 2, 2, 625, 630, 3, 2, 2, 2, 626, 624, 3, 2, 2, 2, 627, 628, 5, 84,
	43, 2, 628, 629, 5, 74, 38, 2, 629, 631, 3, 2, 2, 2, 630, 627, 3, 2, 2,
	2, 631, 632, 3, 2, 2, 2, 632, 630, 3, 2, 2, 2, 632, 633, 3, 2, 2, 2, 633,
	637, 3, 2, 2, 2, 634, 635, 5, 86, 44, 2, 635, 636, 5, 74, 38, 2, 636, 638,
	3, 2, 2, 2, 637, 634, 3, 2, 2, 2, 637, 638, 3, 2, 2, 2, 638, 83, 3, 2,
	2, 2, 639, 640, 7, 39, 2, 2, 640, 645, 5, 92, 47, 2, 641, 642, 7, 4, 2,
	2, 642, 644, 5, 92, 47, 2, 643, 641, 3, 2, 2, 2, 644, 647, 3, 2, 2, 2,
	645, 643, 3, 2, 2, 2, 645, 646, 3, 2, 2, 2, 646, 648, 3, 2, 2, 2, 647,
	645, 3, 2, 2, 2, 648, 649, 7, 106, 2, 2, 649, 85, 3, 2, 2, 2, 650, 651,
	7, 50, 2, 2, 651, 652, 7, 106, 2, 2, 652, 87, 3, 2, 2, 2, 653, 658, 5,
	90, 46, 2, 654, 655, 7, 4, 2, 2, 655, 657, 5, 90, 46, 2, 656, 654, 3, 2,
	2, 2, 657, 660, 3, 2, 2, 2, 658, 656, 3, 2, 2, 2, 658, 659, 3, 2, 2, 2,
	659, 89, 3, 2, 2, 2, 660, 658, 3, 2, 2, 2, 661, 666, 5, 92, 47, 2, 662,
	663, 7, 3, 2, 2, 663, 665, 5, 92, 47, 2, 664, 662, 3, 2, 2, 2, 665, 668,
	3, 2, 2, 2, 666, 664, 3, 2, 2, 2, 666, 667, 3, 2, 2, 2, 667, 91, 3, 2,
	2, 2, 668, 666, 3, 2, 2, 2, 669, 675, 5, 96, 49, 2, 670, 671, 5, 94, 48,
	2, 671, 672, 5, 96, 49, 2, 672, 674, 3, 2, 2, 2, 673, 670, 3, 2, 2, 2,
	674, 677, 3, 2, 2, 2, 675, 673, 3, 2, 2, 2, 675, 676, 3, 2, 2, 2, 676,
	93, 3, 2, 2, 2, 677, 675, 3, 2, 2, 2, 678, 679, 9, 5, 2, 2, 679, 95, 3,
	2, 2, 2, 680, 685, 5, 98, 50, 2, 681, 682, 9, 6, 2, 2, 682, 684, 5, 98,
	50, 2, 683, 681, 3, 2, 2, 2, 684, 687, 3, 2, 2, 2, 685, 683, 3, 2, 2, 2,
	685, 686, 3, 2, 2, 2, 686, 97, 3, 2, 2, 2, 687, 685, 3, 2, 2, 2, 688, 693,
	5, 100, 51, 2, 689, 690, 9, 7, 2, 2, 690, 692, 5, 100, 51, 2, 691, 689,
	3, 2, 2, 2, 692, 695, 3, 2, 2, 2, 693, 691, 3, 2, 2, 2, 693, 694, 3, 2,
	2, 2, 694, 99, 3, 2, 2, 2, 695, 693, 3, 2, 2, 2, 696, 701, 5, 102, 52,
	2, 697, 698, 9, 8, 2, 2, 698, 700, 5, 102, 52, 2, 699, 697, 3, 2, 2, 2,
	700, 703, 3, 2, 2, 2, 701, 699, 3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702,
	101, 3, 2, 2, 2, 703, 701, 3, 2, 2, 2, 704, 709, 5, 104, 53, 2, 705, 706,
	9, 9, 2, 2, 706, 708, 5, 104, 53, 2, 707, 705, 3, 2, 2, 2, 708, 711, 3,
	2, 2, 2, 709, 707, 3, 2, 2, 2, 709, 710, 3, 2, 2, 2, 710, 103, 3, 2, 2,
	2, 711, 709, 3, 2, 2, 2, 712, 717, 5, 106, 54, 2, 713, 714, 9, 10, 2, 2,
	714, 716, 5, 106, 54, 2, 715, 713, 3, 2, 2, 2, 716, 719, 3, 2, 2, 2, 717,
	715, 3, 2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 105, 3, 2, 2, 2, 719, 717,
	3, 2, 2, 2, 720, 725, 5, 108, 55, 2, 721, 722, 7, 6, 2, 2, 722, 724, 5,
	108, 55, 2, 723, 721, 3, 2, 2, 2, 724, 727, 3, 2, 2, 2, 725, 723, 3, 2,
	2, 2, 725, 726, 3, 2, 2, 2, 726, 107, 3, 2, 2, 2, 727, 725, 3, 2, 2, 2,
	728, 729, 7, 82, 2, 2, 729, 734, 5, 108, 55, 2, 730, 731, 7, 30, 2, 2,
	731, 734, 5, 108, 55, 2, 732, 734, 5, 110, 56, 2, 733, 728, 3, 2, 2, 2,
	733, 730, 3, 2, 2, 2, 733, 732, 3, 2, 2, 2, 734, 109, 3, 2, 2, 2, 735,
	736, 7, 20, 2, 2, 736, 741, 5, 110, 56, 2, 737, 738, 7, 21, 2, 2, 738,
	741, 5, 110, 56, 2, 739, 741, 5, 112, 57, 2, 740, 735, 3, 2, 2, 2, 740,
	737, 3, 2, 2, 2, 740, 739, 3, 2, 2, 2, 741, 111, 3, 2, 2, 2, 742, 756,
	5, 114, 58, 2, 743, 748, 5, 68, 35, 2, 744, 745, 7, 24, 2, 2, 745, 747,
	5, 68, 35, 2, 746, 744, 3, 2, 2, 2, 747, 750, 3, 2, 2, 2, 748, 746, 3,
	2, 2, 2, 748, 749, 3, 2, 2, 2, 749, 752, 3, 2, 2, 2, 750, 748, 3, 2, 2,
	2, 751, 753, 5, 122, 62, 2, 752, 751, 3, 2, 2, 2, 752, 753, 3, 2, 2, 2,
	753, 756, 3, 2, 2, 2, 754, 756, 5, 124, 63, 2, 755, 742, 3, 2, 2, 2, 755,
	743, 3, 2, 2, 2, 755, 754, 3, 2, 2, 2, 756, 113, 3, 2, 2, 2, 757, 758,
	7, 8, 2, 2, 758, 759, 5, 90, 46, 2, 759, 760, 7, 9, 2, 2, 760, 115, 3,
	2, 2, 2, 761, 767, 5, 120, 61, 2, 762, 764, 7, 12, 2, 2, 763, 765, 7, 111,
	2, 2, 764, 763, 3, 2, 2, 2, 764, 765, 3, 2, 2, 2, 765, 766, 3, 2, 2, 2,
	766, 768, 7, 13, 2, 2, 767, 762, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768,
	778, 3, 2, 2, 2, 769, 775, 5, 118, 60, 2, 770, 772, 7, 12, 2, 2, 771, 773,
	7, 111, 2, 2, 772, 771, 3, 2, 2, 2, 772, 773, 3, 2, 2, 2, 773, 774, 3,
	2, 2, 2, 774, 776, 7, 13, 2, 2, 775, 770, 3, 2, 2, 2, 775, 776, 3, 2, 2,
	2, 776, 778, 3, 2, 2, 2, 777, 761, 3, 2, 2, 2, 777, 769, 3, 2, 2, 2, 778,
	117, 3, 2, 2, 2, 779, 780, 7, 112, 2, 2, 780, 119, 3, 2, 2, 2, 781, 782,
	9, 11, 2, 2, 782, 121, 3, 2, 2, 2, 783, 785, 7, 8, 2, 2, 784, 786, 5, 88,
	45, 2, 785, 784, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 787, 3, 2, 2, 2,
	787, 788, 7, 9, 2, 2, 788, 123, 3, 2, 2, 2, 789, 798, 7, 111, 2, 2, 790,
	798, 7, 110, 2, 2, 791, 798, 7, 108, 2, 2, 792, 798, 7, 109, 2, 2, 793,
	798, 5, 44, 23, 2, 794, 798, 7, 98, 2, 2, 795, 798, 7, 67, 2, 2, 796, 798,
	5, 126, 64, 2, 797, 789, 3, 2, 2, 2, 797, 790, 3, 2, 2, 2, 797, 791, 3,
	2, 2, 2, 797, 792, 3, 2, 2, 2, 797, 793, 3, 2, 2, 2, 797, 794, 3, 2, 2,
	2, 797, 795, 3, 2, 2, 2, 797, 796, 3, 2, 2, 2, 798, 125, 3, 2, 2, 2, 799,
	800, 7, 25, 2, 2, 800, 801, 7, 112, 2, 2, 801, 127, 3, 2, 2, 2, 88, 130,
	137, 139, 144, 148, 151, 163, 178, 186, 207, 209, 219, 222, 236, 240, 249,
	255, 262, 269, 272, 275, 278, 284, 287, 293, 303, 313, 325, 328, 334, 350,
	352, 364, 372, 375, 381, 397, 405, 407, 409, 411, 413, 422, 437, 456, 500,
	505, 516, 530, 537, 539, 546, 553, 556, 567, 570, 587, 597, 607, 612, 619,
	624, 632, 637, 645, 658, 666, 675, 685, 693, 701, 709, 717, 725, 733, 740,
	748, 752, 755, 764, 767, 772, 775, 777, 785, 797,
}
var literalNames = []string{
	"", "'='", "','", "'{'", "':'", "'}'", "'('", "')'", "'/R1/'", "'..'",
	"'['", "']'", "'=='", "'<>'", "'<='", "'>='", "'<'", "'>'", "'+'", "'-'",
	"'*'", "'/'", "'.'", "'#'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "AND", "ANIN", "ANOUT", "B_AND", "B_NOT", "B_OR",
	"B_EXOR", "BOOL", "BRAKE", "C_DIS", "C_ORI", "C_PTP", "C_VEL", "CASE",
	"CAST_FROM", "CAST_TO", "CHAR", "CIRC_REL", "CIRC", "CONST", "CONTINUE",
	"DELAY", "DECL", "DEF", "DEFAULT", "DEFDAT", "DEFFCT", "DO", "ELSE", "END",
	"ENDDAT", "ENDFCT", "ENDFOR", "ENDIF", "ENDLOOP", "ENDSWITCH", "ENDWHILE",
	"ENUM", "EXIT", "EXT", "EXTFCT", "FALSE", "FOR", "GLOBAL", "GOTO", "HALT",
	"IF", "IMPORT", "INTERRUPT", "INT", "IS", "LIN_REL", "LIN", "LOOP", "MAXIMUM",
	"MINIMUM", "NOT", "OR", "PRIO", "PTP_REL", "PTP", "PUBLIC", "REAL", "REPEAT",
	"RETURN", "SEC", "SIGNAL", "STRUC", "SWITCH", "THEN", "TO", "TRIGGER",
	"TRUE", "UNTIL", "WAIT", "WHEN", "WHILE", "EXOR", "HEADERLINE", "WS", "NEWLINE",
	"LINE_COMMENT", "CHARLITERAL", "STRINGLITERAL", "FLOATLITERAL", "INTLITERAL",
	"IDENTIFIER",
}

var ruleNames = []string{
	"module", "moduleRoutines", "mainRoutine", "subRoutine", "procedureDefinition",
	"procedureName", "functionDefinition", "functionName", "moduleData", "moduleName",
	"dataList", "arrayInitialisation", "typeDeclaration", "structureDefinition",
	"enumDefinition", "enumValue", "variableDeclaration", "signalDeclaration",
	"variableDeclarationInDataList", "variableListRest", "variableInitialisation",
	"structLiteral", "structElementList", "structElement", "formalParameters",
	"parameter", "routineBody", "routineDataSection", "forwardDeclaration",
	"formalParametersWithType", "parameterWithType", "parameterCallType", "importStatement",
	"variableName", "arrayVariableSuffix", "routineImplementationSection",
	"statementList", "statement", "analogOutputStatement", "analogInputStatement",
	"switchBlockStatementGroups", "caseLabel", "defaultLabel", "expressionList",
	"assignmentExpression", "expression", "relationalOp", "conditionalOrExpression",
	"exclusiveOrExpression", "conditionalAndExpression", "additiveExpression",
	"multiplicativeExpression", "geometricExpression", "unaryNotExpression",
	"unaryPlusMinuxExpression", "primary", "parExpression", "type_", "typeName",
	"primitiveType", "arguments", "literal", "enumElement",
}

type krlParser struct {
	*antlr.BaseParser
}

// NewkrlParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *krlParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewkrlParser(input antlr.TokenStream) *krlParser {
	this := new(krlParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "krl.g4"

	return this
}

// krlParser tokens.
const (
	krlParserEOF           = antlr.TokenEOF
	krlParserT__0          = 1
	krlParserT__1          = 2
	krlParserT__2          = 3
	krlParserT__3          = 4
	krlParserT__4          = 5
	krlParserT__5          = 6
	krlParserT__6          = 7
	krlParserT__7          = 8
	krlParserT__8          = 9
	krlParserT__9          = 10
	krlParserT__10         = 11
	krlParserT__11         = 12
	krlParserT__12         = 13
	krlParserT__13         = 14
	krlParserT__14         = 15
	krlParserT__15         = 16
	krlParserT__16         = 17
	krlParserT__17         = 18
	krlParserT__18         = 19
	krlParserT__19         = 20
	krlParserT__20         = 21
	krlParserT__21         = 22
	krlParserT__22         = 23
	krlParserAND           = 24
	krlParserANIN          = 25
	krlParserANOUT         = 26
	krlParserB_AND         = 27
	krlParserB_NOT         = 28
	krlParserB_OR          = 29
	krlParserB_EXOR        = 30
	krlParserBOOL          = 31
	krlParserBRAKE         = 32
	krlParserC_DIS         = 33
	krlParserC_ORI         = 34
	krlParserC_PTP         = 35
	krlParserC_VEL         = 36
	krlParserCASE          = 37
	krlParserCAST_FROM     = 38
	krlParserCAST_TO       = 39
	krlParserCHAR          = 40
	krlParserCIRC_REL      = 41
	krlParserCIRC          = 42
	krlParserCONST         = 43
	krlParserCONTINUE      = 44
	krlParserDELAY         = 45
	krlParserDECL          = 46
	krlParserDEF           = 47
	krlParserDEFAULT       = 48
	krlParserDEFDAT        = 49
	krlParserDEFFCT        = 50
	krlParserDO            = 51
	krlParserELSE          = 52
	krlParserEND           = 53
	krlParserENDDAT        = 54
	krlParserENDFCT        = 55
	krlParserENDFOR        = 56
	krlParserENDIF         = 57
	krlParserENDLOOP       = 58
	krlParserENDSWITCH     = 59
	krlParserENDWHILE      = 60
	krlParserENUM          = 61
	krlParserEXIT          = 62
	krlParserEXT           = 63
	krlParserEXTFCT        = 64
	krlParserFALSE         = 65
	krlParserFOR           = 66
	krlParserGLOBAL        = 67
	krlParserGOTO          = 68
	krlParserHALT          = 69
	krlParserIF            = 70
	krlParserIMPORT        = 71
	krlParserINTERRUPT     = 72
	krlParserINT           = 73
	krlParserIS            = 74
	krlParserLIN_REL       = 75
	krlParserLIN           = 76
	krlParserLOOP          = 77
	krlParserMAXIMUM       = 78
	krlParserMINIMUM       = 79
	krlParserNOT           = 80
	krlParserOR            = 81
	krlParserPRIO          = 82
	krlParserPTP_REL       = 83
	krlParserPTP           = 84
	krlParserPUBLIC        = 85
	krlParserREAL          = 86
	krlParserREPEAT        = 87
	krlParserRETURN        = 88
	krlParserSEC           = 89
	krlParserSIGNAL        = 90
	krlParserSTRUC         = 91
	krlParserSWITCH        = 92
	krlParserTHEN          = 93
	krlParserTO            = 94
	krlParserTRIGGER       = 95
	krlParserTRUE          = 96
	krlParserUNTIL         = 97
	krlParserWAIT          = 98
	krlParserWHEN          = 99
	krlParserWHILE         = 100
	krlParserEXOR          = 101
	krlParserHEADERLINE    = 102
	krlParserWS            = 103
	krlParserNEWLINE       = 104
	krlParserLINE_COMMENT  = 105
	krlParserCHARLITERAL   = 106
	krlParserSTRINGLITERAL = 107
	krlParserFLOATLITERAL  = 108
	krlParserINTLITERAL    = 109
	krlParserIDENTIFIER    = 110
)

// krlParser rules.
const (
	krlParserRULE_module                        = 0
	krlParserRULE_moduleRoutines                = 1
	krlParserRULE_mainRoutine                   = 2
	krlParserRULE_subRoutine                    = 3
	krlParserRULE_procedureDefinition           = 4
	krlParserRULE_procedureName                 = 5
	krlParserRULE_functionDefinition            = 6
	krlParserRULE_functionName                  = 7
	krlParserRULE_moduleData                    = 8
	krlParserRULE_moduleName                    = 9
	krlParserRULE_dataList                      = 10
	krlParserRULE_arrayInitialisation           = 11
	krlParserRULE_typeDeclaration               = 12
	krlParserRULE_structureDefinition           = 13
	krlParserRULE_enumDefinition                = 14
	krlParserRULE_enumValue                     = 15
	krlParserRULE_variableDeclaration           = 16
	krlParserRULE_signalDeclaration             = 17
	krlParserRULE_variableDeclarationInDataList = 18
	krlParserRULE_variableListRest              = 19
	krlParserRULE_variableInitialisation        = 20
	krlParserRULE_structLiteral                 = 21
	krlParserRULE_structElementList             = 22
	krlParserRULE_structElement                 = 23
	krlParserRULE_formalParameters              = 24
	krlParserRULE_parameter                     = 25
	krlParserRULE_routineBody                   = 26
	krlParserRULE_routineDataSection            = 27
	krlParserRULE_forwardDeclaration            = 28
	krlParserRULE_formalParametersWithType      = 29
	krlParserRULE_parameterWithType             = 30
	krlParserRULE_parameterCallType             = 31
	krlParserRULE_importStatement               = 32
	krlParserRULE_variableName                  = 33
	krlParserRULE_arrayVariableSuffix           = 34
	krlParserRULE_routineImplementationSection  = 35
	krlParserRULE_statementList                 = 36
	krlParserRULE_statement                     = 37
	krlParserRULE_analogOutputStatement         = 38
	krlParserRULE_analogInputStatement          = 39
	krlParserRULE_switchBlockStatementGroups    = 40
	krlParserRULE_caseLabel                     = 41
	krlParserRULE_defaultLabel                  = 42
	krlParserRULE_expressionList                = 43
	krlParserRULE_assignmentExpression          = 44
	krlParserRULE_expression                    = 45
	krlParserRULE_relationalOp                  = 46
	krlParserRULE_conditionalOrExpression       = 47
	krlParserRULE_exclusiveOrExpression         = 48
	krlParserRULE_conditionalAndExpression      = 49
	krlParserRULE_additiveExpression            = 50
	krlParserRULE_multiplicativeExpression      = 51
	krlParserRULE_geometricExpression           = 52
	krlParserRULE_unaryNotExpression            = 53
	krlParserRULE_unaryPlusMinuxExpression      = 54
	krlParserRULE_primary                       = 55
	krlParserRULE_parExpression                 = 56
	krlParserRULE_type_                         = 57
	krlParserRULE_typeName                      = 58
	krlParserRULE_primitiveType                 = 59
	krlParserRULE_arguments                     = 60
	krlParserRULE_literal                       = 61
	krlParserRULE_enumElement                   = 62
)

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) EOF() antlr.TerminalNode {
	return s.GetToken(krlParserEOF, 0)
}

func (s *ModuleContext) ModuleData() IModuleDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleDataContext)
}

func (s *ModuleContext) ModuleRoutines() IModuleRoutinesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleRoutinesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleRoutinesContext)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitModule(s)
	}
}

func (p *krlParser) Module() (localctx IModuleContext) {
	this := p
	_ = this

	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, krlParserRULE_module)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(128)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case krlParserDEFDAT:
		{
			p.SetState(126)
			p.ModuleData()
		}

	case krlParserDEF, krlParserDEFFCT, krlParserGLOBAL:
		{
			p.SetState(127)
			p.ModuleRoutines()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(130)
		p.Match(krlParserEOF)
	}

	return localctx
}

// IModuleRoutinesContext is an interface to support dynamic dispatch.
type IModuleRoutinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleRoutinesContext differentiates from other interfaces.
	IsModuleRoutinesContext()
}

type ModuleRoutinesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleRoutinesContext() *ModuleRoutinesContext {
	var p = new(ModuleRoutinesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_moduleRoutines
	return p
}

func (*ModuleRoutinesContext) IsModuleRoutinesContext() {}

func NewModuleRoutinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleRoutinesContext {
	var p = new(ModuleRoutinesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_moduleRoutines

	return p
}

func (s *ModuleRoutinesContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleRoutinesContext) MainRoutine() IMainRoutineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMainRoutineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMainRoutineContext)
}

func (s *ModuleRoutinesContext) AllSubRoutine() []ISubRoutineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubRoutineContext)(nil)).Elem())
	var tst = make([]ISubRoutineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubRoutineContext)
		}
	}

	return tst
}

func (s *ModuleRoutinesContext) SubRoutine(i int) ISubRoutineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubRoutineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubRoutineContext)
}

func (s *ModuleRoutinesContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(krlParserNEWLINE)
}

func (s *ModuleRoutinesContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, i)
}

func (s *ModuleRoutinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleRoutinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleRoutinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterModuleRoutines(s)
	}
}

func (s *ModuleRoutinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitModuleRoutines(s)
	}
}

func (p *krlParser) ModuleRoutines() (localctx IModuleRoutinesContext) {
	this := p
	_ = this

	localctx = NewModuleRoutinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, krlParserRULE_moduleRoutines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(132)
		p.MainRoutine()
	}
	p.SetState(137)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-47)&-(0x1f+1)) == 0 && ((1<<uint((_la-47)))&((1<<(krlParserDEF-47))|(1<<(krlParserDEFFCT-47))|(1<<(krlParserGLOBAL-47)))) != 0) || _la == krlParserNEWLINE {
		p.SetState(135)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case krlParserDEF, krlParserDEFFCT, krlParserGLOBAL:
			{
				p.SetState(133)
				p.SubRoutine()
			}

		case krlParserNEWLINE:
			{
				p.SetState(134)
				p.Match(krlParserNEWLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(139)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMainRoutineContext is an interface to support dynamic dispatch.
type IMainRoutineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMainRoutineContext differentiates from other interfaces.
	IsMainRoutineContext()
}

type MainRoutineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMainRoutineContext() *MainRoutineContext {
	var p = new(MainRoutineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_mainRoutine
	return p
}

func (*MainRoutineContext) IsMainRoutineContext() {}

func NewMainRoutineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MainRoutineContext {
	var p = new(MainRoutineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_mainRoutine

	return p
}

func (s *MainRoutineContext) GetParser() antlr.Parser { return s.parser }

func (s *MainRoutineContext) ProcedureDefinition() IProcedureDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDefinitionContext)
}

func (s *MainRoutineContext) FunctionDefinition() IFunctionDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *MainRoutineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MainRoutineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MainRoutineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterMainRoutine(s)
	}
}

func (s *MainRoutineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitMainRoutine(s)
	}
}

func (p *krlParser) MainRoutine() (localctx IMainRoutineContext) {
	this := p
	_ = this

	localctx = NewMainRoutineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, krlParserRULE_mainRoutine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(142)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(140)
			p.ProcedureDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(141)
			p.FunctionDefinition()
		}

	}

	return localctx
}

// ISubRoutineContext is an interface to support dynamic dispatch.
type ISubRoutineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubRoutineContext differentiates from other interfaces.
	IsSubRoutineContext()
}

type SubRoutineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubRoutineContext() *SubRoutineContext {
	var p = new(SubRoutineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_subRoutine
	return p
}

func (*SubRoutineContext) IsSubRoutineContext() {}

func NewSubRoutineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubRoutineContext {
	var p = new(SubRoutineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_subRoutine

	return p
}

func (s *SubRoutineContext) GetParser() antlr.Parser { return s.parser }

func (s *SubRoutineContext) ProcedureDefinition() IProcedureDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDefinitionContext)
}

func (s *SubRoutineContext) FunctionDefinition() IFunctionDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *SubRoutineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubRoutineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubRoutineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterSubRoutine(s)
	}
}

func (s *SubRoutineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitSubRoutine(s)
	}
}

func (p *krlParser) SubRoutine() (localctx ISubRoutineContext) {
	this := p
	_ = this

	localctx = NewSubRoutineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, krlParserRULE_subRoutine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(146)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(144)
			p.ProcedureDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(145)
			p.FunctionDefinition()
		}

	}

	return localctx
}

// IProcedureDefinitionContext is an interface to support dynamic dispatch.
type IProcedureDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDefinitionContext differentiates from other interfaces.
	IsProcedureDefinitionContext()
}

type ProcedureDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDefinitionContext() *ProcedureDefinitionContext {
	var p = new(ProcedureDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_procedureDefinition
	return p
}

func (*ProcedureDefinitionContext) IsProcedureDefinitionContext() {}

func NewProcedureDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDefinitionContext {
	var p = new(ProcedureDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_procedureDefinition

	return p
}

func (s *ProcedureDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDefinitionContext) DEF() antlr.TerminalNode {
	return s.GetToken(krlParserDEF, 0)
}

func (s *ProcedureDefinitionContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *ProcedureDefinitionContext) FormalParameters() IFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *ProcedureDefinitionContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, 0)
}

func (s *ProcedureDefinitionContext) RoutineBody() IRoutineBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *ProcedureDefinitionContext) END() antlr.TerminalNode {
	return s.GetToken(krlParserEND, 0)
}

func (s *ProcedureDefinitionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(krlParserGLOBAL, 0)
}

func (s *ProcedureDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterProcedureDefinition(s)
	}
}

func (s *ProcedureDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitProcedureDefinition(s)
	}
}

func (p *krlParser) ProcedureDefinition() (localctx IProcedureDefinitionContext) {
	this := p
	_ = this

	localctx = NewProcedureDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, krlParserRULE_procedureDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(149)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserGLOBAL {
		{
			p.SetState(148)
			p.Match(krlParserGLOBAL)
		}

	}
	{
		p.SetState(151)
		p.Match(krlParserDEF)
	}
	{
		p.SetState(152)
		p.ProcedureName()
	}
	{
		p.SetState(153)
		p.FormalParameters()
	}
	{
		p.SetState(154)
		p.Match(krlParserNEWLINE)
	}
	{
		p.SetState(155)
		p.RoutineBody()
	}
	{
		p.SetState(156)
		p.Match(krlParserEND)
	}

	return localctx
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_procedureName
	return p
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (p *krlParser) ProcedureName() (localctx IProcedureNameContext) {
	this := p
	_ = this

	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, krlParserRULE_procedureName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(158)
		p.Match(krlParserIDENTIFIER)
	}

	return localctx
}

// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_functionDefinition
	return p
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) DEFFCT() antlr.TerminalNode {
	return s.GetToken(krlParserDEFFCT, 0)
}

func (s *FunctionDefinitionContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FunctionDefinitionContext) FunctionName() IFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionDefinitionContext) FormalParameters() IFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *FunctionDefinitionContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, 0)
}

func (s *FunctionDefinitionContext) RoutineBody() IRoutineBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *FunctionDefinitionContext) ENDFCT() antlr.TerminalNode {
	return s.GetToken(krlParserENDFCT, 0)
}

func (s *FunctionDefinitionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(krlParserGLOBAL, 0)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterFunctionDefinition(s)
	}
}

func (s *FunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitFunctionDefinition(s)
	}
}

func (p *krlParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, krlParserRULE_functionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(161)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserGLOBAL {
		{
			p.SetState(160)
			p.Match(krlParserGLOBAL)
		}

	}
	{
		p.SetState(163)
		p.Match(krlParserDEFFCT)
	}
	{
		p.SetState(164)
		p.Type_()
	}
	{
		p.SetState(165)
		p.FunctionName()
	}
	{
		p.SetState(166)
		p.FormalParameters()
	}
	{
		p.SetState(167)
		p.Match(krlParserNEWLINE)
	}
	{
		p.SetState(168)
		p.RoutineBody()
	}
	{
		p.SetState(169)
		p.Match(krlParserENDFCT)
	}

	return localctx
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_functionName
	return p
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (p *krlParser) FunctionName() (localctx IFunctionNameContext) {
	this := p
	_ = this

	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, krlParserRULE_functionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(171)
		p.Match(krlParserIDENTIFIER)
	}

	return localctx
}

// IModuleDataContext is an interface to support dynamic dispatch.
type IModuleDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDataContext differentiates from other interfaces.
	IsModuleDataContext()
}

type ModuleDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDataContext() *ModuleDataContext {
	var p = new(ModuleDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_moduleData
	return p
}

func (*ModuleDataContext) IsModuleDataContext() {}

func NewModuleDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDataContext {
	var p = new(ModuleDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_moduleData

	return p
}

func (s *ModuleDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDataContext) DEFDAT() antlr.TerminalNode {
	return s.GetToken(krlParserDEFDAT, 0)
}

func (s *ModuleDataContext) ModuleName() IModuleNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleNameContext)
}

func (s *ModuleDataContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(krlParserNEWLINE)
}

func (s *ModuleDataContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, i)
}

func (s *ModuleDataContext) DataList() IDataListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataListContext)
}

func (s *ModuleDataContext) ENDDAT() antlr.TerminalNode {
	return s.GetToken(krlParserENDDAT, 0)
}

func (s *ModuleDataContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(krlParserPUBLIC, 0)
}

func (s *ModuleDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterModuleData(s)
	}
}

func (s *ModuleDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitModuleData(s)
	}
}

func (p *krlParser) ModuleData() (localctx IModuleDataContext) {
	this := p
	_ = this

	localctx = NewModuleDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, krlParserRULE_moduleData)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(173)
		p.Match(krlParserDEFDAT)
	}
	{
		p.SetState(174)
		p.ModuleName()
	}
	p.SetState(176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserPUBLIC {
		{
			p.SetState(175)
			p.Match(krlParserPUBLIC)
		}

	}
	{
		p.SetState(178)
		p.Match(krlParserNEWLINE)
	}
	{
		p.SetState(179)
		p.DataList()
	}
	{
		p.SetState(180)
		p.Match(krlParserENDDAT)
	}
	p.SetState(184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserNEWLINE {
		{
			p.SetState(181)
			p.Match(krlParserNEWLINE)
		}

		p.SetState(186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModuleNameContext is an interface to support dynamic dispatch.
type IModuleNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleNameContext differentiates from other interfaces.
	IsModuleNameContext()
}

type ModuleNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleNameContext() *ModuleNameContext {
	var p = new(ModuleNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_moduleName
	return p
}

func (*ModuleNameContext) IsModuleNameContext() {}

func NewModuleNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleNameContext {
	var p = new(ModuleNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_moduleName

	return p
}

func (s *ModuleNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *ModuleNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterModuleName(s)
	}
}

func (s *ModuleNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitModuleName(s)
	}
}

func (p *krlParser) ModuleName() (localctx IModuleNameContext) {
	this := p
	_ = this

	localctx = NewModuleNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, krlParserRULE_moduleName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(187)
		p.Match(krlParserIDENTIFIER)
	}

	return localctx
}

// IDataListContext is an interface to support dynamic dispatch.
type IDataListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataListContext differentiates from other interfaces.
	IsDataListContext()
}

type DataListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataListContext() *DataListContext {
	var p = new(DataListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_dataList
	return p
}

func (*DataListContext) IsDataListContext() {}

func NewDataListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataListContext {
	var p = new(DataListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_dataList

	return p
}

func (s *DataListContext) GetParser() antlr.Parser { return s.parser }

func (s *DataListContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(krlParserNEWLINE)
}

func (s *DataListContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, i)
}

func (s *DataListContext) AllForwardDeclaration() []IForwardDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForwardDeclarationContext)(nil)).Elem())
	var tst = make([]IForwardDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForwardDeclarationContext)
		}
	}

	return tst
}

func (s *DataListContext) ForwardDeclaration(i int) IForwardDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForwardDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForwardDeclarationContext)
}

func (s *DataListContext) AllTypeDeclaration() []ITypeDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeDeclarationContext)(nil)).Elem())
	var tst = make([]ITypeDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeDeclarationContext)
		}
	}

	return tst
}

func (s *DataListContext) TypeDeclaration(i int) ITypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *DataListContext) AllVariableDeclarationInDataList() []IVariableDeclarationInDataListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclarationInDataListContext)(nil)).Elem())
	var tst = make([]IVariableDeclarationInDataListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclarationInDataListContext)
		}
	}

	return tst
}

func (s *DataListContext) VariableDeclarationInDataList(i int) IVariableDeclarationInDataListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationInDataListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationInDataListContext)
}

func (s *DataListContext) AllArrayInitialisation() []IArrayInitialisationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArrayInitialisationContext)(nil)).Elem())
	var tst = make([]IArrayInitialisationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArrayInitialisationContext)
		}
	}

	return tst
}

func (s *DataListContext) ArrayInitialisation(i int) IArrayInitialisationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayInitialisationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArrayInitialisationContext)
}

func (s *DataListContext) AllImportStatement() []IImportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportStatementContext)(nil)).Elem())
	var tst = make([]IImportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportStatementContext)
		}
	}

	return tst
}

func (s *DataListContext) ImportStatement(i int) IImportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *DataListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterDataList(s)
	}
}

func (s *DataListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitDataList(s)
	}
}

func (p *krlParser) DataList() (localctx IDataListContext) {
	this := p
	_ = this

	localctx = NewDataListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, krlParserRULE_dataList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-31)&-(0x1f+1)) == 0 && ((1<<uint((_la-31)))&((1<<(krlParserBOOL-31))|(1<<(krlParserCHAR-31))|(1<<(krlParserCONST-31))|(1<<(krlParserDECL-31))|(1<<(krlParserENUM-31)))) != 0) || (((_la-63)&-(0x1f+1)) == 0 && ((1<<uint((_la-63)))&((1<<(krlParserEXT-63))|(1<<(krlParserEXTFCT-63))|(1<<(krlParserGLOBAL-63))|(1<<(krlParserIMPORT-63))|(1<<(krlParserINT-63))|(1<<(krlParserREAL-63))|(1<<(krlParserSIGNAL-63))|(1<<(krlParserSTRUC-63)))) != 0) || _la == krlParserNEWLINE || _la == krlParserIDENTIFIER {
		p.SetState(205)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(189)
				p.Match(krlParserNEWLINE)
			}

		case 2:
			{
				p.SetState(190)
				p.ForwardDeclaration()
			}
			{
				p.SetState(191)
				p.Match(krlParserNEWLINE)
			}

		case 3:
			{
				p.SetState(193)
				p.TypeDeclaration()
			}
			{
				p.SetState(194)
				p.Match(krlParserNEWLINE)
			}

		case 4:
			{
				p.SetState(196)
				p.VariableDeclarationInDataList()
			}
			{
				p.SetState(197)
				p.Match(krlParserNEWLINE)
			}

		case 5:
			{
				p.SetState(199)
				p.ArrayInitialisation()
			}
			{
				p.SetState(200)
				p.Match(krlParserNEWLINE)
			}

		case 6:
			{
				p.SetState(202)
				p.ImportStatement()
			}
			{
				p.SetState(203)
				p.Match(krlParserNEWLINE)
			}

		}

		p.SetState(209)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArrayInitialisationContext is an interface to support dynamic dispatch.
type IArrayInitialisationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayInitialisationContext differentiates from other interfaces.
	IsArrayInitialisationContext()
}

type ArrayInitialisationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitialisationContext() *ArrayInitialisationContext {
	var p = new(ArrayInitialisationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_arrayInitialisation
	return p
}

func (*ArrayInitialisationContext) IsArrayInitialisationContext() {}

func NewArrayInitialisationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitialisationContext {
	var p = new(ArrayInitialisationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_arrayInitialisation

	return p
}

func (s *ArrayInitialisationContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitialisationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *ArrayInitialisationContext) ArrayVariableSuffix() IArrayVariableSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayVariableSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayVariableSuffixContext)
}

func (s *ArrayInitialisationContext) UnaryPlusMinuxExpression() IUnaryPlusMinuxExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryPlusMinuxExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryPlusMinuxExpressionContext)
}

func (s *ArrayInitialisationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitialisationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitialisationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterArrayInitialisation(s)
	}
}

func (s *ArrayInitialisationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitArrayInitialisation(s)
	}
}

func (p *krlParser) ArrayInitialisation() (localctx IArrayInitialisationContext) {
	this := p
	_ = this

	localctx = NewArrayInitialisationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, krlParserRULE_arrayInitialisation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(210)
		p.Match(krlParserIDENTIFIER)
	}
	{
		p.SetState(211)
		p.ArrayVariableSuffix()
	}
	{
		p.SetState(212)
		p.Match(krlParserT__0)
	}
	{
		p.SetState(213)
		p.UnaryPlusMinuxExpression()
	}

	return localctx
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_typeDeclaration
	return p
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) StructureDefinition() IStructureDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructureDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStructureDefinitionContext)
}

func (s *TypeDeclarationContext) EnumDefinition() IEnumDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumDefinitionContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}

func (p *krlParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, krlParserRULE_typeDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(215)
			p.StructureDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(216)
			p.EnumDefinition()
		}

	}

	return localctx
}

// IStructureDefinitionContext is an interface to support dynamic dispatch.
type IStructureDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructureDefinitionContext differentiates from other interfaces.
	IsStructureDefinitionContext()
}

type StructureDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructureDefinitionContext() *StructureDefinitionContext {
	var p = new(StructureDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_structureDefinition
	return p
}

func (*StructureDefinitionContext) IsStructureDefinitionContext() {}

func NewStructureDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructureDefinitionContext {
	var p = new(StructureDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_structureDefinition

	return p
}

func (s *StructureDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *StructureDefinitionContext) STRUC() antlr.TerminalNode {
	return s.GetToken(krlParserSTRUC, 0)
}

func (s *StructureDefinitionContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StructureDefinitionContext) AllType_() []IType_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_Context)(nil)).Elem())
	var tst = make([]IType_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_Context)
		}
	}

	return tst
}

func (s *StructureDefinitionContext) Type_(i int) IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *StructureDefinitionContext) AllVariableName() []IVariableNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableNameContext)(nil)).Elem())
	var tst = make([]IVariableNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableNameContext)
		}
	}

	return tst
}

func (s *StructureDefinitionContext) VariableName(i int) IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *StructureDefinitionContext) AllVariableListRest() []IVariableListRestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableListRestContext)(nil)).Elem())
	var tst = make([]IVariableListRestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableListRestContext)
		}
	}

	return tst
}

func (s *StructureDefinitionContext) VariableListRest(i int) IVariableListRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableListRestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableListRestContext)
}

func (s *StructureDefinitionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(krlParserGLOBAL, 0)
}

func (s *StructureDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructureDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructureDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterStructureDefinition(s)
	}
}

func (s *StructureDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitStructureDefinition(s)
	}
}

func (p *krlParser) StructureDefinition() (localctx IStructureDefinitionContext) {
	this := p
	_ = this

	localctx = NewStructureDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, krlParserRULE_structureDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserGLOBAL {
		{
			p.SetState(219)
			p.Match(krlParserGLOBAL)
		}

	}
	{
		p.SetState(222)
		p.Match(krlParserSTRUC)
	}
	{
		p.SetState(223)
		p.TypeName()
	}
	{
		p.SetState(224)
		p.Type_()
	}
	{
		p.SetState(225)
		p.VariableName()
	}
	{
		p.SetState(226)
		p.VariableListRest()
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserT__1 {
		{
			p.SetState(227)
			p.Match(krlParserT__1)
		}
		{
			p.SetState(228)
			p.Type_()
		}
		{
			p.SetState(229)
			p.VariableName()
		}
		{
			p.SetState(230)
			p.VariableListRest()
		}

		p.SetState(236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEnumDefinitionContext is an interface to support dynamic dispatch.
type IEnumDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumDefinitionContext differentiates from other interfaces.
	IsEnumDefinitionContext()
}

type EnumDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDefinitionContext() *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_enumDefinition
	return p
}

func (*EnumDefinitionContext) IsEnumDefinitionContext() {}

func NewEnumDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_enumDefinition

	return p
}

func (s *EnumDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDefinitionContext) ENUM() antlr.TerminalNode {
	return s.GetToken(krlParserENUM, 0)
}

func (s *EnumDefinitionContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EnumDefinitionContext) AllEnumValue() []IEnumValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumValueContext)(nil)).Elem())
	var tst = make([]IEnumValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumValueContext)
		}
	}

	return tst
}

func (s *EnumDefinitionContext) EnumValue(i int) IEnumValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *EnumDefinitionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(krlParserGLOBAL, 0)
}

func (s *EnumDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterEnumDefinition(s)
	}
}

func (s *EnumDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitEnumDefinition(s)
	}
}

func (p *krlParser) EnumDefinition() (localctx IEnumDefinitionContext) {
	this := p
	_ = this

	localctx = NewEnumDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, krlParserRULE_enumDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(238)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserGLOBAL {
		{
			p.SetState(237)
			p.Match(krlParserGLOBAL)
		}

	}
	{
		p.SetState(240)
		p.Match(krlParserENUM)
	}
	{
		p.SetState(241)
		p.TypeName()
	}
	{
		p.SetState(242)
		p.EnumValue()
	}
	p.SetState(247)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserT__1 {
		{
			p.SetState(243)
			p.Match(krlParserT__1)
		}
		{
			p.SetState(244)
			p.EnumValue()
		}

		p.SetState(249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEnumValueContext is an interface to support dynamic dispatch.
type IEnumValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumValueContext differentiates from other interfaces.
	IsEnumValueContext()
}

type EnumValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueContext() *EnumValueContext {
	var p = new(EnumValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_enumValue
	return p
}

func (*EnumValueContext) IsEnumValueContext() {}

func NewEnumValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueContext {
	var p = new(EnumValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_enumValue

	return p
}

func (s *EnumValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *EnumValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterEnumValue(s)
	}
}

func (s *EnumValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitEnumValue(s)
	}
}

func (p *krlParser) EnumValue() (localctx IEnumValueContext) {
	this := p
	_ = this

	localctx = NewEnumValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, krlParserRULE_enumValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(250)
		p.Match(krlParserIDENTIFIER)
	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *VariableDeclarationContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *VariableDeclarationContext) VariableListRest() IVariableListRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableListRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableListRestContext)
}

func (s *VariableDeclarationContext) SignalDeclaration() ISignalDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignalDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignalDeclarationContext)
}

func (s *VariableDeclarationContext) DECL() antlr.TerminalNode {
	return s.GetToken(krlParserDECL, 0)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *krlParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, krlParserRULE_variableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(253)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserDECL {
		{
			p.SetState(252)
			p.Match(krlParserDECL)
		}

	}
	p.SetState(260)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case krlParserBOOL, krlParserCHAR, krlParserINT, krlParserREAL, krlParserIDENTIFIER:
		{
			p.SetState(255)
			p.Type_()
		}
		{
			p.SetState(256)
			p.VariableName()
		}
		{
			p.SetState(257)
			p.VariableListRest()
		}

	case krlParserSIGNAL:
		{
			p.SetState(259)
			p.SignalDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISignalDeclarationContext is an interface to support dynamic dispatch.
type ISignalDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignalDeclarationContext differentiates from other interfaces.
	IsSignalDeclarationContext()
}

type SignalDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalDeclarationContext() *SignalDeclarationContext {
	var p = new(SignalDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_signalDeclaration
	return p
}

func (*SignalDeclarationContext) IsSignalDeclarationContext() {}

func NewSignalDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalDeclarationContext {
	var p = new(SignalDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_signalDeclaration

	return p
}

func (s *SignalDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalDeclarationContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(krlParserSIGNAL, 0)
}

func (s *SignalDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *SignalDeclarationContext) AllPrimary() []IPrimaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimaryContext)(nil)).Elem())
	var tst = make([]IPrimaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimaryContext)
		}
	}

	return tst
}

func (s *SignalDeclarationContext) Primary(i int) IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *SignalDeclarationContext) TO() antlr.TerminalNode {
	return s.GetToken(krlParserTO, 0)
}

func (s *SignalDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterSignalDeclaration(s)
	}
}

func (s *SignalDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitSignalDeclaration(s)
	}
}

func (p *krlParser) SignalDeclaration() (localctx ISignalDeclarationContext) {
	this := p
	_ = this

	localctx = NewSignalDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, krlParserRULE_signalDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(262)
		p.Match(krlParserSIGNAL)
	}
	{
		p.SetState(263)
		p.Match(krlParserIDENTIFIER)
	}
	{
		p.SetState(264)
		p.Primary()
	}
	p.SetState(267)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserTO {
		{
			p.SetState(265)
			p.Match(krlParserTO)
		}
		{
			p.SetState(266)
			p.Primary()
		}

	}

	return localctx
}

// IVariableDeclarationInDataListContext is an interface to support dynamic dispatch.
type IVariableDeclarationInDataListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationInDataListContext differentiates from other interfaces.
	IsVariableDeclarationInDataListContext()
}

type VariableDeclarationInDataListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationInDataListContext() *VariableDeclarationInDataListContext {
	var p = new(VariableDeclarationInDataListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_variableDeclarationInDataList
	return p
}

func (*VariableDeclarationInDataListContext) IsVariableDeclarationInDataListContext() {}

func NewVariableDeclarationInDataListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationInDataListContext {
	var p = new(VariableDeclarationInDataListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_variableDeclarationInDataList

	return p
}

func (s *VariableDeclarationInDataListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationInDataListContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *VariableDeclarationInDataListContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *VariableDeclarationInDataListContext) SignalDeclaration() ISignalDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignalDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignalDeclarationContext)
}

func (s *VariableDeclarationInDataListContext) DECL() antlr.TerminalNode {
	return s.GetToken(krlParserDECL, 0)
}

func (s *VariableDeclarationInDataListContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(krlParserGLOBAL, 0)
}

func (s *VariableDeclarationInDataListContext) CONST() antlr.TerminalNode {
	return s.GetToken(krlParserCONST, 0)
}

func (s *VariableDeclarationInDataListContext) VariableListRest() IVariableListRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableListRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableListRestContext)
}

func (s *VariableDeclarationInDataListContext) VariableInitialisation() IVariableInitialisationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitialisationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableInitialisationContext)
}

func (s *VariableDeclarationInDataListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationInDataListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationInDataListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterVariableDeclarationInDataList(s)
	}
}

func (s *VariableDeclarationInDataListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitVariableDeclarationInDataList(s)
	}
}

func (p *krlParser) VariableDeclarationInDataList() (localctx IVariableDeclarationInDataListContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationInDataListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, krlParserRULE_variableDeclarationInDataList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(270)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserDECL {
		{
			p.SetState(269)
			p.Match(krlParserDECL)
		}

	}
	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserGLOBAL {
		{
			p.SetState(272)
			p.Match(krlParserGLOBAL)
		}

	}
	p.SetState(276)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserCONST {
		{
			p.SetState(275)
			p.Match(krlParserCONST)
		}

	}
	p.SetState(285)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case krlParserBOOL, krlParserCHAR, krlParserINT, krlParserREAL, krlParserIDENTIFIER:
		{
			p.SetState(278)
			p.Type_()
		}
		{
			p.SetState(279)
			p.VariableName()
		}
		p.SetState(282)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case krlParserT__1, krlParserNEWLINE:
			{
				p.SetState(280)
				p.VariableListRest()
			}

		case krlParserT__0:
			{
				p.SetState(281)
				p.VariableInitialisation()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case krlParserSIGNAL:
		{
			p.SetState(284)
			p.SignalDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableListRestContext is an interface to support dynamic dispatch.
type IVariableListRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableListRestContext differentiates from other interfaces.
	IsVariableListRestContext()
}

type VariableListRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableListRestContext() *VariableListRestContext {
	var p = new(VariableListRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_variableListRest
	return p
}

func (*VariableListRestContext) IsVariableListRestContext() {}

func NewVariableListRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableListRestContext {
	var p = new(VariableListRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_variableListRest

	return p
}

func (s *VariableListRestContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableListRestContext) AllVariableName() []IVariableNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableNameContext)(nil)).Elem())
	var tst = make([]IVariableNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableNameContext)
		}
	}

	return tst
}

func (s *VariableListRestContext) VariableName(i int) IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *VariableListRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableListRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableListRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterVariableListRest(s)
	}
}

func (s *VariableListRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitVariableListRest(s)
	}
}

func (p *krlParser) VariableListRest() (localctx IVariableListRestContext) {
	this := p
	_ = this

	localctx = NewVariableListRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, krlParserRULE_variableListRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(287)
				p.Match(krlParserT__1)
			}
			{
				p.SetState(288)
				p.VariableName()
			}

		}
		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
	}

	return localctx
}

// IVariableInitialisationContext is an interface to support dynamic dispatch.
type IVariableInitialisationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitialisationContext differentiates from other interfaces.
	IsVariableInitialisationContext()
}

type VariableInitialisationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitialisationContext() *VariableInitialisationContext {
	var p = new(VariableInitialisationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_variableInitialisation
	return p
}

func (*VariableInitialisationContext) IsVariableInitialisationContext() {}

func NewVariableInitialisationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitialisationContext {
	var p = new(VariableInitialisationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_variableInitialisation

	return p
}

func (s *VariableInitialisationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitialisationContext) UnaryPlusMinuxExpression() IUnaryPlusMinuxExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryPlusMinuxExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryPlusMinuxExpressionContext)
}

func (s *VariableInitialisationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitialisationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitialisationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterVariableInitialisation(s)
	}
}

func (s *VariableInitialisationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitVariableInitialisation(s)
	}
}

func (p *krlParser) VariableInitialisation() (localctx IVariableInitialisationContext) {
	this := p
	_ = this

	localctx = NewVariableInitialisationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, krlParserRULE_variableInitialisation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(294)
		p.Match(krlParserT__0)
	}
	{
		p.SetState(295)
		p.UnaryPlusMinuxExpression()
	}

	return localctx
}

// IStructLiteralContext is an interface to support dynamic dispatch.
type IStructLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructLiteralContext differentiates from other interfaces.
	IsStructLiteralContext()
}

type StructLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructLiteralContext() *StructLiteralContext {
	var p = new(StructLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_structLiteral
	return p
}

func (*StructLiteralContext) IsStructLiteralContext() {}

func NewStructLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructLiteralContext {
	var p = new(StructLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_structLiteral

	return p
}

func (s *StructLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StructLiteralContext) StructElementList() IStructElementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructElementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStructElementListContext)
}

func (s *StructLiteralContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StructLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterStructLiteral(s)
	}
}

func (s *StructLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitStructLiteral(s)
	}
}

func (p *krlParser) StructLiteral() (localctx IStructLiteralContext) {
	this := p
	_ = this

	localctx = NewStructLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, krlParserRULE_structLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(297)
		p.Match(krlParserT__2)
	}
	p.SetState(301)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(298)
			p.TypeName()
		}
		{
			p.SetState(299)
			p.Match(krlParserT__3)
		}

	}
	{
		p.SetState(303)
		p.StructElementList()
	}
	{
		p.SetState(304)
		p.Match(krlParserT__4)
	}

	return localctx
}

// IStructElementListContext is an interface to support dynamic dispatch.
type IStructElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructElementListContext differentiates from other interfaces.
	IsStructElementListContext()
}

type StructElementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructElementListContext() *StructElementListContext {
	var p = new(StructElementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_structElementList
	return p
}

func (*StructElementListContext) IsStructElementListContext() {}

func NewStructElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructElementListContext {
	var p = new(StructElementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_structElementList

	return p
}

func (s *StructElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StructElementListContext) AllStructElement() []IStructElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStructElementContext)(nil)).Elem())
	var tst = make([]IStructElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStructElementContext)
		}
	}

	return tst
}

func (s *StructElementListContext) StructElement(i int) IStructElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStructElementContext)
}

func (s *StructElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterStructElementList(s)
	}
}

func (s *StructElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitStructElementList(s)
	}
}

func (p *krlParser) StructElementList() (localctx IStructElementListContext) {
	this := p
	_ = this

	localctx = NewStructElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, krlParserRULE_structElementList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(306)
		p.StructElement()
	}
	p.SetState(311)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserT__1 {
		{
			p.SetState(307)
			p.Match(krlParserT__1)
		}
		{
			p.SetState(308)
			p.StructElement()
		}

		p.SetState(313)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStructElementContext is an interface to support dynamic dispatch.
type IStructElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructElementContext differentiates from other interfaces.
	IsStructElementContext()
}

type StructElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructElementContext() *StructElementContext {
	var p = new(StructElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_structElement
	return p
}

func (*StructElementContext) IsStructElementContext() {}

func NewStructElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructElementContext {
	var p = new(StructElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_structElement

	return p
}

func (s *StructElementContext) GetParser() antlr.Parser { return s.parser }

func (s *StructElementContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *StructElementContext) UnaryPlusMinuxExpression() IUnaryPlusMinuxExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryPlusMinuxExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryPlusMinuxExpressionContext)
}

func (s *StructElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterStructElement(s)
	}
}

func (s *StructElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitStructElement(s)
	}
}

func (p *krlParser) StructElement() (localctx IStructElementContext) {
	this := p
	_ = this

	localctx = NewStructElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, krlParserRULE_structElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.VariableName()
	}
	{
		p.SetState(315)
		p.UnaryPlusMinuxExpression()
	}

	return localctx
}

// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_formalParameters
	return p
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *FormalParametersContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterFormalParameters(s)
	}
}

func (s *FormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitFormalParameters(s)
	}
}

func (p *krlParser) FormalParameters() (localctx IFormalParametersContext) {
	this := p
	_ = this

	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, krlParserRULE_formalParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(317)
		p.Match(krlParserT__5)
	}
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserIDENTIFIER {
		{
			p.SetState(318)
			p.Parameter()
		}
		p.SetState(323)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == krlParserT__1 {
			{
				p.SetState(319)
				p.Match(krlParserT__1)
			}
			{
				p.SetState(320)
				p.Parameter()
			}

			p.SetState(325)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(328)
		p.Match(krlParserT__6)
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *ParameterContext) ParameterCallType() IParameterCallTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterCallTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterCallTypeContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *krlParser) Parameter() (localctx IParameterContext) {
	this := p
	_ = this

	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, krlParserRULE_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(330)
		p.VariableName()
	}
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserT__3 {
		{
			p.SetState(331)
			p.ParameterCallType()
		}

	}

	return localctx
}

// IRoutineBodyContext is an interface to support dynamic dispatch.
type IRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineBodyContext differentiates from other interfaces.
	IsRoutineBodyContext()
}

type RoutineBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineBodyContext() *RoutineBodyContext {
	var p = new(RoutineBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_routineBody
	return p
}

func (*RoutineBodyContext) IsRoutineBodyContext() {}

func NewRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineBodyContext {
	var p = new(RoutineBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_routineBody

	return p
}

func (s *RoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineBodyContext) RoutineDataSection() IRoutineDataSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineDataSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineDataSectionContext)
}

func (s *RoutineBodyContext) RoutineImplementationSection() IRoutineImplementationSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineImplementationSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineImplementationSectionContext)
}

func (s *RoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterRoutineBody(s)
	}
}

func (s *RoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitRoutineBody(s)
	}
}

func (p *krlParser) RoutineBody() (localctx IRoutineBodyContext) {
	this := p
	_ = this

	localctx = NewRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, krlParserRULE_routineBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(334)
		p.RoutineDataSection()
	}
	{
		p.SetState(335)
		p.RoutineImplementationSection()
	}

	return localctx
}

// IRoutineDataSectionContext is an interface to support dynamic dispatch.
type IRoutineDataSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineDataSectionContext differentiates from other interfaces.
	IsRoutineDataSectionContext()
}

type RoutineDataSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineDataSectionContext() *RoutineDataSectionContext {
	var p = new(RoutineDataSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_routineDataSection
	return p
}

func (*RoutineDataSectionContext) IsRoutineDataSectionContext() {}

func NewRoutineDataSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineDataSectionContext {
	var p = new(RoutineDataSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_routineDataSection

	return p
}

func (s *RoutineDataSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineDataSectionContext) AllForwardDeclaration() []IForwardDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForwardDeclarationContext)(nil)).Elem())
	var tst = make([]IForwardDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForwardDeclarationContext)
		}
	}

	return tst
}

func (s *RoutineDataSectionContext) ForwardDeclaration(i int) IForwardDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForwardDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForwardDeclarationContext)
}

func (s *RoutineDataSectionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(krlParserNEWLINE)
}

func (s *RoutineDataSectionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, i)
}

func (s *RoutineDataSectionContext) AllVariableDeclaration() []IVariableDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem())
	var tst = make([]IVariableDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclarationContext)
		}
	}

	return tst
}

func (s *RoutineDataSectionContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *RoutineDataSectionContext) AllImportStatement() []IImportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportStatementContext)(nil)).Elem())
	var tst = make([]IImportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportStatementContext)
		}
	}

	return tst
}

func (s *RoutineDataSectionContext) ImportStatement(i int) IImportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *RoutineDataSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineDataSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineDataSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterRoutineDataSection(s)
	}
}

func (s *RoutineDataSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitRoutineDataSection(s)
	}
}

func (p *krlParser) RoutineDataSection() (localctx IRoutineDataSectionContext) {
	this := p
	_ = this

	localctx = NewRoutineDataSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, krlParserRULE_routineDataSection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(348)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case krlParserEXT, krlParserEXTFCT:
				{
					p.SetState(337)
					p.ForwardDeclaration()
				}
				{
					p.SetState(338)
					p.Match(krlParserNEWLINE)
				}

			case krlParserBOOL, krlParserCHAR, krlParserDECL, krlParserINT, krlParserREAL, krlParserSIGNAL, krlParserIDENTIFIER:
				{
					p.SetState(340)
					p.VariableDeclaration()
				}
				{
					p.SetState(341)
					p.Match(krlParserNEWLINE)
				}

			case krlParserNEWLINE:
				{
					p.SetState(343)
					p.Match(krlParserNEWLINE)
				}

				{
					p.SetState(344)
					p.Match(krlParserNEWLINE)
				}

			case krlParserIMPORT:
				{
					p.SetState(345)
					p.ImportStatement()
				}
				{
					p.SetState(346)
					p.Match(krlParserNEWLINE)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}

	return localctx
}

// IForwardDeclarationContext is an interface to support dynamic dispatch.
type IForwardDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForwardDeclarationContext differentiates from other interfaces.
	IsForwardDeclarationContext()
}

type ForwardDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardDeclarationContext() *ForwardDeclarationContext {
	var p = new(ForwardDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_forwardDeclaration
	return p
}

func (*ForwardDeclarationContext) IsForwardDeclarationContext() {}

func NewForwardDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardDeclarationContext {
	var p = new(ForwardDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_forwardDeclaration

	return p
}

func (s *ForwardDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardDeclarationContext) EXT() antlr.TerminalNode {
	return s.GetToken(krlParserEXT, 0)
}

func (s *ForwardDeclarationContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *ForwardDeclarationContext) FormalParametersWithType() IFormalParametersWithTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersWithTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersWithTypeContext)
}

func (s *ForwardDeclarationContext) EXTFCT() antlr.TerminalNode {
	return s.GetToken(krlParserEXTFCT, 0)
}

func (s *ForwardDeclarationContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ForwardDeclarationContext) FunctionName() IFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *ForwardDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterForwardDeclaration(s)
	}
}

func (s *ForwardDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitForwardDeclaration(s)
	}
}

func (p *krlParser) ForwardDeclaration() (localctx IForwardDeclarationContext) {
	this := p
	_ = this

	localctx = NewForwardDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, krlParserRULE_forwardDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(362)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case krlParserEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(353)
			p.Match(krlParserEXT)
		}
		{
			p.SetState(354)
			p.ProcedureName()
		}
		{
			p.SetState(355)
			p.FormalParametersWithType()
		}

	case krlParserEXTFCT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(357)
			p.Match(krlParserEXTFCT)
		}
		{
			p.SetState(358)
			p.Type_()
		}
		{
			p.SetState(359)
			p.FunctionName()
		}
		{
			p.SetState(360)
			p.FormalParametersWithType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFormalParametersWithTypeContext is an interface to support dynamic dispatch.
type IFormalParametersWithTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParametersWithTypeContext differentiates from other interfaces.
	IsFormalParametersWithTypeContext()
}

type FormalParametersWithTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersWithTypeContext() *FormalParametersWithTypeContext {
	var p = new(FormalParametersWithTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_formalParametersWithType
	return p
}

func (*FormalParametersWithTypeContext) IsFormalParametersWithTypeContext() {}

func NewFormalParametersWithTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersWithTypeContext {
	var p = new(FormalParametersWithTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_formalParametersWithType

	return p
}

func (s *FormalParametersWithTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersWithTypeContext) AllParameterWithType() []IParameterWithTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterWithTypeContext)(nil)).Elem())
	var tst = make([]IParameterWithTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterWithTypeContext)
		}
	}

	return tst
}

func (s *FormalParametersWithTypeContext) ParameterWithType(i int) IParameterWithTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterWithTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterWithTypeContext)
}

func (s *FormalParametersWithTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersWithTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersWithTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterFormalParametersWithType(s)
	}
}

func (s *FormalParametersWithTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitFormalParametersWithType(s)
	}
}

func (p *krlParser) FormalParametersWithType() (localctx IFormalParametersWithTypeContext) {
	this := p
	_ = this

	localctx = NewFormalParametersWithTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, krlParserRULE_formalParametersWithType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(364)
		p.Match(krlParserT__5)
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserBOOL || _la == krlParserCHAR || _la == krlParserINT || _la == krlParserREAL || _la == krlParserIDENTIFIER {
		{
			p.SetState(365)
			p.ParameterWithType()
		}
		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == krlParserT__1 {
			{
				p.SetState(366)
				p.Match(krlParserT__1)
			}
			{
				p.SetState(367)
				p.ParameterWithType()
			}

			p.SetState(372)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(375)
		p.Match(krlParserT__6)
	}

	return localctx
}

// IParameterWithTypeContext is an interface to support dynamic dispatch.
type IParameterWithTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterWithTypeContext differentiates from other interfaces.
	IsParameterWithTypeContext()
}

type ParameterWithTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterWithTypeContext() *ParameterWithTypeContext {
	var p = new(ParameterWithTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_parameterWithType
	return p
}

func (*ParameterWithTypeContext) IsParameterWithTypeContext() {}

func NewParameterWithTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterWithTypeContext {
	var p = new(ParameterWithTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_parameterWithType

	return p
}

func (s *ParameterWithTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterWithTypeContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ParameterWithTypeContext) ParameterCallType() IParameterCallTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterCallTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterCallTypeContext)
}

func (s *ParameterWithTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterWithTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterWithTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterParameterWithType(s)
	}
}

func (s *ParameterWithTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitParameterWithType(s)
	}
}

func (p *krlParser) ParameterWithType() (localctx IParameterWithTypeContext) {
	this := p
	_ = this

	localctx = NewParameterWithTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, krlParserRULE_parameterWithType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		p.Type_()
	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserT__3 {
		{
			p.SetState(378)
			p.ParameterCallType()
		}

	}

	return localctx
}

// IParameterCallTypeContext is an interface to support dynamic dispatch.
type IParameterCallTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterCallTypeContext differentiates from other interfaces.
	IsParameterCallTypeContext()
}

type ParameterCallTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterCallTypeContext() *ParameterCallTypeContext {
	var p = new(ParameterCallTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_parameterCallType
	return p
}

func (*ParameterCallTypeContext) IsParameterCallTypeContext() {}

func NewParameterCallTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterCallTypeContext {
	var p = new(ParameterCallTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_parameterCallType

	return p
}

func (s *ParameterCallTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterCallTypeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *ParameterCallTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterCallTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterCallTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterParameterCallType(s)
	}
}

func (s *ParameterCallTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitParameterCallType(s)
	}
}

func (p *krlParser) ParameterCallType() (localctx IParameterCallTypeContext) {
	this := p
	_ = this

	localctx = NewParameterCallTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, krlParserRULE_parameterCallType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Match(krlParserT__3)
	}
	{
		p.SetState(382)
		p.Match(krlParserIDENTIFIER)
	}

	return localctx
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_importStatement
	return p
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(krlParserIMPORT, 0)
}

func (s *ImportStatementContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ImportStatementContext) AllVariableName() []IVariableNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableNameContext)(nil)).Elem())
	var tst = make([]IVariableNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableNameContext)
		}
	}

	return tst
}

func (s *ImportStatementContext) VariableName(i int) IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *ImportStatementContext) IS() antlr.TerminalNode {
	return s.GetToken(krlParserIS, 0)
}

func (s *ImportStatementContext) ModuleName() IModuleNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleNameContext)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (p *krlParser) ImportStatement() (localctx IImportStatementContext) {
	this := p
	_ = this

	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, krlParserRULE_importStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Match(krlParserIMPORT)
	}
	{
		p.SetState(385)
		p.Type_()
	}
	{
		p.SetState(386)
		p.VariableName()
	}
	{
		p.SetState(387)
		p.Match(krlParserIS)
	}
	{
		p.SetState(388)
		p.Match(krlParserT__7)
	}
	{
		p.SetState(389)
		p.ModuleName()
	}
	{
		p.SetState(390)
		p.Match(krlParserT__8)
	}
	{
		p.SetState(391)
		p.VariableName()
	}

	return localctx
}

// IVariableNameContext is an interface to support dynamic dispatch.
type IVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableNameContext differentiates from other interfaces.
	IsVariableNameContext()
}

type VariableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNameContext() *VariableNameContext {
	var p = new(VariableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_variableName
	return p
}

func (*VariableNameContext) IsVariableNameContext() {}

func NewVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNameContext {
	var p = new(VariableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_variableName

	return p
}

func (s *VariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *VariableNameContext) ArrayVariableSuffix() IArrayVariableSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayVariableSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayVariableSuffixContext)
}

func (s *VariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterVariableName(s)
	}
}

func (s *VariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitVariableName(s)
	}
}

func (p *krlParser) VariableName() (localctx IVariableNameContext) {
	this := p
	_ = this

	localctx = NewVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, krlParserRULE_variableName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(393)
		p.Match(krlParserIDENTIFIER)
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserT__9 {
		{
			p.SetState(394)
			p.ArrayVariableSuffix()
		}

	}

	return localctx
}

// IArrayVariableSuffixContext is an interface to support dynamic dispatch.
type IArrayVariableSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayVariableSuffixContext differentiates from other interfaces.
	IsArrayVariableSuffixContext()
}

type ArrayVariableSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayVariableSuffixContext() *ArrayVariableSuffixContext {
	var p = new(ArrayVariableSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_arrayVariableSuffix
	return p
}

func (*ArrayVariableSuffixContext) IsArrayVariableSuffixContext() {}

func NewArrayVariableSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayVariableSuffixContext {
	var p = new(ArrayVariableSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_arrayVariableSuffix

	return p
}

func (s *ArrayVariableSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayVariableSuffixContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayVariableSuffixContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayVariableSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayVariableSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayVariableSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterArrayVariableSuffix(s)
	}
}

func (s *ArrayVariableSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitArrayVariableSuffix(s)
	}
}

func (p *krlParser) ArrayVariableSuffix() (localctx IArrayVariableSuffixContext) {
	this := p
	_ = this

	localctx = NewArrayVariableSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, krlParserRULE_arrayVariableSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		p.Match(krlParserT__9)
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<krlParserT__2)|(1<<krlParserT__5)|(1<<krlParserT__17)|(1<<krlParserT__18)|(1<<krlParserT__22)|(1<<krlParserB_NOT))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(krlParserFALSE-65))|(1<<(krlParserNOT-65))|(1<<(krlParserTRUE-65)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(krlParserCHARLITERAL-106))|(1<<(krlParserSTRINGLITERAL-106))|(1<<(krlParserFLOATLITERAL-106))|(1<<(krlParserINTLITERAL-106))|(1<<(krlParserIDENTIFIER-106)))) != 0) {
		{
			p.SetState(398)
			p.Expression()
		}
		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserT__1 {
			{
				p.SetState(399)
				p.Match(krlParserT__1)
			}
			p.SetState(407)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<krlParserT__2)|(1<<krlParserT__5)|(1<<krlParserT__17)|(1<<krlParserT__18)|(1<<krlParserT__22)|(1<<krlParserB_NOT))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(krlParserFALSE-65))|(1<<(krlParserNOT-65))|(1<<(krlParserTRUE-65)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(krlParserCHARLITERAL-106))|(1<<(krlParserSTRINGLITERAL-106))|(1<<(krlParserFLOATLITERAL-106))|(1<<(krlParserINTLITERAL-106))|(1<<(krlParserIDENTIFIER-106)))) != 0) {
				{
					p.SetState(400)
					p.Expression()
				}
				p.SetState(405)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == krlParserT__1 {
					{
						p.SetState(401)
						p.Match(krlParserT__1)
					}
					p.SetState(403)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<krlParserT__2)|(1<<krlParserT__5)|(1<<krlParserT__17)|(1<<krlParserT__18)|(1<<krlParserT__22)|(1<<krlParserB_NOT))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(krlParserFALSE-65))|(1<<(krlParserNOT-65))|(1<<(krlParserTRUE-65)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(krlParserCHARLITERAL-106))|(1<<(krlParserSTRINGLITERAL-106))|(1<<(krlParserFLOATLITERAL-106))|(1<<(krlParserINTLITERAL-106))|(1<<(krlParserIDENTIFIER-106)))) != 0) {
						{
							p.SetState(402)
							p.Expression()
						}

					}

				}

			}

		}

	}
	{
		p.SetState(413)
		p.Match(krlParserT__10)
	}

	return localctx
}

// IRoutineImplementationSectionContext is an interface to support dynamic dispatch.
type IRoutineImplementationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineImplementationSectionContext differentiates from other interfaces.
	IsRoutineImplementationSectionContext()
}

type RoutineImplementationSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineImplementationSectionContext() *RoutineImplementationSectionContext {
	var p = new(RoutineImplementationSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_routineImplementationSection
	return p
}

func (*RoutineImplementationSectionContext) IsRoutineImplementationSectionContext() {}

func NewRoutineImplementationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineImplementationSectionContext {
	var p = new(RoutineImplementationSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_routineImplementationSection

	return p
}

func (s *RoutineImplementationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineImplementationSectionContext) StatementList() IStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *RoutineImplementationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineImplementationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineImplementationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterRoutineImplementationSection(s)
	}
}

func (s *RoutineImplementationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitRoutineImplementationSection(s)
	}
}

func (p *krlParser) RoutineImplementationSection() (localctx IRoutineImplementationSectionContext) {
	this := p
	_ = this

	localctx = NewRoutineImplementationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, krlParserRULE_routineImplementationSection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.StatementList()
	}

	return localctx
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_statementList
	return p
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (p *krlParser) StatementList() (localctx IStatementListContext) {
	this := p
	_ = this

	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, krlParserRULE_statementList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<krlParserT__2)|(1<<krlParserT__5)|(1<<krlParserT__17)|(1<<krlParserT__18)|(1<<krlParserT__22)|(1<<krlParserANIN)|(1<<krlParserANOUT)|(1<<krlParserB_NOT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(krlParserBRAKE-32))|(1<<(krlParserCIRC_REL-32))|(1<<(krlParserCIRC-32))|(1<<(krlParserCONTINUE-32))|(1<<(krlParserEXIT-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(krlParserFALSE-65))|(1<<(krlParserFOR-65))|(1<<(krlParserGLOBAL-65))|(1<<(krlParserGOTO-65))|(1<<(krlParserHALT-65))|(1<<(krlParserIF-65))|(1<<(krlParserINTERRUPT-65))|(1<<(krlParserLIN_REL-65))|(1<<(krlParserLIN-65))|(1<<(krlParserLOOP-65))|(1<<(krlParserNOT-65))|(1<<(krlParserPTP_REL-65))|(1<<(krlParserPTP-65))|(1<<(krlParserREPEAT-65))|(1<<(krlParserRETURN-65))|(1<<(krlParserSWITCH-65))|(1<<(krlParserTRIGGER-65))|(1<<(krlParserTRUE-65)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(krlParserWAIT-98))|(1<<(krlParserWHILE-98))|(1<<(krlParserNEWLINE-98))|(1<<(krlParserCHARLITERAL-98))|(1<<(krlParserSTRINGLITERAL-98))|(1<<(krlParserFLOATLITERAL-98))|(1<<(krlParserINTLITERAL-98))|(1<<(krlParserIDENTIFIER-98)))) != 0) {
		{
			p.SetState(417)
			p.Statement()
		}

		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(krlParserCONTINUE, 0)
}

func (s *StatementContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(krlParserNEWLINE)
}

func (s *StatementContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, i)
}

func (s *StatementContext) EXIT() antlr.TerminalNode {
	return s.GetToken(krlParserEXIT, 0)
}

func (s *StatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(krlParserFOR, 0)
}

func (s *StatementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(krlParserIDENTIFIER)
}

func (s *StatementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, i)
}

func (s *StatementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *StatementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) TO() antlr.TerminalNode {
	return s.GetToken(krlParserTO, 0)
}

func (s *StatementContext) AllStatementList() []IStatementListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementListContext)(nil)).Elem())
	var tst = make([]IStatementListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementListContext)
		}
	}

	return tst
}

func (s *StatementContext) StatementList(i int) IStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *StatementContext) ENDFOR() antlr.TerminalNode {
	return s.GetToken(krlParserENDFOR, 0)
}

func (s *StatementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(krlParserGOTO, 0)
}

func (s *StatementContext) HALT() antlr.TerminalNode {
	return s.GetToken(krlParserHALT, 0)
}

func (s *StatementContext) IF() antlr.TerminalNode {
	return s.GetToken(krlParserIF, 0)
}

func (s *StatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(krlParserTHEN, 0)
}

func (s *StatementContext) ENDIF() antlr.TerminalNode {
	return s.GetToken(krlParserENDIF, 0)
}

func (s *StatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(krlParserELSE, 0)
}

func (s *StatementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(krlParserLOOP, 0)
}

func (s *StatementContext) ENDLOOP() antlr.TerminalNode {
	return s.GetToken(krlParserENDLOOP, 0)
}

func (s *StatementContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(krlParserREPEAT, 0)
}

func (s *StatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(krlParserUNTIL, 0)
}

func (s *StatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(krlParserSWITCH, 0)
}

func (s *StatementContext) SwitchBlockStatementGroups() ISwitchBlockStatementGroupsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchBlockStatementGroupsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockStatementGroupsContext)
}

func (s *StatementContext) ENDSWITCH() antlr.TerminalNode {
	return s.GetToken(krlParserENDSWITCH, 0)
}

func (s *StatementContext) WAIT() antlr.TerminalNode {
	return s.GetToken(krlParserWAIT, 0)
}

func (s *StatementContext) SEC() antlr.TerminalNode {
	return s.GetToken(krlParserSEC, 0)
}

func (s *StatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(krlParserWHILE, 0)
}

func (s *StatementContext) ENDWHILE() antlr.TerminalNode {
	return s.GetToken(krlParserENDWHILE, 0)
}

func (s *StatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(krlParserRETURN, 0)
}

func (s *StatementContext) AssignmentExpression() IAssignmentExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *StatementContext) BRAKE() antlr.TerminalNode {
	return s.GetToken(krlParserBRAKE, 0)
}

func (s *StatementContext) INTERRUPT() antlr.TerminalNode {
	return s.GetToken(krlParserINTERRUPT, 0)
}

func (s *StatementContext) DECL() antlr.TerminalNode {
	return s.GetToken(krlParserDECL, 0)
}

func (s *StatementContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *StatementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(krlParserWHEN, 0)
}

func (s *StatementContext) DO() antlr.TerminalNode {
	return s.GetToken(krlParserDO, 0)
}

func (s *StatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(krlParserGLOBAL, 0)
}

func (s *StatementContext) AllGeometricExpression() []IGeometricExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGeometricExpressionContext)(nil)).Elem())
	var tst = make([]IGeometricExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGeometricExpressionContext)
		}
	}

	return tst
}

func (s *StatementContext) GeometricExpression(i int) IGeometricExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeometricExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGeometricExpressionContext)
}

func (s *StatementContext) PTP() antlr.TerminalNode {
	return s.GetToken(krlParserPTP, 0)
}

func (s *StatementContext) PTP_REL() antlr.TerminalNode {
	return s.GetToken(krlParserPTP_REL, 0)
}

func (s *StatementContext) C_PTP() antlr.TerminalNode {
	return s.GetToken(krlParserC_PTP, 0)
}

func (s *StatementContext) C_DIS() antlr.TerminalNode {
	return s.GetToken(krlParserC_DIS, 0)
}

func (s *StatementContext) C_ORI() antlr.TerminalNode {
	return s.GetToken(krlParserC_ORI, 0)
}

func (s *StatementContext) C_VEL() antlr.TerminalNode {
	return s.GetToken(krlParserC_VEL, 0)
}

func (s *StatementContext) LIN() antlr.TerminalNode {
	return s.GetToken(krlParserLIN, 0)
}

func (s *StatementContext) LIN_REL() antlr.TerminalNode {
	return s.GetToken(krlParserLIN_REL, 0)
}

func (s *StatementContext) EnumElement() IEnumElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumElementContext)
}

func (s *StatementContext) CIRC() antlr.TerminalNode {
	return s.GetToken(krlParserCIRC, 0)
}

func (s *StatementContext) CIRC_REL() antlr.TerminalNode {
	return s.GetToken(krlParserCIRC_REL, 0)
}

func (s *StatementContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(krlParserTRIGGER, 0)
}

func (s *StatementContext) DELAY() antlr.TerminalNode {
	return s.GetToken(krlParserDELAY, 0)
}

func (s *StatementContext) PRIO() antlr.TerminalNode {
	return s.GetToken(krlParserPRIO, 0)
}

func (s *StatementContext) AnalogInputStatement() IAnalogInputStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnalogInputStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnalogInputStatementContext)
}

func (s *StatementContext) AnalogOutputStatement() IAnalogOutputStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnalogOutputStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnalogOutputStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *krlParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, krlParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(423)
			p.Match(krlParserCONTINUE)
		}
		{
			p.SetState(424)
			p.Match(krlParserNEWLINE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(425)
			p.Match(krlParserEXIT)
		}
		{
			p.SetState(426)
			p.Match(krlParserNEWLINE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(427)
			p.Match(krlParserFOR)
		}
		{
			p.SetState(428)
			p.Match(krlParserIDENTIFIER)
		}
		{
			p.SetState(429)
			p.Match(krlParserT__0)
		}
		{
			p.SetState(430)
			p.Expression()
		}
		{
			p.SetState(431)
			p.Match(krlParserTO)
		}
		{
			p.SetState(432)
			p.Expression()
		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserIDENTIFIER {
			{
				p.SetState(433)
				p.Match(krlParserIDENTIFIER)
			}
			{
				p.SetState(434)
				p.Expression()
			}

		}
		{
			p.SetState(437)
			p.Match(krlParserNEWLINE)
		}
		{
			p.SetState(438)
			p.StatementList()
		}
		{
			p.SetState(439)
			p.Match(krlParserENDFOR)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(441)
			p.Match(krlParserGOTO)
		}
		{
			p.SetState(442)
			p.Match(krlParserIDENTIFIER)
		}
		{
			p.SetState(443)
			p.Match(krlParserNEWLINE)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(444)
			p.Match(krlParserHALT)
		}
		{
			p.SetState(445)
			p.Match(krlParserNEWLINE)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(446)
			p.Match(krlParserIF)
		}
		{
			p.SetState(447)
			p.Expression()
		}
		{
			p.SetState(448)
			p.Match(krlParserTHEN)
		}
		{
			p.SetState(449)
			p.Match(krlParserNEWLINE)
		}
		{
			p.SetState(450)
			p.StatementList()
		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserELSE {
			{
				p.SetState(451)
				p.Match(krlParserELSE)
			}
			{
				p.SetState(452)
				p.Match(krlParserNEWLINE)
			}
			{
				p.SetState(453)
				p.StatementList()
			}

		}
		{
			p.SetState(456)
			p.Match(krlParserENDIF)
		}
		{
			p.SetState(457)
			p.Match(krlParserNEWLINE)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(459)
			p.Match(krlParserLOOP)
		}
		{
			p.SetState(460)
			p.Match(krlParserNEWLINE)
		}
		{
			p.SetState(461)
			p.StatementList()
		}
		{
			p.SetState(462)
			p.Match(krlParserENDLOOP)
		}
		{
			p.SetState(463)
			p.Match(krlParserNEWLINE)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(465)
			p.Match(krlParserREPEAT)
		}
		{
			p.SetState(466)
			p.Match(krlParserNEWLINE)
		}
		{
			p.SetState(467)
			p.StatementList()
		}
		{
			p.SetState(468)
			p.Match(krlParserUNTIL)
		}
		{
			p.SetState(469)
			p.Expression()
		}
		{
			p.SetState(470)
			p.Match(krlParserNEWLINE)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(472)
			p.Match(krlParserSWITCH)
		}
		{
			p.SetState(473)
			p.Expression()
		}
		{
			p.SetState(474)
			p.Match(krlParserNEWLINE)
		}
		{
			p.SetState(475)
			p.SwitchBlockStatementGroups()
		}
		{
			p.SetState(476)
			p.Match(krlParserENDSWITCH)
		}
		{
			p.SetState(477)
			p.Match(krlParserNEWLINE)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(479)
			p.Match(krlParserWAIT)
		}
		{
			p.SetState(480)
			p.Match(krlParserFOR)
		}
		{
			p.SetState(481)
			p.Expression()
		}
		{
			p.SetState(482)
			p.Match(krlParserNEWLINE)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(484)
			p.Match(krlParserWAIT)
		}
		{
			p.SetState(485)
			p.Match(krlParserSEC)
		}
		{
			p.SetState(486)
			p.Expression()
		}
		{
			p.SetState(487)
			p.Match(krlParserNEWLINE)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(489)
			p.Match(krlParserWHILE)
		}
		{
			p.SetState(490)
			p.Expression()
		}
		{
			p.SetState(491)
			p.Match(krlParserNEWLINE)
		}
		{
			p.SetState(492)
			p.StatementList()
		}
		{
			p.SetState(493)
			p.Match(krlParserENDWHILE)
		}
		{
			p.SetState(494)
			p.Match(krlParserNEWLINE)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(496)
			p.Match(krlParserRETURN)
		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<krlParserT__2)|(1<<krlParserT__5)|(1<<krlParserT__17)|(1<<krlParserT__18)|(1<<krlParserT__22)|(1<<krlParserB_NOT))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(krlParserFALSE-65))|(1<<(krlParserNOT-65))|(1<<(krlParserTRUE-65)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(krlParserCHARLITERAL-106))|(1<<(krlParserSTRINGLITERAL-106))|(1<<(krlParserFLOATLITERAL-106))|(1<<(krlParserINTLITERAL-106))|(1<<(krlParserIDENTIFIER-106)))) != 0) {
			{
				p.SetState(497)
				p.AssignmentExpression()
			}

		}
		{
			p.SetState(500)
			p.Match(krlParserNEWLINE)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(501)
			p.Match(krlParserBRAKE)
		}
		p.SetState(503)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserIDENTIFIER {
			{
				p.SetState(502)
				p.Match(krlParserIDENTIFIER)
			}

		}
		{
			p.SetState(505)
			p.Match(krlParserNEWLINE)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(506)
			p.AssignmentExpression()
		}
		{
			p.SetState(507)
			p.Match(krlParserNEWLINE)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(509)
			p.Match(krlParserIDENTIFIER)
		}
		{
			p.SetState(510)
			p.Match(krlParserT__3)
		}
		{
			p.SetState(511)
			p.Match(krlParserNEWLINE)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(512)
			p.Match(krlParserNEWLINE)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserGLOBAL {
			{
				p.SetState(513)
				p.Match(krlParserGLOBAL)
			}

		}
		{
			p.SetState(516)
			p.Match(krlParserINTERRUPT)
		}
		{
			p.SetState(517)
			p.Match(krlParserDECL)
		}
		{
			p.SetState(518)
			p.Primary()
		}
		{
			p.SetState(519)
			p.Match(krlParserWHEN)
		}
		{
			p.SetState(520)
			p.Expression()
		}
		{
			p.SetState(521)
			p.Match(krlParserDO)
		}
		{
			p.SetState(522)
			p.AssignmentExpression()
		}
		{
			p.SetState(523)
			p.Match(krlParserNEWLINE)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(525)
			p.Match(krlParserINTERRUPT)
		}
		{
			p.SetState(526)
			p.Match(krlParserIDENTIFIER)
		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<krlParserT__2)|(1<<krlParserT__5)|(1<<krlParserT__22))) != 0) || _la == krlParserFALSE || _la == krlParserTRUE || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(krlParserCHARLITERAL-106))|(1<<(krlParserSTRINGLITERAL-106))|(1<<(krlParserFLOATLITERAL-106))|(1<<(krlParserINTLITERAL-106))|(1<<(krlParserIDENTIFIER-106)))) != 0) {
			{
				p.SetState(527)
				p.Primary()
			}

		}
		{
			p.SetState(530)
			p.Match(krlParserNEWLINE)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(531)
			_la = p.GetTokenStream().LA(1)

			if !(_la == krlParserPTP_REL || _la == krlParserPTP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(532)
			p.GeometricExpression()
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserC_PTP {
			{
				p.SetState(533)
				p.Match(krlParserC_PTP)
			}
			p.SetState(535)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(krlParserC_DIS-33))|(1<<(krlParserC_ORI-33))|(1<<(krlParserC_VEL-33)))) != 0 {
				{
					p.SetState(534)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(krlParserC_DIS-33))|(1<<(krlParserC_ORI-33))|(1<<(krlParserC_VEL-33)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		}
		{
			p.SetState(539)
			p.Match(krlParserNEWLINE)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(541)
			p.Match(krlParserLIN)
		}
		{
			p.SetState(542)
			p.GeometricExpression()
		}
		p.SetState(544)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(krlParserC_DIS-33))|(1<<(krlParserC_ORI-33))|(1<<(krlParserC_VEL-33)))) != 0 {
			{
				p.SetState(543)
				_la = p.GetTokenStream().LA(1)

				if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(krlParserC_DIS-33))|(1<<(krlParserC_ORI-33))|(1<<(krlParserC_VEL-33)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(546)
			p.Match(krlParserNEWLINE)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(548)
			p.Match(krlParserLIN_REL)
		}
		{
			p.SetState(549)
			p.GeometricExpression()
		}
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(krlParserC_DIS-33))|(1<<(krlParserC_ORI-33))|(1<<(krlParserC_VEL-33)))) != 0 {
			{
				p.SetState(550)
				_la = p.GetTokenStream().LA(1)

				if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(krlParserC_DIS-33))|(1<<(krlParserC_ORI-33))|(1<<(krlParserC_VEL-33)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserT__22 {
			{
				p.SetState(553)
				p.EnumElement()
			}

		}
		{
			p.SetState(556)
			p.Match(krlParserNEWLINE)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(558)
			_la = p.GetTokenStream().LA(1)

			if !(_la == krlParserCIRC_REL || _la == krlParserCIRC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(559)
			p.GeometricExpression()
		}
		{
			p.SetState(560)
			p.Match(krlParserT__1)
		}
		{
			p.SetState(561)
			p.GeometricExpression()
		}
		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserT__1 {
			{
				p.SetState(562)
				p.Match(krlParserT__1)
			}
			{
				p.SetState(563)
				p.Match(krlParserIDENTIFIER)
			}
			{
				p.SetState(564)
				p.Primary()
			}

		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(krlParserC_DIS-33))|(1<<(krlParserC_ORI-33))|(1<<(krlParserC_VEL-33)))) != 0 {
			{
				p.SetState(567)
				_la = p.GetTokenStream().LA(1)

				if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(krlParserC_DIS-33))|(1<<(krlParserC_ORI-33))|(1<<(krlParserC_VEL-33)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(570)
			p.Match(krlParserNEWLINE)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(572)
			p.Match(krlParserTRIGGER)
		}
		{
			p.SetState(573)
			p.Match(krlParserWHEN)
		}

		{
			p.SetState(574)
			p.Match(krlParserIDENTIFIER)
		}

		{
			p.SetState(575)
			p.Match(krlParserT__0)
		}
		{
			p.SetState(576)
			p.Expression()
		}
		{
			p.SetState(577)
			p.Match(krlParserDELAY)
		}
		{
			p.SetState(578)
			p.Match(krlParserT__0)
		}
		{
			p.SetState(579)
			p.Expression()
		}
		{
			p.SetState(580)
			p.Match(krlParserDO)
		}
		{
			p.SetState(581)
			p.AssignmentExpression()
		}
		p.SetState(585)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserPRIO {
			{
				p.SetState(582)
				p.Match(krlParserPRIO)
			}
			{
				p.SetState(583)
				p.Match(krlParserT__0)
			}
			{
				p.SetState(584)
				p.Expression()
			}

		}
		{
			p.SetState(587)
			p.Match(krlParserNEWLINE)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(589)
			p.AnalogInputStatement()
		}
		{
			p.SetState(590)
			p.Match(krlParserNEWLINE)
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(592)
			p.AnalogOutputStatement()
		}
		{
			p.SetState(593)
			p.Match(krlParserNEWLINE)
		}

	}

	return localctx
}

// IAnalogOutputStatementContext is an interface to support dynamic dispatch.
type IAnalogOutputStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnalogOutputStatementContext differentiates from other interfaces.
	IsAnalogOutputStatementContext()
}

type AnalogOutputStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalogOutputStatementContext() *AnalogOutputStatementContext {
	var p = new(AnalogOutputStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_analogOutputStatement
	return p
}

func (*AnalogOutputStatementContext) IsAnalogOutputStatementContext() {}

func NewAnalogOutputStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalogOutputStatementContext {
	var p = new(AnalogOutputStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_analogOutputStatement

	return p
}

func (s *AnalogOutputStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalogOutputStatementContext) ANOUT() antlr.TerminalNode {
	return s.GetToken(krlParserANOUT, 0)
}

func (s *AnalogOutputStatementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(krlParserIDENTIFIER)
}

func (s *AnalogOutputStatementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, i)
}

func (s *AnalogOutputStatementContext) AssignmentExpression() IAssignmentExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *AnalogOutputStatementContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *AnalogOutputStatementContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AnalogOutputStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalogOutputStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalogOutputStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterAnalogOutputStatement(s)
	}
}

func (s *AnalogOutputStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitAnalogOutputStatement(s)
	}
}

func (p *krlParser) AnalogOutputStatement() (localctx IAnalogOutputStatementContext) {
	this := p
	_ = this

	localctx = NewAnalogOutputStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, krlParserRULE_analogOutputStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.Match(krlParserANOUT)
	}
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(598)
			p.Match(krlParserIDENTIFIER)
		}
		{
			p.SetState(599)
			p.AssignmentExpression()
		}
		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == krlParserIDENTIFIER {
			{
				p.SetState(600)
				p.Match(krlParserIDENTIFIER)
			}
			{
				p.SetState(601)
				p.Match(krlParserT__0)
			}
			{
				p.SetState(602)
				p.Literal()
			}

			p.SetState(607)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(608)
			p.Match(krlParserIDENTIFIER)
		}
		{
			p.SetState(609)
			p.Match(krlParserIDENTIFIER)
		}

	}

	return localctx
}

// IAnalogInputStatementContext is an interface to support dynamic dispatch.
type IAnalogInputStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnalogInputStatementContext differentiates from other interfaces.
	IsAnalogInputStatementContext()
}

type AnalogInputStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalogInputStatementContext() *AnalogInputStatementContext {
	var p = new(AnalogInputStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_analogInputStatement
	return p
}

func (*AnalogInputStatementContext) IsAnalogInputStatementContext() {}

func NewAnalogInputStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalogInputStatementContext {
	var p = new(AnalogInputStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_analogInputStatement

	return p
}

func (s *AnalogInputStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalogInputStatementContext) ANIN() antlr.TerminalNode {
	return s.GetToken(krlParserANIN, 0)
}

func (s *AnalogInputStatementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(krlParserIDENTIFIER)
}

func (s *AnalogInputStatementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, i)
}

func (s *AnalogInputStatementContext) AssignmentExpression() IAssignmentExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *AnalogInputStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalogInputStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalogInputStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterAnalogInputStatement(s)
	}
}

func (s *AnalogInputStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitAnalogInputStatement(s)
	}
}

func (p *krlParser) AnalogInputStatement() (localctx IAnalogInputStatementContext) {
	this := p
	_ = this

	localctx = NewAnalogInputStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, krlParserRULE_analogInputStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Match(krlParserANIN)
	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(613)
			p.Match(krlParserIDENTIFIER)
		}
		{
			p.SetState(614)
			p.AssignmentExpression()
		}

	case 2:
		{
			p.SetState(615)
			p.Match(krlParserIDENTIFIER)
		}
		{
			p.SetState(616)
			p.Match(krlParserIDENTIFIER)
		}

	}

	return localctx
}

// ISwitchBlockStatementGroupsContext is an interface to support dynamic dispatch.
type ISwitchBlockStatementGroupsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockStatementGroupsContext differentiates from other interfaces.
	IsSwitchBlockStatementGroupsContext()
}

type SwitchBlockStatementGroupsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockStatementGroupsContext() *SwitchBlockStatementGroupsContext {
	var p = new(SwitchBlockStatementGroupsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_switchBlockStatementGroups
	return p
}

func (*SwitchBlockStatementGroupsContext) IsSwitchBlockStatementGroupsContext() {}

func NewSwitchBlockStatementGroupsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockStatementGroupsContext {
	var p = new(SwitchBlockStatementGroupsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_switchBlockStatementGroups

	return p
}

func (s *SwitchBlockStatementGroupsContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockStatementGroupsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(krlParserNEWLINE)
}

func (s *SwitchBlockStatementGroupsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, i)
}

func (s *SwitchBlockStatementGroupsContext) AllCaseLabel() []ICaseLabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseLabelContext)(nil)).Elem())
	var tst = make([]ICaseLabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseLabelContext)
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupsContext) CaseLabel(i int) ICaseLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseLabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseLabelContext)
}

func (s *SwitchBlockStatementGroupsContext) AllStatementList() []IStatementListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementListContext)(nil)).Elem())
	var tst = make([]IStatementListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementListContext)
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupsContext) StatementList(i int) IStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *SwitchBlockStatementGroupsContext) DefaultLabel() IDefaultLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultLabelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultLabelContext)
}

func (s *SwitchBlockStatementGroupsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockStatementGroupsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockStatementGroupsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterSwitchBlockStatementGroups(s)
	}
}

func (s *SwitchBlockStatementGroupsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitSwitchBlockStatementGroups(s)
	}
}

func (p *krlParser) SwitchBlockStatementGroups() (localctx ISwitchBlockStatementGroupsContext) {
	this := p
	_ = this

	localctx = NewSwitchBlockStatementGroupsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, krlParserRULE_switchBlockStatementGroups)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(622)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserNEWLINE {
		{
			p.SetState(619)
			p.Match(krlParserNEWLINE)
		}

		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == krlParserCASE {
		{
			p.SetState(625)
			p.CaseLabel()
		}
		{
			p.SetState(626)
			p.StatementList()
		}

		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == krlParserDEFAULT {
		{
			p.SetState(632)
			p.DefaultLabel()
		}
		{
			p.SetState(633)
			p.StatementList()
		}

	}

	return localctx
}

// ICaseLabelContext is an interface to support dynamic dispatch.
type ICaseLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseLabelContext differentiates from other interfaces.
	IsCaseLabelContext()
}

type CaseLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseLabelContext() *CaseLabelContext {
	var p = new(CaseLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_caseLabel
	return p
}

func (*CaseLabelContext) IsCaseLabelContext() {}

func NewCaseLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseLabelContext {
	var p = new(CaseLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_caseLabel

	return p
}

func (s *CaseLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(krlParserCASE, 0)
}

func (s *CaseLabelContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *CaseLabelContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseLabelContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, 0)
}

func (s *CaseLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterCaseLabel(s)
	}
}

func (s *CaseLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitCaseLabel(s)
	}
}

func (p *krlParser) CaseLabel() (localctx ICaseLabelContext) {
	this := p
	_ = this

	localctx = NewCaseLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, krlParserRULE_caseLabel)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Match(krlParserCASE)
	}
	{
		p.SetState(638)
		p.Expression()
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserT__1 {
		{
			p.SetState(639)
			p.Match(krlParserT__1)
		}
		{
			p.SetState(640)
			p.Expression()
		}

		p.SetState(645)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(646)
		p.Match(krlParserNEWLINE)
	}

	return localctx
}

// IDefaultLabelContext is an interface to support dynamic dispatch.
type IDefaultLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultLabelContext differentiates from other interfaces.
	IsDefaultLabelContext()
}

type DefaultLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultLabelContext() *DefaultLabelContext {
	var p = new(DefaultLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_defaultLabel
	return p
}

func (*DefaultLabelContext) IsDefaultLabelContext() {}

func NewDefaultLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultLabelContext {
	var p = new(DefaultLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_defaultLabel

	return p
}

func (s *DefaultLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(krlParserDEFAULT, 0)
}

func (s *DefaultLabelContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(krlParserNEWLINE, 0)
}

func (s *DefaultLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterDefaultLabel(s)
	}
}

func (s *DefaultLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitDefaultLabel(s)
	}
}

func (p *krlParser) DefaultLabel() (localctx IDefaultLabelContext) {
	this := p
	_ = this

	localctx = NewDefaultLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, krlParserRULE_defaultLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(krlParserDEFAULT)
	}
	{
		p.SetState(649)
		p.Match(krlParserNEWLINE)
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllAssignmentExpression() []IAssignmentExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentExpressionContext)(nil)).Elem())
	var tst = make([]IAssignmentExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionListContext) AssignmentExpression(i int) IAssignmentExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *krlParser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, krlParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.AssignmentExpression()
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserT__1 {
		{
			p.SetState(652)
			p.Match(krlParserT__1)
		}
		{
			p.SetState(653)
			p.AssignmentExpression()
		}

		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentExpressionContext is an interface to support dynamic dispatch.
type IAssignmentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentExpressionContext differentiates from other interfaces.
	IsAssignmentExpressionContext()
}

type AssignmentExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExpressionContext() *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_assignmentExpression
	return p
}

func (*AssignmentExpressionContext) IsAssignmentExpressionContext() {}

func NewAssignmentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_assignmentExpression

	return p
}

func (s *AssignmentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

func (p *krlParser) AssignmentExpression() (localctx IAssignmentExpressionContext) {
	this := p
	_ = this

	localctx = NewAssignmentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, krlParserRULE_assignmentExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.Expression()
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserT__0 {
		{
			p.SetState(660)
			p.Match(krlParserT__0)
		}
		{
			p.SetState(661)
			p.Expression()
		}

		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllConditionalOrExpression() []IConditionalOrExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionalOrExpressionContext)(nil)).Elem())
	var tst = make([]IConditionalOrExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionalOrExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) ConditionalOrExpression(i int) IConditionalOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalOrExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionalOrExpressionContext)
}

func (s *ExpressionContext) AllRelationalOp() []IRelationalOpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationalOpContext)(nil)).Elem())
	var tst = make([]IRelationalOpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationalOpContext)
		}
	}

	return tst
}

func (s *ExpressionContext) RelationalOp(i int) IRelationalOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalOpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationalOpContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *krlParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, krlParserRULE_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.ConditionalOrExpression()
	}
	p.SetState(673)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<krlParserT__11)|(1<<krlParserT__12)|(1<<krlParserT__13)|(1<<krlParserT__14)|(1<<krlParserT__15)|(1<<krlParserT__16))) != 0 {
		{
			p.SetState(668)
			p.RelationalOp()
		}
		{
			p.SetState(669)
			p.ConditionalOrExpression()
		}

		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRelationalOpContext is an interface to support dynamic dispatch.
type IRelationalOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationalOpContext differentiates from other interfaces.
	IsRelationalOpContext()
}

type RelationalOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalOpContext() *RelationalOpContext {
	var p = new(RelationalOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_relationalOp
	return p
}

func (*RelationalOpContext) IsRelationalOpContext() {}

func NewRelationalOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalOpContext {
	var p = new(RelationalOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_relationalOp

	return p
}

func (s *RelationalOpContext) GetParser() antlr.Parser { return s.parser }
func (s *RelationalOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterRelationalOp(s)
	}
}

func (s *RelationalOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitRelationalOp(s)
	}
}

func (p *krlParser) RelationalOp() (localctx IRelationalOpContext) {
	this := p
	_ = this

	localctx = NewRelationalOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, krlParserRULE_relationalOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<krlParserT__11)|(1<<krlParserT__12)|(1<<krlParserT__13)|(1<<krlParserT__14)|(1<<krlParserT__15)|(1<<krlParserT__16))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConditionalOrExpressionContext is an interface to support dynamic dispatch.
type IConditionalOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalOrExpressionContext differentiates from other interfaces.
	IsConditionalOrExpressionContext()
}

type ConditionalOrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalOrExpressionContext() *ConditionalOrExpressionContext {
	var p = new(ConditionalOrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_conditionalOrExpression
	return p
}

func (*ConditionalOrExpressionContext) IsConditionalOrExpressionContext() {}

func NewConditionalOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalOrExpressionContext {
	var p = new(ConditionalOrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_conditionalOrExpression

	return p
}

func (s *ConditionalOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalOrExpressionContext) AllExclusiveOrExpression() []IExclusiveOrExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExclusiveOrExpressionContext)(nil)).Elem())
	var tst = make([]IExclusiveOrExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExclusiveOrExpressionContext)
		}
	}

	return tst
}

func (s *ConditionalOrExpressionContext) ExclusiveOrExpression(i int) IExclusiveOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusiveOrExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExclusiveOrExpressionContext)
}

func (s *ConditionalOrExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(krlParserOR)
}

func (s *ConditionalOrExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(krlParserOR, i)
}

func (s *ConditionalOrExpressionContext) AllB_OR() []antlr.TerminalNode {
	return s.GetTokens(krlParserB_OR)
}

func (s *ConditionalOrExpressionContext) B_OR(i int) antlr.TerminalNode {
	return s.GetToken(krlParserB_OR, i)
}

func (s *ConditionalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterConditionalOrExpression(s)
	}
}

func (s *ConditionalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitConditionalOrExpression(s)
	}
}

func (p *krlParser) ConditionalOrExpression() (localctx IConditionalOrExpressionContext) {
	this := p
	_ = this

	localctx = NewConditionalOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, krlParserRULE_conditionalOrExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.ExclusiveOrExpression()
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserB_OR || _la == krlParserOR {
		{
			p.SetState(679)
			_la = p.GetTokenStream().LA(1)

			if !(_la == krlParserB_OR || _la == krlParserOR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(680)
			p.ExclusiveOrExpression()
		}

		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExclusiveOrExpressionContext is an interface to support dynamic dispatch.
type IExclusiveOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusiveOrExpressionContext differentiates from other interfaces.
	IsExclusiveOrExpressionContext()
}

type ExclusiveOrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusiveOrExpressionContext() *ExclusiveOrExpressionContext {
	var p = new(ExclusiveOrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_exclusiveOrExpression
	return p
}

func (*ExclusiveOrExpressionContext) IsExclusiveOrExpressionContext() {}

func NewExclusiveOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusiveOrExpressionContext {
	var p = new(ExclusiveOrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_exclusiveOrExpression

	return p
}

func (s *ExclusiveOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclusiveOrExpressionContext) AllConditionalAndExpression() []IConditionalAndExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionalAndExpressionContext)(nil)).Elem())
	var tst = make([]IConditionalAndExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionalAndExpressionContext)
		}
	}

	return tst
}

func (s *ExclusiveOrExpressionContext) ConditionalAndExpression(i int) IConditionalAndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalAndExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionalAndExpressionContext)
}

func (s *ExclusiveOrExpressionContext) AllEXOR() []antlr.TerminalNode {
	return s.GetTokens(krlParserEXOR)
}

func (s *ExclusiveOrExpressionContext) EXOR(i int) antlr.TerminalNode {
	return s.GetToken(krlParserEXOR, i)
}

func (s *ExclusiveOrExpressionContext) AllB_EXOR() []antlr.TerminalNode {
	return s.GetTokens(krlParserB_EXOR)
}

func (s *ExclusiveOrExpressionContext) B_EXOR(i int) antlr.TerminalNode {
	return s.GetToken(krlParserB_EXOR, i)
}

func (s *ExclusiveOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusiveOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusiveOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterExclusiveOrExpression(s)
	}
}

func (s *ExclusiveOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitExclusiveOrExpression(s)
	}
}

func (p *krlParser) ExclusiveOrExpression() (localctx IExclusiveOrExpressionContext) {
	this := p
	_ = this

	localctx = NewExclusiveOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, krlParserRULE_exclusiveOrExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.ConditionalAndExpression()
	}
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserB_EXOR || _la == krlParserEXOR {
		{
			p.SetState(687)
			_la = p.GetTokenStream().LA(1)

			if !(_la == krlParserB_EXOR || _la == krlParserEXOR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(688)
			p.ConditionalAndExpression()
		}

		p.SetState(693)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConditionalAndExpressionContext is an interface to support dynamic dispatch.
type IConditionalAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalAndExpressionContext differentiates from other interfaces.
	IsConditionalAndExpressionContext()
}

type ConditionalAndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalAndExpressionContext() *ConditionalAndExpressionContext {
	var p = new(ConditionalAndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_conditionalAndExpression
	return p
}

func (*ConditionalAndExpressionContext) IsConditionalAndExpressionContext() {}

func NewConditionalAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalAndExpressionContext {
	var p = new(ConditionalAndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_conditionalAndExpression

	return p
}

func (s *ConditionalAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalAndExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem())
	var tst = make([]IAdditiveExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditiveExpressionContext)
		}
	}

	return tst
}

func (s *ConditionalAndExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *ConditionalAndExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(krlParserAND)
}

func (s *ConditionalAndExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(krlParserAND, i)
}

func (s *ConditionalAndExpressionContext) AllB_AND() []antlr.TerminalNode {
	return s.GetTokens(krlParserB_AND)
}

func (s *ConditionalAndExpressionContext) B_AND(i int) antlr.TerminalNode {
	return s.GetToken(krlParserB_AND, i)
}

func (s *ConditionalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterConditionalAndExpression(s)
	}
}

func (s *ConditionalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitConditionalAndExpression(s)
	}
}

func (p *krlParser) ConditionalAndExpression() (localctx IConditionalAndExpressionContext) {
	this := p
	_ = this

	localctx = NewConditionalAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, krlParserRULE_conditionalAndExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.AdditiveExpression()
	}
	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserAND || _la == krlParserB_AND {
		{
			p.SetState(695)
			_la = p.GetTokenStream().LA(1)

			if !(_la == krlParserAND || _la == krlParserB_AND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(696)
			p.AdditiveExpression()
		}

		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_additiveExpression
	return p
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem())
	var tst = make([]IMultiplicativeExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicativeExpressionContext)
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (p *krlParser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	this := p
	_ = this

	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, krlParserRULE_additiveExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.MultiplicativeExpression()
	}
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserT__17 || _la == krlParserT__18 {
		{
			p.SetState(703)
			_la = p.GetTokenStream().LA(1)

			if !(_la == krlParserT__17 || _la == krlParserT__18) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(704)
			p.MultiplicativeExpression()
		}

		p.SetState(709)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_multiplicativeExpression
	return p
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllGeometricExpression() []IGeometricExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGeometricExpressionContext)(nil)).Elem())
	var tst = make([]IGeometricExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGeometricExpressionContext)
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) GeometricExpression(i int) IGeometricExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeometricExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGeometricExpressionContext)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (p *krlParser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	this := p
	_ = this

	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, krlParserRULE_multiplicativeExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.GeometricExpression()
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserT__19 || _la == krlParserT__20 {
		{
			p.SetState(711)
			_la = p.GetTokenStream().LA(1)

			if !(_la == krlParserT__19 || _la == krlParserT__20) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(712)
			p.GeometricExpression()
		}

		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGeometricExpressionContext is an interface to support dynamic dispatch.
type IGeometricExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeometricExpressionContext differentiates from other interfaces.
	IsGeometricExpressionContext()
}

type GeometricExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeometricExpressionContext() *GeometricExpressionContext {
	var p = new(GeometricExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_geometricExpression
	return p
}

func (*GeometricExpressionContext) IsGeometricExpressionContext() {}

func NewGeometricExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeometricExpressionContext {
	var p = new(GeometricExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_geometricExpression

	return p
}

func (s *GeometricExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *GeometricExpressionContext) AllUnaryNotExpression() []IUnaryNotExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnaryNotExpressionContext)(nil)).Elem())
	var tst = make([]IUnaryNotExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnaryNotExpressionContext)
		}
	}

	return tst
}

func (s *GeometricExpressionContext) UnaryNotExpression(i int) IUnaryNotExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryNotExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnaryNotExpressionContext)
}

func (s *GeometricExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeometricExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeometricExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterGeometricExpression(s)
	}
}

func (s *GeometricExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitGeometricExpression(s)
	}
}

func (p *krlParser) GeometricExpression() (localctx IGeometricExpressionContext) {
	this := p
	_ = this

	localctx = NewGeometricExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, krlParserRULE_geometricExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.UnaryNotExpression()
	}
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == krlParserT__3 {
		{
			p.SetState(719)
			p.Match(krlParserT__3)
		}
		{
			p.SetState(720)
			p.UnaryNotExpression()
		}

		p.SetState(725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnaryNotExpressionContext is an interface to support dynamic dispatch.
type IUnaryNotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryNotExpressionContext differentiates from other interfaces.
	IsUnaryNotExpressionContext()
}

type UnaryNotExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryNotExpressionContext() *UnaryNotExpressionContext {
	var p = new(UnaryNotExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_unaryNotExpression
	return p
}

func (*UnaryNotExpressionContext) IsUnaryNotExpressionContext() {}

func NewUnaryNotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryNotExpressionContext {
	var p = new(UnaryNotExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_unaryNotExpression

	return p
}

func (s *UnaryNotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryNotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(krlParserNOT, 0)
}

func (s *UnaryNotExpressionContext) UnaryNotExpression() IUnaryNotExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryNotExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryNotExpressionContext)
}

func (s *UnaryNotExpressionContext) B_NOT() antlr.TerminalNode {
	return s.GetToken(krlParserB_NOT, 0)
}

func (s *UnaryNotExpressionContext) UnaryPlusMinuxExpression() IUnaryPlusMinuxExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryPlusMinuxExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryPlusMinuxExpressionContext)
}

func (s *UnaryNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryNotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryNotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterUnaryNotExpression(s)
	}
}

func (s *UnaryNotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitUnaryNotExpression(s)
	}
}

func (p *krlParser) UnaryNotExpression() (localctx IUnaryNotExpressionContext) {
	this := p
	_ = this

	localctx = NewUnaryNotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, krlParserRULE_unaryNotExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(731)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case krlParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(726)
			p.Match(krlParserNOT)
		}
		{
			p.SetState(727)
			p.UnaryNotExpression()
		}

	case krlParserB_NOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(728)
			p.Match(krlParserB_NOT)
		}
		{
			p.SetState(729)
			p.UnaryNotExpression()
		}

	case krlParserT__2, krlParserT__5, krlParserT__17, krlParserT__18, krlParserT__22, krlParserFALSE, krlParserTRUE, krlParserCHARLITERAL, krlParserSTRINGLITERAL, krlParserFLOATLITERAL, krlParserINTLITERAL, krlParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(730)
			p.UnaryPlusMinuxExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnaryPlusMinuxExpressionContext is an interface to support dynamic dispatch.
type IUnaryPlusMinuxExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryPlusMinuxExpressionContext differentiates from other interfaces.
	IsUnaryPlusMinuxExpressionContext()
}

type UnaryPlusMinuxExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryPlusMinuxExpressionContext() *UnaryPlusMinuxExpressionContext {
	var p = new(UnaryPlusMinuxExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_unaryPlusMinuxExpression
	return p
}

func (*UnaryPlusMinuxExpressionContext) IsUnaryPlusMinuxExpressionContext() {}

func NewUnaryPlusMinuxExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryPlusMinuxExpressionContext {
	var p = new(UnaryPlusMinuxExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_unaryPlusMinuxExpression

	return p
}

func (s *UnaryPlusMinuxExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryPlusMinuxExpressionContext) UnaryPlusMinuxExpression() IUnaryPlusMinuxExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryPlusMinuxExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryPlusMinuxExpressionContext)
}

func (s *UnaryPlusMinuxExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *UnaryPlusMinuxExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPlusMinuxExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryPlusMinuxExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterUnaryPlusMinuxExpression(s)
	}
}

func (s *UnaryPlusMinuxExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitUnaryPlusMinuxExpression(s)
	}
}

func (p *krlParser) UnaryPlusMinuxExpression() (localctx IUnaryPlusMinuxExpressionContext) {
	this := p
	_ = this

	localctx = NewUnaryPlusMinuxExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, krlParserRULE_unaryPlusMinuxExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(738)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case krlParserT__17:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(733)
			p.Match(krlParserT__17)
		}
		{
			p.SetState(734)
			p.UnaryPlusMinuxExpression()
		}

	case krlParserT__18:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(735)
			p.Match(krlParserT__18)
		}
		{
			p.SetState(736)
			p.UnaryPlusMinuxExpression()
		}

	case krlParserT__2, krlParserT__5, krlParserT__22, krlParserFALSE, krlParserTRUE, krlParserCHARLITERAL, krlParserSTRINGLITERAL, krlParserFLOATLITERAL, krlParserINTLITERAL, krlParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(737)
			p.Primary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) ParExpression() IParExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *PrimaryContext) AllVariableName() []IVariableNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableNameContext)(nil)).Elem())
	var tst = make([]IVariableNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableNameContext)
		}
	}

	return tst
}

func (s *PrimaryContext) VariableName(i int) IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *PrimaryContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PrimaryContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *krlParser) Primary() (localctx IPrimaryContext) {
	this := p
	_ = this

	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, krlParserRULE_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(753)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case krlParserT__5:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(740)
			p.ParExpression()
		}

	case krlParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(741)
			p.VariableName()
		}
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == krlParserT__21 {
			{
				p.SetState(742)
				p.Match(krlParserT__21)
			}
			{
				p.SetState(743)
				p.VariableName()
			}

			p.SetState(748)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserT__5 {
			{
				p.SetState(749)
				p.Arguments()
			}

		}

	case krlParserT__2, krlParserT__22, krlParserFALSE, krlParserTRUE, krlParserCHARLITERAL, krlParserSTRINGLITERAL, krlParserFLOATLITERAL, krlParserINTLITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(752)
			p.Literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParExpressionContext is an interface to support dynamic dispatch.
type IParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParExpressionContext differentiates from other interfaces.
	IsParExpressionContext()
}

type ParExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParExpressionContext() *ParExpressionContext {
	var p = new(ParExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_parExpression
	return p
}

func (*ParExpressionContext) IsParExpressionContext() {}

func NewParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParExpressionContext {
	var p = new(ParExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_parExpression

	return p
}

func (s *ParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParExpressionContext) AssignmentExpression() IAssignmentExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *ParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterParExpression(s)
	}
}

func (s *ParExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitParExpression(s)
	}
}

func (p *krlParser) ParExpression() (localctx IParExpressionContext) {
	this := p
	_ = this

	localctx = NewParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, krlParserRULE_parExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.Match(krlParserT__5)
	}
	{
		p.SetState(756)
		p.AssignmentExpression()
	}
	{
		p.SetState(757)
		p.Match(krlParserT__6)
	}

	return localctx
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_type_
	return p
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *Type_Context) INTLITERAL() antlr.TerminalNode {
	return s.GetToken(krlParserINTLITERAL, 0)
}

func (s *Type_Context) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *krlParser) Type_() (localctx IType_Context) {
	this := p
	_ = this

	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, krlParserRULE_type_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(775)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case krlParserBOOL, krlParserCHAR, krlParserINT, krlParserREAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(759)
			p.PrimitiveType()
		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserT__9 {
			{
				p.SetState(760)
				p.Match(krlParserT__9)
			}
			p.SetState(762)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == krlParserINTLITERAL {
				{
					p.SetState(761)
					p.Match(krlParserINTLITERAL)
				}

			}
			{
				p.SetState(764)
				p.Match(krlParserT__10)
			}

		}

	case krlParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(767)
			p.TypeName()
		}
		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == krlParserT__9 {
			{
				p.SetState(768)
				p.Match(krlParserT__9)
			}
			p.SetState(770)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == krlParserINTLITERAL {
				{
					p.SetState(769)
					p.Match(krlParserINTLITERAL)
				}

			}
			{
				p.SetState(772)
				p.Match(krlParserT__10)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *krlParser) TypeName() (localctx ITypeNameContext) {
	this := p
	_ = this

	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, krlParserRULE_typeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Match(krlParserIDENTIFIER)
	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(krlParserBOOL, 0)
}

func (s *PrimitiveTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(krlParserCHAR, 0)
}

func (s *PrimitiveTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(krlParserINT, 0)
}

func (s *PrimitiveTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(krlParserREAL, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *krlParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	this := p
	_ = this

	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, krlParserRULE_primitiveType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		_la = p.GetTokenStream().LA(1)

		if !(_la == krlParserBOOL || _la == krlParserCHAR || _la == krlParserINT || _la == krlParserREAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *krlParser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, krlParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.Match(krlParserT__5)
	}
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<krlParserT__2)|(1<<krlParserT__5)|(1<<krlParserT__17)|(1<<krlParserT__18)|(1<<krlParserT__22)|(1<<krlParserB_NOT))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(krlParserFALSE-65))|(1<<(krlParserNOT-65))|(1<<(krlParserTRUE-65)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(krlParserCHARLITERAL-106))|(1<<(krlParserSTRINGLITERAL-106))|(1<<(krlParserFLOATLITERAL-106))|(1<<(krlParserINTLITERAL-106))|(1<<(krlParserIDENTIFIER-106)))) != 0) {
		{
			p.SetState(782)
			p.ExpressionList()
		}

	}
	{
		p.SetState(785)
		p.Match(krlParserT__6)
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) INTLITERAL() antlr.TerminalNode {
	return s.GetToken(krlParserINTLITERAL, 0)
}

func (s *LiteralContext) FLOATLITERAL() antlr.TerminalNode {
	return s.GetToken(krlParserFLOATLITERAL, 0)
}

func (s *LiteralContext) CHARLITERAL() antlr.TerminalNode {
	return s.GetToken(krlParserCHARLITERAL, 0)
}

func (s *LiteralContext) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(krlParserSTRINGLITERAL, 0)
}

func (s *LiteralContext) StructLiteral() IStructLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStructLiteralContext)
}

func (s *LiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(krlParserTRUE, 0)
}

func (s *LiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(krlParserFALSE, 0)
}

func (s *LiteralContext) EnumElement() IEnumElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumElementContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *krlParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, krlParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(795)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case krlParserINTLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(787)
			p.Match(krlParserINTLITERAL)
		}

	case krlParserFLOATLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(788)
			p.Match(krlParserFLOATLITERAL)
		}

	case krlParserCHARLITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(789)
			p.Match(krlParserCHARLITERAL)
		}

	case krlParserSTRINGLITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(790)
			p.Match(krlParserSTRINGLITERAL)
		}

	case krlParserT__2:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(791)
			p.StructLiteral()
		}

	case krlParserTRUE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(792)
			p.Match(krlParserTRUE)
		}

	case krlParserFALSE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(793)
			p.Match(krlParserFALSE)
		}

	case krlParserT__22:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(794)
			p.EnumElement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumElementContext is an interface to support dynamic dispatch.
type IEnumElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumElementContext differentiates from other interfaces.
	IsEnumElementContext()
}

type EnumElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumElementContext() *EnumElementContext {
	var p = new(EnumElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = krlParserRULE_enumElement
	return p
}

func (*EnumElementContext) IsEnumElementContext() {}

func NewEnumElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumElementContext {
	var p = new(EnumElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = krlParserRULE_enumElement

	return p
}

func (s *EnumElementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumElementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(krlParserIDENTIFIER, 0)
}

func (s *EnumElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.EnterEnumElement(s)
	}
}

func (s *EnumElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(krlListener); ok {
		listenerT.ExitEnumElement(s)
	}
}

func (p *krlParser) EnumElement() (localctx IEnumElementContext) {
	this := p
	_ = this

	localctx = NewEnumElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, krlParserRULE_enumElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		p.Match(krlParserT__22)
	}
	{
		p.SetState(798)
		p.Match(krlParserIDENTIFIER)
	}

	return localctx
}
