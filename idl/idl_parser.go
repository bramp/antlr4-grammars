// Code generated from IDL.g4 by ANTLR 4.9.3. DO NOT EDIT.

package idl // IDL
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 118, 1449,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 3, 2, 7, 2, 326, 10, 2, 12, 2, 14, 2, 329,
	11, 2, 3, 2, 6, 2, 332, 10, 2, 13, 2, 14, 2, 333, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 373, 10,
	3, 3, 4, 3, 4, 3, 4, 3, 4, 6, 4, 379, 10, 4, 13, 4, 14, 4, 380, 3, 4, 3,
	4, 3, 5, 3, 5, 3, 5, 5, 5, 388, 10, 5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	7, 5, 7, 396, 10, 7, 3, 7, 3, 7, 3, 7, 3, 8, 5, 8, 402, 10, 8, 3, 8, 3,
	8, 3, 8, 5, 8, 407, 10, 8, 3, 9, 7, 9, 410, 10, 9, 12, 9, 14, 9, 413, 11,
	9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3,
	10, 3, 10, 5, 10, 437, 10, 10, 3, 11, 3, 11, 3, 11, 3, 11, 7, 11, 443,
	10, 11, 12, 11, 14, 11, 446, 11, 11, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13,
	3, 14, 5, 14, 454, 10, 14, 3, 14, 3, 14, 3, 14, 7, 14, 459, 10, 14, 12,
	14, 14, 14, 462, 11, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 469,
	10, 15, 3, 16, 5, 16, 472, 10, 16, 3, 16, 3, 16, 3, 16, 3, 17, 3, 17, 3,
	17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 7, 18, 487, 10, 18,
	12, 18, 14, 18, 490, 11, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 7, 19,
	497, 10, 19, 12, 19, 14, 19, 500, 11, 19, 3, 19, 3, 19, 3, 20, 5, 20, 505,
	10, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 21, 3, 21, 5, 21, 513, 10, 21, 3,
	21, 3, 21, 3, 21, 7, 21, 518, 10, 21, 12, 21, 14, 21, 521, 11, 21, 5, 21,
	523, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 7, 21, 529, 10, 21, 12, 21, 14,
	21, 532, 11, 21, 5, 21, 534, 10, 21, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23,
	5, 23, 541, 10, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 548, 10,
	24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25,
	559, 10, 25, 3, 25, 3, 25, 5, 25, 563, 10, 25, 3, 25, 3, 25, 3, 26, 3,
	26, 3, 26, 7, 26, 570, 10, 26, 12, 26, 14, 26, 573, 11, 26, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 5, 30, 601, 10, 30, 3, 31, 3, 31, 3, 32, 3, 32, 3,
	32, 7, 32, 608, 10, 32, 12, 32, 14, 32, 611, 11, 32, 3, 33, 3, 33, 3, 33,
	7, 33, 616, 10, 33, 12, 33, 14, 33, 619, 11, 33, 3, 34, 3, 34, 3, 34, 7,
	34, 624, 10, 34, 12, 34, 14, 34, 627, 11, 34, 3, 35, 3, 35, 3, 35, 7, 35,
	632, 10, 35, 12, 35, 14, 35, 635, 11, 35, 3, 36, 3, 36, 3, 36, 7, 36, 640,
	10, 36, 12, 36, 14, 36, 643, 11, 36, 3, 37, 3, 37, 3, 37, 7, 37, 648, 10,
	37, 12, 37, 14, 37, 651, 11, 37, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38, 657,
	10, 38, 3, 39, 3, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40,
	667, 10, 40, 3, 41, 3, 41, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3,
	43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43,
	687, 10, 43, 3, 44, 3, 44, 3, 44, 3, 45, 3, 45, 5, 45, 694, 10, 45, 3,
	46, 3, 46, 3, 46, 5, 46, 699, 10, 46, 3, 47, 3, 47, 3, 47, 5, 47, 704,
	10, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48,
	5, 48, 715, 10, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 5, 49, 723,
	10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 730, 10, 50, 3, 51, 3,
	51, 3, 51, 7, 51, 735, 10, 51, 12, 51, 14, 51, 738, 11, 51, 3, 52, 3, 52,
	3, 52, 7, 52, 743, 10, 52, 12, 52, 14, 52, 746, 11, 52, 3, 53, 3, 53, 3,
	53, 5, 53, 751, 10, 53, 3, 54, 3, 54, 3, 55, 3, 55, 3, 56, 3, 56, 3, 56,
	3, 56, 5, 56, 761, 10, 56, 3, 57, 3, 57, 5, 57, 765, 10, 57, 3, 58, 3,
	58, 3, 58, 3, 58, 5, 58, 771, 10, 58, 3, 59, 3, 59, 3, 60, 3, 60, 3, 61,
	3, 61, 3, 62, 3, 62, 3, 62, 5, 62, 782, 10, 62, 3, 63, 3, 63, 3, 63, 3,
	63, 5, 63, 788, 10, 63, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 5, 65, 795,
	10, 65, 3, 66, 3, 66, 3, 66, 5, 66, 800, 10, 66, 3, 67, 3, 67, 3, 67, 3,
	67, 5, 67, 806, 10, 67, 3, 68, 3, 68, 3, 69, 3, 69, 3, 70, 3, 70, 3, 71,
	3, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 74, 3, 74, 5, 74, 822, 10, 74, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 5, 76, 832, 10, 76,
	3, 77, 3, 77, 3, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3,
	78, 3, 78, 3, 78, 3, 78, 7, 78, 848, 10, 78, 12, 78, 14, 78, 851, 11, 78,
	3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 857, 10, 79, 3, 79, 3, 79, 3, 80, 3,
	80, 3, 80, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81, 868, 10, 81, 3, 81, 3, 81,
	3, 81, 3, 81, 3, 82, 3, 82, 5, 82, 876, 10, 82, 3, 82, 3, 82, 6, 82, 880,
	10, 82, 13, 82, 14, 82, 881, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83,
	5, 83, 890, 10, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3,
	84, 3, 85, 3, 85, 3, 85, 7, 85, 903, 10, 85, 12, 85, 14, 85, 906, 11, 85,
	3, 86, 3, 86, 3, 86, 3, 86, 5, 86, 912, 10, 86, 3, 86, 3, 86, 3, 86, 3,
	86, 3, 87, 7, 87, 919, 10, 87, 12, 87, 14, 87, 922, 11, 87, 3, 88, 3, 88,
	3, 88, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3,
	89, 3, 89, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90,
	5, 90, 947, 10, 90, 3, 91, 6, 91, 950, 10, 91, 13, 91, 14, 91, 951, 3,
	92, 6, 92, 955, 10, 92, 13, 92, 14, 92, 956, 3, 92, 3, 92, 3, 92, 3, 93,
	3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 5, 93, 969, 10, 93, 3, 94, 3,
	94, 3, 94, 3, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 7, 95, 981,
	10, 95, 12, 95, 14, 95, 984, 11, 95, 3, 95, 3, 95, 3, 96, 3, 96, 3, 97,
	3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 5, 97, 996, 10, 97, 3, 97, 3, 97, 3,
	98, 3, 98, 3, 98, 3, 98, 3, 98, 5, 98, 1005, 10, 98, 3, 98, 3, 98, 3, 99,
	3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 5, 99, 1016, 10, 99, 3, 99, 3,
	99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 5, 100, 1025, 10, 100, 3, 101,
	3, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1032, 10, 101, 3, 102, 3, 102,
	6, 102, 1036, 10, 102, 13, 102, 14, 102, 1037, 3, 103, 3, 103, 3, 103,
	3, 103, 3, 104, 3, 104, 5, 104, 1046, 10, 104, 3, 105, 3, 105, 3, 105,
	3, 105, 7, 105, 1052, 10, 105, 12, 105, 14, 105, 1055, 11, 105, 3, 105,
	3, 105, 3, 106, 5, 106, 1060, 10, 106, 3, 106, 3, 106, 3, 106, 3, 106,
	5, 106, 1066, 10, 106, 3, 106, 5, 106, 1069, 10, 106, 3, 107, 3, 107, 3,
	108, 3, 108, 3, 108, 5, 108, 1076, 10, 108, 3, 109, 3, 109, 3, 109, 3,
	109, 7, 109, 1082, 10, 109, 12, 109, 14, 109, 1085, 11, 109, 5, 109, 1087,
	10, 109, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 3, 110, 3, 110, 3, 110,
	3, 110, 3, 111, 3, 111, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 7, 112,
	1105, 10, 112, 12, 112, 14, 112, 1108, 11, 112, 3, 112, 3, 112, 3, 113,
	3, 113, 3, 113, 3, 113, 3, 113, 7, 113, 1117, 10, 113, 12, 113, 14, 113,
	1120, 11, 113, 3, 113, 3, 113, 3, 114, 3, 114, 3, 114, 3, 114, 5, 114,
	1128, 10, 114, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115,
	3, 116, 3, 116, 3, 117, 3, 117, 3, 118, 3, 118, 3, 118, 3, 118, 5, 118,
	1145, 10, 118, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 120,
	3, 120, 5, 120, 1155, 10, 120, 3, 121, 3, 121, 3, 121, 3, 121, 3, 122,
	3, 122, 3, 122, 3, 122, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123,
	3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 7, 124, 1178, 10,
	124, 12, 124, 14, 124, 1181, 11, 124, 5, 124, 1183, 10, 124, 3, 125, 3,
	125, 3, 125, 3, 125, 3, 125, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3,
	126, 3, 126, 7, 126, 1197, 10, 126, 12, 126, 14, 126, 1200, 11, 126, 5,
	126, 1202, 10, 126, 3, 127, 3, 127, 5, 127, 1206, 10, 127, 3, 127, 5, 127,
	1209, 10, 127, 3, 128, 3, 128, 3, 128, 3, 129, 3, 129, 3, 129, 3, 130,
	3, 130, 3, 130, 3, 130, 7, 130, 1221, 10, 130, 12, 130, 14, 130, 1224,
	11, 130, 3, 130, 3, 130, 3, 131, 3, 131, 5, 131, 1230, 10, 131, 3, 132,
	3, 132, 3, 132, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 134, 3, 134,
	3, 134, 5, 134, 1243, 10, 134, 3, 134, 5, 134, 1246, 10, 134, 3, 135, 3,
	135, 3, 135, 3, 135, 7, 135, 1252, 10, 135, 12, 135, 14, 135, 1255, 11,
	135, 3, 136, 3, 136, 3, 136, 3, 137, 7, 137, 1261, 10, 137, 12, 137, 14,
	137, 1264, 11, 137, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3,
	138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3,
	138, 3, 138, 3, 138, 3, 138, 5, 138, 1285, 10, 138, 3, 139, 3, 139, 3,
	139, 3, 139, 3, 140, 3, 140, 3, 140, 5, 140, 1294, 10, 140, 3, 141, 3,
	141, 5, 141, 1298, 10, 141, 3, 141, 3, 141, 3, 141, 3, 142, 3, 142, 3,
	142, 3, 142, 3, 143, 3, 143, 3, 143, 3, 143, 3, 144, 3, 144, 3, 144, 3,
	144, 3, 145, 3, 145, 3, 145, 3, 146, 3, 146, 3, 146, 5, 146, 1321, 10,
	146, 3, 146, 5, 146, 1324, 10, 146, 3, 146, 3, 146, 3, 146, 5, 146, 1329,
	10, 146, 3, 147, 3, 147, 3, 147, 3, 148, 3, 148, 3, 148, 3, 149, 3, 149,
	7, 149, 1339, 10, 149, 12, 149, 14, 149, 1342, 11, 149, 3, 149, 3, 149,
	3, 150, 3, 150, 3, 150, 3, 150, 5, 150, 1350, 10, 150, 3, 150, 3, 150,
	5, 150, 1354, 10, 150, 3, 151, 3, 151, 3, 151, 3, 151, 5, 151, 1360, 10,
	151, 3, 151, 3, 151, 5, 151, 1364, 10, 151, 3, 152, 3, 152, 3, 152, 3,
	152, 5, 152, 1370, 10, 152, 3, 152, 3, 152, 5, 152, 1374, 10, 152, 3, 153,
	3, 153, 3, 153, 5, 153, 1379, 10, 153, 3, 154, 5, 154, 1382, 10, 154, 3,
	154, 3, 154, 3, 154, 3, 155, 3, 155, 3, 155, 3, 155, 3, 155, 3, 155, 7,
	155, 1393, 10, 155, 12, 155, 14, 155, 1396, 11, 155, 3, 155, 3, 155, 3,
	156, 3, 156, 3, 156, 7, 156, 1403, 10, 156, 12, 156, 14, 156, 1406, 11,
	156, 3, 156, 3, 156, 3, 157, 5, 157, 1411, 10, 157, 3, 157, 3, 157, 3,
	157, 3, 157, 3, 158, 7, 158, 1418, 10, 158, 12, 158, 14, 158, 1421, 11,
	158, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 5, 159, 1429, 10,
	159, 3, 160, 3, 160, 3, 160, 3, 160, 7, 160, 1435, 10, 160, 12, 160, 14,
	160, 1438, 11, 160, 5, 160, 1440, 10, 160, 3, 161, 3, 161, 3, 161, 3, 161,
	3, 162, 3, 162, 3, 162, 3, 162, 2, 2, 163, 2, 4, 6, 8, 10, 12, 14, 16,
	18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
	54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
	90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
	122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
	152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
	182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
	212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240,
	242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270,
	272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300,
	302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 2, 11, 4, 2, 89,
	89, 97, 97, 3, 2, 35, 36, 3, 2, 27, 28, 5, 2, 23, 23, 26, 26, 33, 33, 4,
	2, 22, 22, 27, 28, 3, 2, 3, 12, 4, 2, 63, 63, 108, 108, 4, 2, 64, 64, 110,
	110, 5, 2, 39, 39, 60, 60, 90, 90, 2, 1480, 2, 327, 3, 2, 2, 2, 4, 335,
	3, 2, 2, 2, 6, 374, 3, 2, 2, 2, 8, 384, 3, 2, 2, 2, 10, 389, 3, 2, 2, 2,
	12, 395, 3, 2, 2, 2, 14, 401, 3, 2, 2, 2, 16, 411, 3, 2, 2, 2, 18, 414,
	3, 2, 2, 2, 20, 438, 3, 2, 2, 2, 22, 447, 3, 2, 2, 2, 24, 449, 3, 2, 2,
	2, 26, 453, 3, 2, 2, 2, 28, 463, 3, 2, 2, 2, 30, 471, 3, 2, 2, 2, 32, 476,
	3, 2, 2, 2, 34, 480, 3, 2, 2, 2, 36, 493, 3, 2, 2, 2, 38, 504, 3, 2, 2,
	2, 40, 522, 3, 2, 2, 2, 42, 535, 3, 2, 2, 2, 44, 540, 3, 2, 2, 2, 46, 542,
	3, 2, 2, 2, 48, 553, 3, 2, 2, 2, 50, 566, 3, 2, 2, 2, 52, 574, 3, 2, 2,
	2, 54, 581, 3, 2, 2, 2, 56, 583, 3, 2, 2, 2, 58, 589, 3, 2, 2, 2, 60, 602,
	3, 2, 2, 2, 62, 604, 3, 2, 2, 2, 64, 612, 3, 2, 2, 2, 66, 620, 3, 2, 2,
	2, 68, 628, 3, 2, 2, 2, 70, 636, 3, 2, 2, 2, 72, 644, 3, 2, 2, 2, 74, 656,
	3, 2, 2, 2, 76, 658, 3, 2, 2, 2, 78, 666, 3, 2, 2, 2, 80, 668, 3, 2, 2,
	2, 82, 670, 3, 2, 2, 2, 84, 686, 3, 2, 2, 2, 86, 688, 3, 2, 2, 2, 88, 693,
	3, 2, 2, 2, 90, 698, 3, 2, 2, 2, 92, 703, 3, 2, 2, 2, 94, 714, 3, 2, 2,
	2, 96, 722, 3, 2, 2, 2, 98, 729, 3, 2, 2, 2, 100, 731, 3, 2, 2, 2, 102,
	739, 3, 2, 2, 2, 104, 747, 3, 2, 2, 2, 106, 752, 3, 2, 2, 2, 108, 754,
	3, 2, 2, 2, 110, 760, 3, 2, 2, 2, 112, 764, 3, 2, 2, 2, 114, 770, 3, 2,
	2, 2, 116, 772, 3, 2, 2, 2, 118, 774, 3, 2, 2, 2, 120, 776, 3, 2, 2, 2,
	122, 781, 3, 2, 2, 2, 124, 787, 3, 2, 2, 2, 126, 789, 3, 2, 2, 2, 128,
	794, 3, 2, 2, 2, 130, 799, 3, 2, 2, 2, 132, 805, 3, 2, 2, 2, 134, 807,
	3, 2, 2, 2, 136, 809, 3, 2, 2, 2, 138, 811, 3, 2, 2, 2, 140, 813, 3, 2,
	2, 2, 142, 815, 3, 2, 2, 2, 144, 817, 3, 2, 2, 2, 146, 821, 3, 2, 2, 2,
	148, 823, 3, 2, 2, 2, 150, 828, 3, 2, 2, 2, 152, 833, 3, 2, 2, 2, 154,
	849, 3, 2, 2, 2, 156, 852, 3, 2, 2, 2, 158, 860, 3, 2, 2, 2, 160, 863,
	3, 2, 2, 2, 162, 879, 3, 2, 2, 2, 164, 883, 3, 2, 2, 2, 166, 893, 3, 2,
	2, 2, 168, 899, 3, 2, 2, 2, 170, 907, 3, 2, 2, 2, 172, 920, 3, 2, 2, 2,
	174, 923, 3, 2, 2, 2, 176, 928, 3, 2, 2, 2, 178, 946, 3, 2, 2, 2, 180,
	949, 3, 2, 2, 2, 182, 954, 3, 2, 2, 2, 184, 961, 3, 2, 2, 2, 186, 970,
	3, 2, 2, 2, 188, 974, 3, 2, 2, 2, 190, 987, 3, 2, 2, 2, 192, 989, 3, 2,
	2, 2, 194, 999, 3, 2, 2, 2, 196, 1008, 3, 2, 2, 2, 198, 1019, 3, 2, 2,
	2, 200, 1026, 3, 2, 2, 2, 202, 1033, 3, 2, 2, 2, 204, 1039, 3, 2, 2, 2,
	206, 1045, 3, 2, 2, 2, 208, 1047, 3, 2, 2, 2, 210, 1059, 3, 2, 2, 2, 212,
	1070, 3, 2, 2, 2, 214, 1072, 3, 2, 2, 2, 216, 1077, 3, 2, 2, 2, 218, 1090,
	3, 2, 2, 2, 220, 1097, 3, 2, 2, 2, 222, 1099, 3, 2, 2, 2, 224, 1111, 3,
	2, 2, 2, 226, 1127, 3, 2, 2, 2, 228, 1129, 3, 2, 2, 2, 230, 1136, 3, 2,
	2, 2, 232, 1138, 3, 2, 2, 2, 234, 1144, 3, 2, 2, 2, 236, 1146, 3, 2, 2,
	2, 238, 1154, 3, 2, 2, 2, 240, 1156, 3, 2, 2, 2, 242, 1160, 3, 2, 2, 2,
	244, 1164, 3, 2, 2, 2, 246, 1170, 3, 2, 2, 2, 248, 1184, 3, 2, 2, 2, 250,
	1189, 3, 2, 2, 2, 252, 1208, 3, 2, 2, 2, 254, 1210, 3, 2, 2, 2, 256, 1213,
	3, 2, 2, 2, 258, 1216, 3, 2, 2, 2, 260, 1229, 3, 2, 2, 2, 262, 1231, 3,
	2, 2, 2, 264, 1234, 3, 2, 2, 2, 266, 1239, 3, 2, 2, 2, 268, 1247, 3, 2,
	2, 2, 270, 1256, 3, 2, 2, 2, 272, 1262, 3, 2, 2, 2, 274, 1265, 3, 2, 2,
	2, 276, 1286, 3, 2, 2, 2, 278, 1290, 3, 2, 2, 2, 280, 1295, 3, 2, 2, 2,
	282, 1302, 3, 2, 2, 2, 284, 1306, 3, 2, 2, 2, 286, 1310, 3, 2, 2, 2, 288,
	1314, 3, 2, 2, 2, 290, 1317, 3, 2, 2, 2, 292, 1330, 3, 2, 2, 2, 294, 1333,
	3, 2, 2, 2, 296, 1336, 3, 2, 2, 2, 298, 1353, 3, 2, 2, 2, 300, 1355, 3,
	2, 2, 2, 302, 1365, 3, 2, 2, 2, 304, 1378, 3, 2, 2, 2, 306, 1381, 3, 2,
	2, 2, 308, 1386, 3, 2, 2, 2, 310, 1399, 3, 2, 2, 2, 312, 1410, 3, 2, 2,
	2, 314, 1419, 3, 2, 2, 2, 316, 1422, 3, 2, 2, 2, 318, 1439, 3, 2, 2, 2,
	320, 1441, 3, 2, 2, 2, 322, 1445, 3, 2, 2, 2, 324, 326, 5, 236, 119, 2,
	325, 324, 3, 2, 2, 2, 326, 329, 3, 2, 2, 2, 327, 325, 3, 2, 2, 2, 327,
	328, 3, 2, 2, 2, 328, 331, 3, 2, 2, 2, 329, 327, 3, 2, 2, 2, 330, 332,
	5, 4, 3, 2, 331, 330, 3, 2, 2, 2, 332, 333, 3, 2, 2, 2, 333, 331, 3, 2,
	2, 2, 333, 334, 3, 2, 2, 2, 334, 3, 3, 2, 2, 2, 335, 372, 5, 314, 158,
	2, 336, 337, 5, 84, 43, 2, 337, 338, 7, 13, 2, 2, 338, 373, 3, 2, 2, 2,
	339, 340, 5, 56, 29, 2, 340, 341, 7, 13, 2, 2, 341, 373, 3, 2, 2, 2, 342,
	343, 5, 208, 105, 2, 343, 344, 7, 13, 2, 2, 344, 373, 3, 2, 2, 2, 345,
	346, 5, 8, 5, 2, 346, 347, 7, 13, 2, 2, 347, 373, 3, 2, 2, 2, 348, 349,
	5, 6, 4, 2, 349, 350, 7, 13, 2, 2, 350, 373, 3, 2, 2, 2, 351, 352, 5, 28,
	15, 2, 352, 353, 7, 13, 2, 2, 353, 373, 3, 2, 2, 2, 354, 355, 5, 240, 121,
	2, 355, 356, 7, 13, 2, 2, 356, 373, 3, 2, 2, 2, 357, 358, 5, 242, 122,
	2, 358, 359, 7, 13, 2, 2, 359, 373, 3, 2, 2, 2, 360, 361, 5, 304, 153,
	2, 361, 362, 7, 13, 2, 2, 362, 373, 3, 2, 2, 2, 363, 364, 5, 260, 131,
	2, 364, 365, 7, 13, 2, 2, 365, 373, 3, 2, 2, 2, 366, 367, 5, 288, 145,
	2, 367, 368, 7, 13, 2, 2, 368, 373, 3, 2, 2, 2, 369, 370, 5, 146, 74, 2,
	370, 371, 7, 13, 2, 2, 371, 373, 3, 2, 2, 2, 372, 336, 3, 2, 2, 2, 372,
	339, 3, 2, 2, 2, 372, 342, 3, 2, 2, 2, 372, 345, 3, 2, 2, 2, 372, 348,
	3, 2, 2, 2, 372, 351, 3, 2, 2, 2, 372, 354, 3, 2, 2, 2, 372, 357, 3, 2,
	2, 2, 372, 360, 3, 2, 2, 2, 372, 363, 3, 2, 2, 2, 372, 366, 3, 2, 2, 2,
	372, 369, 3, 2, 2, 2, 373, 5, 3, 2, 2, 2, 374, 375, 7, 76, 2, 2, 375, 376,
	5, 322, 162, 2, 376, 378, 7, 16, 2, 2, 377, 379, 5, 4, 3, 2, 378, 377,
	3, 2, 2, 2, 379, 380, 3, 2, 2, 2, 380, 378, 3, 2, 2, 2, 380, 381, 3, 2,
	2, 2, 381, 382, 3, 2, 2, 2, 382, 383, 7, 17, 2, 2, 383, 7, 3, 2, 2, 2,
	384, 387, 5, 314, 158, 2, 385, 388, 5, 10, 6, 2, 386, 388, 5, 12, 7, 2,
	387, 385, 3, 2, 2, 2, 387, 386, 3, 2, 2, 2, 388, 9, 3, 2, 2, 2, 389, 390,
	5, 14, 8, 2, 390, 391, 7, 16, 2, 2, 391, 392, 5, 16, 9, 2, 392, 393, 7,
	17, 2, 2, 393, 11, 3, 2, 2, 2, 394, 396, 9, 2, 2, 2, 395, 394, 3, 2, 2,
	2, 395, 396, 3, 2, 2, 2, 396, 397, 3, 2, 2, 2, 397, 398, 7, 99, 2, 2, 398,
	399, 5, 322, 162, 2, 399, 13, 3, 2, 2, 2, 400, 402, 9, 2, 2, 2, 401, 400,
	3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402, 403, 3, 2, 2, 2, 403, 404, 7, 99,
	2, 2, 404, 406, 5, 322, 162, 2, 405, 407, 5, 20, 11, 2, 406, 405, 3, 2,
	2, 2, 406, 407, 3, 2, 2, 2, 407, 15, 3, 2, 2, 2, 408, 410, 5, 18, 10, 2,
	409, 408, 3, 2, 2, 2, 410, 413, 3, 2, 2, 2, 411, 409, 3, 2, 2, 2, 411,
	412, 3, 2, 2, 2, 412, 17, 3, 2, 2, 2, 413, 411, 3, 2, 2, 2, 414, 436, 5,
	314, 158, 2, 415, 416, 5, 84, 43, 2, 416, 417, 7, 13, 2, 2, 417, 437, 3,
	2, 2, 2, 418, 419, 5, 56, 29, 2, 419, 420, 7, 13, 2, 2, 420, 437, 3, 2,
	2, 2, 421, 422, 5, 208, 105, 2, 422, 423, 7, 13, 2, 2, 423, 437, 3, 2,
	2, 2, 424, 425, 5, 206, 104, 2, 425, 426, 7, 13, 2, 2, 426, 437, 3, 2,
	2, 2, 427, 428, 5, 210, 106, 2, 428, 429, 7, 13, 2, 2, 429, 437, 3, 2,
	2, 2, 430, 431, 5, 240, 121, 2, 431, 432, 7, 13, 2, 2, 432, 437, 3, 2,
	2, 2, 433, 434, 5, 242, 122, 2, 434, 435, 7, 13, 2, 2, 435, 437, 3, 2,
	2, 2, 436, 415, 3, 2, 2, 2, 436, 418, 3, 2, 2, 2, 436, 421, 3, 2, 2, 2,
	436, 424, 3, 2, 2, 2, 436, 427, 3, 2, 2, 2, 436, 430, 3, 2, 2, 2, 436,
	433, 3, 2, 2, 2, 437, 19, 3, 2, 2, 2, 438, 439, 7, 14, 2, 2, 439, 444,
	5, 22, 12, 2, 440, 441, 7, 15, 2, 2, 441, 443, 5, 22, 12, 2, 442, 440,
	3, 2, 2, 2, 443, 446, 3, 2, 2, 2, 444, 442, 3, 2, 2, 2, 444, 445, 3, 2,
	2, 2, 445, 21, 3, 2, 2, 2, 446, 444, 3, 2, 2, 2, 447, 448, 5, 24, 13, 2,
	448, 23, 3, 2, 2, 2, 449, 450, 5, 314, 158, 2, 450, 451, 5, 26, 14, 2,
	451, 25, 3, 2, 2, 2, 452, 454, 7, 34, 2, 2, 453, 452, 3, 2, 2, 2, 453,
	454, 3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455, 460, 7, 115, 2, 2, 456, 457,
	7, 34, 2, 2, 457, 459, 7, 115, 2, 2, 458, 456, 3, 2, 2, 2, 459, 462, 3,
	2, 2, 2, 460, 458, 3, 2, 2, 2, 460, 461, 3, 2, 2, 2, 461, 27, 3, 2, 2,
	2, 462, 460, 3, 2, 2, 2, 463, 468, 5, 314, 158, 2, 464, 469, 5, 36, 19,
	2, 465, 469, 5, 34, 18, 2, 466, 469, 5, 32, 17, 2, 467, 469, 5, 30, 16,
	2, 468, 464, 3, 2, 2, 2, 468, 465, 3, 2, 2, 2, 468, 466, 3, 2, 2, 2, 468,
	467, 3, 2, 2, 2, 469, 29, 3, 2, 2, 2, 470, 472, 7, 89, 2, 2, 471, 470,
	3, 2, 2, 2, 471, 472, 3, 2, 2, 2, 472, 473, 3, 2, 2, 2, 473, 474, 7, 74,
	2, 2, 474, 475, 5, 322, 162, 2, 475, 31, 3, 2, 2, 2, 476, 477, 7, 74, 2,
	2, 477, 478, 5, 322, 162, 2, 478, 479, 5, 88, 45, 2, 479, 33, 3, 2, 2,
	2, 480, 481, 7, 89, 2, 2, 481, 482, 7, 74, 2, 2, 482, 483, 5, 322, 162,
	2, 483, 484, 5, 40, 21, 2, 484, 488, 7, 16, 2, 2, 485, 487, 5, 18, 10,
	2, 486, 485, 3, 2, 2, 2, 487, 490, 3, 2, 2, 2, 488, 486, 3, 2, 2, 2, 488,
	489, 3, 2, 2, 2, 489, 491, 3, 2, 2, 2, 490, 488, 3, 2, 2, 2, 491, 492,
	7, 17, 2, 2, 492, 35, 3, 2, 2, 2, 493, 494, 5, 38, 20, 2, 494, 498, 7,
	16, 2, 2, 495, 497, 5, 44, 23, 2, 496, 495, 3, 2, 2, 2, 497, 500, 3, 2,
	2, 2, 498, 496, 3, 2, 2, 2, 498, 499, 3, 2, 2, 2, 499, 501, 3, 2, 2, 2,
	500, 498, 3, 2, 2, 2, 501, 502, 7, 17, 2, 2, 502, 37, 3, 2, 2, 2, 503,
	505, 7, 47, 2, 2, 504, 503, 3, 2, 2, 2, 504, 505, 3, 2, 2, 2, 505, 506,
	3, 2, 2, 2, 506, 507, 7, 74, 2, 2, 507, 508, 5, 322, 162, 2, 508, 509,
	5, 40, 21, 2, 509, 39, 3, 2, 2, 2, 510, 512, 7, 14, 2, 2, 511, 513, 7,
	78, 2, 2, 512, 511, 3, 2, 2, 2, 512, 513, 3, 2, 2, 2, 513, 514, 3, 2, 2,
	2, 514, 519, 5, 42, 22, 2, 515, 516, 7, 15, 2, 2, 516, 518, 5, 42, 22,
	2, 517, 515, 3, 2, 2, 2, 518, 521, 3, 2, 2, 2, 519, 517, 3, 2, 2, 2, 519,
	520, 3, 2, 2, 2, 520, 523, 3, 2, 2, 2, 521, 519, 3, 2, 2, 2, 522, 510,
	3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523, 533, 3, 2, 2, 2, 524, 525, 7, 75,
	2, 2, 525, 530, 5, 22, 12, 2, 526, 527, 7, 15, 2, 2, 527, 529, 5, 22, 12,
	2, 528, 526, 3, 2, 2, 2, 529, 532, 3, 2, 2, 2, 530, 528, 3, 2, 2, 2, 530,
	531, 3, 2, 2, 2, 531, 534, 3, 2, 2, 2, 532, 530, 3, 2, 2, 2, 533, 524,
	3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534, 41, 3, 2, 2, 2, 535, 536, 5, 24,
	13, 2, 536, 43, 3, 2, 2, 2, 537, 541, 5, 18, 10, 2, 538, 541, 5, 46, 24,
	2, 539, 541, 5, 48, 25, 2, 540, 537, 3, 2, 2, 2, 540, 538, 3, 2, 2, 2,
	540, 539, 3, 2, 2, 2, 541, 45, 3, 2, 2, 2, 542, 547, 5, 314, 158, 2, 543,
	544, 7, 62, 2, 2, 544, 548, 5, 314, 158, 2, 545, 546, 7, 57, 2, 2, 546,
	548, 5, 314, 158, 2, 547, 543, 3, 2, 2, 2, 547, 545, 3, 2, 2, 2, 548, 549,
	3, 2, 2, 2, 549, 550, 5, 88, 45, 2, 550, 551, 5, 102, 52, 2, 551, 552,
	7, 13, 2, 2, 552, 47, 3, 2, 2, 2, 553, 554, 5, 314, 158, 2, 554, 555, 7,
	69, 2, 2, 555, 556, 5, 322, 162, 2, 556, 558, 7, 18, 2, 2, 557, 559, 5,
	50, 26, 2, 558, 557, 3, 2, 2, 2, 558, 559, 3, 2, 2, 2, 559, 560, 3, 2,
	2, 2, 560, 562, 7, 19, 2, 2, 561, 563, 5, 222, 112, 2, 562, 561, 3, 2,
	2, 2, 562, 563, 3, 2, 2, 2, 563, 564, 3, 2, 2, 2, 564, 565, 7, 13, 2, 2,
	565, 49, 3, 2, 2, 2, 566, 571, 5, 52, 27, 2, 567, 568, 7, 15, 2, 2, 568,
	570, 5, 52, 27, 2, 569, 567, 3, 2, 2, 2, 570, 573, 3, 2, 2, 2, 571, 569,
	3, 2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 51, 3, 2, 2, 2, 573, 571, 3, 2,
	2, 2, 574, 575, 5, 314, 158, 2, 575, 576, 5, 54, 28, 2, 576, 577, 5, 314,
	158, 2, 577, 578, 5, 226, 114, 2, 578, 579, 5, 314, 158, 2, 579, 580, 5,
	106, 54, 2, 580, 53, 3, 2, 2, 2, 581, 582, 7, 60, 2, 2, 582, 55, 3, 2,
	2, 2, 583, 584, 7, 72, 2, 2, 584, 585, 5, 58, 30, 2, 585, 586, 5, 322,
	162, 2, 586, 587, 7, 32, 2, 2, 587, 588, 5, 60, 31, 2, 588, 57, 3, 2, 2,
	2, 589, 600, 5, 314, 158, 2, 590, 601, 5, 112, 57, 2, 591, 601, 5, 134,
	68, 2, 592, 601, 5, 136, 69, 2, 593, 601, 5, 138, 70, 2, 594, 601, 5, 110,
	56, 2, 595, 601, 5, 198, 100, 2, 596, 601, 5, 200, 101, 2, 597, 601, 5,
	230, 116, 2, 598, 601, 5, 26, 14, 2, 599, 601, 5, 140, 71, 2, 600, 590,
	3, 2, 2, 2, 600, 591, 3, 2, 2, 2, 600, 592, 3, 2, 2, 2, 600, 593, 3, 2,
	2, 2, 600, 594, 3, 2, 2, 2, 600, 595, 3, 2, 2, 2, 600, 596, 3, 2, 2, 2,
	600, 597, 3, 2, 2, 2, 600, 598, 3, 2, 2, 2, 600, 599, 3, 2, 2, 2, 601,
	59, 3, 2, 2, 2, 602, 603, 5, 62, 32, 2, 603, 61, 3, 2, 2, 2, 604, 609,
	5, 64, 33, 2, 605, 606, 7, 31, 2, 2, 606, 608, 5, 64, 33, 2, 607, 605,
	3, 2, 2, 2, 608, 611, 3, 2, 2, 2, 609, 607, 3, 2, 2, 2, 609, 610, 3, 2,
	2, 2, 610, 63, 3, 2, 2, 2, 611, 609, 3, 2, 2, 2, 612, 617, 5, 66, 34, 2,
	613, 614, 7, 29, 2, 2, 614, 616, 5, 66, 34, 2, 615, 613, 3, 2, 2, 2, 616,
	619, 3, 2, 2, 2, 617, 615, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 65, 3,
	2, 2, 2, 619, 617, 3, 2, 2, 2, 620, 625, 5, 68, 35, 2, 621, 622, 7, 30,
	2, 2, 622, 624, 5, 68, 35, 2, 623, 621, 3, 2, 2, 2, 624, 627, 3, 2, 2,
	2, 625, 623, 3, 2, 2, 2, 625, 626, 3, 2, 2, 2, 626, 67, 3, 2, 2, 2, 627,
	625, 3, 2, 2, 2, 628, 633, 5, 70, 36, 2, 629, 630, 9, 3, 2, 2, 630, 632,
	5, 70, 36, 2, 631, 629, 3, 2, 2, 2, 632, 635, 3, 2, 2, 2, 633, 631, 3,
	2, 2, 2, 633, 634, 3, 2, 2, 2, 634, 69, 3, 2, 2, 2, 635, 633, 3, 2, 2,
	2, 636, 641, 5, 72, 37, 2, 637, 638, 9, 4, 2, 2, 638, 640, 5, 72, 37, 2,
	639, 637, 3, 2, 2, 2, 640, 643, 3, 2, 2, 2, 641, 639, 3, 2, 2, 2, 641,
	642, 3, 2, 2, 2, 642, 71, 3, 2, 2, 2, 643, 641, 3, 2, 2, 2, 644, 649, 5,
	74, 38, 2, 645, 646, 9, 5, 2, 2, 646, 648, 5, 74, 38, 2, 647, 645, 3, 2,
	2, 2, 648, 651, 3, 2, 2, 2, 649, 647, 3, 2, 2, 2, 649, 650, 3, 2, 2, 2,
	650, 73, 3, 2, 2, 2, 651, 649, 3, 2, 2, 2, 652, 653, 5, 76, 39, 2, 653,
	654, 5, 78, 40, 2, 654, 657, 3, 2, 2, 2, 655, 657, 5, 78, 40, 2, 656, 652,
	3, 2, 2, 2, 656, 655, 3, 2, 2, 2, 657, 75, 3, 2, 2, 2, 658, 659, 9, 6,
	2, 2, 659, 77, 3, 2, 2, 2, 660, 667, 5, 26, 14, 2, 661, 667, 5, 80, 41,
	2, 662, 663, 7, 18, 2, 2, 663, 664, 5, 60, 31, 2, 664, 665, 7, 19, 2, 2,
	665, 667, 3, 2, 2, 2, 666, 660, 3, 2, 2, 2, 666, 661, 3, 2, 2, 2, 666,
	662, 3, 2, 2, 2, 667, 79, 3, 2, 2, 2, 668, 669, 9, 7, 2, 2, 669, 81, 3,
	2, 2, 2, 670, 671, 5, 60, 31, 2, 671, 83, 3, 2, 2, 2, 672, 673, 7, 44,
	2, 2, 673, 674, 5, 314, 158, 2, 674, 675, 5, 86, 44, 2, 675, 687, 3, 2,
	2, 2, 676, 687, 5, 170, 86, 2, 677, 687, 5, 176, 89, 2, 678, 687, 5, 188,
	95, 2, 679, 687, 5, 160, 81, 2, 680, 687, 5, 166, 84, 2, 681, 682, 7, 52,
	2, 2, 682, 683, 5, 314, 158, 2, 683, 684, 5, 106, 54, 2, 684, 687, 3, 2,
	2, 2, 685, 687, 5, 234, 118, 2, 686, 672, 3, 2, 2, 2, 686, 676, 3, 2, 2,
	2, 686, 677, 3, 2, 2, 2, 686, 678, 3, 2, 2, 2, 686, 679, 3, 2, 2, 2, 686,
	680, 3, 2, 2, 2, 686, 681, 3, 2, 2, 2, 686, 685, 3, 2, 2, 2, 687, 85, 3,
	2, 2, 2, 688, 689, 5, 88, 45, 2, 689, 690, 5, 102, 52, 2, 690, 87, 3, 2,
	2, 2, 691, 694, 5, 90, 46, 2, 692, 694, 5, 98, 50, 2, 693, 691, 3, 2, 2,
	2, 693, 692, 3, 2, 2, 2, 694, 89, 3, 2, 2, 2, 695, 699, 5, 94, 48, 2, 696,
	699, 5, 96, 49, 2, 697, 699, 5, 26, 14, 2, 698, 695, 3, 2, 2, 2, 698, 696,
	3, 2, 2, 2, 698, 697, 3, 2, 2, 2, 699, 91, 3, 2, 2, 2, 700, 704, 5, 112,
	57, 2, 701, 704, 5, 138, 70, 2, 702, 704, 5, 140, 71, 2, 703, 700, 3, 2,
	2, 2, 703, 701, 3, 2, 2, 2, 703, 702, 3, 2, 2, 2, 704, 93, 3, 2, 2, 2,
	705, 715, 5, 110, 56, 2, 706, 715, 5, 112, 57, 2, 707, 715, 5, 134, 68,
	2, 708, 715, 5, 136, 69, 2, 709, 715, 5, 138, 70, 2, 710, 715, 5, 140,
	71, 2, 711, 715, 5, 142, 72, 2, 712, 715, 5, 144, 73, 2, 713, 715, 5, 232,
	117, 2, 714, 705, 3, 2, 2, 2, 714, 706, 3, 2, 2, 2, 714, 707, 3, 2, 2,
	2, 714, 708, 3, 2, 2, 2, 714, 709, 3, 2, 2, 2, 714, 710, 3, 2, 2, 2, 714,
	711, 3, 2, 2, 2, 714, 712, 3, 2, 2, 2, 714, 713, 3, 2, 2, 2, 715, 95, 3,
	2, 2, 2, 716, 723, 5, 192, 97, 2, 717, 723, 5, 194, 98, 2, 718, 723, 5,
	196, 99, 2, 719, 723, 5, 198, 100, 2, 720, 723, 5, 200, 101, 2, 721, 723,
	5, 228, 115, 2, 722, 716, 3, 2, 2, 2, 722, 717, 3, 2, 2, 2, 722, 718, 3,
	2, 2, 2, 722, 719, 3, 2, 2, 2, 722, 720, 3, 2, 2, 2, 722, 721, 3, 2, 2,
	2, 723, 97, 3, 2, 2, 2, 724, 730, 5, 170, 86, 2, 725, 730, 5, 176, 89,
	2, 726, 730, 5, 188, 95, 2, 727, 730, 5, 160, 81, 2, 728, 730, 5, 166,
	84, 2, 729, 724, 3, 2, 2, 2, 729, 725, 3, 2, 2, 2, 729, 726, 3, 2, 2, 2,
	729, 727, 3, 2, 2, 2, 729, 728, 3, 2, 2, 2, 730, 99, 3, 2, 2, 2, 731, 736,
	5, 322, 162, 2, 732, 733, 7, 15, 2, 2, 733, 735, 5, 322, 162, 2, 734, 732,
	3, 2, 2, 2, 735, 738, 3, 2, 2, 2, 736, 734, 3, 2, 2, 2, 736, 737, 3, 2,
	2, 2, 737, 101, 3, 2, 2, 2, 738, 736, 3, 2, 2, 2, 739, 744, 5, 104, 53,
	2, 740, 741, 7, 15, 2, 2, 741, 743, 5, 104, 53, 2, 742, 740, 3, 2, 2, 2,
	743, 746, 3, 2, 2, 2, 744, 742, 3, 2, 2, 2, 744, 745, 3, 2, 2, 2, 745,
	103, 3, 2, 2, 2, 746, 744, 3, 2, 2, 2, 747, 750, 5, 314, 158, 2, 748, 751,
	5, 106, 54, 2, 749, 751, 5, 108, 55, 2, 750, 748, 3, 2, 2, 2, 750, 749,
	3, 2, 2, 2, 751, 105, 3, 2, 2, 2, 752, 753, 7, 115, 2, 2, 753, 107, 3,
	2, 2, 2, 754, 755, 5, 202, 102, 2, 755, 109, 3, 2, 2, 2, 756, 761, 7, 86,
	2, 2, 757, 761, 7, 93, 2, 2, 758, 759, 7, 64, 2, 2, 759, 761, 7, 93, 2,
	2, 760, 756, 3, 2, 2, 2, 760, 757, 3, 2, 2, 2, 760, 758, 3, 2, 2, 2, 761,
	111, 3, 2, 2, 2, 762, 765, 5, 114, 58, 2, 763, 765, 5, 124, 63, 2, 764,
	762, 3, 2, 2, 2, 764, 763, 3, 2, 2, 2, 765, 113, 3, 2, 2, 2, 766, 771,
	5, 118, 60, 2, 767, 771, 5, 120, 61, 2, 768, 771, 5, 122, 62, 2, 769, 771,
	5, 116, 59, 2, 770, 766, 3, 2, 2, 2, 770, 767, 3, 2, 2, 2, 770, 768, 3,
	2, 2, 2, 770, 769, 3, 2, 2, 2, 771, 115, 3, 2, 2, 2, 772, 773, 7, 106,
	2, 2, 773, 117, 3, 2, 2, 2, 774, 775, 9, 8, 2, 2, 775, 119, 3, 2, 2, 2,
	776, 777, 9, 9, 2, 2, 777, 121, 3, 2, 2, 2, 778, 779, 7, 64, 2, 2, 779,
	782, 7, 64, 2, 2, 780, 782, 7, 112, 2, 2, 781, 778, 3, 2, 2, 2, 781, 780,
	3, 2, 2, 2, 782, 123, 3, 2, 2, 2, 783, 788, 5, 128, 65, 2, 784, 788, 5,
	130, 66, 2, 785, 788, 5, 132, 67, 2, 786, 788, 5, 126, 64, 2, 787, 783,
	3, 2, 2, 2, 787, 784, 3, 2, 2, 2, 787, 785, 3, 2, 2, 2, 787, 786, 3, 2,
	2, 2, 788, 125, 3, 2, 2, 2, 789, 790, 7, 107, 2, 2, 790, 127, 3, 2, 2,
	2, 791, 792, 7, 79, 2, 2, 792, 795, 7, 63, 2, 2, 793, 795, 7, 109, 2, 2,
	794, 791, 3, 2, 2, 2, 794, 793, 3, 2, 2, 2, 795, 129, 3, 2, 2, 2, 796,
	797, 7, 79, 2, 2, 797, 800, 7, 64, 2, 2, 798, 800, 7, 111, 2, 2, 799, 796,
	3, 2, 2, 2, 799, 798, 3, 2, 2, 2, 800, 131, 3, 2, 2, 2, 801, 802, 7, 79,
	2, 2, 802, 803, 7, 64, 2, 2, 803, 806, 7, 64, 2, 2, 804, 806, 7, 113, 2,
	2, 805, 801, 3, 2, 2, 2, 805, 804, 3, 2, 2, 2, 806, 133, 3, 2, 2, 2, 807,
	808, 7, 84, 2, 2, 808, 135, 3, 2, 2, 2, 809, 810, 7, 59, 2, 2, 810, 137,
	3, 2, 2, 2, 811, 812, 7, 87, 2, 2, 812, 139, 3, 2, 2, 2, 813, 814, 7, 48,
	2, 2, 814, 141, 3, 2, 2, 2, 815, 816, 7, 83, 2, 2, 816, 143, 3, 2, 2, 2,
	817, 818, 7, 77, 2, 2, 818, 145, 3, 2, 2, 2, 819, 822, 5, 148, 75, 2, 820,
	822, 5, 158, 80, 2, 821, 819, 3, 2, 2, 2, 821, 820, 3, 2, 2, 2, 822, 147,
	3, 2, 2, 2, 823, 824, 5, 150, 76, 2, 824, 825, 7, 16, 2, 2, 825, 826, 5,
	154, 78, 2, 826, 827, 7, 17, 2, 2, 827, 149, 3, 2, 2, 2, 828, 829, 7, 114,
	2, 2, 829, 831, 5, 322, 162, 2, 830, 832, 5, 152, 77, 2, 831, 830, 3, 2,
	2, 2, 831, 832, 3, 2, 2, 2, 832, 151, 3, 2, 2, 2, 833, 834, 7, 14, 2, 2,
	834, 835, 5, 26, 14, 2, 835, 153, 3, 2, 2, 2, 836, 848, 5, 156, 79, 2,
	837, 838, 5, 188, 95, 2, 838, 839, 7, 13, 2, 2, 839, 848, 3, 2, 2, 2, 840,
	841, 5, 56, 29, 2, 841, 842, 7, 13, 2, 2, 842, 848, 3, 2, 2, 2, 843, 844,
	7, 44, 2, 2, 844, 845, 5, 86, 44, 2, 845, 846, 7, 13, 2, 2, 846, 848, 3,
	2, 2, 2, 847, 836, 3, 2, 2, 2, 847, 837, 3, 2, 2, 2, 847, 840, 3, 2, 2,
	2, 847, 843, 3, 2, 2, 2, 848, 851, 3, 2, 2, 2, 849, 847, 3, 2, 2, 2, 849,
	850, 3, 2, 2, 2, 850, 155, 3, 2, 2, 2, 851, 849, 3, 2, 2, 2, 852, 853,
	5, 58, 30, 2, 853, 856, 5, 106, 54, 2, 854, 855, 7, 61, 2, 2, 855, 857,
	5, 60, 31, 2, 856, 854, 3, 2, 2, 2, 856, 857, 3, 2, 2, 2, 857, 858, 3,
	2, 2, 2, 858, 859, 7, 13, 2, 2, 859, 157, 3, 2, 2, 2, 860, 861, 7, 114,
	2, 2, 861, 862, 5, 26, 14, 2, 862, 159, 3, 2, 2, 2, 863, 864, 7, 104, 2,
	2, 864, 867, 5, 322, 162, 2, 865, 866, 7, 14, 2, 2, 866, 868, 5, 26, 14,
	2, 867, 865, 3, 2, 2, 2, 867, 868, 3, 2, 2, 2, 868, 869, 3, 2, 2, 2, 869,
	870, 7, 16, 2, 2, 870, 871, 5, 162, 82, 2, 871, 872, 7, 17, 2, 2, 872,
	161, 3, 2, 2, 2, 873, 875, 5, 164, 83, 2, 874, 876, 5, 100, 51, 2, 875,
	874, 3, 2, 2, 2, 875, 876, 3, 2, 2, 2, 876, 877, 3, 2, 2, 2, 877, 878,
	7, 13, 2, 2, 878, 880, 3, 2, 2, 2, 879, 873, 3, 2, 2, 2, 880, 881, 3, 2,
	2, 2, 881, 879, 3, 2, 2, 2, 881, 882, 3, 2, 2, 2, 882, 163, 3, 2, 2, 2,
	883, 884, 5, 314, 158, 2, 884, 885, 7, 103, 2, 2, 885, 886, 7, 24, 2, 2,
	886, 889, 5, 82, 42, 2, 887, 888, 7, 15, 2, 2, 888, 890, 5, 92, 47, 2,
	889, 887, 3, 2, 2, 2, 889, 890, 3, 2, 2, 2, 890, 891, 3, 2, 2, 2, 891,
	892, 7, 25, 2, 2, 892, 165, 3, 2, 2, 2, 893, 894, 7, 105, 2, 2, 894, 895,
	5, 322, 162, 2, 895, 896, 7, 16, 2, 2, 896, 897, 5, 168, 85, 2, 897, 898,
	7, 17, 2, 2, 898, 167, 3, 2, 2, 2, 899, 904, 5, 322, 162, 2, 900, 901,
	7, 15, 2, 2, 901, 903, 5, 322, 162, 2, 902, 900, 3, 2, 2, 2, 903, 906,
	3, 2, 2, 2, 904, 902, 3, 2, 2, 2, 904, 905, 3, 2, 2, 2, 905, 169, 3, 2,
	2, 2, 906, 904, 3, 2, 2, 2, 907, 908, 7, 51, 2, 2, 908, 911, 5, 322, 162,
	2, 909, 910, 7, 14, 2, 2, 910, 912, 5, 26, 14, 2, 911, 909, 3, 2, 2, 2,
	911, 912, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2, 913, 914, 7, 16, 2, 2, 914,
	915, 5, 172, 87, 2, 915, 916, 7, 17, 2, 2, 916, 171, 3, 2, 2, 2, 917, 919,
	5, 174, 88, 2, 918, 917, 3, 2, 2, 2, 919, 922, 3, 2, 2, 2, 920, 918, 3,
	2, 2, 2, 920, 921, 3, 2, 2, 2, 921, 173, 3, 2, 2, 2, 922, 920, 3, 2, 2,
	2, 923, 924, 5, 314, 158, 2, 924, 925, 5, 88, 45, 2, 925, 926, 5, 102,
	52, 2, 926, 927, 7, 13, 2, 2, 927, 175, 3, 2, 2, 2, 928, 929, 7, 81, 2,
	2, 929, 930, 5, 322, 162, 2, 930, 931, 7, 42, 2, 2, 931, 932, 7, 18, 2,
	2, 932, 933, 5, 314, 158, 2, 933, 934, 5, 178, 90, 2, 934, 935, 7, 19,
	2, 2, 935, 936, 7, 16, 2, 2, 936, 937, 5, 180, 91, 2, 937, 938, 7, 17,
	2, 2, 938, 177, 3, 2, 2, 2, 939, 947, 5, 112, 57, 2, 940, 947, 5, 134,
	68, 2, 941, 947, 5, 136, 69, 2, 942, 947, 5, 140, 71, 2, 943, 947, 5, 138,
	70, 2, 944, 947, 5, 188, 95, 2, 945, 947, 5, 26, 14, 2, 946, 939, 3, 2,
	2, 2, 946, 940, 3, 2, 2, 2, 946, 941, 3, 2, 2, 2, 946, 942, 3, 2, 2, 2,
	946, 943, 3, 2, 2, 2, 946, 944, 3, 2, 2, 2, 946, 945, 3, 2, 2, 2, 947,
	179, 3, 2, 2, 2, 948, 950, 5, 182, 92, 2, 949, 948, 3, 2, 2, 2, 950, 951,
	3, 2, 2, 2, 951, 949, 3, 2, 2, 2, 951, 952, 3, 2, 2, 2, 952, 181, 3, 2,
	2, 2, 953, 955, 5, 184, 93, 2, 954, 953, 3, 2, 2, 2, 955, 956, 3, 2, 2,
	2, 956, 954, 3, 2, 2, 2, 956, 957, 3, 2, 2, 2, 957, 958, 3, 2, 2, 2, 958,
	959, 5, 186, 94, 2, 959, 960, 7, 13, 2, 2, 960, 183, 3, 2, 2, 2, 961, 968,
	5, 314, 158, 2, 962, 963, 7, 85, 2, 2, 963, 964, 5, 60, 31, 2, 964, 965,
	7, 14, 2, 2, 965, 969, 3, 2, 2, 2, 966, 967, 7, 61, 2, 2, 967, 969, 7,
	14, 2, 2, 968, 962, 3, 2, 2, 2, 968, 966, 3, 2, 2, 2, 969, 185, 3, 2, 2,
	2, 970, 971, 5, 314, 158, 2, 971, 972, 5, 88, 45, 2, 972, 973, 5, 104,
	53, 2, 973, 187, 3, 2, 2, 2, 974, 975, 7, 65, 2, 2, 975, 976, 5, 322, 162,
	2, 976, 977, 7, 16, 2, 2, 977, 982, 5, 190, 96, 2, 978, 979, 7, 15, 2,
	2, 979, 981, 5, 190, 96, 2, 980, 978, 3, 2, 2, 2, 981, 984, 3, 2, 2, 2,
	982, 980, 3, 2, 2, 2, 982, 983, 3, 2, 2, 2, 983, 985, 3, 2, 2, 2, 984,
	982, 3, 2, 2, 2, 985, 986, 7, 17, 2, 2, 986, 189, 3, 2, 2, 2, 987, 988,
	5, 322, 162, 2, 988, 191, 3, 2, 2, 2, 989, 990, 7, 49, 2, 2, 990, 991,
	7, 24, 2, 2, 991, 992, 5, 314, 158, 2, 992, 995, 5, 90, 46, 2, 993, 994,
	7, 15, 2, 2, 994, 996, 5, 82, 42, 2, 995, 993, 3, 2, 2, 2, 995, 996, 3,
	2, 2, 2, 996, 997, 3, 2, 2, 2, 997, 998, 7, 25, 2, 2, 998, 193, 3, 2, 2,
	2, 999, 1000, 7, 101, 2, 2, 1000, 1001, 7, 24, 2, 2, 1001, 1004, 5, 90,
	46, 2, 1002, 1003, 7, 15, 2, 2, 1003, 1005, 5, 82, 42, 2, 1004, 1002, 3,
	2, 2, 2, 1004, 1005, 3, 2, 2, 2, 1005, 1006, 3, 2, 2, 2, 1006, 1007, 7,
	25, 2, 2, 1007, 195, 3, 2, 2, 2, 1008, 1009, 7, 102, 2, 2, 1009, 1010,
	7, 24, 2, 2, 1010, 1011, 5, 90, 46, 2, 1011, 1012, 7, 15, 2, 2, 1012, 1015,
	5, 90, 46, 2, 1013, 1014, 7, 15, 2, 2, 1014, 1016, 5, 82, 42, 2, 1015,
	1013, 3, 2, 2, 2, 1015, 1016, 3, 2, 2, 2, 1016, 1017, 3, 2, 2, 2, 1017,
	1018, 7, 25, 2, 2, 1018, 197, 3, 2, 2, 2, 1019, 1024, 7, 41, 2, 2, 1020,
	1021, 7, 24, 2, 2, 1021, 1022, 5, 82, 42, 2, 1022, 1023, 7, 25, 2, 2, 1023,
	1025, 3, 2, 2, 2, 1024, 1020, 3, 2, 2, 2, 1024, 1025, 3, 2, 2, 2, 1025,
	199, 3, 2, 2, 2, 1026, 1031, 7, 66, 2, 2, 1027, 1028, 7, 24, 2, 2, 1028,
	1029, 5, 82, 42, 2, 1029, 1030, 7, 25, 2, 2, 1030, 1032, 3, 2, 2, 2, 1031,
	1027, 3, 2, 2, 2, 1031, 1032, 3, 2, 2, 2, 1032, 201, 3, 2, 2, 2, 1033,
	1035, 7, 115, 2, 2, 1034, 1036, 5, 204, 103, 2, 1035, 1034, 3, 2, 2, 2,
	1036, 1037, 3, 2, 2, 2, 1037, 1035, 3, 2, 2, 2, 1037, 1038, 3, 2, 2, 2,
	1038, 203, 3, 2, 2, 2, 1039, 1040, 7, 20, 2, 2, 1040, 1041, 5, 82, 42,
	2, 1041, 1042, 7, 21, 2, 2, 1042, 205, 3, 2, 2, 2, 1043, 1046, 5, 244,
	123, 2, 1044, 1046, 5, 248, 125, 2, 1045, 1043, 3, 2, 2, 2, 1045, 1044,
	3, 2, 2, 2, 1046, 207, 3, 2, 2, 2, 1047, 1048, 7, 70, 2, 2, 1048, 1049,
	5, 322, 162, 2, 1049, 1053, 7, 16, 2, 2, 1050, 1052, 5, 174, 88, 2, 1051,
	1050, 3, 2, 2, 2, 1052, 1055, 3, 2, 2, 2, 1053, 1051, 3, 2, 2, 2, 1053,
	1054, 3, 2, 2, 2, 1054, 1056, 3, 2, 2, 2, 1055, 1053, 3, 2, 2, 2, 1056,
	1057, 7, 17, 2, 2, 1057, 209, 3, 2, 2, 2, 1058, 1060, 5, 212, 107, 2, 1059,
	1058, 3, 2, 2, 2, 1059, 1060, 3, 2, 2, 2, 1060, 1061, 3, 2, 2, 2, 1061,
	1062, 5, 214, 108, 2, 1062, 1063, 5, 322, 162, 2, 1063, 1065, 5, 216, 109,
	2, 1064, 1066, 5, 222, 112, 2, 1065, 1064, 3, 2, 2, 2, 1065, 1066, 3, 2,
	2, 2, 1066, 1068, 3, 2, 2, 2, 1067, 1069, 5, 224, 113, 2, 1068, 1067, 3,
	2, 2, 2, 1068, 1069, 3, 2, 2, 2, 1069, 211, 3, 2, 2, 2, 1070, 1071, 7,
	82, 2, 2, 1071, 213, 3, 2, 2, 2, 1072, 1075, 5, 314, 158, 2, 1073, 1076,
	5, 226, 114, 2, 1074, 1076, 7, 56, 2, 2, 1075, 1073, 3, 2, 2, 2, 1075,
	1074, 3, 2, 2, 2, 1076, 215, 3, 2, 2, 2, 1077, 1086, 7, 18, 2, 2, 1078,
	1083, 5, 218, 110, 2, 1079, 1080, 7, 15, 2, 2, 1080, 1082, 5, 218, 110,
	2, 1081, 1079, 3, 2, 2, 2, 1082, 1085, 3, 2, 2, 2, 1083, 1081, 3, 2, 2,
	2, 1083, 1084, 3, 2, 2, 2, 1084, 1087, 3, 2, 2, 2, 1085, 1083, 3, 2, 2,
	2, 1086, 1078, 3, 2, 2, 2, 1086, 1087, 3, 2, 2, 2, 1087, 1088, 3, 2, 2,
	2, 1088, 1089, 7, 19, 2, 2, 1089, 217, 3, 2, 2, 2, 1090, 1091, 5, 314,
	158, 2, 1091, 1092, 5, 220, 111, 2, 1092, 1093, 5, 314, 158, 2, 1093, 1094,
	5, 226, 114, 2, 1094, 1095, 5, 314, 158, 2, 1095, 1096, 5, 106, 54, 2,
	1096, 219, 3, 2, 2, 2, 1097, 1098, 9, 10, 2, 2, 1098, 221, 3, 2, 2, 2,
	1099, 1100, 7, 55, 2, 2, 1100, 1101, 7, 18, 2, 2, 1101, 1106, 5, 24, 13,
	2, 1102, 1103, 7, 15, 2, 2, 1103, 1105, 5, 24, 13, 2, 1104, 1102, 3, 2,
	2, 2, 1105, 1108, 3, 2, 2, 2, 1106, 1104, 3, 2, 2, 2, 1106, 1107, 3, 2,
	2, 2, 1107, 1109, 3, 2, 2, 2, 1108, 1106, 3, 2, 2, 2, 1109, 1110, 7, 19,
	2, 2, 1110, 223, 3, 2, 2, 2, 1111, 1112, 7, 67, 2, 2, 1112, 1113, 7, 18,
	2, 2, 1113, 1118, 7, 11, 2, 2, 1114, 1115, 7, 15, 2, 2, 1115, 1117, 7,
	11, 2, 2, 1116, 1114, 3, 2, 2, 2, 1117, 1120, 3, 2, 2, 2, 1118, 1116, 3,
	2, 2, 2, 1118, 1119, 3, 2, 2, 2, 1119, 1121, 3, 2, 2, 2, 1120, 1118, 3,
	2, 2, 2, 1121, 1122, 7, 19, 2, 2, 1122, 225, 3, 2, 2, 2, 1123, 1128, 5,
	94, 48, 2, 1124, 1128, 5, 198, 100, 2, 1125, 1128, 5, 200, 101, 2, 1126,
	1128, 5, 26, 14, 2, 1127, 1123, 3, 2, 2, 2, 1127, 1124, 3, 2, 2, 2, 1127,
	1125, 3, 2, 2, 2, 1127, 1126, 3, 2, 2, 2, 1128, 227, 3, 2, 2, 2, 1129,
	1130, 7, 80, 2, 2, 1130, 1131, 7, 24, 2, 2, 1131, 1132, 5, 82, 42, 2, 1132,
	1133, 7, 15, 2, 2, 1133, 1134, 5, 82, 42, 2, 1134, 1135, 7, 25, 2, 2, 1135,
	229, 3, 2, 2, 2, 1136, 1137, 7, 80, 2, 2, 1137, 231, 3, 2, 2, 2, 1138,
	1139, 7, 73, 2, 2, 1139, 233, 3, 2, 2, 2, 1140, 1141, 7, 51, 2, 2, 1141,
	1145, 7, 115, 2, 2, 1142, 1143, 7, 81, 2, 2, 1143, 1145, 7, 115, 2, 2,
	1144, 1140, 3, 2, 2, 2, 1144, 1142, 3, 2, 2, 2, 1145, 235, 3, 2, 2, 2,
	1146, 1147, 5, 314, 158, 2, 1147, 1148, 7, 50, 2, 2, 1148, 1149, 5, 314,
	158, 2, 1149, 1150, 5, 238, 120, 2, 1150, 1151, 7, 13, 2, 2, 1151, 237,
	3, 2, 2, 2, 1152, 1155, 5, 26, 14, 2, 1153, 1155, 7, 11, 2, 2, 1154, 1152,
	3, 2, 2, 2, 1154, 1153, 3, 2, 2, 2, 1155, 239, 3, 2, 2, 2, 1156, 1157,
	7, 95, 2, 2, 1157, 1158, 5, 24, 13, 2, 1158, 1159, 7, 11, 2, 2, 1159, 241,
	3, 2, 2, 2, 1160, 1161, 7, 94, 2, 2, 1161, 1162, 5, 24, 13, 2, 1162, 1163,
	7, 11, 2, 2, 1163, 243, 3, 2, 2, 2, 1164, 1165, 7, 53, 2, 2, 1165, 1166,
	7, 96, 2, 2, 1166, 1167, 5, 314, 158, 2, 1167, 1168, 5, 226, 114, 2, 1168,
	1169, 5, 246, 124, 2, 1169, 245, 3, 2, 2, 2, 1170, 1171, 5, 314, 158, 2,
	1171, 1182, 5, 106, 54, 2, 1172, 1183, 5, 222, 112, 2, 1173, 1174, 7, 15,
	2, 2, 1174, 1175, 5, 314, 158, 2, 1175, 1176, 5, 106, 54, 2, 1176, 1178,
	3, 2, 2, 2, 1177, 1173, 3, 2, 2, 2, 1178, 1181, 3, 2, 2, 2, 1179, 1177,
	3, 2, 2, 2, 1179, 1180, 3, 2, 2, 2, 1180, 1183, 3, 2, 2, 2, 1181, 1179,
	3, 2, 2, 2, 1182, 1172, 3, 2, 2, 2, 1182, 1179, 3, 2, 2, 2, 1183, 247,
	3, 2, 2, 2, 1184, 1185, 7, 96, 2, 2, 1185, 1186, 5, 314, 158, 2, 1186,
	1187, 5, 226, 114, 2, 1187, 1188, 5, 250, 126, 2, 1188, 249, 3, 2, 2, 2,
	1189, 1190, 5, 314, 158, 2, 1190, 1201, 5, 106, 54, 2, 1191, 1202, 5, 252,
	127, 2, 1192, 1193, 7, 15, 2, 2, 1193, 1194, 5, 314, 158, 2, 1194, 1195,
	5, 106, 54, 2, 1195, 1197, 3, 2, 2, 2, 1196, 1192, 3, 2, 2, 2, 1197, 1200,
	3, 2, 2, 2, 1198, 1196, 3, 2, 2, 2, 1198, 1199, 3, 2, 2, 2, 1199, 1202,
	3, 2, 2, 2, 1200, 1198, 3, 2, 2, 2, 1201, 1191, 3, 2, 2, 2, 1201, 1198,
	3, 2, 2, 2, 1202, 251, 3, 2, 2, 2, 1203, 1205, 5, 254, 128, 2, 1204, 1206,
	5, 256, 129, 2, 1205, 1204, 3, 2, 2, 2, 1205, 1206, 3, 2, 2, 2, 1206, 1209,
	3, 2, 2, 2, 1207, 1209, 5, 256, 129, 2, 1208, 1203, 3, 2, 2, 2, 1208, 1207,
	3, 2, 2, 2, 1209, 253, 3, 2, 2, 2, 1210, 1211, 7, 71, 2, 2, 1211, 1212,
	5, 258, 130, 2, 1212, 255, 3, 2, 2, 2, 1213, 1214, 7, 38, 2, 2, 1214, 1215,
	5, 258, 130, 2, 1215, 257, 3, 2, 2, 2, 1216, 1217, 7, 18, 2, 2, 1217, 1222,
	5, 24, 13, 2, 1218, 1219, 7, 15, 2, 2, 1219, 1221, 5, 24, 13, 2, 1220,
	1218, 3, 2, 2, 2, 1221, 1224, 3, 2, 2, 2, 1222, 1220, 3, 2, 2, 2, 1222,
	1223, 3, 2, 2, 2, 1223, 1225, 3, 2, 2, 2, 1224, 1222, 3, 2, 2, 2, 1225,
	1226, 7, 19, 2, 2, 1226, 259, 3, 2, 2, 2, 1227, 1230, 5, 264, 133, 2, 1228,
	1230, 5, 262, 132, 2, 1229, 1227, 3, 2, 2, 2, 1229, 1228, 3, 2, 2, 2, 1230,
	261, 3, 2, 2, 2, 1231, 1232, 7, 100, 2, 2, 1232, 1233, 7, 115, 2, 2, 1233,
	263, 3, 2, 2, 2, 1234, 1235, 5, 266, 134, 2, 1235, 1236, 7, 16, 2, 2, 1236,
	1237, 5, 272, 137, 2, 1237, 1238, 7, 17, 2, 2, 1238, 265, 3, 2, 2, 2, 1239,
	1240, 7, 100, 2, 2, 1240, 1242, 5, 322, 162, 2, 1241, 1243, 5, 270, 136,
	2, 1242, 1241, 3, 2, 2, 2, 1242, 1243, 3, 2, 2, 2, 1243, 1245, 3, 2, 2,
	2, 1244, 1246, 5, 268, 135, 2, 1245, 1244, 3, 2, 2, 2, 1245, 1246, 3, 2,
	2, 2, 1246, 267, 3, 2, 2, 2, 1247, 1248, 7, 75, 2, 2, 1248, 1253, 5, 24,
	13, 2, 1249, 1250, 7, 15, 2, 2, 1250, 1252, 5, 24, 13, 2, 1251, 1249, 3,
	2, 2, 2, 1252, 1255, 3, 2, 2, 2, 1253, 1251, 3, 2, 2, 2, 1253, 1254, 3,
	2, 2, 2, 1254, 269, 3, 2, 2, 2, 1255, 1253, 3, 2, 2, 2, 1256, 1257, 7,
	14, 2, 2, 1257, 1258, 5, 24, 13, 2, 1258, 271, 3, 2, 2, 2, 1259, 1261,
	5, 274, 138, 2, 1260, 1259, 3, 2, 2, 2, 1261, 1264, 3, 2, 2, 2, 1262, 1260,
	3, 2, 2, 2, 1262, 1263, 3, 2, 2, 2, 1263, 273, 3, 2, 2, 2, 1264, 1262,
	3, 2, 2, 2, 1265, 1284, 5, 314, 158, 2, 1266, 1267, 5, 276, 139, 2, 1267,
	1268, 7, 13, 2, 2, 1268, 1285, 3, 2, 2, 2, 1269, 1270, 5, 280, 141, 2,
	1270, 1271, 7, 13, 2, 2, 1271, 1285, 3, 2, 2, 2, 1272, 1273, 5, 282, 142,
	2, 1273, 1274, 7, 13, 2, 2, 1274, 1285, 3, 2, 2, 2, 1275, 1276, 5, 284,
	143, 2, 1276, 1277, 7, 13, 2, 2, 1277, 1285, 3, 2, 2, 2, 1278, 1279, 5,
	286, 144, 2, 1279, 1280, 7, 13, 2, 2, 1280, 1285, 3, 2, 2, 2, 1281, 1282,
	5, 206, 104, 2, 1282, 1283, 7, 13, 2, 2, 1283, 1285, 3, 2, 2, 2, 1284,
	1266, 3, 2, 2, 2, 1284, 1269, 3, 2, 2, 2, 1284, 1272, 3, 2, 2, 2, 1284,
	1275, 3, 2, 2, 2, 1284, 1278, 3, 2, 2, 2, 1284, 1281, 3, 2, 2, 2, 1285,
	275, 3, 2, 2, 2, 1286, 1287, 7, 91, 2, 2, 1287, 1288, 5, 278, 140, 2, 1288,
	1289, 7, 115, 2, 2, 1289, 277, 3, 2, 2, 2, 1290, 1293, 5, 314, 158, 2,
	1291, 1294, 5, 26, 14, 2, 1292, 1294, 7, 77, 2, 2, 1293, 1291, 3, 2, 2,
	2, 1293, 1292, 3, 2, 2, 2, 1294, 279, 3, 2, 2, 2, 1295, 1297, 7, 45, 2,
	2, 1296, 1298, 7, 88, 2, 2, 1297, 1296, 3, 2, 2, 2, 1297, 1298, 3, 2, 2,
	2, 1298, 1299, 3, 2, 2, 2, 1299, 1300, 5, 278, 140, 2, 1300, 1301, 7, 115,
	2, 2, 1301, 281, 3, 2, 2, 2, 1302, 1303, 7, 40, 2, 2, 1303, 1304, 5, 24,
	13, 2, 1304, 1305, 7, 115, 2, 2, 1305, 283, 3, 2, 2, 2, 1306, 1307, 7,
	43, 2, 2, 1307, 1308, 5, 24, 13, 2, 1308, 1309, 7, 115, 2, 2, 1309, 285,
	3, 2, 2, 2, 1310, 1311, 7, 92, 2, 2, 1311, 1312, 5, 24, 13, 2, 1312, 1313,
	7, 115, 2, 2, 1313, 287, 3, 2, 2, 2, 1314, 1315, 5, 290, 146, 2, 1315,
	1316, 5, 296, 149, 2, 1316, 289, 3, 2, 2, 2, 1317, 1318, 7, 68, 2, 2, 1318,
	1320, 5, 322, 162, 2, 1319, 1321, 5, 292, 147, 2, 1320, 1319, 3, 2, 2,
	2, 1320, 1321, 3, 2, 2, 2, 1321, 1323, 3, 2, 2, 2, 1322, 1324, 5, 268,
	135, 2, 1323, 1322, 3, 2, 2, 2, 1323, 1324, 3, 2, 2, 2, 1324, 1325, 3,
	2, 2, 2, 1325, 1326, 7, 98, 2, 2, 1326, 1328, 5, 24, 13, 2, 1327, 1329,
	5, 294, 148, 2, 1328, 1327, 3, 2, 2, 2, 1328, 1329, 3, 2, 2, 2, 1329, 291,
	3, 2, 2, 2, 1330, 1331, 7, 14, 2, 2, 1331, 1332, 5, 24, 13, 2, 1332, 293,
	3, 2, 2, 2, 1333, 1334, 7, 46, 2, 2, 1334, 1335, 5, 24, 13, 2, 1335, 295,
	3, 2, 2, 2, 1336, 1340, 7, 16, 2, 2, 1337, 1339, 5, 298, 150, 2, 1338,
	1337, 3, 2, 2, 2, 1339, 1342, 3, 2, 2, 2, 1340, 1338, 3, 2, 2, 2, 1340,
	1341, 3, 2, 2, 2, 1341, 1343, 3, 2, 2, 2, 1342, 1340, 3, 2, 2, 2, 1343,
	1344, 7, 17, 2, 2, 1344, 297, 3, 2, 2, 2, 1345, 1354, 5, 18, 10, 2, 1346,
	1349, 5, 314, 158, 2, 1347, 1350, 5, 300, 151, 2, 1348, 1350, 5, 302, 152,
	2, 1349, 1347, 3, 2, 2, 2, 1349, 1348, 3, 2, 2, 2, 1350, 1351, 3, 2, 2,
	2, 1351, 1352, 7, 13, 2, 2, 1352, 1354, 3, 2, 2, 2, 1353, 1345, 3, 2, 2,
	2, 1353, 1346, 3, 2, 2, 2, 1354, 299, 3, 2, 2, 2, 1355, 1356, 7, 69, 2,
	2, 1356, 1357, 5, 322, 162, 2, 1357, 1359, 7, 18, 2, 2, 1358, 1360, 5,
	50, 26, 2, 1359, 1358, 3, 2, 2, 2, 1359, 1360, 3, 2, 2, 2, 1360, 1361,
	3, 2, 2, 2, 1361, 1363, 7, 19, 2, 2, 1362, 1364, 5, 222, 112, 2, 1363,
	1362, 3, 2, 2, 2, 1363, 1364, 3, 2, 2, 2, 1364, 301, 3, 2, 2, 2, 1365,
	1366, 7, 54, 2, 2, 1366, 1367, 5, 322, 162, 2, 1367, 1369, 7, 18, 2, 2,
	1368, 1370, 5, 50, 26, 2, 1369, 1368, 3, 2, 2, 2, 1369, 1370, 3, 2, 2,
	2, 1370, 1371, 3, 2, 2, 2, 1371, 1373, 7, 19, 2, 2, 1372, 1374, 5, 222,
	112, 2, 1373, 1372, 3, 2, 2, 2, 1373, 1374, 3, 2, 2, 2, 1374, 303, 3, 2,
	2, 2, 1375, 1379, 5, 310, 156, 2, 1376, 1379, 5, 308, 155, 2, 1377, 1379,
	5, 306, 154, 2, 1378, 1375, 3, 2, 2, 2, 1378, 1376, 3, 2, 2, 2, 1378, 1377,
	3, 2, 2, 2, 1379, 305, 3, 2, 2, 2, 1380, 1382, 7, 89, 2, 2, 1381, 1380,
	3, 2, 2, 2, 1381, 1382, 3, 2, 2, 2, 1382, 1383, 3, 2, 2, 2, 1383, 1384,
	7, 58, 2, 2, 1384, 1385, 7, 115, 2, 2, 1385, 307, 3, 2, 2, 2, 1386, 1387,
	7, 89, 2, 2, 1387, 1388, 7, 58, 2, 2, 1388, 1389, 5, 322, 162, 2, 1389,
	1390, 5, 40, 21, 2, 1390, 1394, 7, 16, 2, 2, 1391, 1393, 5, 18, 10, 2,
	1392, 1391, 3, 2, 2, 2, 1393, 1396, 3, 2, 2, 2, 1394, 1392, 3, 2, 2, 2,
	1394, 1395, 3, 2, 2, 2, 1395, 1397, 3, 2, 2, 2, 1396, 1394, 3, 2, 2, 2,
	1397, 1398, 7, 17, 2, 2, 1398, 309, 3, 2, 2, 2, 1399, 1400, 5, 312, 157,
	2, 1400, 1404, 7, 16, 2, 2, 1401, 1403, 5, 44, 23, 2, 1402, 1401, 3, 2,
	2, 2, 1403, 1406, 3, 2, 2, 2, 1404, 1402, 3, 2, 2, 2, 1404, 1405, 3, 2,
	2, 2, 1405, 1407, 3, 2, 2, 2, 1406, 1404, 3, 2, 2, 2, 1407, 1408, 7, 17,
	2, 2, 1408, 311, 3, 2, 2, 2, 1409, 1411, 7, 47, 2, 2, 1410, 1409, 3, 2,
	2, 2, 1410, 1411, 3, 2, 2, 2, 1411, 1412, 3, 2, 2, 2, 1412, 1413, 7, 58,
	2, 2, 1413, 1414, 5, 322, 162, 2, 1414, 1415, 5, 40, 21, 2, 1415, 313,
	3, 2, 2, 2, 1416, 1418, 5, 316, 159, 2, 1417, 1416, 3, 2, 2, 2, 1418, 1421,
	3, 2, 2, 2, 1419, 1417, 3, 2, 2, 2, 1419, 1420, 3, 2, 2, 2, 1420, 315,
	3, 2, 2, 2, 1421, 1419, 3, 2, 2, 2, 1422, 1423, 7, 37, 2, 2, 1423, 1428,
	5, 26, 14, 2, 1424, 1425, 7, 18, 2, 2, 1425, 1426, 5, 318, 160, 2, 1426,
	1427, 7, 19, 2, 2, 1427, 1429, 3, 2, 2, 2, 1428, 1424, 3, 2, 2, 2, 1428,
	1429, 3, 2, 2, 2, 1429, 317, 3, 2, 2, 2, 1430, 1440, 5, 60, 31, 2, 1431,
	1436, 5, 320, 161, 2, 1432, 1433, 7, 15, 2, 2, 1433, 1435, 5, 320, 161,
	2, 1434, 1432, 3, 2, 2, 2, 1435, 1438, 3, 2, 2, 2, 1436, 1434, 3, 2, 2,
	2, 1436, 1437, 3, 2, 2, 2, 1437, 1440, 3, 2, 2, 2, 1438, 1436, 3, 2, 2,
	2, 1439, 1430, 3, 2, 2, 2, 1439, 1431, 3, 2, 2, 2, 1440, 319, 3, 2, 2,
	2, 1441, 1442, 7, 115, 2, 2, 1442, 1443, 7, 32, 2, 2, 1443, 1444, 5, 60,
	31, 2, 1444, 321, 3, 2, 2, 2, 1445, 1446, 5, 314, 158, 2, 1446, 1447, 7,
	115, 2, 2, 1447, 323, 3, 2, 2, 2, 127, 327, 333, 372, 380, 387, 395, 401,
	406, 411, 436, 444, 453, 460, 468, 471, 488, 498, 504, 512, 519, 522, 530,
	533, 540, 547, 558, 562, 571, 600, 609, 617, 625, 633, 641, 649, 656, 666,
	686, 693, 698, 703, 714, 722, 729, 736, 744, 750, 760, 764, 770, 781, 787,
	794, 799, 805, 821, 831, 847, 849, 856, 867, 875, 881, 889, 904, 911, 920,
	946, 951, 956, 968, 982, 995, 1004, 1015, 1024, 1031, 1037, 1045, 1053,
	1059, 1065, 1068, 1075, 1083, 1086, 1106, 1118, 1127, 1144, 1154, 1179,
	1182, 1198, 1201, 1205, 1208, 1222, 1229, 1242, 1245, 1253, 1262, 1284,
	1293, 1297, 1320, 1323, 1328, 1340, 1349, 1353, 1359, 1363, 1369, 1373,
	1378, 1381, 1394, 1404, 1410, 1419, 1428, 1436, 1439,
}
var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "';'", "':'", "','", "'{'",
	"'}'", "'('", "')'", "'['", "']'", "'~'", "'/'", "'<'", "'>'", "'*'", "'+'",
	"'-'", "'^'", "'&'", "'|'", "'='", "'%'", "'::'", "'>>'", "'<<'", "'@'",
	"'setraises'", "'out'", "'emits'", "'string'", "'switch'", "'publishes'",
	"'typedef'", "'uses'", "'primarykey'", "'custom'", "'octet'", "'sequence'",
	"'import'", "'struct'", "'native'", "'readonly'", "'finder'", "'raises'",
	"'void'", "'private'", "'eventtype'", "'wchar'", "'in'", "'default'", "'public'",
	"'short'", "'long'", "'enum'", "'wstring'", "'context'", "'home'", "'factory'",
	"'exception'", "'getraises'", "'const'", "'ValueBase'", "'valuetype'",
	"'supports'", "'module'", "'Object'", "'truncatable'", "'unsigned'", "'fixed'",
	"'union'", "'oneway'", "'any'", "'char'", "'case'", "'float'", "'boolean'",
	"'multiple'", "'abstract'", "'inout'", "'provides'", "'consumes'", "'double'",
	"'typeprefix'", "'typeid'", "'attribute'", "'local'", "'manages'", "'interface'",
	"'component'", "'set'", "'map'", "'bitfield'", "'bitset'", "'bitmask'",
	"'int8'", "'uint8'", "'int16'", "'uint16'", "'int32'", "'uint32'", "'int64'",
	"'uint64'", "'@annotation'",
}
var symbolicNames = []string{
	"", "INTEGER_LITERAL", "OCTAL_LITERAL", "HEX_LITERAL", "FLOATING_PT_LITERAL",
	"FIXED_PT_LITERAL", "WIDE_CHARACTER_LITERAL", "CHARACTER_LITERAL", "WIDE_STRING_LITERAL",
	"STRING_LITERAL", "BOOLEAN_LITERAL", "SEMICOLON", "COLON", "COMMA", "LEFT_BRACE",
	"RIGHT_BRACE", "LEFT_BRACKET", "RIGHT_BRACKET", "LEFT_SQUARE_BRACKET",
	"RIGHT_SQUARE_BRACKET", "TILDE", "SLASH", "LEFT_ANG_BRACKET", "RIGHT_ANG_BRACKET",
	"STAR", "PLUS", "MINUS", "CARET", "AMPERSAND", "PIPE", "EQUAL", "PERCENT",
	"DOUBLE_COLON", "RIGHT_SHIFT", "LEFT_SHIFT", "AT", "KW_SETRAISES", "KW_OUT",
	"KW_EMITS", "KW_STRING", "KW_SWITCH", "KW_PUBLISHES", "KW_TYPEDEF", "KW_USES",
	"KW_PRIMARYKEY", "KW_CUSTOM", "KW_OCTET", "KW_SEQUENCE", "KW_IMPORT", "KW_STRUCT",
	"KW_NATIVE", "KW_READONLY", "KW_FINDER", "KW_RAISES", "KW_VOID", "KW_PRIVATE",
	"KW_EVENTTYPE", "KW_WCHAR", "KW_IN", "KW_DEFAULT", "KW_PUBLIC", "KW_SHORT",
	"KW_LONG", "KW_ENUM", "KW_WSTRING", "KW_CONTEXT", "KW_HOME", "KW_FACTORY",
	"KW_EXCEPTION", "KW_GETRAISES", "KW_CONST", "KW_VALUEBASE", "KW_VALUETYPE",
	"KW_SUPPORTS", "KW_MODULE", "KW_OBJECT", "KW_TRUNCATABLE", "KW_UNSIGNED",
	"KW_FIXED", "KW_UNION", "KW_ONEWAY", "KW_ANY", "KW_CHAR", "KW_CASE", "KW_FLOAT",
	"KW_BOOLEAN", "KW_MULTIPLE", "KW_ABSTRACT", "KW_INOUT", "KW_PROVIDES",
	"KW_CONSUMES", "KW_DOUBLE", "KW_TYPEPREFIX", "KW_TYPEID", "KW_ATTRIBUTE",
	"KW_LOCAL", "KW_MANAGES", "KW_INTERFACE", "KW_COMPONENT", "KW_SET", "KW_MAP",
	"KW_BITFIELD", "KW_BITSET", "KW_BITMASK", "KW_INT8", "KW_UINT8", "KW_INT16",
	"KW_UINT16", "KW_INT32", "KW_UINT32", "KW_INT64", "KW_UINT64", "KW_AT_ANNOTATION",
	"ID", "WS", "COMMENT", "LINE_COMMENT",
}

var ruleNames = []string{
	"specification", "definition", "module", "interface_or_forward_decl", "interface_decl",
	"forward_decl", "interface_header", "interface_body", "export_", "interface_inheritance_spec",
	"interface_name", "a_scoped_name", "scoped_name", "value", "value_forward_decl",
	"value_box_decl", "value_abs_decl", "value_decl", "value_header", "value_inheritance_spec",
	"value_name", "value_element", "state_member", "init_decl", "init_param_decls",
	"init_param_decl", "init_param_attribute", "const_decl", "const_type",
	"const_exp", "or_expr", "xor_expr", "and_expr", "shift_expr", "add_expr",
	"mult_expr", "unary_expr", "unary_operator", "primary_expr", "literal",
	"positive_int_const", "type_decl", "type_declarator", "type_spec", "simple_type_spec",
	"bitfield_type_spec", "base_type_spec", "template_type_spec", "constr_type_spec",
	"simple_declarators", "declarators", "declarator", "simple_declarator",
	"complex_declarator", "floating_pt_type", "integer_type", "signed_int",
	"signed_tiny_int", "signed_short_int", "signed_long_int", "signed_longlong_int",
	"unsigned_int", "unsigned_tiny_int", "unsigned_short_int", "unsigned_long_int",
	"unsigned_longlong_int", "char_type", "wide_char_type", "boolean_type",
	"octet_type", "any_type", "object_type", "annotation_decl", "annotation_def",
	"annotation_header", "annotation_inheritance_spec", "annotation_body",
	"annotation_member", "annotation_forward_dcl", "bitset_type", "bitfield",
	"bitfield_spec", "bitmask_type", "bit_values", "struct_type", "member_list",
	"member", "union_type", "switch_type_spec", "switch_body", "case_stmt",
	"case_label", "element_spec", "enum_type", "enumerator", "sequence_type",
	"set_type", "map_type", "string_type", "wide_string_type", "array_declarator",
	"fixed_array_size", "attr_decl", "except_decl", "op_decl", "op_attribute",
	"op_type_spec", "parameter_decls", "param_decl", "param_attribute", "raises_expr",
	"context_expr", "param_type_spec", "fixed_pt_type", "fixed_pt_const_type",
	"value_base_type", "constr_forward_decl", "import_decl", "imported_scope",
	"type_id_decl", "type_prefix_decl", "readonly_attr_spec", "readonly_attr_declarator",
	"attr_spec", "attr_declarator", "attr_raises_expr", "get_excep_expr", "set_excep_expr",
	"exception_list", "component", "component_forward_decl", "component_decl",
	"component_header", "supported_interface_spec", "component_inheritance_spec",
	"component_body", "component_export", "provides_decl", "interface_type",
	"uses_decl", "emits_decl", "publishes_decl", "consumes_decl", "home_decl",
	"home_header", "home_inheritance_spec", "primary_key_spec", "home_body",
	"home_export", "factory_decl", "finder_decl", "event", "event_forward_decl",
	"event_abs_decl", "event_decl", "event_header", "annapps", "annotation_appl",
	"annotation_appl_params", "annotation_appl_param", "identifier",
}

type IDLParser struct {
	*antlr.BaseParser
}

// NewIDLParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *IDLParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewIDLParser(input antlr.TokenStream) *IDLParser {
	this := new(IDLParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "IDL.g4"

	return this
}

// IDLParser tokens.
const (
	IDLParserEOF                    = antlr.TokenEOF
	IDLParserINTEGER_LITERAL        = 1
	IDLParserOCTAL_LITERAL          = 2
	IDLParserHEX_LITERAL            = 3
	IDLParserFLOATING_PT_LITERAL    = 4
	IDLParserFIXED_PT_LITERAL       = 5
	IDLParserWIDE_CHARACTER_LITERAL = 6
	IDLParserCHARACTER_LITERAL      = 7
	IDLParserWIDE_STRING_LITERAL    = 8
	IDLParserSTRING_LITERAL         = 9
	IDLParserBOOLEAN_LITERAL        = 10
	IDLParserSEMICOLON              = 11
	IDLParserCOLON                  = 12
	IDLParserCOMMA                  = 13
	IDLParserLEFT_BRACE             = 14
	IDLParserRIGHT_BRACE            = 15
	IDLParserLEFT_BRACKET           = 16
	IDLParserRIGHT_BRACKET          = 17
	IDLParserLEFT_SQUARE_BRACKET    = 18
	IDLParserRIGHT_SQUARE_BRACKET   = 19
	IDLParserTILDE                  = 20
	IDLParserSLASH                  = 21
	IDLParserLEFT_ANG_BRACKET       = 22
	IDLParserRIGHT_ANG_BRACKET      = 23
	IDLParserSTAR                   = 24
	IDLParserPLUS                   = 25
	IDLParserMINUS                  = 26
	IDLParserCARET                  = 27
	IDLParserAMPERSAND              = 28
	IDLParserPIPE                   = 29
	IDLParserEQUAL                  = 30
	IDLParserPERCENT                = 31
	IDLParserDOUBLE_COLON           = 32
	IDLParserRIGHT_SHIFT            = 33
	IDLParserLEFT_SHIFT             = 34
	IDLParserAT                     = 35
	IDLParserKW_SETRAISES           = 36
	IDLParserKW_OUT                 = 37
	IDLParserKW_EMITS               = 38
	IDLParserKW_STRING              = 39
	IDLParserKW_SWITCH              = 40
	IDLParserKW_PUBLISHES           = 41
	IDLParserKW_TYPEDEF             = 42
	IDLParserKW_USES                = 43
	IDLParserKW_PRIMARYKEY          = 44
	IDLParserKW_CUSTOM              = 45
	IDLParserKW_OCTET               = 46
	IDLParserKW_SEQUENCE            = 47
	IDLParserKW_IMPORT              = 48
	IDLParserKW_STRUCT              = 49
	IDLParserKW_NATIVE              = 50
	IDLParserKW_READONLY            = 51
	IDLParserKW_FINDER              = 52
	IDLParserKW_RAISES              = 53
	IDLParserKW_VOID                = 54
	IDLParserKW_PRIVATE             = 55
	IDLParserKW_EVENTTYPE           = 56
	IDLParserKW_WCHAR               = 57
	IDLParserKW_IN                  = 58
	IDLParserKW_DEFAULT             = 59
	IDLParserKW_PUBLIC              = 60
	IDLParserKW_SHORT               = 61
	IDLParserKW_LONG                = 62
	IDLParserKW_ENUM                = 63
	IDLParserKW_WSTRING             = 64
	IDLParserKW_CONTEXT             = 65
	IDLParserKW_HOME                = 66
	IDLParserKW_FACTORY             = 67
	IDLParserKW_EXCEPTION           = 68
	IDLParserKW_GETRAISES           = 69
	IDLParserKW_CONST               = 70
	IDLParserKW_VALUEBASE           = 71
	IDLParserKW_VALUETYPE           = 72
	IDLParserKW_SUPPORTS            = 73
	IDLParserKW_MODULE              = 74
	IDLParserKW_OBJECT              = 75
	IDLParserKW_TRUNCATABLE         = 76
	IDLParserKW_UNSIGNED            = 77
	IDLParserKW_FIXED               = 78
	IDLParserKW_UNION               = 79
	IDLParserKW_ONEWAY              = 80
	IDLParserKW_ANY                 = 81
	IDLParserKW_CHAR                = 82
	IDLParserKW_CASE                = 83
	IDLParserKW_FLOAT               = 84
	IDLParserKW_BOOLEAN             = 85
	IDLParserKW_MULTIPLE            = 86
	IDLParserKW_ABSTRACT            = 87
	IDLParserKW_INOUT               = 88
	IDLParserKW_PROVIDES            = 89
	IDLParserKW_CONSUMES            = 90
	IDLParserKW_DOUBLE              = 91
	IDLParserKW_TYPEPREFIX          = 92
	IDLParserKW_TYPEID              = 93
	IDLParserKW_ATTRIBUTE           = 94
	IDLParserKW_LOCAL               = 95
	IDLParserKW_MANAGES             = 96
	IDLParserKW_INTERFACE           = 97
	IDLParserKW_COMPONENT           = 98
	IDLParserKW_SET                 = 99
	IDLParserKW_MAP                 = 100
	IDLParserKW_BITFIELD            = 101
	IDLParserKW_BITSET              = 102
	IDLParserKW_BITMASK             = 103
	IDLParserKW_INT8                = 104
	IDLParserKW_UINT8               = 105
	IDLParserKW_INT16               = 106
	IDLParserKW_UINT16              = 107
	IDLParserKW_INT32               = 108
	IDLParserKW_UINT32              = 109
	IDLParserKW_INT64               = 110
	IDLParserKW_UINT64              = 111
	IDLParserKW_AT_ANNOTATION       = 112
	IDLParserID                     = 113
	IDLParserWS                     = 114
	IDLParserCOMMENT                = 115
	IDLParserLINE_COMMENT           = 116
)

// IDLParser rules.
const (
	IDLParserRULE_specification               = 0
	IDLParserRULE_definition                  = 1
	IDLParserRULE_module                      = 2
	IDLParserRULE_interface_or_forward_decl   = 3
	IDLParserRULE_interface_decl              = 4
	IDLParserRULE_forward_decl                = 5
	IDLParserRULE_interface_header            = 6
	IDLParserRULE_interface_body              = 7
	IDLParserRULE_export_                     = 8
	IDLParserRULE_interface_inheritance_spec  = 9
	IDLParserRULE_interface_name              = 10
	IDLParserRULE_a_scoped_name               = 11
	IDLParserRULE_scoped_name                 = 12
	IDLParserRULE_value                       = 13
	IDLParserRULE_value_forward_decl          = 14
	IDLParserRULE_value_box_decl              = 15
	IDLParserRULE_value_abs_decl              = 16
	IDLParserRULE_value_decl                  = 17
	IDLParserRULE_value_header                = 18
	IDLParserRULE_value_inheritance_spec      = 19
	IDLParserRULE_value_name                  = 20
	IDLParserRULE_value_element               = 21
	IDLParserRULE_state_member                = 22
	IDLParserRULE_init_decl                   = 23
	IDLParserRULE_init_param_decls            = 24
	IDLParserRULE_init_param_decl             = 25
	IDLParserRULE_init_param_attribute        = 26
	IDLParserRULE_const_decl                  = 27
	IDLParserRULE_const_type                  = 28
	IDLParserRULE_const_exp                   = 29
	IDLParserRULE_or_expr                     = 30
	IDLParserRULE_xor_expr                    = 31
	IDLParserRULE_and_expr                    = 32
	IDLParserRULE_shift_expr                  = 33
	IDLParserRULE_add_expr                    = 34
	IDLParserRULE_mult_expr                   = 35
	IDLParserRULE_unary_expr                  = 36
	IDLParserRULE_unary_operator              = 37
	IDLParserRULE_primary_expr                = 38
	IDLParserRULE_literal                     = 39
	IDLParserRULE_positive_int_const          = 40
	IDLParserRULE_type_decl                   = 41
	IDLParserRULE_type_declarator             = 42
	IDLParserRULE_type_spec                   = 43
	IDLParserRULE_simple_type_spec            = 44
	IDLParserRULE_bitfield_type_spec          = 45
	IDLParserRULE_base_type_spec              = 46
	IDLParserRULE_template_type_spec          = 47
	IDLParserRULE_constr_type_spec            = 48
	IDLParserRULE_simple_declarators          = 49
	IDLParserRULE_declarators                 = 50
	IDLParserRULE_declarator                  = 51
	IDLParserRULE_simple_declarator           = 52
	IDLParserRULE_complex_declarator          = 53
	IDLParserRULE_floating_pt_type            = 54
	IDLParserRULE_integer_type                = 55
	IDLParserRULE_signed_int                  = 56
	IDLParserRULE_signed_tiny_int             = 57
	IDLParserRULE_signed_short_int            = 58
	IDLParserRULE_signed_long_int             = 59
	IDLParserRULE_signed_longlong_int         = 60
	IDLParserRULE_unsigned_int                = 61
	IDLParserRULE_unsigned_tiny_int           = 62
	IDLParserRULE_unsigned_short_int          = 63
	IDLParserRULE_unsigned_long_int           = 64
	IDLParserRULE_unsigned_longlong_int       = 65
	IDLParserRULE_char_type                   = 66
	IDLParserRULE_wide_char_type              = 67
	IDLParserRULE_boolean_type                = 68
	IDLParserRULE_octet_type                  = 69
	IDLParserRULE_any_type                    = 70
	IDLParserRULE_object_type                 = 71
	IDLParserRULE_annotation_decl             = 72
	IDLParserRULE_annotation_def              = 73
	IDLParserRULE_annotation_header           = 74
	IDLParserRULE_annotation_inheritance_spec = 75
	IDLParserRULE_annotation_body             = 76
	IDLParserRULE_annotation_member           = 77
	IDLParserRULE_annotation_forward_dcl      = 78
	IDLParserRULE_bitset_type                 = 79
	IDLParserRULE_bitfield                    = 80
	IDLParserRULE_bitfield_spec               = 81
	IDLParserRULE_bitmask_type                = 82
	IDLParserRULE_bit_values                  = 83
	IDLParserRULE_struct_type                 = 84
	IDLParserRULE_member_list                 = 85
	IDLParserRULE_member                      = 86
	IDLParserRULE_union_type                  = 87
	IDLParserRULE_switch_type_spec            = 88
	IDLParserRULE_switch_body                 = 89
	IDLParserRULE_case_stmt                   = 90
	IDLParserRULE_case_label                  = 91
	IDLParserRULE_element_spec                = 92
	IDLParserRULE_enum_type                   = 93
	IDLParserRULE_enumerator                  = 94
	IDLParserRULE_sequence_type               = 95
	IDLParserRULE_set_type                    = 96
	IDLParserRULE_map_type                    = 97
	IDLParserRULE_string_type                 = 98
	IDLParserRULE_wide_string_type            = 99
	IDLParserRULE_array_declarator            = 100
	IDLParserRULE_fixed_array_size            = 101
	IDLParserRULE_attr_decl                   = 102
	IDLParserRULE_except_decl                 = 103
	IDLParserRULE_op_decl                     = 104
	IDLParserRULE_op_attribute                = 105
	IDLParserRULE_op_type_spec                = 106
	IDLParserRULE_parameter_decls             = 107
	IDLParserRULE_param_decl                  = 108
	IDLParserRULE_param_attribute             = 109
	IDLParserRULE_raises_expr                 = 110
	IDLParserRULE_context_expr                = 111
	IDLParserRULE_param_type_spec             = 112
	IDLParserRULE_fixed_pt_type               = 113
	IDLParserRULE_fixed_pt_const_type         = 114
	IDLParserRULE_value_base_type             = 115
	IDLParserRULE_constr_forward_decl         = 116
	IDLParserRULE_import_decl                 = 117
	IDLParserRULE_imported_scope              = 118
	IDLParserRULE_type_id_decl                = 119
	IDLParserRULE_type_prefix_decl            = 120
	IDLParserRULE_readonly_attr_spec          = 121
	IDLParserRULE_readonly_attr_declarator    = 122
	IDLParserRULE_attr_spec                   = 123
	IDLParserRULE_attr_declarator             = 124
	IDLParserRULE_attr_raises_expr            = 125
	IDLParserRULE_get_excep_expr              = 126
	IDLParserRULE_set_excep_expr              = 127
	IDLParserRULE_exception_list              = 128
	IDLParserRULE_component                   = 129
	IDLParserRULE_component_forward_decl      = 130
	IDLParserRULE_component_decl              = 131
	IDLParserRULE_component_header            = 132
	IDLParserRULE_supported_interface_spec    = 133
	IDLParserRULE_component_inheritance_spec  = 134
	IDLParserRULE_component_body              = 135
	IDLParserRULE_component_export            = 136
	IDLParserRULE_provides_decl               = 137
	IDLParserRULE_interface_type              = 138
	IDLParserRULE_uses_decl                   = 139
	IDLParserRULE_emits_decl                  = 140
	IDLParserRULE_publishes_decl              = 141
	IDLParserRULE_consumes_decl               = 142
	IDLParserRULE_home_decl                   = 143
	IDLParserRULE_home_header                 = 144
	IDLParserRULE_home_inheritance_spec       = 145
	IDLParserRULE_primary_key_spec            = 146
	IDLParserRULE_home_body                   = 147
	IDLParserRULE_home_export                 = 148
	IDLParserRULE_factory_decl                = 149
	IDLParserRULE_finder_decl                 = 150
	IDLParserRULE_event                       = 151
	IDLParserRULE_event_forward_decl          = 152
	IDLParserRULE_event_abs_decl              = 153
	IDLParserRULE_event_decl                  = 154
	IDLParserRULE_event_header                = 155
	IDLParserRULE_annapps                     = 156
	IDLParserRULE_annotation_appl             = 157
	IDLParserRULE_annotation_appl_params      = 158
	IDLParserRULE_annotation_appl_param       = 159
	IDLParserRULE_identifier                  = 160
)

// ISpecificationContext is an interface to support dynamic dispatch.
type ISpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecificationContext differentiates from other interfaces.
	IsSpecificationContext()
}

type SpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecificationContext() *SpecificationContext {
	var p = new(SpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_specification
	return p
}

func (*SpecificationContext) IsSpecificationContext() {}

func NewSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecificationContext {
	var p = new(SpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_specification

	return p
}

func (s *SpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecificationContext) AllImport_decl() []IImport_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_declContext)(nil)).Elem())
	var tst = make([]IImport_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_declContext)
		}
	}

	return tst
}

func (s *SpecificationContext) Import_decl(i int) IImport_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_declContext)
}

func (s *SpecificationContext) AllDefinition() []IDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefinitionContext)(nil)).Elem())
	var tst = make([]IDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefinitionContext)
		}
	}

	return tst
}

func (s *SpecificationContext) Definition(i int) IDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefinitionContext)
}

func (s *SpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSpecification(s)
	}
}

func (s *SpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSpecification(s)
	}
}

func (p *IDLParser) Specification() (localctx ISpecificationContext) {
	this := p
	_ = this

	localctx = NewSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, IDLParserRULE_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(322)
				p.Import_decl()
			}

		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(IDLParserAT-35))|(1<<(IDLParserKW_TYPEDEF-35))|(1<<(IDLParserKW_CUSTOM-35))|(1<<(IDLParserKW_STRUCT-35))|(1<<(IDLParserKW_NATIVE-35))|(1<<(IDLParserKW_EVENTTYPE-35))|(1<<(IDLParserKW_ENUM-35))|(1<<(IDLParserKW_HOME-35)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(IDLParserKW_EXCEPTION-68))|(1<<(IDLParserKW_CONST-68))|(1<<(IDLParserKW_VALUETYPE-68))|(1<<(IDLParserKW_MODULE-68))|(1<<(IDLParserKW_UNION-68))|(1<<(IDLParserKW_ABSTRACT-68))|(1<<(IDLParserKW_TYPEPREFIX-68))|(1<<(IDLParserKW_TYPEID-68))|(1<<(IDLParserKW_LOCAL-68))|(1<<(IDLParserKW_INTERFACE-68))|(1<<(IDLParserKW_COMPONENT-68)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(IDLParserKW_BITSET-102))|(1<<(IDLParserKW_BITMASK-102))|(1<<(IDLParserKW_AT_ANNOTATION-102)))) != 0) {
		{
			p.SetState(328)
			p.Definition()
		}

		p.SetState(331)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDefinitionContext is an interface to support dynamic dispatch.
type IDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinitionContext differentiates from other interfaces.
	IsDefinitionContext()
}

type DefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionContext() *DefinitionContext {
	var p = new(DefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_definition
	return p
}

func (*DefinitionContext) IsDefinitionContext() {}

func NewDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionContext {
	var p = new(DefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_definition

	return p
}

func (s *DefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *DefinitionContext) Type_decl() IType_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declContext)
}

func (s *DefinitionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *DefinitionContext) Const_decl() IConst_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_declContext)
}

func (s *DefinitionContext) Except_decl() IExcept_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExcept_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExcept_declContext)
}

func (s *DefinitionContext) Interface_or_forward_decl() IInterface_or_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_or_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_or_forward_declContext)
}

func (s *DefinitionContext) Module() IModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleContext)
}

func (s *DefinitionContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *DefinitionContext) Type_id_decl() IType_id_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_id_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_id_declContext)
}

func (s *DefinitionContext) Type_prefix_decl() IType_prefix_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_prefix_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_prefix_declContext)
}

func (s *DefinitionContext) Event() IEventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEventContext)
}

func (s *DefinitionContext) Component() IComponentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentContext)
}

func (s *DefinitionContext) Home_decl() IHome_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHome_declContext)
}

func (s *DefinitionContext) Annotation_decl() IAnnotation_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_declContext)
}

func (s *DefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterDefinition(s)
	}
}

func (s *DefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitDefinition(s)
	}
}

func (p *IDLParser) Definition() (localctx IDefinitionContext) {
	this := p
	_ = this

	localctx = NewDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, IDLParserRULE_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Annapps()
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(334)
			p.Type_decl()
		}
		{
			p.SetState(335)
			p.Match(IDLParserSEMICOLON)
		}

	case 2:
		{
			p.SetState(337)
			p.Const_decl()
		}
		{
			p.SetState(338)
			p.Match(IDLParserSEMICOLON)
		}

	case 3:
		{
			p.SetState(340)
			p.Except_decl()
		}
		{
			p.SetState(341)
			p.Match(IDLParserSEMICOLON)
		}

	case 4:
		{
			p.SetState(343)
			p.Interface_or_forward_decl()
		}
		{
			p.SetState(344)
			p.Match(IDLParserSEMICOLON)
		}

	case 5:
		{
			p.SetState(346)
			p.Module()
		}
		{
			p.SetState(347)
			p.Match(IDLParserSEMICOLON)
		}

	case 6:
		{
			p.SetState(349)
			p.Value()
		}
		{
			p.SetState(350)
			p.Match(IDLParserSEMICOLON)
		}

	case 7:
		{
			p.SetState(352)
			p.Type_id_decl()
		}
		{
			p.SetState(353)
			p.Match(IDLParserSEMICOLON)
		}

	case 8:
		{
			p.SetState(355)
			p.Type_prefix_decl()
		}
		{
			p.SetState(356)
			p.Match(IDLParserSEMICOLON)
		}

	case 9:
		{
			p.SetState(358)
			p.Event()
		}
		{
			p.SetState(359)
			p.Match(IDLParserSEMICOLON)
		}

	case 10:
		{
			p.SetState(361)
			p.Component()
		}
		{
			p.SetState(362)
			p.Match(IDLParserSEMICOLON)
		}

	case 11:
		{
			p.SetState(364)
			p.Home_decl()
		}
		{
			p.SetState(365)
			p.Match(IDLParserSEMICOLON)
		}

	case 12:
		{
			p.SetState(367)
			p.Annotation_decl()
		}
		{
			p.SetState(368)
			p.Match(IDLParserSEMICOLON)
		}

	}

	return localctx
}

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) KW_MODULE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_MODULE, 0)
}

func (s *ModuleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModuleContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *ModuleContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *ModuleContext) AllDefinition() []IDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefinitionContext)(nil)).Elem())
	var tst = make([]IDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefinitionContext)
		}
	}

	return tst
}

func (s *ModuleContext) Definition(i int) IDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefinitionContext)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitModule(s)
	}
}

func (p *IDLParser) Module() (localctx IModuleContext) {
	this := p
	_ = this

	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, IDLParserRULE_module)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Match(IDLParserKW_MODULE)
	}
	{
		p.SetState(373)
		p.Identifier()
	}
	{
		p.SetState(374)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(IDLParserAT-35))|(1<<(IDLParserKW_TYPEDEF-35))|(1<<(IDLParserKW_CUSTOM-35))|(1<<(IDLParserKW_STRUCT-35))|(1<<(IDLParserKW_NATIVE-35))|(1<<(IDLParserKW_EVENTTYPE-35))|(1<<(IDLParserKW_ENUM-35))|(1<<(IDLParserKW_HOME-35)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(IDLParserKW_EXCEPTION-68))|(1<<(IDLParserKW_CONST-68))|(1<<(IDLParserKW_VALUETYPE-68))|(1<<(IDLParserKW_MODULE-68))|(1<<(IDLParserKW_UNION-68))|(1<<(IDLParserKW_ABSTRACT-68))|(1<<(IDLParserKW_TYPEPREFIX-68))|(1<<(IDLParserKW_TYPEID-68))|(1<<(IDLParserKW_LOCAL-68))|(1<<(IDLParserKW_INTERFACE-68))|(1<<(IDLParserKW_COMPONENT-68)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(IDLParserKW_BITSET-102))|(1<<(IDLParserKW_BITMASK-102))|(1<<(IDLParserKW_AT_ANNOTATION-102)))) != 0) {
		{
			p.SetState(375)
			p.Definition()
		}

		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(380)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IInterface_or_forward_declContext is an interface to support dynamic dispatch.
type IInterface_or_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_or_forward_declContext differentiates from other interfaces.
	IsInterface_or_forward_declContext()
}

type Interface_or_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_or_forward_declContext() *Interface_or_forward_declContext {
	var p = new(Interface_or_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_or_forward_decl
	return p
}

func (*Interface_or_forward_declContext) IsInterface_or_forward_declContext() {}

func NewInterface_or_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_or_forward_declContext {
	var p = new(Interface_or_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_or_forward_decl

	return p
}

func (s *Interface_or_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_or_forward_declContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Interface_or_forward_declContext) Interface_decl() IInterface_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declContext)
}

func (s *Interface_or_forward_declContext) Forward_decl() IForward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForward_declContext)
}

func (s *Interface_or_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_or_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_or_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_or_forward_decl(s)
	}
}

func (s *Interface_or_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_or_forward_decl(s)
	}
}

func (p *IDLParser) Interface_or_forward_decl() (localctx IInterface_or_forward_declContext) {
	this := p
	_ = this

	localctx = NewInterface_or_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, IDLParserRULE_interface_or_forward_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)
		p.Annapps()
	}
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(383)
			p.Interface_decl()
		}

	case 2:
		{
			p.SetState(384)
			p.Forward_decl()
		}

	}

	return localctx
}

// IInterface_declContext is an interface to support dynamic dispatch.
type IInterface_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_declContext differentiates from other interfaces.
	IsInterface_declContext()
}

type Interface_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_declContext() *Interface_declContext {
	var p = new(Interface_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_decl
	return p
}

func (*Interface_declContext) IsInterface_declContext() {}

func NewInterface_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_declContext {
	var p = new(Interface_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_decl

	return p
}

func (s *Interface_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_declContext) Interface_header() IInterface_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_headerContext)
}

func (s *Interface_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Interface_declContext) Interface_body() IInterface_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_bodyContext)
}

func (s *Interface_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Interface_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_decl(s)
	}
}

func (s *Interface_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_decl(s)
	}
}

func (p *IDLParser) Interface_decl() (localctx IInterface_declContext) {
	this := p
	_ = this

	localctx = NewInterface_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, IDLParserRULE_interface_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Interface_header()
	}
	{
		p.SetState(388)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(389)
		p.Interface_body()
	}
	{
		p.SetState(390)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IForward_declContext is an interface to support dynamic dispatch.
type IForward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForward_declContext differentiates from other interfaces.
	IsForward_declContext()
}

type Forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForward_declContext() *Forward_declContext {
	var p = new(Forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_forward_decl
	return p
}

func (*Forward_declContext) IsForward_declContext() {}

func NewForward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forward_declContext {
	var p = new(Forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_forward_decl

	return p
}

func (s *Forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Forward_declContext) KW_INTERFACE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INTERFACE, 0)
}

func (s *Forward_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Forward_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Forward_declContext) KW_LOCAL() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LOCAL, 0)
}

func (s *Forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterForward_decl(s)
	}
}

func (s *Forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitForward_decl(s)
	}
}

func (p *IDLParser) Forward_decl() (localctx IForward_declContext) {
	this := p
	_ = this

	localctx = NewForward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, IDLParserRULE_forward_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(393)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ABSTRACT || _la == IDLParserKW_LOCAL {
		{
			p.SetState(392)
			_la = p.GetTokenStream().LA(1)

			if !(_la == IDLParserKW_ABSTRACT || _la == IDLParserKW_LOCAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(395)
		p.Match(IDLParserKW_INTERFACE)
	}
	{
		p.SetState(396)
		p.Identifier()
	}

	return localctx
}

// IInterface_headerContext is an interface to support dynamic dispatch.
type IInterface_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_headerContext differentiates from other interfaces.
	IsInterface_headerContext()
}

type Interface_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_headerContext() *Interface_headerContext {
	var p = new(Interface_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_header
	return p
}

func (*Interface_headerContext) IsInterface_headerContext() {}

func NewInterface_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_headerContext {
	var p = new(Interface_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_header

	return p
}

func (s *Interface_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_headerContext) KW_INTERFACE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INTERFACE, 0)
}

func (s *Interface_headerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Interface_headerContext) Interface_inheritance_spec() IInterface_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_inheritance_specContext)
}

func (s *Interface_headerContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Interface_headerContext) KW_LOCAL() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LOCAL, 0)
}

func (s *Interface_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_header(s)
	}
}

func (s *Interface_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_header(s)
	}
}

func (p *IDLParser) Interface_header() (localctx IInterface_headerContext) {
	this := p
	_ = this

	localctx = NewInterface_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, IDLParserRULE_interface_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ABSTRACT || _la == IDLParserKW_LOCAL {
		{
			p.SetState(398)
			_la = p.GetTokenStream().LA(1)

			if !(_la == IDLParserKW_ABSTRACT || _la == IDLParserKW_LOCAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(401)
		p.Match(IDLParserKW_INTERFACE)
	}
	{
		p.SetState(402)
		p.Identifier()
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(403)
			p.Interface_inheritance_spec()
		}

	}

	return localctx
}

// IInterface_bodyContext is an interface to support dynamic dispatch.
type IInterface_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_bodyContext differentiates from other interfaces.
	IsInterface_bodyContext()
}

type Interface_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_bodyContext() *Interface_bodyContext {
	var p = new(Interface_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_body
	return p
}

func (*Interface_bodyContext) IsInterface_bodyContext() {}

func NewInterface_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_bodyContext {
	var p = new(Interface_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_body

	return p
}

func (s *Interface_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_bodyContext) AllExport_() []IExport_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExport_Context)(nil)).Elem())
	var tst = make([]IExport_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExport_Context)
		}
	}

	return tst
}

func (s *Interface_bodyContext) Export_(i int) IExport_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExport_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExport_Context)
}

func (s *Interface_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_body(s)
	}
}

func (s *Interface_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_body(s)
	}
}

func (p *IDLParser) Interface_body() (localctx IInterface_bodyContext) {
	this := p
	_ = this

	localctx = NewInterface_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, IDLParserRULE_interface_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserAT-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(IDLParserKW_WSTRING-64))|(1<<(IDLParserKW_EXCEPTION-64))|(1<<(IDLParserKW_CONST-64))|(1<<(IDLParserKW_VALUEBASE-64))|(1<<(IDLParserKW_OBJECT-64))|(1<<(IDLParserKW_UNSIGNED-64))|(1<<(IDLParserKW_UNION-64))|(1<<(IDLParserKW_ONEWAY-64))|(1<<(IDLParserKW_ANY-64))|(1<<(IDLParserKW_CHAR-64))|(1<<(IDLParserKW_FLOAT-64))|(1<<(IDLParserKW_BOOLEAN-64))|(1<<(IDLParserKW_DOUBLE-64))|(1<<(IDLParserKW_TYPEPREFIX-64))|(1<<(IDLParserKW_TYPEID-64))|(1<<(IDLParserKW_ATTRIBUTE-64)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(IDLParserKW_BITSET-102))|(1<<(IDLParserKW_BITMASK-102))|(1<<(IDLParserKW_INT8-102))|(1<<(IDLParserKW_UINT8-102))|(1<<(IDLParserKW_INT16-102))|(1<<(IDLParserKW_UINT16-102))|(1<<(IDLParserKW_INT32-102))|(1<<(IDLParserKW_UINT32-102))|(1<<(IDLParserKW_INT64-102))|(1<<(IDLParserKW_UINT64-102))|(1<<(IDLParserID-102)))) != 0) {
		{
			p.SetState(406)
			p.Export_()
		}

		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExport_Context is an interface to support dynamic dispatch.
type IExport_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExport_Context differentiates from other interfaces.
	IsExport_Context()
}

type Export_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExport_Context() *Export_Context {
	var p = new(Export_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_export_
	return p
}

func (*Export_Context) IsExport_Context() {}

func NewExport_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Export_Context {
	var p = new(Export_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_export_

	return p
}

func (s *Export_Context) GetParser() antlr.Parser { return s.parser }

func (s *Export_Context) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Export_Context) Type_decl() IType_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declContext)
}

func (s *Export_Context) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Export_Context) Const_decl() IConst_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_declContext)
}

func (s *Export_Context) Except_decl() IExcept_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExcept_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExcept_declContext)
}

func (s *Export_Context) Attr_decl() IAttr_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_declContext)
}

func (s *Export_Context) Op_decl() IOp_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOp_declContext)
}

func (s *Export_Context) Type_id_decl() IType_id_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_id_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_id_declContext)
}

func (s *Export_Context) Type_prefix_decl() IType_prefix_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_prefix_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_prefix_declContext)
}

func (s *Export_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Export_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Export_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterExport_(s)
	}
}

func (s *Export_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitExport_(s)
	}
}

func (p *IDLParser) Export_() (localctx IExport_Context) {
	this := p
	_ = this

	localctx = NewExport_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, IDLParserRULE_export_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(412)
		p.Annapps()
	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_TYPEDEF, IDLParserKW_STRUCT, IDLParserKW_NATIVE, IDLParserKW_ENUM, IDLParserKW_UNION, IDLParserKW_BITSET, IDLParserKW_BITMASK:
		{
			p.SetState(413)
			p.Type_decl()
		}
		{
			p.SetState(414)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_CONST:
		{
			p.SetState(416)
			p.Const_decl()
		}
		{
			p.SetState(417)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_EXCEPTION:
		{
			p.SetState(419)
			p.Except_decl()
		}
		{
			p.SetState(420)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_READONLY, IDLParserKW_ATTRIBUTE:
		{
			p.SetState(422)
			p.Attr_decl()
		}
		{
			p.SetState(423)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserDOUBLE_COLON, IDLParserAT, IDLParserKW_STRING, IDLParserKW_OCTET, IDLParserKW_VOID, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_WSTRING, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_ONEWAY, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserKW_INT8, IDLParserKW_UINT8, IDLParserKW_INT16, IDLParserKW_UINT16, IDLParserKW_INT32, IDLParserKW_UINT32, IDLParserKW_INT64, IDLParserKW_UINT64, IDLParserID:
		{
			p.SetState(425)
			p.Op_decl()
		}
		{
			p.SetState(426)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_TYPEID:
		{
			p.SetState(428)
			p.Type_id_decl()
		}
		{
			p.SetState(429)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_TYPEPREFIX:
		{
			p.SetState(431)
			p.Type_prefix_decl()
		}
		{
			p.SetState(432)
			p.Match(IDLParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterface_inheritance_specContext is an interface to support dynamic dispatch.
type IInterface_inheritance_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_inheritance_specContext differentiates from other interfaces.
	IsInterface_inheritance_specContext()
}

type Interface_inheritance_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_inheritance_specContext() *Interface_inheritance_specContext {
	var p = new(Interface_inheritance_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_inheritance_spec
	return p
}

func (*Interface_inheritance_specContext) IsInterface_inheritance_specContext() {}

func NewInterface_inheritance_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_inheritance_specContext {
	var p = new(Interface_inheritance_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_inheritance_spec

	return p
}

func (s *Interface_inheritance_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_inheritance_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Interface_inheritance_specContext) AllInterface_name() []IInterface_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_nameContext)(nil)).Elem())
	var tst = make([]IInterface_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_nameContext)
		}
	}

	return tst
}

func (s *Interface_inheritance_specContext) Interface_name(i int) IInterface_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_nameContext)
}

func (s *Interface_inheritance_specContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Interface_inheritance_specContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Interface_inheritance_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_inheritance_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_inheritance_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_inheritance_spec(s)
	}
}

func (s *Interface_inheritance_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_inheritance_spec(s)
	}
}

func (p *IDLParser) Interface_inheritance_spec() (localctx IInterface_inheritance_specContext) {
	this := p
	_ = this

	localctx = NewInterface_inheritance_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, IDLParserRULE_interface_inheritance_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.Match(IDLParserCOLON)
	}
	{
		p.SetState(437)
		p.Interface_name()
	}
	p.SetState(442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(438)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(439)
			p.Interface_name()
		}

		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterface_nameContext is an interface to support dynamic dispatch.
type IInterface_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_nameContext differentiates from other interfaces.
	IsInterface_nameContext()
}

type Interface_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_nameContext() *Interface_nameContext {
	var p = new(Interface_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_name
	return p
}

func (*Interface_nameContext) IsInterface_nameContext() {}

func NewInterface_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_nameContext {
	var p = new(Interface_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_name

	return p
}

func (s *Interface_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_nameContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Interface_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_name(s)
	}
}

func (s *Interface_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_name(s)
	}
}

func (p *IDLParser) Interface_name() (localctx IInterface_nameContext) {
	this := p
	_ = this

	localctx = NewInterface_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, IDLParserRULE_interface_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.A_scoped_name()
	}

	return localctx
}

// IA_scoped_nameContext is an interface to support dynamic dispatch.
type IA_scoped_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsA_scoped_nameContext differentiates from other interfaces.
	IsA_scoped_nameContext()
}

type A_scoped_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyA_scoped_nameContext() *A_scoped_nameContext {
	var p = new(A_scoped_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_a_scoped_name
	return p
}

func (*A_scoped_nameContext) IsA_scoped_nameContext() {}

func NewA_scoped_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *A_scoped_nameContext {
	var p = new(A_scoped_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_a_scoped_name

	return p
}

func (s *A_scoped_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *A_scoped_nameContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *A_scoped_nameContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *A_scoped_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *A_scoped_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *A_scoped_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterA_scoped_name(s)
	}
}

func (s *A_scoped_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitA_scoped_name(s)
	}
}

func (p *IDLParser) A_scoped_name() (localctx IA_scoped_nameContext) {
	this := p
	_ = this

	localctx = NewA_scoped_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, IDLParserRULE_a_scoped_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Annapps()
	}
	{
		p.SetState(448)
		p.Scoped_name()
	}

	return localctx
}

// IScoped_nameContext is an interface to support dynamic dispatch.
type IScoped_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScoped_nameContext differentiates from other interfaces.
	IsScoped_nameContext()
}

type Scoped_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScoped_nameContext() *Scoped_nameContext {
	var p = new(Scoped_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_scoped_name
	return p
}

func (*Scoped_nameContext) IsScoped_nameContext() {}

func NewScoped_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scoped_nameContext {
	var p = new(Scoped_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_scoped_name

	return p
}

func (s *Scoped_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Scoped_nameContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(IDLParserID)
}

func (s *Scoped_nameContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserID, i)
}

func (s *Scoped_nameContext) AllDOUBLE_COLON() []antlr.TerminalNode {
	return s.GetTokens(IDLParserDOUBLE_COLON)
}

func (s *Scoped_nameContext) DOUBLE_COLON(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserDOUBLE_COLON, i)
}

func (s *Scoped_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scoped_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scoped_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterScoped_name(s)
	}
}

func (s *Scoped_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitScoped_name(s)
	}
}

func (p *IDLParser) Scoped_name() (localctx IScoped_nameContext) {
	this := p
	_ = this

	localctx = NewScoped_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, IDLParserRULE_scoped_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserDOUBLE_COLON {
		{
			p.SetState(450)
			p.Match(IDLParserDOUBLE_COLON)
		}

	}
	{
		p.SetState(453)
		p.Match(IDLParserID)
	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(454)
				p.Match(IDLParserDOUBLE_COLON)
			}
			{
				p.SetState(455)
				p.Match(IDLParserID)
			}

		}
		p.SetState(460)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *ValueContext) Value_decl() IValue_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_declContext)
}

func (s *ValueContext) Value_abs_decl() IValue_abs_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_abs_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_abs_declContext)
}

func (s *ValueContext) Value_box_decl() IValue_box_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_box_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_box_declContext)
}

func (s *ValueContext) Value_forward_decl() IValue_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_forward_declContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue(s)
	}
}

func (p *IDLParser) Value() (localctx IValueContext) {
	this := p
	_ = this

	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, IDLParserRULE_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.Annapps()
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(462)
			p.Value_decl()
		}

	case 2:
		{
			p.SetState(463)
			p.Value_abs_decl()
		}

	case 3:
		{
			p.SetState(464)
			p.Value_box_decl()
		}

	case 4:
		{
			p.SetState(465)
			p.Value_forward_decl()
		}

	}

	return localctx
}

// IValue_forward_declContext is an interface to support dynamic dispatch.
type IValue_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_forward_declContext differentiates from other interfaces.
	IsValue_forward_declContext()
}

type Value_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_forward_declContext() *Value_forward_declContext {
	var p = new(Value_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_forward_decl
	return p
}

func (*Value_forward_declContext) IsValue_forward_declContext() {}

func NewValue_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_forward_declContext {
	var p = new(Value_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_forward_decl

	return p
}

func (s *Value_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_forward_declContext) KW_VALUETYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUETYPE, 0)
}

func (s *Value_forward_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Value_forward_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Value_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_forward_decl(s)
	}
}

func (s *Value_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_forward_decl(s)
	}
}

func (p *IDLParser) Value_forward_decl() (localctx IValue_forward_declContext) {
	this := p
	_ = this

	localctx = NewValue_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, IDLParserRULE_value_forward_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ABSTRACT {
		{
			p.SetState(468)
			p.Match(IDLParserKW_ABSTRACT)
		}

	}
	{
		p.SetState(471)
		p.Match(IDLParserKW_VALUETYPE)
	}
	{
		p.SetState(472)
		p.Identifier()
	}

	return localctx
}

// IValue_box_declContext is an interface to support dynamic dispatch.
type IValue_box_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_box_declContext differentiates from other interfaces.
	IsValue_box_declContext()
}

type Value_box_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_box_declContext() *Value_box_declContext {
	var p = new(Value_box_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_box_decl
	return p
}

func (*Value_box_declContext) IsValue_box_declContext() {}

func NewValue_box_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_box_declContext {
	var p = new(Value_box_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_box_decl

	return p
}

func (s *Value_box_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_box_declContext) KW_VALUETYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUETYPE, 0)
}

func (s *Value_box_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Value_box_declContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Value_box_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_box_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_box_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_box_decl(s)
	}
}

func (s *Value_box_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_box_decl(s)
	}
}

func (p *IDLParser) Value_box_decl() (localctx IValue_box_declContext) {
	this := p
	_ = this

	localctx = NewValue_box_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, IDLParserRULE_value_box_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(474)
		p.Match(IDLParserKW_VALUETYPE)
	}
	{
		p.SetState(475)
		p.Identifier()
	}
	{
		p.SetState(476)
		p.Type_spec()
	}

	return localctx
}

// IValue_abs_declContext is an interface to support dynamic dispatch.
type IValue_abs_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_abs_declContext differentiates from other interfaces.
	IsValue_abs_declContext()
}

type Value_abs_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_abs_declContext() *Value_abs_declContext {
	var p = new(Value_abs_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_abs_decl
	return p
}

func (*Value_abs_declContext) IsValue_abs_declContext() {}

func NewValue_abs_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_abs_declContext {
	var p = new(Value_abs_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_abs_decl

	return p
}

func (s *Value_abs_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_abs_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Value_abs_declContext) KW_VALUETYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUETYPE, 0)
}

func (s *Value_abs_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Value_abs_declContext) Value_inheritance_spec() IValue_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_inheritance_specContext)
}

func (s *Value_abs_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Value_abs_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Value_abs_declContext) AllExport_() []IExport_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExport_Context)(nil)).Elem())
	var tst = make([]IExport_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExport_Context)
		}
	}

	return tst
}

func (s *Value_abs_declContext) Export_(i int) IExport_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExport_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExport_Context)
}

func (s *Value_abs_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_abs_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_abs_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_abs_decl(s)
	}
}

func (s *Value_abs_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_abs_decl(s)
	}
}

func (p *IDLParser) Value_abs_decl() (localctx IValue_abs_declContext) {
	this := p
	_ = this

	localctx = NewValue_abs_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, IDLParserRULE_value_abs_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.Match(IDLParserKW_ABSTRACT)
	}
	{
		p.SetState(479)
		p.Match(IDLParserKW_VALUETYPE)
	}
	{
		p.SetState(480)
		p.Identifier()
	}
	{
		p.SetState(481)
		p.Value_inheritance_spec()
	}
	{
		p.SetState(482)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserAT-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(IDLParserKW_WSTRING-64))|(1<<(IDLParserKW_EXCEPTION-64))|(1<<(IDLParserKW_CONST-64))|(1<<(IDLParserKW_VALUEBASE-64))|(1<<(IDLParserKW_OBJECT-64))|(1<<(IDLParserKW_UNSIGNED-64))|(1<<(IDLParserKW_UNION-64))|(1<<(IDLParserKW_ONEWAY-64))|(1<<(IDLParserKW_ANY-64))|(1<<(IDLParserKW_CHAR-64))|(1<<(IDLParserKW_FLOAT-64))|(1<<(IDLParserKW_BOOLEAN-64))|(1<<(IDLParserKW_DOUBLE-64))|(1<<(IDLParserKW_TYPEPREFIX-64))|(1<<(IDLParserKW_TYPEID-64))|(1<<(IDLParserKW_ATTRIBUTE-64)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(IDLParserKW_BITSET-102))|(1<<(IDLParserKW_BITMASK-102))|(1<<(IDLParserKW_INT8-102))|(1<<(IDLParserKW_UINT8-102))|(1<<(IDLParserKW_INT16-102))|(1<<(IDLParserKW_UINT16-102))|(1<<(IDLParserKW_INT32-102))|(1<<(IDLParserKW_UINT32-102))|(1<<(IDLParserKW_INT64-102))|(1<<(IDLParserKW_UINT64-102))|(1<<(IDLParserID-102)))) != 0) {
		{
			p.SetState(483)
			p.Export_()
		}

		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(489)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IValue_declContext is an interface to support dynamic dispatch.
type IValue_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_declContext differentiates from other interfaces.
	IsValue_declContext()
}

type Value_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_declContext() *Value_declContext {
	var p = new(Value_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_decl
	return p
}

func (*Value_declContext) IsValue_declContext() {}

func NewValue_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_declContext {
	var p = new(Value_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_decl

	return p
}

func (s *Value_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_declContext) Value_header() IValue_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_headerContext)
}

func (s *Value_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Value_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Value_declContext) AllValue_element() []IValue_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValue_elementContext)(nil)).Elem())
	var tst = make([]IValue_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValue_elementContext)
		}
	}

	return tst
}

func (s *Value_declContext) Value_element(i int) IValue_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValue_elementContext)
}

func (s *Value_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_decl(s)
	}
}

func (s *Value_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_decl(s)
	}
}

func (p *IDLParser) Value_decl() (localctx IValue_declContext) {
	this := p
	_ = this

	localctx = NewValue_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, IDLParserRULE_value_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Value_header()
	}
	{
		p.SetState(492)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserAT-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_PRIVATE-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_PUBLIC-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(IDLParserKW_WSTRING-64))|(1<<(IDLParserKW_FACTORY-64))|(1<<(IDLParserKW_EXCEPTION-64))|(1<<(IDLParserKW_CONST-64))|(1<<(IDLParserKW_VALUEBASE-64))|(1<<(IDLParserKW_OBJECT-64))|(1<<(IDLParserKW_UNSIGNED-64))|(1<<(IDLParserKW_UNION-64))|(1<<(IDLParserKW_ONEWAY-64))|(1<<(IDLParserKW_ANY-64))|(1<<(IDLParserKW_CHAR-64))|(1<<(IDLParserKW_FLOAT-64))|(1<<(IDLParserKW_BOOLEAN-64))|(1<<(IDLParserKW_DOUBLE-64))|(1<<(IDLParserKW_TYPEPREFIX-64))|(1<<(IDLParserKW_TYPEID-64))|(1<<(IDLParserKW_ATTRIBUTE-64)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(IDLParserKW_BITSET-102))|(1<<(IDLParserKW_BITMASK-102))|(1<<(IDLParserKW_INT8-102))|(1<<(IDLParserKW_UINT8-102))|(1<<(IDLParserKW_INT16-102))|(1<<(IDLParserKW_UINT16-102))|(1<<(IDLParserKW_INT32-102))|(1<<(IDLParserKW_UINT32-102))|(1<<(IDLParserKW_INT64-102))|(1<<(IDLParserKW_UINT64-102))|(1<<(IDLParserID-102)))) != 0) {
		{
			p.SetState(493)
			p.Value_element()
		}

		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(499)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IValue_headerContext is an interface to support dynamic dispatch.
type IValue_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_headerContext differentiates from other interfaces.
	IsValue_headerContext()
}

type Value_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_headerContext() *Value_headerContext {
	var p = new(Value_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_header
	return p
}

func (*Value_headerContext) IsValue_headerContext() {}

func NewValue_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_headerContext {
	var p = new(Value_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_header

	return p
}

func (s *Value_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_headerContext) KW_VALUETYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUETYPE, 0)
}

func (s *Value_headerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Value_headerContext) Value_inheritance_spec() IValue_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_inheritance_specContext)
}

func (s *Value_headerContext) KW_CUSTOM() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CUSTOM, 0)
}

func (s *Value_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_header(s)
	}
}

func (s *Value_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_header(s)
	}
}

func (p *IDLParser) Value_header() (localctx IValue_headerContext) {
	this := p
	_ = this

	localctx = NewValue_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, IDLParserRULE_value_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_CUSTOM {
		{
			p.SetState(501)
			p.Match(IDLParserKW_CUSTOM)
		}

	}
	{
		p.SetState(504)
		p.Match(IDLParserKW_VALUETYPE)
	}
	{
		p.SetState(505)
		p.Identifier()
	}
	{
		p.SetState(506)
		p.Value_inheritance_spec()
	}

	return localctx
}

// IValue_inheritance_specContext is an interface to support dynamic dispatch.
type IValue_inheritance_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_inheritance_specContext differentiates from other interfaces.
	IsValue_inheritance_specContext()
}

type Value_inheritance_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_inheritance_specContext() *Value_inheritance_specContext {
	var p = new(Value_inheritance_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_inheritance_spec
	return p
}

func (*Value_inheritance_specContext) IsValue_inheritance_specContext() {}

func NewValue_inheritance_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_inheritance_specContext {
	var p = new(Value_inheritance_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_inheritance_spec

	return p
}

func (s *Value_inheritance_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_inheritance_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Value_inheritance_specContext) AllValue_name() []IValue_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValue_nameContext)(nil)).Elem())
	var tst = make([]IValue_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValue_nameContext)
		}
	}

	return tst
}

func (s *Value_inheritance_specContext) Value_name(i int) IValue_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValue_nameContext)
}

func (s *Value_inheritance_specContext) KW_SUPPORTS() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SUPPORTS, 0)
}

func (s *Value_inheritance_specContext) AllInterface_name() []IInterface_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_nameContext)(nil)).Elem())
	var tst = make([]IInterface_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_nameContext)
		}
	}

	return tst
}

func (s *Value_inheritance_specContext) Interface_name(i int) IInterface_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_nameContext)
}

func (s *Value_inheritance_specContext) KW_TRUNCATABLE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_TRUNCATABLE, 0)
}

func (s *Value_inheritance_specContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Value_inheritance_specContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Value_inheritance_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_inheritance_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_inheritance_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_inheritance_spec(s)
	}
}

func (s *Value_inheritance_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_inheritance_spec(s)
	}
}

func (p *IDLParser) Value_inheritance_spec() (localctx IValue_inheritance_specContext) {
	this := p
	_ = this

	localctx = NewValue_inheritance_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, IDLParserRULE_value_inheritance_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(508)
			p.Match(IDLParserCOLON)
		}
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == IDLParserKW_TRUNCATABLE {
			{
				p.SetState(509)
				p.Match(IDLParserKW_TRUNCATABLE)
			}

		}
		{
			p.SetState(512)
			p.Value_name()
		}
		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMMA {
			{
				p.SetState(513)
				p.Match(IDLParserCOMMA)
			}
			{
				p.SetState(514)
				p.Value_name()
			}

			p.SetState(519)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_SUPPORTS {
		{
			p.SetState(522)
			p.Match(IDLParserKW_SUPPORTS)
		}
		{
			p.SetState(523)
			p.Interface_name()
		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMMA {
			{
				p.SetState(524)
				p.Match(IDLParserCOMMA)
			}
			{
				p.SetState(525)
				p.Interface_name()
			}

			p.SetState(530)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IValue_nameContext is an interface to support dynamic dispatch.
type IValue_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_nameContext differentiates from other interfaces.
	IsValue_nameContext()
}

type Value_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_nameContext() *Value_nameContext {
	var p = new(Value_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_name
	return p
}

func (*Value_nameContext) IsValue_nameContext() {}

func NewValue_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_nameContext {
	var p = new(Value_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_name

	return p
}

func (s *Value_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_nameContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Value_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_name(s)
	}
}

func (s *Value_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_name(s)
	}
}

func (p *IDLParser) Value_name() (localctx IValue_nameContext) {
	this := p
	_ = this

	localctx = NewValue_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, IDLParserRULE_value_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.A_scoped_name()
	}

	return localctx
}

// IValue_elementContext is an interface to support dynamic dispatch.
type IValue_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_elementContext differentiates from other interfaces.
	IsValue_elementContext()
}

type Value_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_elementContext() *Value_elementContext {
	var p = new(Value_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_element
	return p
}

func (*Value_elementContext) IsValue_elementContext() {}

func NewValue_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_elementContext {
	var p = new(Value_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_element

	return p
}

func (s *Value_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_elementContext) Export_() IExport_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExport_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExport_Context)
}

func (s *Value_elementContext) State_member() IState_memberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_memberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_memberContext)
}

func (s *Value_elementContext) Init_decl() IInit_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declContext)
}

func (s *Value_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_element(s)
	}
}

func (s *Value_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_element(s)
	}
}

func (p *IDLParser) Value_element() (localctx IValue_elementContext) {
	this := p
	_ = this

	localctx = NewValue_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, IDLParserRULE_value_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(535)
			p.Export_()
		}

	case 2:
		{
			p.SetState(536)
			p.State_member()
		}

	case 3:
		{
			p.SetState(537)
			p.Init_decl()
		}

	}

	return localctx
}

// IState_memberContext is an interface to support dynamic dispatch.
type IState_memberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsState_memberContext differentiates from other interfaces.
	IsState_memberContext()
}

type State_memberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyState_memberContext() *State_memberContext {
	var p = new(State_memberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_state_member
	return p
}

func (*State_memberContext) IsState_memberContext() {}

func NewState_memberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *State_memberContext {
	var p = new(State_memberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_state_member

	return p
}

func (s *State_memberContext) GetParser() antlr.Parser { return s.parser }

func (s *State_memberContext) AllAnnapps() []IAnnappsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnappsContext)(nil)).Elem())
	var tst = make([]IAnnappsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnappsContext)
		}
	}

	return tst
}

func (s *State_memberContext) Annapps(i int) IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *State_memberContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *State_memberContext) Declarators() IDeclaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorsContext)
}

func (s *State_memberContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *State_memberContext) KW_PUBLIC() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PUBLIC, 0)
}

func (s *State_memberContext) KW_PRIVATE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PRIVATE, 0)
}

func (s *State_memberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *State_memberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *State_memberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterState_member(s)
	}
}

func (s *State_memberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitState_member(s)
	}
}

func (p *IDLParser) State_member() (localctx IState_memberContext) {
	this := p
	_ = this

	localctx = NewState_memberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, IDLParserRULE_state_member)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(540)
		p.Annapps()
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_PUBLIC:
		{
			p.SetState(541)
			p.Match(IDLParserKW_PUBLIC)
		}
		{
			p.SetState(542)
			p.Annapps()
		}

	case IDLParserKW_PRIVATE:
		{
			p.SetState(543)
			p.Match(IDLParserKW_PRIVATE)
		}
		{
			p.SetState(544)
			p.Annapps()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(547)
		p.Type_spec()
	}
	{
		p.SetState(548)
		p.Declarators()
	}
	{
		p.SetState(549)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// IInit_declContext is an interface to support dynamic dispatch.
type IInit_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declContext differentiates from other interfaces.
	IsInit_declContext()
}

type Init_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declContext() *Init_declContext {
	var p = new(Init_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_init_decl
	return p
}

func (*Init_declContext) IsInit_declContext() {}

func NewInit_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declContext {
	var p = new(Init_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_init_decl

	return p
}

func (s *Init_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Init_declContext) KW_FACTORY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FACTORY, 0)
}

func (s *Init_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Init_declContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Init_declContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Init_declContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Init_declContext) Init_param_decls() IInit_param_declsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_declsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_param_declsContext)
}

func (s *Init_declContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Init_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInit_decl(s)
	}
}

func (s *Init_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInit_decl(s)
	}
}

func (p *IDLParser) Init_decl() (localctx IInit_declContext) {
	this := p
	_ = this

	localctx = NewInit_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, IDLParserRULE_init_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Annapps()
	}
	{
		p.SetState(552)
		p.Match(IDLParserKW_FACTORY)
	}
	{
		p.SetState(553)
		p.Identifier()
	}
	{
		p.SetState(554)
		p.Match(IDLParserLEFT_BRACKET)
	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserAT || _la == IDLParserKW_IN {
		{
			p.SetState(555)
			p.Init_param_decls()
		}

	}
	{
		p.SetState(558)
		p.Match(IDLParserRIGHT_BRACKET)
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_RAISES {
		{
			p.SetState(559)
			p.Raises_expr()
		}

	}
	{
		p.SetState(562)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// IInit_param_declsContext is an interface to support dynamic dispatch.
type IInit_param_declsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_param_declsContext differentiates from other interfaces.
	IsInit_param_declsContext()
}

type Init_param_declsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_param_declsContext() *Init_param_declsContext {
	var p = new(Init_param_declsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_init_param_decls
	return p
}

func (*Init_param_declsContext) IsInit_param_declsContext() {}

func NewInit_param_declsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_param_declsContext {
	var p = new(Init_param_declsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_init_param_decls

	return p
}

func (s *Init_param_declsContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_param_declsContext) AllInit_param_decl() []IInit_param_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInit_param_declContext)(nil)).Elem())
	var tst = make([]IInit_param_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInit_param_declContext)
		}
	}

	return tst
}

func (s *Init_param_declsContext) Init_param_decl(i int) IInit_param_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInit_param_declContext)
}

func (s *Init_param_declsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Init_param_declsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Init_param_declsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_param_declsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_param_declsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInit_param_decls(s)
	}
}

func (s *Init_param_declsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInit_param_decls(s)
	}
}

func (p *IDLParser) Init_param_decls() (localctx IInit_param_declsContext) {
	this := p
	_ = this

	localctx = NewInit_param_declsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, IDLParserRULE_init_param_decls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Init_param_decl()
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(565)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(566)
			p.Init_param_decl()
		}

		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInit_param_declContext is an interface to support dynamic dispatch.
type IInit_param_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_param_declContext differentiates from other interfaces.
	IsInit_param_declContext()
}

type Init_param_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_param_declContext() *Init_param_declContext {
	var p = new(Init_param_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_init_param_decl
	return p
}

func (*Init_param_declContext) IsInit_param_declContext() {}

func NewInit_param_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_param_declContext {
	var p = new(Init_param_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_init_param_decl

	return p
}

func (s *Init_param_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_param_declContext) AllAnnapps() []IAnnappsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnappsContext)(nil)).Elem())
	var tst = make([]IAnnappsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnappsContext)
		}
	}

	return tst
}

func (s *Init_param_declContext) Annapps(i int) IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Init_param_declContext) Init_param_attribute() IInit_param_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_param_attributeContext)
}

func (s *Init_param_declContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Init_param_declContext) Simple_declarator() ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Init_param_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_param_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_param_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInit_param_decl(s)
	}
}

func (s *Init_param_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInit_param_decl(s)
	}
}

func (p *IDLParser) Init_param_decl() (localctx IInit_param_declContext) {
	this := p
	_ = this

	localctx = NewInit_param_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, IDLParserRULE_init_param_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Annapps()
	}
	{
		p.SetState(573)
		p.Init_param_attribute()
	}
	{
		p.SetState(574)
		p.Annapps()
	}
	{
		p.SetState(575)
		p.Param_type_spec()
	}
	{
		p.SetState(576)
		p.Annapps()
	}
	{
		p.SetState(577)
		p.Simple_declarator()
	}

	return localctx
}

// IInit_param_attributeContext is an interface to support dynamic dispatch.
type IInit_param_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_param_attributeContext differentiates from other interfaces.
	IsInit_param_attributeContext()
}

type Init_param_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_param_attributeContext() *Init_param_attributeContext {
	var p = new(Init_param_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_init_param_attribute
	return p
}

func (*Init_param_attributeContext) IsInit_param_attributeContext() {}

func NewInit_param_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_param_attributeContext {
	var p = new(Init_param_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_init_param_attribute

	return p
}

func (s *Init_param_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_param_attributeContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_IN, 0)
}

func (s *Init_param_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_param_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_param_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInit_param_attribute(s)
	}
}

func (s *Init_param_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInit_param_attribute(s)
	}
}

func (p *IDLParser) Init_param_attribute() (localctx IInit_param_attributeContext) {
	this := p
	_ = this

	localctx = NewInit_param_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, IDLParserRULE_init_param_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(IDLParserKW_IN)
	}

	return localctx
}

// IConst_declContext is an interface to support dynamic dispatch.
type IConst_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_declContext differentiates from other interfaces.
	IsConst_declContext()
}

type Const_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_declContext() *Const_declContext {
	var p = new(Const_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_const_decl
	return p
}

func (*Const_declContext) IsConst_declContext() {}

func NewConst_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_declContext {
	var p = new(Const_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_const_decl

	return p
}

func (s *Const_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Const_declContext) KW_CONST() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CONST, 0)
}

func (s *Const_declContext) Const_type() IConst_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_typeContext)
}

func (s *Const_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Const_declContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(IDLParserEQUAL, 0)
}

func (s *Const_declContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Const_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConst_decl(s)
	}
}

func (s *Const_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConst_decl(s)
	}
}

func (p *IDLParser) Const_decl() (localctx IConst_declContext) {
	this := p
	_ = this

	localctx = NewConst_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, IDLParserRULE_const_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.Match(IDLParserKW_CONST)
	}
	{
		p.SetState(582)
		p.Const_type()
	}
	{
		p.SetState(583)
		p.Identifier()
	}
	{
		p.SetState(584)
		p.Match(IDLParserEQUAL)
	}
	{
		p.SetState(585)
		p.Const_exp()
	}

	return localctx
}

// IConst_typeContext is an interface to support dynamic dispatch.
type IConst_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_typeContext differentiates from other interfaces.
	IsConst_typeContext()
}

type Const_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_typeContext() *Const_typeContext {
	var p = new(Const_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_const_type
	return p
}

func (*Const_typeContext) IsConst_typeContext() {}

func NewConst_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_typeContext {
	var p = new(Const_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_const_type

	return p
}

func (s *Const_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Const_typeContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Const_typeContext) Integer_type() IInteger_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *Const_typeContext) Char_type() IChar_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_typeContext)
}

func (s *Const_typeContext) Wide_char_type() IWide_char_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_char_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_char_typeContext)
}

func (s *Const_typeContext) Boolean_type() IBoolean_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_typeContext)
}

func (s *Const_typeContext) Floating_pt_type() IFloating_pt_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloating_pt_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloating_pt_typeContext)
}

func (s *Const_typeContext) String_type() IString_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_typeContext)
}

func (s *Const_typeContext) Wide_string_type() IWide_string_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_string_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_string_typeContext)
}

func (s *Const_typeContext) Fixed_pt_const_type() IFixed_pt_const_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFixed_pt_const_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFixed_pt_const_typeContext)
}

func (s *Const_typeContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Const_typeContext) Octet_type() IOctet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctet_typeContext)
}

func (s *Const_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConst_type(s)
	}
}

func (s *Const_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConst_type(s)
	}
}

func (p *IDLParser) Const_type() (localctx IConst_typeContext) {
	this := p
	_ = this

	localctx = NewConst_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, IDLParserRULE_const_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		p.Annapps()
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(588)
			p.Integer_type()
		}

	case 2:
		{
			p.SetState(589)
			p.Char_type()
		}

	case 3:
		{
			p.SetState(590)
			p.Wide_char_type()
		}

	case 4:
		{
			p.SetState(591)
			p.Boolean_type()
		}

	case 5:
		{
			p.SetState(592)
			p.Floating_pt_type()
		}

	case 6:
		{
			p.SetState(593)
			p.String_type()
		}

	case 7:
		{
			p.SetState(594)
			p.Wide_string_type()
		}

	case 8:
		{
			p.SetState(595)
			p.Fixed_pt_const_type()
		}

	case 9:
		{
			p.SetState(596)
			p.Scoped_name()
		}

	case 10:
		{
			p.SetState(597)
			p.Octet_type()
		}

	}

	return localctx
}

// IConst_expContext is an interface to support dynamic dispatch.
type IConst_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_expContext differentiates from other interfaces.
	IsConst_expContext()
}

type Const_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_expContext() *Const_expContext {
	var p = new(Const_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_const_exp
	return p
}

func (*Const_expContext) IsConst_expContext() {}

func NewConst_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_expContext {
	var p = new(Const_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_const_exp

	return p
}

func (s *Const_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Const_expContext) Or_expr() IOr_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_exprContext)
}

func (s *Const_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConst_exp(s)
	}
}

func (s *Const_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConst_exp(s)
	}
}

func (p *IDLParser) Const_exp() (localctx IConst_expContext) {
	this := p
	_ = this

	localctx = NewConst_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, IDLParserRULE_const_exp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.Or_expr()
	}

	return localctx
}

// IOr_exprContext is an interface to support dynamic dispatch.
type IOr_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_exprContext differentiates from other interfaces.
	IsOr_exprContext()
}

type Or_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_exprContext() *Or_exprContext {
	var p = new(Or_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_or_expr
	return p
}

func (*Or_exprContext) IsOr_exprContext() {}

func NewOr_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_exprContext {
	var p = new(Or_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_or_expr

	return p
}

func (s *Or_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_exprContext) AllXor_expr() []IXor_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXor_exprContext)(nil)).Elem())
	var tst = make([]IXor_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXor_exprContext)
		}
	}

	return tst
}

func (s *Or_exprContext) Xor_expr(i int) IXor_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXor_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXor_exprContext)
}

func (s *Or_exprContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(IDLParserPIPE)
}

func (s *Or_exprContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserPIPE, i)
}

func (s *Or_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOr_expr(s)
	}
}

func (s *Or_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOr_expr(s)
	}
}

func (p *IDLParser) Or_expr() (localctx IOr_exprContext) {
	this := p
	_ = this

	localctx = NewOr_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, IDLParserRULE_or_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		p.Xor_expr()
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserPIPE {
		{
			p.SetState(603)
			p.Match(IDLParserPIPE)
		}
		{
			p.SetState(604)
			p.Xor_expr()
		}

		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IXor_exprContext is an interface to support dynamic dispatch.
type IXor_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXor_exprContext differentiates from other interfaces.
	IsXor_exprContext()
}

type Xor_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_exprContext() *Xor_exprContext {
	var p = new(Xor_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_xor_expr
	return p
}

func (*Xor_exprContext) IsXor_exprContext() {}

func NewXor_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_exprContext {
	var p = new(Xor_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_xor_expr

	return p
}

func (s *Xor_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_exprContext) AllAnd_expr() []IAnd_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem())
	var tst = make([]IAnd_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_exprContext)
		}
	}

	return tst
}

func (s *Xor_exprContext) And_expr(i int) IAnd_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_exprContext)
}

func (s *Xor_exprContext) AllCARET() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCARET)
}

func (s *Xor_exprContext) CARET(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCARET, i)
}

func (s *Xor_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xor_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterXor_expr(s)
	}
}

func (s *Xor_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitXor_expr(s)
	}
}

func (p *IDLParser) Xor_expr() (localctx IXor_exprContext) {
	this := p
	_ = this

	localctx = NewXor_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, IDLParserRULE_xor_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.And_expr()
	}
	p.SetState(615)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCARET {
		{
			p.SetState(611)
			p.Match(IDLParserCARET)
		}
		{
			p.SetState(612)
			p.And_expr()
		}

		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAnd_exprContext is an interface to support dynamic dispatch.
type IAnd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_exprContext differentiates from other interfaces.
	IsAnd_exprContext()
}

type And_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_exprContext() *And_exprContext {
	var p = new(And_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_and_expr
	return p
}

func (*And_exprContext) IsAnd_exprContext() {}

func NewAnd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_exprContext {
	var p = new(And_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_and_expr

	return p
}

func (s *And_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_exprContext) AllShift_expr() []IShift_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_exprContext)(nil)).Elem())
	var tst = make([]IShift_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_exprContext)
		}
	}

	return tst
}

func (s *And_exprContext) Shift_expr(i int) IShift_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_exprContext)
}

func (s *And_exprContext) AllAMPERSAND() []antlr.TerminalNode {
	return s.GetTokens(IDLParserAMPERSAND)
}

func (s *And_exprContext) AMPERSAND(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserAMPERSAND, i)
}

func (s *And_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnd_expr(s)
	}
}

func (s *And_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnd_expr(s)
	}
}

func (p *IDLParser) And_expr() (localctx IAnd_exprContext) {
	this := p
	_ = this

	localctx = NewAnd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, IDLParserRULE_and_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Shift_expr()
	}
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserAMPERSAND {
		{
			p.SetState(619)
			p.Match(IDLParserAMPERSAND)
		}
		{
			p.SetState(620)
			p.Shift_expr()
		}

		p.SetState(625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IShift_exprContext is an interface to support dynamic dispatch.
type IShift_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_exprContext differentiates from other interfaces.
	IsShift_exprContext()
}

type Shift_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_exprContext() *Shift_exprContext {
	var p = new(Shift_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_shift_expr
	return p
}

func (*Shift_exprContext) IsShift_exprContext() {}

func NewShift_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_exprContext {
	var p = new(Shift_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_shift_expr

	return p
}

func (s *Shift_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_exprContext) AllAdd_expr() []IAdd_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdd_exprContext)(nil)).Elem())
	var tst = make([]IAdd_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdd_exprContext)
		}
	}

	return tst
}

func (s *Shift_exprContext) Add_expr(i int) IAdd_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdd_exprContext)
}

func (s *Shift_exprContext) AllRIGHT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(IDLParserRIGHT_SHIFT)
}

func (s *Shift_exprContext) RIGHT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_SHIFT, i)
}

func (s *Shift_exprContext) AllLEFT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(IDLParserLEFT_SHIFT)
}

func (s *Shift_exprContext) LEFT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_SHIFT, i)
}

func (s *Shift_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterShift_expr(s)
	}
}

func (s *Shift_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitShift_expr(s)
	}
}

func (p *IDLParser) Shift_expr() (localctx IShift_exprContext) {
	this := p
	_ = this

	localctx = NewShift_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, IDLParserRULE_shift_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.Add_expr()
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserRIGHT_SHIFT || _la == IDLParserLEFT_SHIFT {
		{
			p.SetState(627)
			_la = p.GetTokenStream().LA(1)

			if !(_la == IDLParserRIGHT_SHIFT || _la == IDLParserLEFT_SHIFT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(628)
			p.Add_expr()
		}

		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAdd_exprContext is an interface to support dynamic dispatch.
type IAdd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdd_exprContext differentiates from other interfaces.
	IsAdd_exprContext()
}

type Add_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_exprContext() *Add_exprContext {
	var p = new(Add_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_add_expr
	return p
}

func (*Add_exprContext) IsAdd_exprContext() {}

func NewAdd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_exprContext {
	var p = new(Add_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_add_expr

	return p
}

func (s *Add_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_exprContext) AllMult_expr() []IMult_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMult_exprContext)(nil)).Elem())
	var tst = make([]IMult_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMult_exprContext)
		}
	}

	return tst
}

func (s *Add_exprContext) Mult_expr(i int) IMult_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMult_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMult_exprContext)
}

func (s *Add_exprContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(IDLParserPLUS)
}

func (s *Add_exprContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserPLUS, i)
}

func (s *Add_exprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(IDLParserMINUS)
}

func (s *Add_exprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserMINUS, i)
}

func (s *Add_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAdd_expr(s)
	}
}

func (s *Add_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAdd_expr(s)
	}
}

func (p *IDLParser) Add_expr() (localctx IAdd_exprContext) {
	this := p
	_ = this

	localctx = NewAdd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, IDLParserRULE_add_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(634)
		p.Mult_expr()
	}
	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserPLUS || _la == IDLParserMINUS {
		{
			p.SetState(635)
			_la = p.GetTokenStream().LA(1)

			if !(_la == IDLParserPLUS || _la == IDLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(636)
			p.Mult_expr()
		}

		p.SetState(641)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMult_exprContext is an interface to support dynamic dispatch.
type IMult_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMult_exprContext differentiates from other interfaces.
	IsMult_exprContext()
}

type Mult_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMult_exprContext() *Mult_exprContext {
	var p = new(Mult_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_mult_expr
	return p
}

func (*Mult_exprContext) IsMult_exprContext() {}

func NewMult_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mult_exprContext {
	var p = new(Mult_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_mult_expr

	return p
}

func (s *Mult_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Mult_exprContext) AllUnary_expr() []IUnary_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnary_exprContext)(nil)).Elem())
	var tst = make([]IUnary_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnary_exprContext)
		}
	}

	return tst
}

func (s *Mult_exprContext) Unary_expr(i int) IUnary_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnary_exprContext)
}

func (s *Mult_exprContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(IDLParserSTAR)
}

func (s *Mult_exprContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserSTAR, i)
}

func (s *Mult_exprContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(IDLParserSLASH)
}

func (s *Mult_exprContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserSLASH, i)
}

func (s *Mult_exprContext) AllPERCENT() []antlr.TerminalNode {
	return s.GetTokens(IDLParserPERCENT)
}

func (s *Mult_exprContext) PERCENT(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserPERCENT, i)
}

func (s *Mult_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mult_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mult_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterMult_expr(s)
	}
}

func (s *Mult_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitMult_expr(s)
	}
}

func (p *IDLParser) Mult_expr() (localctx IMult_exprContext) {
	this := p
	_ = this

	localctx = NewMult_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, IDLParserRULE_mult_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.Unary_expr()
	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<IDLParserSLASH)|(1<<IDLParserSTAR)|(1<<IDLParserPERCENT))) != 0 {
		{
			p.SetState(643)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<IDLParserSLASH)|(1<<IDLParserSTAR)|(1<<IDLParserPERCENT))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(644)
			p.Unary_expr()
		}

		p.SetState(649)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnary_exprContext is an interface to support dynamic dispatch.
type IUnary_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_exprContext differentiates from other interfaces.
	IsUnary_exprContext()
}

type Unary_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_exprContext() *Unary_exprContext {
	var p = new(Unary_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unary_expr
	return p
}

func (*Unary_exprContext) IsUnary_exprContext() {}

func NewUnary_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_exprContext {
	var p = new(Unary_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unary_expr

	return p
}

func (s *Unary_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_exprContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Unary_exprContext) Primary_expr() IPrimary_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_exprContext)
}

func (s *Unary_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnary_expr(s)
	}
}

func (s *Unary_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnary_expr(s)
	}
}

func (p *IDLParser) Unary_expr() (localctx IUnary_exprContext) {
	this := p
	_ = this

	localctx = NewUnary_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, IDLParserRULE_unary_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(654)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserTILDE, IDLParserPLUS, IDLParserMINUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(650)
			p.Unary_operator()
		}
		{
			p.SetState(651)
			p.Primary_expr()
		}

	case IDLParserINTEGER_LITERAL, IDLParserOCTAL_LITERAL, IDLParserHEX_LITERAL, IDLParserFLOATING_PT_LITERAL, IDLParserFIXED_PT_LITERAL, IDLParserWIDE_CHARACTER_LITERAL, IDLParserCHARACTER_LITERAL, IDLParserWIDE_STRING_LITERAL, IDLParserSTRING_LITERAL, IDLParserBOOLEAN_LITERAL, IDLParserLEFT_BRACKET, IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)
			p.Primary_expr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(IDLParserMINUS, 0)
}

func (s *Unary_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(IDLParserPLUS, 0)
}

func (s *Unary_operatorContext) TILDE() antlr.TerminalNode {
	return s.GetToken(IDLParserTILDE, 0)
}

func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (p *IDLParser) Unary_operator() (localctx IUnary_operatorContext) {
	this := p
	_ = this

	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, IDLParserRULE_unary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<IDLParserTILDE)|(1<<IDLParserPLUS)|(1<<IDLParserMINUS))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimary_exprContext is an interface to support dynamic dispatch.
type IPrimary_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_exprContext differentiates from other interfaces.
	IsPrimary_exprContext()
}

type Primary_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_exprContext() *Primary_exprContext {
	var p = new(Primary_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_primary_expr
	return p
}

func (*Primary_exprContext) IsPrimary_exprContext() {}

func NewPrimary_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_exprContext {
	var p = new(Primary_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_primary_expr

	return p
}

func (s *Primary_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_exprContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Primary_exprContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Primary_exprContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Primary_exprContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Primary_exprContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Primary_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterPrimary_expr(s)
	}
}

func (s *Primary_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitPrimary_expr(s)
	}
}

func (p *IDLParser) Primary_expr() (localctx IPrimary_exprContext) {
	this := p
	_ = this

	localctx = NewPrimary_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, IDLParserRULE_primary_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(664)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(658)
			p.Scoped_name()
		}

	case IDLParserINTEGER_LITERAL, IDLParserOCTAL_LITERAL, IDLParserHEX_LITERAL, IDLParserFLOATING_PT_LITERAL, IDLParserFIXED_PT_LITERAL, IDLParserWIDE_CHARACTER_LITERAL, IDLParserCHARACTER_LITERAL, IDLParserWIDE_STRING_LITERAL, IDLParserSTRING_LITERAL, IDLParserBOOLEAN_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(659)
			p.Literal()
		}

	case IDLParserLEFT_BRACKET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(660)
			p.Match(IDLParserLEFT_BRACKET)
		}
		{
			p.SetState(661)
			p.Const_exp()
		}
		{
			p.SetState(662)
			p.Match(IDLParserRIGHT_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserHEX_LITERAL, 0)
}

func (s *LiteralContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserINTEGER_LITERAL, 0)
}

func (s *LiteralContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserOCTAL_LITERAL, 0)
}

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) WIDE_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserWIDE_STRING_LITERAL, 0)
}

func (s *LiteralContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserCHARACTER_LITERAL, 0)
}

func (s *LiteralContext) WIDE_CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserWIDE_CHARACTER_LITERAL, 0)
}

func (s *LiteralContext) FIXED_PT_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserFIXED_PT_LITERAL, 0)
}

func (s *LiteralContext) FLOATING_PT_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserFLOATING_PT_LITERAL, 0)
}

func (s *LiteralContext) BOOLEAN_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserBOOLEAN_LITERAL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *IDLParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, IDLParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<IDLParserINTEGER_LITERAL)|(1<<IDLParserOCTAL_LITERAL)|(1<<IDLParserHEX_LITERAL)|(1<<IDLParserFLOATING_PT_LITERAL)|(1<<IDLParserFIXED_PT_LITERAL)|(1<<IDLParserWIDE_CHARACTER_LITERAL)|(1<<IDLParserCHARACTER_LITERAL)|(1<<IDLParserWIDE_STRING_LITERAL)|(1<<IDLParserSTRING_LITERAL)|(1<<IDLParserBOOLEAN_LITERAL))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPositive_int_constContext is an interface to support dynamic dispatch.
type IPositive_int_constContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPositive_int_constContext differentiates from other interfaces.
	IsPositive_int_constContext()
}

type Positive_int_constContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPositive_int_constContext() *Positive_int_constContext {
	var p = new(Positive_int_constContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_positive_int_const
	return p
}

func (*Positive_int_constContext) IsPositive_int_constContext() {}

func NewPositive_int_constContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Positive_int_constContext {
	var p = new(Positive_int_constContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_positive_int_const

	return p
}

func (s *Positive_int_constContext) GetParser() antlr.Parser { return s.parser }

func (s *Positive_int_constContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Positive_int_constContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Positive_int_constContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Positive_int_constContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterPositive_int_const(s)
	}
}

func (s *Positive_int_constContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitPositive_int_const(s)
	}
}

func (p *IDLParser) Positive_int_const() (localctx IPositive_int_constContext) {
	this := p
	_ = this

	localctx = NewPositive_int_constContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, IDLParserRULE_positive_int_const)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		p.Const_exp()
	}

	return localctx
}

// IType_declContext is an interface to support dynamic dispatch.
type IType_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_declContext differentiates from other interfaces.
	IsType_declContext()
}

type Type_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declContext() *Type_declContext {
	var p = new(Type_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_decl
	return p
}

func (*Type_declContext) IsType_declContext() {}

func NewType_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declContext {
	var p = new(Type_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_decl

	return p
}

func (s *Type_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declContext) KW_TYPEDEF() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_TYPEDEF, 0)
}

func (s *Type_declContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Type_declContext) Type_declarator() IType_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declaratorContext)
}

func (s *Type_declContext) Struct_type() IStruct_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Type_declContext) Union_type() IUnion_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnion_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnion_typeContext)
}

func (s *Type_declContext) Enum_type() IEnum_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_typeContext)
}

func (s *Type_declContext) Bitset_type() IBitset_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitset_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitset_typeContext)
}

func (s *Type_declContext) Bitmask_type() IBitmask_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitmask_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitmask_typeContext)
}

func (s *Type_declContext) KW_NATIVE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_NATIVE, 0)
}

func (s *Type_declContext) Simple_declarator() ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Type_declContext) Constr_forward_decl() IConstr_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstr_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstr_forward_declContext)
}

func (s *Type_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_decl(s)
	}
}

func (s *Type_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_decl(s)
	}
}

func (p *IDLParser) Type_decl() (localctx IType_declContext) {
	this := p
	_ = this

	localctx = NewType_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, IDLParserRULE_type_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(670)
			p.Match(IDLParserKW_TYPEDEF)
		}
		{
			p.SetState(671)
			p.Annapps()
		}
		{
			p.SetState(672)
			p.Type_declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(674)
			p.Struct_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(675)
			p.Union_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(676)
			p.Enum_type()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(677)
			p.Bitset_type()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(678)
			p.Bitmask_type()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(679)
			p.Match(IDLParserKW_NATIVE)
		}
		{
			p.SetState(680)
			p.Annapps()
		}
		{
			p.SetState(681)
			p.Simple_declarator()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(683)
			p.Constr_forward_decl()
		}

	}

	return localctx
}

// IType_declaratorContext is an interface to support dynamic dispatch.
type IType_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_declaratorContext differentiates from other interfaces.
	IsType_declaratorContext()
}

type Type_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declaratorContext() *Type_declaratorContext {
	var p = new(Type_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_declarator
	return p
}

func (*Type_declaratorContext) IsType_declaratorContext() {}

func NewType_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declaratorContext {
	var p = new(Type_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_declarator

	return p
}

func (s *Type_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declaratorContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Type_declaratorContext) Declarators() IDeclaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorsContext)
}

func (s *Type_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_declarator(s)
	}
}

func (s *Type_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_declarator(s)
	}
}

func (p *IDLParser) Type_declarator() (localctx IType_declaratorContext) {
	this := p
	_ = this

	localctx = NewType_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, IDLParserRULE_type_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Type_spec()
	}
	{
		p.SetState(687)
		p.Declarators()
	}

	return localctx
}

// IType_specContext is an interface to support dynamic dispatch.
type IType_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specContext differentiates from other interfaces.
	IsType_specContext()
}

type Type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specContext() *Type_specContext {
	var p = new(Type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_spec
	return p
}

func (*Type_specContext) IsType_specContext() {}

func NewType_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specContext {
	var p = new(Type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_spec

	return p
}

func (s *Type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specContext) Simple_type_spec() ISimple_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_type_specContext)
}

func (s *Type_specContext) Constr_type_spec() IConstr_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstr_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstr_type_specContext)
}

func (s *Type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_spec(s)
	}
}

func (s *Type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_spec(s)
	}
}

func (p *IDLParser) Type_spec() (localctx IType_specContext) {
	this := p
	_ = this

	localctx = NewType_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, IDLParserRULE_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(691)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserKW_STRING, IDLParserKW_OCTET, IDLParserKW_SEQUENCE, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_WSTRING, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_FIXED, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserKW_SET, IDLParserKW_MAP, IDLParserKW_INT8, IDLParserKW_UINT8, IDLParserKW_INT16, IDLParserKW_UINT16, IDLParserKW_INT32, IDLParserKW_UINT32, IDLParserKW_INT64, IDLParserKW_UINT64, IDLParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(689)
			p.Simple_type_spec()
		}

	case IDLParserKW_STRUCT, IDLParserKW_ENUM, IDLParserKW_UNION, IDLParserKW_BITSET, IDLParserKW_BITMASK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(690)
			p.Constr_type_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimple_type_specContext is an interface to support dynamic dispatch.
type ISimple_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_type_specContext differentiates from other interfaces.
	IsSimple_type_specContext()
}

type Simple_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_type_specContext() *Simple_type_specContext {
	var p = new(Simple_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_simple_type_spec
	return p
}

func (*Simple_type_specContext) IsSimple_type_specContext() {}

func NewSimple_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_type_specContext {
	var p = new(Simple_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_simple_type_spec

	return p
}

func (s *Simple_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_type_specContext) Base_type_spec() IBase_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_type_specContext)
}

func (s *Simple_type_specContext) Template_type_spec() ITemplate_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_specContext)
}

func (s *Simple_type_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Simple_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSimple_type_spec(s)
	}
}

func (s *Simple_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSimple_type_spec(s)
	}
}

func (p *IDLParser) Simple_type_spec() (localctx ISimple_type_specContext) {
	this := p
	_ = this

	localctx = NewSimple_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, IDLParserRULE_simple_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(696)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_OCTET, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserKW_INT8, IDLParserKW_UINT8, IDLParserKW_INT16, IDLParserKW_UINT16, IDLParserKW_INT32, IDLParserKW_UINT32, IDLParserKW_INT64, IDLParserKW_UINT64:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(693)
			p.Base_type_spec()
		}

	case IDLParserKW_STRING, IDLParserKW_SEQUENCE, IDLParserKW_WSTRING, IDLParserKW_FIXED, IDLParserKW_SET, IDLParserKW_MAP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(694)
			p.Template_type_spec()
		}

	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(695)
			p.Scoped_name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBitfield_type_specContext is an interface to support dynamic dispatch.
type IBitfield_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitfield_type_specContext differentiates from other interfaces.
	IsBitfield_type_specContext()
}

type Bitfield_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitfield_type_specContext() *Bitfield_type_specContext {
	var p = new(Bitfield_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_bitfield_type_spec
	return p
}

func (*Bitfield_type_specContext) IsBitfield_type_specContext() {}

func NewBitfield_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bitfield_type_specContext {
	var p = new(Bitfield_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_bitfield_type_spec

	return p
}

func (s *Bitfield_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Bitfield_type_specContext) Integer_type() IInteger_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *Bitfield_type_specContext) Boolean_type() IBoolean_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_typeContext)
}

func (s *Bitfield_type_specContext) Octet_type() IOctet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctet_typeContext)
}

func (s *Bitfield_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bitfield_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bitfield_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBitfield_type_spec(s)
	}
}

func (s *Bitfield_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBitfield_type_spec(s)
	}
}

func (p *IDLParser) Bitfield_type_spec() (localctx IBitfield_type_specContext) {
	this := p
	_ = this

	localctx = NewBitfield_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, IDLParserRULE_bitfield_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(701)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_UNSIGNED, IDLParserKW_INT8, IDLParserKW_UINT8, IDLParserKW_INT16, IDLParserKW_UINT16, IDLParserKW_INT32, IDLParserKW_UINT32, IDLParserKW_INT64, IDLParserKW_UINT64:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)
			p.Integer_type()
		}

	case IDLParserKW_BOOLEAN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(699)
			p.Boolean_type()
		}

	case IDLParserKW_OCTET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(700)
			p.Octet_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBase_type_specContext is an interface to support dynamic dispatch.
type IBase_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_type_specContext differentiates from other interfaces.
	IsBase_type_specContext()
}

type Base_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_type_specContext() *Base_type_specContext {
	var p = new(Base_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_base_type_spec
	return p
}

func (*Base_type_specContext) IsBase_type_specContext() {}

func NewBase_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_type_specContext {
	var p = new(Base_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_base_type_spec

	return p
}

func (s *Base_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_type_specContext) Floating_pt_type() IFloating_pt_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloating_pt_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloating_pt_typeContext)
}

func (s *Base_type_specContext) Integer_type() IInteger_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *Base_type_specContext) Char_type() IChar_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_typeContext)
}

func (s *Base_type_specContext) Wide_char_type() IWide_char_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_char_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_char_typeContext)
}

func (s *Base_type_specContext) Boolean_type() IBoolean_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_typeContext)
}

func (s *Base_type_specContext) Octet_type() IOctet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctet_typeContext)
}

func (s *Base_type_specContext) Any_type() IAny_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAny_typeContext)
}

func (s *Base_type_specContext) Object_type() IObject_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_typeContext)
}

func (s *Base_type_specContext) Value_base_type() IValue_base_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_base_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_base_typeContext)
}

func (s *Base_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBase_type_spec(s)
	}
}

func (s *Base_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBase_type_spec(s)
	}
}

func (p *IDLParser) Base_type_spec() (localctx IBase_type_specContext) {
	this := p
	_ = this

	localctx = NewBase_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, IDLParserRULE_base_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(703)
			p.Floating_pt_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(704)
			p.Integer_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(705)
			p.Char_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(706)
			p.Wide_char_type()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(707)
			p.Boolean_type()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(708)
			p.Octet_type()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(709)
			p.Any_type()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(710)
			p.Object_type()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(711)
			p.Value_base_type()
		}

	}

	return localctx
}

// ITemplate_type_specContext is an interface to support dynamic dispatch.
type ITemplate_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_type_specContext differentiates from other interfaces.
	IsTemplate_type_specContext()
}

type Template_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_type_specContext() *Template_type_specContext {
	var p = new(Template_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_template_type_spec
	return p
}

func (*Template_type_specContext) IsTemplate_type_specContext() {}

func NewTemplate_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_type_specContext {
	var p = new(Template_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_template_type_spec

	return p
}

func (s *Template_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_type_specContext) Sequence_type() ISequence_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_typeContext)
}

func (s *Template_type_specContext) Set_type() ISet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_typeContext)
}

func (s *Template_type_specContext) Map_type() IMap_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMap_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMap_typeContext)
}

func (s *Template_type_specContext) String_type() IString_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_typeContext)
}

func (s *Template_type_specContext) Wide_string_type() IWide_string_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_string_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_string_typeContext)
}

func (s *Template_type_specContext) Fixed_pt_type() IFixed_pt_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFixed_pt_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFixed_pt_typeContext)
}

func (s *Template_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterTemplate_type_spec(s)
	}
}

func (s *Template_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitTemplate_type_spec(s)
	}
}

func (p *IDLParser) Template_type_spec() (localctx ITemplate_type_specContext) {
	this := p
	_ = this

	localctx = NewTemplate_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, IDLParserRULE_template_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(720)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_SEQUENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(714)
			p.Sequence_type()
		}

	case IDLParserKW_SET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(715)
			p.Set_type()
		}

	case IDLParserKW_MAP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(716)
			p.Map_type()
		}

	case IDLParserKW_STRING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(717)
			p.String_type()
		}

	case IDLParserKW_WSTRING:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(718)
			p.Wide_string_type()
		}

	case IDLParserKW_FIXED:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(719)
			p.Fixed_pt_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstr_type_specContext is an interface to support dynamic dispatch.
type IConstr_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstr_type_specContext differentiates from other interfaces.
	IsConstr_type_specContext()
}

type Constr_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstr_type_specContext() *Constr_type_specContext {
	var p = new(Constr_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_constr_type_spec
	return p
}

func (*Constr_type_specContext) IsConstr_type_specContext() {}

func NewConstr_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constr_type_specContext {
	var p = new(Constr_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_constr_type_spec

	return p
}

func (s *Constr_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Constr_type_specContext) Struct_type() IStruct_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Constr_type_specContext) Union_type() IUnion_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnion_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnion_typeContext)
}

func (s *Constr_type_specContext) Enum_type() IEnum_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_typeContext)
}

func (s *Constr_type_specContext) Bitset_type() IBitset_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitset_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitset_typeContext)
}

func (s *Constr_type_specContext) Bitmask_type() IBitmask_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitmask_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitmask_typeContext)
}

func (s *Constr_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constr_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constr_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConstr_type_spec(s)
	}
}

func (s *Constr_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConstr_type_spec(s)
	}
}

func (p *IDLParser) Constr_type_spec() (localctx IConstr_type_specContext) {
	this := p
	_ = this

	localctx = NewConstr_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, IDLParserRULE_constr_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(727)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_STRUCT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(722)
			p.Struct_type()
		}

	case IDLParserKW_UNION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(723)
			p.Union_type()
		}

	case IDLParserKW_ENUM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(724)
			p.Enum_type()
		}

	case IDLParserKW_BITSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(725)
			p.Bitset_type()
		}

	case IDLParserKW_BITMASK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(726)
			p.Bitmask_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimple_declaratorsContext is an interface to support dynamic dispatch.
type ISimple_declaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_declaratorsContext differentiates from other interfaces.
	IsSimple_declaratorsContext()
}

type Simple_declaratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_declaratorsContext() *Simple_declaratorsContext {
	var p = new(Simple_declaratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_simple_declarators
	return p
}

func (*Simple_declaratorsContext) IsSimple_declaratorsContext() {}

func NewSimple_declaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_declaratorsContext {
	var p = new(Simple_declaratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_simple_declarators

	return p
}

func (s *Simple_declaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_declaratorsContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Simple_declaratorsContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Simple_declaratorsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Simple_declaratorsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Simple_declaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_declaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_declaratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSimple_declarators(s)
	}
}

func (s *Simple_declaratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSimple_declarators(s)
	}
}

func (p *IDLParser) Simple_declarators() (localctx ISimple_declaratorsContext) {
	this := p
	_ = this

	localctx = NewSimple_declaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, IDLParserRULE_simple_declarators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.Identifier()
	}
	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(730)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(731)
			p.Identifier()
		}

		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclaratorsContext is an interface to support dynamic dispatch.
type IDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorsContext differentiates from other interfaces.
	IsDeclaratorsContext()
}

type DeclaratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorsContext() *DeclaratorsContext {
	var p = new(DeclaratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_declarators
	return p
}

func (*DeclaratorsContext) IsDeclaratorsContext() {}

func NewDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorsContext {
	var p = new(DeclaratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_declarators

	return p
}

func (s *DeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorsContext) AllDeclarator() []IDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem())
	var tst = make([]IDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclaratorContext)
		}
	}

	return tst
}

func (s *DeclaratorsContext) Declarator(i int) IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *DeclaratorsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *DeclaratorsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *DeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterDeclarators(s)
	}
}

func (s *DeclaratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitDeclarators(s)
	}
}

func (p *IDLParser) Declarators() (localctx IDeclaratorsContext) {
	this := p
	_ = this

	localctx = NewDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, IDLParserRULE_declarators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		p.Declarator()
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(738)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(739)
			p.Declarator()
		}

		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_declarator
	return p
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *DeclaratorContext) Simple_declarator() ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *DeclaratorContext) Complex_declarator() IComplex_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComplex_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComplex_declaratorContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterDeclarator(s)
	}
}

func (s *DeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitDeclarator(s)
	}
}

func (p *IDLParser) Declarator() (localctx IDeclaratorContext) {
	this := p
	_ = this

	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, IDLParserRULE_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Annapps()
	}
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(746)
			p.Simple_declarator()
		}

	case 2:
		{
			p.SetState(747)
			p.Complex_declarator()
		}

	}

	return localctx
}

// ISimple_declaratorContext is an interface to support dynamic dispatch.
type ISimple_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_declaratorContext differentiates from other interfaces.
	IsSimple_declaratorContext()
}

type Simple_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_declaratorContext() *Simple_declaratorContext {
	var p = new(Simple_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_simple_declarator
	return p
}

func (*Simple_declaratorContext) IsSimple_declaratorContext() {}

func NewSimple_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_declaratorContext {
	var p = new(Simple_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_simple_declarator

	return p
}

func (s *Simple_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_declaratorContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Simple_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSimple_declarator(s)
	}
}

func (s *Simple_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSimple_declarator(s)
	}
}

func (p *IDLParser) Simple_declarator() (localctx ISimple_declaratorContext) {
	this := p
	_ = this

	localctx = NewSimple_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, IDLParserRULE_simple_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(750)
		p.Match(IDLParserID)
	}

	return localctx
}

// IComplex_declaratorContext is an interface to support dynamic dispatch.
type IComplex_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComplex_declaratorContext differentiates from other interfaces.
	IsComplex_declaratorContext()
}

type Complex_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplex_declaratorContext() *Complex_declaratorContext {
	var p = new(Complex_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_complex_declarator
	return p
}

func (*Complex_declaratorContext) IsComplex_declaratorContext() {}

func NewComplex_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Complex_declaratorContext {
	var p = new(Complex_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_complex_declarator

	return p
}

func (s *Complex_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Complex_declaratorContext) Array_declarator() IArray_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_declaratorContext)
}

func (s *Complex_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Complex_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Complex_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComplex_declarator(s)
	}
}

func (s *Complex_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComplex_declarator(s)
	}
}

func (p *IDLParser) Complex_declarator() (localctx IComplex_declaratorContext) {
	this := p
	_ = this

	localctx = NewComplex_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, IDLParserRULE_complex_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		p.Array_declarator()
	}

	return localctx
}

// IFloating_pt_typeContext is an interface to support dynamic dispatch.
type IFloating_pt_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloating_pt_typeContext differentiates from other interfaces.
	IsFloating_pt_typeContext()
}

type Floating_pt_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloating_pt_typeContext() *Floating_pt_typeContext {
	var p = new(Floating_pt_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_floating_pt_type
	return p
}

func (*Floating_pt_typeContext) IsFloating_pt_typeContext() {}

func NewFloating_pt_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Floating_pt_typeContext {
	var p = new(Floating_pt_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_floating_pt_type

	return p
}

func (s *Floating_pt_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Floating_pt_typeContext) KW_FLOAT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FLOAT, 0)
}

func (s *Floating_pt_typeContext) KW_DOUBLE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_DOUBLE, 0)
}

func (s *Floating_pt_typeContext) KW_LONG() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, 0)
}

func (s *Floating_pt_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Floating_pt_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Floating_pt_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFloating_pt_type(s)
	}
}

func (s *Floating_pt_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFloating_pt_type(s)
	}
}

func (p *IDLParser) Floating_pt_type() (localctx IFloating_pt_typeContext) {
	this := p
	_ = this

	localctx = NewFloating_pt_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, IDLParserRULE_floating_pt_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(758)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_FLOAT:
		{
			p.SetState(754)
			p.Match(IDLParserKW_FLOAT)
		}

	case IDLParserKW_DOUBLE:
		{
			p.SetState(755)
			p.Match(IDLParserKW_DOUBLE)
		}

	case IDLParserKW_LONG:
		{
			p.SetState(756)
			p.Match(IDLParserKW_LONG)
		}
		{
			p.SetState(757)
			p.Match(IDLParserKW_DOUBLE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInteger_typeContext is an interface to support dynamic dispatch.
type IInteger_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_typeContext differentiates from other interfaces.
	IsInteger_typeContext()
}

type Integer_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_typeContext() *Integer_typeContext {
	var p = new(Integer_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_integer_type
	return p
}

func (*Integer_typeContext) IsInteger_typeContext() {}

func NewInteger_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_typeContext {
	var p = new(Integer_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_integer_type

	return p
}

func (s *Integer_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_typeContext) Signed_int() ISigned_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigned_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigned_intContext)
}

func (s *Integer_typeContext) Unsigned_int() IUnsigned_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsigned_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsigned_intContext)
}

func (s *Integer_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInteger_type(s)
	}
}

func (s *Integer_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInteger_type(s)
	}
}

func (p *IDLParser) Integer_type() (localctx IInteger_typeContext) {
	this := p
	_ = this

	localctx = NewInteger_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, IDLParserRULE_integer_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(762)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_INT8, IDLParserKW_INT16, IDLParserKW_INT32, IDLParserKW_INT64:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(760)
			p.Signed_int()
		}

	case IDLParserKW_UNSIGNED, IDLParserKW_UINT8, IDLParserKW_UINT16, IDLParserKW_UINT32, IDLParserKW_UINT64:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(761)
			p.Unsigned_int()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISigned_intContext is an interface to support dynamic dispatch.
type ISigned_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigned_intContext differentiates from other interfaces.
	IsSigned_intContext()
}

type Signed_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_intContext() *Signed_intContext {
	var p = new(Signed_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_signed_int
	return p
}

func (*Signed_intContext) IsSigned_intContext() {}

func NewSigned_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_intContext {
	var p = new(Signed_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_signed_int

	return p
}

func (s *Signed_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_intContext) Signed_short_int() ISigned_short_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigned_short_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigned_short_intContext)
}

func (s *Signed_intContext) Signed_long_int() ISigned_long_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigned_long_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigned_long_intContext)
}

func (s *Signed_intContext) Signed_longlong_int() ISigned_longlong_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigned_longlong_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigned_longlong_intContext)
}

func (s *Signed_intContext) Signed_tiny_int() ISigned_tiny_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigned_tiny_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigned_tiny_intContext)
}

func (s *Signed_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSigned_int(s)
	}
}

func (s *Signed_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSigned_int(s)
	}
}

func (p *IDLParser) Signed_int() (localctx ISigned_intContext) {
	this := p
	_ = this

	localctx = NewSigned_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, IDLParserRULE_signed_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(764)
			p.Signed_short_int()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(765)
			p.Signed_long_int()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(766)
			p.Signed_longlong_int()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(767)
			p.Signed_tiny_int()
		}

	}

	return localctx
}

// ISigned_tiny_intContext is an interface to support dynamic dispatch.
type ISigned_tiny_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigned_tiny_intContext differentiates from other interfaces.
	IsSigned_tiny_intContext()
}

type Signed_tiny_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_tiny_intContext() *Signed_tiny_intContext {
	var p = new(Signed_tiny_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_signed_tiny_int
	return p
}

func (*Signed_tiny_intContext) IsSigned_tiny_intContext() {}

func NewSigned_tiny_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_tiny_intContext {
	var p = new(Signed_tiny_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_signed_tiny_int

	return p
}

func (s *Signed_tiny_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_tiny_intContext) KW_INT8() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INT8, 0)
}

func (s *Signed_tiny_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_tiny_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_tiny_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSigned_tiny_int(s)
	}
}

func (s *Signed_tiny_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSigned_tiny_int(s)
	}
}

func (p *IDLParser) Signed_tiny_int() (localctx ISigned_tiny_intContext) {
	this := p
	_ = this

	localctx = NewSigned_tiny_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, IDLParserRULE_signed_tiny_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		p.Match(IDLParserKW_INT8)
	}

	return localctx
}

// ISigned_short_intContext is an interface to support dynamic dispatch.
type ISigned_short_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigned_short_intContext differentiates from other interfaces.
	IsSigned_short_intContext()
}

type Signed_short_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_short_intContext() *Signed_short_intContext {
	var p = new(Signed_short_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_signed_short_int
	return p
}

func (*Signed_short_intContext) IsSigned_short_intContext() {}

func NewSigned_short_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_short_intContext {
	var p = new(Signed_short_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_signed_short_int

	return p
}

func (s *Signed_short_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_short_intContext) KW_SHORT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SHORT, 0)
}

func (s *Signed_short_intContext) KW_INT16() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INT16, 0)
}

func (s *Signed_short_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_short_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_short_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSigned_short_int(s)
	}
}

func (s *Signed_short_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSigned_short_int(s)
	}
}

func (p *IDLParser) Signed_short_int() (localctx ISigned_short_intContext) {
	this := p
	_ = this

	localctx = NewSigned_short_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, IDLParserRULE_signed_short_int)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		_la = p.GetTokenStream().LA(1)

		if !(_la == IDLParserKW_SHORT || _la == IDLParserKW_INT16) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISigned_long_intContext is an interface to support dynamic dispatch.
type ISigned_long_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigned_long_intContext differentiates from other interfaces.
	IsSigned_long_intContext()
}

type Signed_long_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_long_intContext() *Signed_long_intContext {
	var p = new(Signed_long_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_signed_long_int
	return p
}

func (*Signed_long_intContext) IsSigned_long_intContext() {}

func NewSigned_long_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_long_intContext {
	var p = new(Signed_long_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_signed_long_int

	return p
}

func (s *Signed_long_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_long_intContext) KW_LONG() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, 0)
}

func (s *Signed_long_intContext) KW_INT32() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INT32, 0)
}

func (s *Signed_long_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_long_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_long_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSigned_long_int(s)
	}
}

func (s *Signed_long_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSigned_long_int(s)
	}
}

func (p *IDLParser) Signed_long_int() (localctx ISigned_long_intContext) {
	this := p
	_ = this

	localctx = NewSigned_long_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, IDLParserRULE_signed_long_int)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		_la = p.GetTokenStream().LA(1)

		if !(_la == IDLParserKW_LONG || _la == IDLParserKW_INT32) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISigned_longlong_intContext is an interface to support dynamic dispatch.
type ISigned_longlong_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigned_longlong_intContext differentiates from other interfaces.
	IsSigned_longlong_intContext()
}

type Signed_longlong_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_longlong_intContext() *Signed_longlong_intContext {
	var p = new(Signed_longlong_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_signed_longlong_int
	return p
}

func (*Signed_longlong_intContext) IsSigned_longlong_intContext() {}

func NewSigned_longlong_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_longlong_intContext {
	var p = new(Signed_longlong_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_signed_longlong_int

	return p
}

func (s *Signed_longlong_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_longlong_intContext) AllKW_LONG() []antlr.TerminalNode {
	return s.GetTokens(IDLParserKW_LONG)
}

func (s *Signed_longlong_intContext) KW_LONG(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, i)
}

func (s *Signed_longlong_intContext) KW_INT64() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INT64, 0)
}

func (s *Signed_longlong_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_longlong_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_longlong_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSigned_longlong_int(s)
	}
}

func (s *Signed_longlong_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSigned_longlong_int(s)
	}
}

func (p *IDLParser) Signed_longlong_int() (localctx ISigned_longlong_intContext) {
	this := p
	_ = this

	localctx = NewSigned_longlong_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, IDLParserRULE_signed_longlong_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(779)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_LONG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(776)
			p.Match(IDLParserKW_LONG)
		}
		{
			p.SetState(777)
			p.Match(IDLParserKW_LONG)
		}

	case IDLParserKW_INT64:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(778)
			p.Match(IDLParserKW_INT64)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnsigned_intContext is an interface to support dynamic dispatch.
type IUnsigned_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsigned_intContext differentiates from other interfaces.
	IsUnsigned_intContext()
}

type Unsigned_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsigned_intContext() *Unsigned_intContext {
	var p = new(Unsigned_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unsigned_int
	return p
}

func (*Unsigned_intContext) IsUnsigned_intContext() {}

func NewUnsigned_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsigned_intContext {
	var p = new(Unsigned_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unsigned_int

	return p
}

func (s *Unsigned_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsigned_intContext) Unsigned_short_int() IUnsigned_short_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsigned_short_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsigned_short_intContext)
}

func (s *Unsigned_intContext) Unsigned_long_int() IUnsigned_long_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsigned_long_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsigned_long_intContext)
}

func (s *Unsigned_intContext) Unsigned_longlong_int() IUnsigned_longlong_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsigned_longlong_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsigned_longlong_intContext)
}

func (s *Unsigned_intContext) Unsigned_tiny_int() IUnsigned_tiny_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsigned_tiny_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsigned_tiny_intContext)
}

func (s *Unsigned_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsigned_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsigned_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnsigned_int(s)
	}
}

func (s *Unsigned_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnsigned_int(s)
	}
}

func (p *IDLParser) Unsigned_int() (localctx IUnsigned_intContext) {
	this := p
	_ = this

	localctx = NewUnsigned_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, IDLParserRULE_unsigned_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(781)
			p.Unsigned_short_int()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(782)
			p.Unsigned_long_int()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(783)
			p.Unsigned_longlong_int()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(784)
			p.Unsigned_tiny_int()
		}

	}

	return localctx
}

// IUnsigned_tiny_intContext is an interface to support dynamic dispatch.
type IUnsigned_tiny_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsigned_tiny_intContext differentiates from other interfaces.
	IsUnsigned_tiny_intContext()
}

type Unsigned_tiny_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsigned_tiny_intContext() *Unsigned_tiny_intContext {
	var p = new(Unsigned_tiny_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unsigned_tiny_int
	return p
}

func (*Unsigned_tiny_intContext) IsUnsigned_tiny_intContext() {}

func NewUnsigned_tiny_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsigned_tiny_intContext {
	var p = new(Unsigned_tiny_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unsigned_tiny_int

	return p
}

func (s *Unsigned_tiny_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsigned_tiny_intContext) KW_UINT8() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UINT8, 0)
}

func (s *Unsigned_tiny_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsigned_tiny_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsigned_tiny_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnsigned_tiny_int(s)
	}
}

func (s *Unsigned_tiny_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnsigned_tiny_int(s)
	}
}

func (p *IDLParser) Unsigned_tiny_int() (localctx IUnsigned_tiny_intContext) {
	this := p
	_ = this

	localctx = NewUnsigned_tiny_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, IDLParserRULE_unsigned_tiny_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.Match(IDLParserKW_UINT8)
	}

	return localctx
}

// IUnsigned_short_intContext is an interface to support dynamic dispatch.
type IUnsigned_short_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsigned_short_intContext differentiates from other interfaces.
	IsUnsigned_short_intContext()
}

type Unsigned_short_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsigned_short_intContext() *Unsigned_short_intContext {
	var p = new(Unsigned_short_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unsigned_short_int
	return p
}

func (*Unsigned_short_intContext) IsUnsigned_short_intContext() {}

func NewUnsigned_short_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsigned_short_intContext {
	var p = new(Unsigned_short_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unsigned_short_int

	return p
}

func (s *Unsigned_short_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsigned_short_intContext) KW_UNSIGNED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNSIGNED, 0)
}

func (s *Unsigned_short_intContext) KW_SHORT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SHORT, 0)
}

func (s *Unsigned_short_intContext) KW_UINT16() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UINT16, 0)
}

func (s *Unsigned_short_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsigned_short_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsigned_short_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnsigned_short_int(s)
	}
}

func (s *Unsigned_short_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnsigned_short_int(s)
	}
}

func (p *IDLParser) Unsigned_short_int() (localctx IUnsigned_short_intContext) {
	this := p
	_ = this

	localctx = NewUnsigned_short_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, IDLParserRULE_unsigned_short_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(792)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_UNSIGNED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(789)
			p.Match(IDLParserKW_UNSIGNED)
		}
		{
			p.SetState(790)
			p.Match(IDLParserKW_SHORT)
		}

	case IDLParserKW_UINT16:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(791)
			p.Match(IDLParserKW_UINT16)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnsigned_long_intContext is an interface to support dynamic dispatch.
type IUnsigned_long_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsigned_long_intContext differentiates from other interfaces.
	IsUnsigned_long_intContext()
}

type Unsigned_long_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsigned_long_intContext() *Unsigned_long_intContext {
	var p = new(Unsigned_long_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unsigned_long_int
	return p
}

func (*Unsigned_long_intContext) IsUnsigned_long_intContext() {}

func NewUnsigned_long_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsigned_long_intContext {
	var p = new(Unsigned_long_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unsigned_long_int

	return p
}

func (s *Unsigned_long_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsigned_long_intContext) KW_UNSIGNED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNSIGNED, 0)
}

func (s *Unsigned_long_intContext) KW_LONG() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, 0)
}

func (s *Unsigned_long_intContext) KW_UINT32() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UINT32, 0)
}

func (s *Unsigned_long_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsigned_long_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsigned_long_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnsigned_long_int(s)
	}
}

func (s *Unsigned_long_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnsigned_long_int(s)
	}
}

func (p *IDLParser) Unsigned_long_int() (localctx IUnsigned_long_intContext) {
	this := p
	_ = this

	localctx = NewUnsigned_long_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, IDLParserRULE_unsigned_long_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(797)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_UNSIGNED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(794)
			p.Match(IDLParserKW_UNSIGNED)
		}
		{
			p.SetState(795)
			p.Match(IDLParserKW_LONG)
		}

	case IDLParserKW_UINT32:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(796)
			p.Match(IDLParserKW_UINT32)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnsigned_longlong_intContext is an interface to support dynamic dispatch.
type IUnsigned_longlong_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsigned_longlong_intContext differentiates from other interfaces.
	IsUnsigned_longlong_intContext()
}

type Unsigned_longlong_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsigned_longlong_intContext() *Unsigned_longlong_intContext {
	var p = new(Unsigned_longlong_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unsigned_longlong_int
	return p
}

func (*Unsigned_longlong_intContext) IsUnsigned_longlong_intContext() {}

func NewUnsigned_longlong_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsigned_longlong_intContext {
	var p = new(Unsigned_longlong_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unsigned_longlong_int

	return p
}

func (s *Unsigned_longlong_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsigned_longlong_intContext) KW_UNSIGNED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNSIGNED, 0)
}

func (s *Unsigned_longlong_intContext) AllKW_LONG() []antlr.TerminalNode {
	return s.GetTokens(IDLParserKW_LONG)
}

func (s *Unsigned_longlong_intContext) KW_LONG(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, i)
}

func (s *Unsigned_longlong_intContext) KW_UINT64() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UINT64, 0)
}

func (s *Unsigned_longlong_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsigned_longlong_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsigned_longlong_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnsigned_longlong_int(s)
	}
}

func (s *Unsigned_longlong_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnsigned_longlong_int(s)
	}
}

func (p *IDLParser) Unsigned_longlong_int() (localctx IUnsigned_longlong_intContext) {
	this := p
	_ = this

	localctx = NewUnsigned_longlong_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, IDLParserRULE_unsigned_longlong_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(803)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_UNSIGNED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(799)
			p.Match(IDLParserKW_UNSIGNED)
		}
		{
			p.SetState(800)
			p.Match(IDLParserKW_LONG)
		}
		{
			p.SetState(801)
			p.Match(IDLParserKW_LONG)
		}

	case IDLParserKW_UINT64:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(802)
			p.Match(IDLParserKW_UINT64)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChar_typeContext is an interface to support dynamic dispatch.
type IChar_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChar_typeContext differentiates from other interfaces.
	IsChar_typeContext()
}

type Char_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChar_typeContext() *Char_typeContext {
	var p = new(Char_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_char_type
	return p
}

func (*Char_typeContext) IsChar_typeContext() {}

func NewChar_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Char_typeContext {
	var p = new(Char_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_char_type

	return p
}

func (s *Char_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Char_typeContext) KW_CHAR() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CHAR, 0)
}

func (s *Char_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Char_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Char_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterChar_type(s)
	}
}

func (s *Char_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitChar_type(s)
	}
}

func (p *IDLParser) Char_type() (localctx IChar_typeContext) {
	this := p
	_ = this

	localctx = NewChar_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, IDLParserRULE_char_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		p.Match(IDLParserKW_CHAR)
	}

	return localctx
}

// IWide_char_typeContext is an interface to support dynamic dispatch.
type IWide_char_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWide_char_typeContext differentiates from other interfaces.
	IsWide_char_typeContext()
}

type Wide_char_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWide_char_typeContext() *Wide_char_typeContext {
	var p = new(Wide_char_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_wide_char_type
	return p
}

func (*Wide_char_typeContext) IsWide_char_typeContext() {}

func NewWide_char_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wide_char_typeContext {
	var p = new(Wide_char_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_wide_char_type

	return p
}

func (s *Wide_char_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Wide_char_typeContext) KW_WCHAR() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_WCHAR, 0)
}

func (s *Wide_char_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wide_char_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wide_char_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterWide_char_type(s)
	}
}

func (s *Wide_char_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitWide_char_type(s)
	}
}

func (p *IDLParser) Wide_char_type() (localctx IWide_char_typeContext) {
	this := p
	_ = this

	localctx = NewWide_char_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, IDLParserRULE_wide_char_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(807)
		p.Match(IDLParserKW_WCHAR)
	}

	return localctx
}

// IBoolean_typeContext is an interface to support dynamic dispatch.
type IBoolean_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoolean_typeContext differentiates from other interfaces.
	IsBoolean_typeContext()
}

type Boolean_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolean_typeContext() *Boolean_typeContext {
	var p = new(Boolean_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_boolean_type
	return p
}

func (*Boolean_typeContext) IsBoolean_typeContext() {}

func NewBoolean_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Boolean_typeContext {
	var p = new(Boolean_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_boolean_type

	return p
}

func (s *Boolean_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Boolean_typeContext) KW_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_BOOLEAN, 0)
}

func (s *Boolean_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Boolean_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBoolean_type(s)
	}
}

func (s *Boolean_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBoolean_type(s)
	}
}

func (p *IDLParser) Boolean_type() (localctx IBoolean_typeContext) {
	this := p
	_ = this

	localctx = NewBoolean_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, IDLParserRULE_boolean_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(809)
		p.Match(IDLParserKW_BOOLEAN)
	}

	return localctx
}

// IOctet_typeContext is an interface to support dynamic dispatch.
type IOctet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctet_typeContext differentiates from other interfaces.
	IsOctet_typeContext()
}

type Octet_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctet_typeContext() *Octet_typeContext {
	var p = new(Octet_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_octet_type
	return p
}

func (*Octet_typeContext) IsOctet_typeContext() {}

func NewOctet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Octet_typeContext {
	var p = new(Octet_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_octet_type

	return p
}

func (s *Octet_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Octet_typeContext) KW_OCTET() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_OCTET, 0)
}

func (s *Octet_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Octet_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Octet_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOctet_type(s)
	}
}

func (s *Octet_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOctet_type(s)
	}
}

func (p *IDLParser) Octet_type() (localctx IOctet_typeContext) {
	this := p
	_ = this

	localctx = NewOctet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, IDLParserRULE_octet_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		p.Match(IDLParserKW_OCTET)
	}

	return localctx
}

// IAny_typeContext is an interface to support dynamic dispatch.
type IAny_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAny_typeContext differentiates from other interfaces.
	IsAny_typeContext()
}

type Any_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAny_typeContext() *Any_typeContext {
	var p = new(Any_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_any_type
	return p
}

func (*Any_typeContext) IsAny_typeContext() {}

func NewAny_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Any_typeContext {
	var p = new(Any_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_any_type

	return p
}

func (s *Any_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Any_typeContext) KW_ANY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ANY, 0)
}

func (s *Any_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Any_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Any_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAny_type(s)
	}
}

func (s *Any_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAny_type(s)
	}
}

func (p *IDLParser) Any_type() (localctx IAny_typeContext) {
	this := p
	_ = this

	localctx = NewAny_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, IDLParserRULE_any_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(813)
		p.Match(IDLParserKW_ANY)
	}

	return localctx
}

// IObject_typeContext is an interface to support dynamic dispatch.
type IObject_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_typeContext differentiates from other interfaces.
	IsObject_typeContext()
}

type Object_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_typeContext() *Object_typeContext {
	var p = new(Object_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_object_type
	return p
}

func (*Object_typeContext) IsObject_typeContext() {}

func NewObject_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_typeContext {
	var p = new(Object_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_object_type

	return p
}

func (s *Object_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_typeContext) KW_OBJECT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_OBJECT, 0)
}

func (s *Object_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterObject_type(s)
	}
}

func (s *Object_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitObject_type(s)
	}
}

func (p *IDLParser) Object_type() (localctx IObject_typeContext) {
	this := p
	_ = this

	localctx = NewObject_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, IDLParserRULE_object_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(815)
		p.Match(IDLParserKW_OBJECT)
	}

	return localctx
}

// IAnnotation_declContext is an interface to support dynamic dispatch.
type IAnnotation_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_declContext differentiates from other interfaces.
	IsAnnotation_declContext()
}

type Annotation_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_declContext() *Annotation_declContext {
	var p = new(Annotation_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_decl
	return p
}

func (*Annotation_declContext) IsAnnotation_declContext() {}

func NewAnnotation_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_declContext {
	var p = new(Annotation_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_decl

	return p
}

func (s *Annotation_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_declContext) Annotation_def() IAnnotation_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_defContext)
}

func (s *Annotation_declContext) Annotation_forward_dcl() IAnnotation_forward_dclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_forward_dclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_forward_dclContext)
}

func (s *Annotation_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_decl(s)
	}
}

func (s *Annotation_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_decl(s)
	}
}

func (p *IDLParser) Annotation_decl() (localctx IAnnotation_declContext) {
	this := p
	_ = this

	localctx = NewAnnotation_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, IDLParserRULE_annotation_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(817)
			p.Annotation_def()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(818)
			p.Annotation_forward_dcl()
		}

	}

	return localctx
}

// IAnnotation_defContext is an interface to support dynamic dispatch.
type IAnnotation_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_defContext differentiates from other interfaces.
	IsAnnotation_defContext()
}

type Annotation_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_defContext() *Annotation_defContext {
	var p = new(Annotation_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_def
	return p
}

func (*Annotation_defContext) IsAnnotation_defContext() {}

func NewAnnotation_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_defContext {
	var p = new(Annotation_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_def

	return p
}

func (s *Annotation_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_defContext) Annotation_header() IAnnotation_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_headerContext)
}

func (s *Annotation_defContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Annotation_defContext) Annotation_body() IAnnotation_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_bodyContext)
}

func (s *Annotation_defContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Annotation_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_def(s)
	}
}

func (s *Annotation_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_def(s)
	}
}

func (p *IDLParser) Annotation_def() (localctx IAnnotation_defContext) {
	this := p
	_ = this

	localctx = NewAnnotation_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, IDLParserRULE_annotation_def)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.Annotation_header()
	}
	{
		p.SetState(822)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(823)
		p.Annotation_body()
	}
	{
		p.SetState(824)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IAnnotation_headerContext is an interface to support dynamic dispatch.
type IAnnotation_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_headerContext differentiates from other interfaces.
	IsAnnotation_headerContext()
}

type Annotation_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_headerContext() *Annotation_headerContext {
	var p = new(Annotation_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_header
	return p
}

func (*Annotation_headerContext) IsAnnotation_headerContext() {}

func NewAnnotation_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_headerContext {
	var p = new(Annotation_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_header

	return p
}

func (s *Annotation_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_headerContext) KW_AT_ANNOTATION() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_AT_ANNOTATION, 0)
}

func (s *Annotation_headerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Annotation_headerContext) Annotation_inheritance_spec() IAnnotation_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_inheritance_specContext)
}

func (s *Annotation_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_header(s)
	}
}

func (s *Annotation_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_header(s)
	}
}

func (p *IDLParser) Annotation_header() (localctx IAnnotation_headerContext) {
	this := p
	_ = this

	localctx = NewAnnotation_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, IDLParserRULE_annotation_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(826)
		p.Match(IDLParserKW_AT_ANNOTATION)
	}
	{
		p.SetState(827)
		p.Identifier()
	}
	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(828)
			p.Annotation_inheritance_spec()
		}

	}

	return localctx
}

// IAnnotation_inheritance_specContext is an interface to support dynamic dispatch.
type IAnnotation_inheritance_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_inheritance_specContext differentiates from other interfaces.
	IsAnnotation_inheritance_specContext()
}

type Annotation_inheritance_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_inheritance_specContext() *Annotation_inheritance_specContext {
	var p = new(Annotation_inheritance_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_inheritance_spec
	return p
}

func (*Annotation_inheritance_specContext) IsAnnotation_inheritance_specContext() {}

func NewAnnotation_inheritance_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_inheritance_specContext {
	var p = new(Annotation_inheritance_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_inheritance_spec

	return p
}

func (s *Annotation_inheritance_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_inheritance_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Annotation_inheritance_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Annotation_inheritance_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_inheritance_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_inheritance_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_inheritance_spec(s)
	}
}

func (s *Annotation_inheritance_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_inheritance_spec(s)
	}
}

func (p *IDLParser) Annotation_inheritance_spec() (localctx IAnnotation_inheritance_specContext) {
	this := p
	_ = this

	localctx = NewAnnotation_inheritance_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, IDLParserRULE_annotation_inheritance_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(831)
		p.Match(IDLParserCOLON)
	}
	{
		p.SetState(832)
		p.Scoped_name()
	}

	return localctx
}

// IAnnotation_bodyContext is an interface to support dynamic dispatch.
type IAnnotation_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_bodyContext differentiates from other interfaces.
	IsAnnotation_bodyContext()
}

type Annotation_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_bodyContext() *Annotation_bodyContext {
	var p = new(Annotation_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_body
	return p
}

func (*Annotation_bodyContext) IsAnnotation_bodyContext() {}

func NewAnnotation_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_bodyContext {
	var p = new(Annotation_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_body

	return p
}

func (s *Annotation_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_bodyContext) AllAnnotation_member() []IAnnotation_memberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotation_memberContext)(nil)).Elem())
	var tst = make([]IAnnotation_memberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotation_memberContext)
		}
	}

	return tst
}

func (s *Annotation_bodyContext) Annotation_member(i int) IAnnotation_memberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_memberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_memberContext)
}

func (s *Annotation_bodyContext) AllEnum_type() []IEnum_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnum_typeContext)(nil)).Elem())
	var tst = make([]IEnum_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnum_typeContext)
		}
	}

	return tst
}

func (s *Annotation_bodyContext) Enum_type(i int) IEnum_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnum_typeContext)
}

func (s *Annotation_bodyContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(IDLParserSEMICOLON)
}

func (s *Annotation_bodyContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, i)
}

func (s *Annotation_bodyContext) AllConst_decl() []IConst_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConst_declContext)(nil)).Elem())
	var tst = make([]IConst_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConst_declContext)
		}
	}

	return tst
}

func (s *Annotation_bodyContext) Const_decl(i int) IConst_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConst_declContext)
}

func (s *Annotation_bodyContext) AllKW_TYPEDEF() []antlr.TerminalNode {
	return s.GetTokens(IDLParserKW_TYPEDEF)
}

func (s *Annotation_bodyContext) KW_TYPEDEF(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserKW_TYPEDEF, i)
}

func (s *Annotation_bodyContext) AllType_declarator() []IType_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_declaratorContext)(nil)).Elem())
	var tst = make([]IType_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_declaratorContext)
		}
	}

	return tst
}

func (s *Annotation_bodyContext) Type_declarator(i int) IType_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_declaratorContext)
}

func (s *Annotation_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_body(s)
	}
}

func (s *Annotation_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_body(s)
	}
}

func (p *IDLParser) Annotation_body() (localctx IAnnotation_bodyContext) {
	this := p
	_ = this

	localctx = NewAnnotation_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, IDLParserRULE_annotation_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserAT-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(IDLParserKW_WSTRING-64))|(1<<(IDLParserKW_CONST-64))|(1<<(IDLParserKW_UNSIGNED-64))|(1<<(IDLParserKW_FIXED-64))|(1<<(IDLParserKW_CHAR-64))|(1<<(IDLParserKW_FLOAT-64))|(1<<(IDLParserKW_BOOLEAN-64))|(1<<(IDLParserKW_DOUBLE-64)))) != 0) || (((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(IDLParserKW_INT8-104))|(1<<(IDLParserKW_UINT8-104))|(1<<(IDLParserKW_INT16-104))|(1<<(IDLParserKW_UINT16-104))|(1<<(IDLParserKW_INT32-104))|(1<<(IDLParserKW_UINT32-104))|(1<<(IDLParserKW_INT64-104))|(1<<(IDLParserKW_UINT64-104))|(1<<(IDLParserID-104)))) != 0) {
		p.SetState(845)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case IDLParserDOUBLE_COLON, IDLParserAT, IDLParserKW_STRING, IDLParserKW_OCTET, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_WSTRING, IDLParserKW_UNSIGNED, IDLParserKW_FIXED, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserKW_INT8, IDLParserKW_UINT8, IDLParserKW_INT16, IDLParserKW_UINT16, IDLParserKW_INT32, IDLParserKW_UINT32, IDLParserKW_INT64, IDLParserKW_UINT64, IDLParserID:
			{
				p.SetState(834)
				p.Annotation_member()
			}

		case IDLParserKW_ENUM:
			{
				p.SetState(835)
				p.Enum_type()
			}
			{
				p.SetState(836)
				p.Match(IDLParserSEMICOLON)
			}

		case IDLParserKW_CONST:
			{
				p.SetState(838)
				p.Const_decl()
			}
			{
				p.SetState(839)
				p.Match(IDLParserSEMICOLON)
			}

		case IDLParserKW_TYPEDEF:
			{
				p.SetState(841)
				p.Match(IDLParserKW_TYPEDEF)
			}
			{
				p.SetState(842)
				p.Type_declarator()
			}
			{
				p.SetState(843)
				p.Match(IDLParserSEMICOLON)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(849)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAnnotation_memberContext is an interface to support dynamic dispatch.
type IAnnotation_memberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_memberContext differentiates from other interfaces.
	IsAnnotation_memberContext()
}

type Annotation_memberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_memberContext() *Annotation_memberContext {
	var p = new(Annotation_memberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_member
	return p
}

func (*Annotation_memberContext) IsAnnotation_memberContext() {}

func NewAnnotation_memberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_memberContext {
	var p = new(Annotation_memberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_member

	return p
}

func (s *Annotation_memberContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_memberContext) Const_type() IConst_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_typeContext)
}

func (s *Annotation_memberContext) Simple_declarator() ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Annotation_memberContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Annotation_memberContext) KW_DEFAULT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_DEFAULT, 0)
}

func (s *Annotation_memberContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Annotation_memberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_memberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_memberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_member(s)
	}
}

func (s *Annotation_memberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_member(s)
	}
}

func (p *IDLParser) Annotation_member() (localctx IAnnotation_memberContext) {
	this := p
	_ = this

	localctx = NewAnnotation_memberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, IDLParserRULE_annotation_member)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Const_type()
	}
	{
		p.SetState(851)
		p.Simple_declarator()
	}
	p.SetState(854)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_DEFAULT {
		{
			p.SetState(852)
			p.Match(IDLParserKW_DEFAULT)
		}
		{
			p.SetState(853)
			p.Const_exp()
		}

	}
	{
		p.SetState(856)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// IAnnotation_forward_dclContext is an interface to support dynamic dispatch.
type IAnnotation_forward_dclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_forward_dclContext differentiates from other interfaces.
	IsAnnotation_forward_dclContext()
}

type Annotation_forward_dclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_forward_dclContext() *Annotation_forward_dclContext {
	var p = new(Annotation_forward_dclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_forward_dcl
	return p
}

func (*Annotation_forward_dclContext) IsAnnotation_forward_dclContext() {}

func NewAnnotation_forward_dclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_forward_dclContext {
	var p = new(Annotation_forward_dclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_forward_dcl

	return p
}

func (s *Annotation_forward_dclContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_forward_dclContext) KW_AT_ANNOTATION() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_AT_ANNOTATION, 0)
}

func (s *Annotation_forward_dclContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Annotation_forward_dclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_forward_dclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_forward_dclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_forward_dcl(s)
	}
}

func (s *Annotation_forward_dclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_forward_dcl(s)
	}
}

func (p *IDLParser) Annotation_forward_dcl() (localctx IAnnotation_forward_dclContext) {
	this := p
	_ = this

	localctx = NewAnnotation_forward_dclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, IDLParserRULE_annotation_forward_dcl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.Match(IDLParserKW_AT_ANNOTATION)
	}
	{
		p.SetState(859)
		p.Scoped_name()
	}

	return localctx
}

// IBitset_typeContext is an interface to support dynamic dispatch.
type IBitset_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitset_typeContext differentiates from other interfaces.
	IsBitset_typeContext()
}

type Bitset_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitset_typeContext() *Bitset_typeContext {
	var p = new(Bitset_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_bitset_type
	return p
}

func (*Bitset_typeContext) IsBitset_typeContext() {}

func NewBitset_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bitset_typeContext {
	var p = new(Bitset_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_bitset_type

	return p
}

func (s *Bitset_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Bitset_typeContext) KW_BITSET() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_BITSET, 0)
}

func (s *Bitset_typeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Bitset_typeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Bitset_typeContext) Bitfield() IBitfieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitfieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitfieldContext)
}

func (s *Bitset_typeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Bitset_typeContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Bitset_typeContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Bitset_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bitset_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bitset_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBitset_type(s)
	}
}

func (s *Bitset_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBitset_type(s)
	}
}

func (p *IDLParser) Bitset_type() (localctx IBitset_typeContext) {
	this := p
	_ = this

	localctx = NewBitset_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, IDLParserRULE_bitset_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.Match(IDLParserKW_BITSET)
	}
	{
		p.SetState(862)
		p.Identifier()
	}
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(863)
			p.Match(IDLParserCOLON)
		}
		{
			p.SetState(864)
			p.Scoped_name()
		}

	}
	{
		p.SetState(867)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(868)
		p.Bitfield()
	}
	{
		p.SetState(869)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IBitfieldContext is an interface to support dynamic dispatch.
type IBitfieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitfieldContext differentiates from other interfaces.
	IsBitfieldContext()
}

type BitfieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitfieldContext() *BitfieldContext {
	var p = new(BitfieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_bitfield
	return p
}

func (*BitfieldContext) IsBitfieldContext() {}

func NewBitfieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitfieldContext {
	var p = new(BitfieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_bitfield

	return p
}

func (s *BitfieldContext) GetParser() antlr.Parser { return s.parser }

func (s *BitfieldContext) AllBitfield_spec() []IBitfield_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitfield_specContext)(nil)).Elem())
	var tst = make([]IBitfield_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitfield_specContext)
		}
	}

	return tst
}

func (s *BitfieldContext) Bitfield_spec(i int) IBitfield_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitfield_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitfield_specContext)
}

func (s *BitfieldContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(IDLParserSEMICOLON)
}

func (s *BitfieldContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, i)
}

func (s *BitfieldContext) AllSimple_declarators() []ISimple_declaratorsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_declaratorsContext)(nil)).Elem())
	var tst = make([]ISimple_declaratorsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_declaratorsContext)
		}
	}

	return tst
}

func (s *BitfieldContext) Simple_declarators(i int) ISimple_declaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorsContext)
}

func (s *BitfieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitfieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitfieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBitfield(s)
	}
}

func (s *BitfieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBitfield(s)
	}
}

func (p *IDLParser) Bitfield() (localctx IBitfieldContext) {
	this := p
	_ = this

	localctx = NewBitfieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, IDLParserRULE_bitfield)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == IDLParserAT || _la == IDLParserKW_BITFIELD {
		{
			p.SetState(871)
			p.Bitfield_spec()
		}
		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == IDLParserAT || _la == IDLParserID {
			{
				p.SetState(872)
				p.Simple_declarators()
			}

		}
		{
			p.SetState(875)
			p.Match(IDLParserSEMICOLON)
		}

		p.SetState(879)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBitfield_specContext is an interface to support dynamic dispatch.
type IBitfield_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitfield_specContext differentiates from other interfaces.
	IsBitfield_specContext()
}

type Bitfield_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitfield_specContext() *Bitfield_specContext {
	var p = new(Bitfield_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_bitfield_spec
	return p
}

func (*Bitfield_specContext) IsBitfield_specContext() {}

func NewBitfield_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bitfield_specContext {
	var p = new(Bitfield_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_bitfield_spec

	return p
}

func (s *Bitfield_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Bitfield_specContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Bitfield_specContext) KW_BITFIELD() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_BITFIELD, 0)
}

func (s *Bitfield_specContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *Bitfield_specContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Bitfield_specContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *Bitfield_specContext) COMMA() antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, 0)
}

func (s *Bitfield_specContext) Bitfield_type_spec() IBitfield_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitfield_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitfield_type_specContext)
}

func (s *Bitfield_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bitfield_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bitfield_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBitfield_spec(s)
	}
}

func (s *Bitfield_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBitfield_spec(s)
	}
}

func (p *IDLParser) Bitfield_spec() (localctx IBitfield_specContext) {
	this := p
	_ = this

	localctx = NewBitfield_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, IDLParserRULE_bitfield_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.Annapps()
	}
	{
		p.SetState(882)
		p.Match(IDLParserKW_BITFIELD)
	}
	{
		p.SetState(883)
		p.Match(IDLParserLEFT_ANG_BRACKET)
	}
	{
		p.SetState(884)
		p.Positive_int_const()
	}
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOMMA {
		{
			p.SetState(885)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(886)
			p.Bitfield_type_spec()
		}

	}
	{
		p.SetState(889)
		p.Match(IDLParserRIGHT_ANG_BRACKET)
	}

	return localctx
}

// IBitmask_typeContext is an interface to support dynamic dispatch.
type IBitmask_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitmask_typeContext differentiates from other interfaces.
	IsBitmask_typeContext()
}

type Bitmask_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitmask_typeContext() *Bitmask_typeContext {
	var p = new(Bitmask_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_bitmask_type
	return p
}

func (*Bitmask_typeContext) IsBitmask_typeContext() {}

func NewBitmask_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bitmask_typeContext {
	var p = new(Bitmask_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_bitmask_type

	return p
}

func (s *Bitmask_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Bitmask_typeContext) KW_BITMASK() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_BITMASK, 0)
}

func (s *Bitmask_typeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Bitmask_typeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Bitmask_typeContext) Bit_values() IBit_valuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBit_valuesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBit_valuesContext)
}

func (s *Bitmask_typeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Bitmask_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bitmask_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bitmask_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBitmask_type(s)
	}
}

func (s *Bitmask_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBitmask_type(s)
	}
}

func (p *IDLParser) Bitmask_type() (localctx IBitmask_typeContext) {
	this := p
	_ = this

	localctx = NewBitmask_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, IDLParserRULE_bitmask_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(891)
		p.Match(IDLParserKW_BITMASK)
	}
	{
		p.SetState(892)
		p.Identifier()
	}
	{
		p.SetState(893)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(894)
		p.Bit_values()
	}
	{
		p.SetState(895)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IBit_valuesContext is an interface to support dynamic dispatch.
type IBit_valuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBit_valuesContext differentiates from other interfaces.
	IsBit_valuesContext()
}

type Bit_valuesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBit_valuesContext() *Bit_valuesContext {
	var p = new(Bit_valuesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_bit_values
	return p
}

func (*Bit_valuesContext) IsBit_valuesContext() {}

func NewBit_valuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bit_valuesContext {
	var p = new(Bit_valuesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_bit_values

	return p
}

func (s *Bit_valuesContext) GetParser() antlr.Parser { return s.parser }

func (s *Bit_valuesContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Bit_valuesContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Bit_valuesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Bit_valuesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Bit_valuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bit_valuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bit_valuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBit_values(s)
	}
}

func (s *Bit_valuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBit_values(s)
	}
}

func (p *IDLParser) Bit_values() (localctx IBit_valuesContext) {
	this := p
	_ = this

	localctx = NewBit_valuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, IDLParserRULE_bit_values)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.Identifier()
	}
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(898)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(899)
			p.Identifier()
		}

		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStruct_typeContext is an interface to support dynamic dispatch.
type IStruct_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_typeContext differentiates from other interfaces.
	IsStruct_typeContext()
}

type Struct_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_typeContext() *Struct_typeContext {
	var p = new(Struct_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_struct_type
	return p
}

func (*Struct_typeContext) IsStruct_typeContext() {}

func NewStruct_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_typeContext {
	var p = new(Struct_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_struct_type

	return p
}

func (s *Struct_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_typeContext) KW_STRUCT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_STRUCT, 0)
}

func (s *Struct_typeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Struct_typeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Struct_typeContext) Member_list() IMember_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_listContext)
}

func (s *Struct_typeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Struct_typeContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Struct_typeContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Struct_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterStruct_type(s)
	}
}

func (s *Struct_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitStruct_type(s)
	}
}

func (p *IDLParser) Struct_type() (localctx IStruct_typeContext) {
	this := p
	_ = this

	localctx = NewStruct_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, IDLParserRULE_struct_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.Match(IDLParserKW_STRUCT)
	}
	{
		p.SetState(906)
		p.Identifier()
	}
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(907)
			p.Match(IDLParserCOLON)
		}
		{
			p.SetState(908)
			p.Scoped_name()
		}

	}
	{
		p.SetState(911)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(912)
		p.Member_list()
	}
	{
		p.SetState(913)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IMember_listContext is an interface to support dynamic dispatch.
type IMember_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_listContext differentiates from other interfaces.
	IsMember_listContext()
}

type Member_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_listContext() *Member_listContext {
	var p = new(Member_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_member_list
	return p
}

func (*Member_listContext) IsMember_listContext() {}

func NewMember_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_listContext {
	var p = new(Member_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_member_list

	return p
}

func (s *Member_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_listContext) AllMember() []IMemberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMemberContext)(nil)).Elem())
	var tst = make([]IMemberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMemberContext)
		}
	}

	return tst
}

func (s *Member_listContext) Member(i int) IMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMemberContext)
}

func (s *Member_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterMember_list(s)
	}
}

func (s *Member_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitMember_list(s)
	}
}

func (p *IDLParser) Member_list() (localctx IMember_listContext) {
	this := p
	_ = this

	localctx = NewMember_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, IDLParserRULE_member_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserAT-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_SEQUENCE-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(IDLParserKW_WSTRING-64))|(1<<(IDLParserKW_VALUEBASE-64))|(1<<(IDLParserKW_OBJECT-64))|(1<<(IDLParserKW_UNSIGNED-64))|(1<<(IDLParserKW_FIXED-64))|(1<<(IDLParserKW_UNION-64))|(1<<(IDLParserKW_ANY-64))|(1<<(IDLParserKW_CHAR-64))|(1<<(IDLParserKW_FLOAT-64))|(1<<(IDLParserKW_BOOLEAN-64))|(1<<(IDLParserKW_DOUBLE-64)))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(IDLParserKW_SET-99))|(1<<(IDLParserKW_MAP-99))|(1<<(IDLParserKW_BITSET-99))|(1<<(IDLParserKW_BITMASK-99))|(1<<(IDLParserKW_INT8-99))|(1<<(IDLParserKW_UINT8-99))|(1<<(IDLParserKW_INT16-99))|(1<<(IDLParserKW_UINT16-99))|(1<<(IDLParserKW_INT32-99))|(1<<(IDLParserKW_UINT32-99))|(1<<(IDLParserKW_INT64-99))|(1<<(IDLParserKW_UINT64-99))|(1<<(IDLParserID-99)))) != 0) {
		{
			p.SetState(915)
			p.Member()
		}

		p.SetState(920)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMemberContext is an interface to support dynamic dispatch.
type IMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberContext differentiates from other interfaces.
	IsMemberContext()
}

type MemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberContext() *MemberContext {
	var p = new(MemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_member
	return p
}

func (*MemberContext) IsMemberContext() {}

func NewMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberContext {
	var p = new(MemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_member

	return p
}

func (s *MemberContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *MemberContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *MemberContext) Declarators() IDeclaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorsContext)
}

func (s *MemberContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *MemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterMember(s)
	}
}

func (s *MemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitMember(s)
	}
}

func (p *IDLParser) Member() (localctx IMemberContext) {
	this := p
	_ = this

	localctx = NewMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, IDLParserRULE_member)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(921)
		p.Annapps()
	}
	{
		p.SetState(922)
		p.Type_spec()
	}
	{
		p.SetState(923)
		p.Declarators()
	}
	{
		p.SetState(924)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// IUnion_typeContext is an interface to support dynamic dispatch.
type IUnion_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnion_typeContext differentiates from other interfaces.
	IsUnion_typeContext()
}

type Union_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnion_typeContext() *Union_typeContext {
	var p = new(Union_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_union_type
	return p
}

func (*Union_typeContext) IsUnion_typeContext() {}

func NewUnion_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Union_typeContext {
	var p = new(Union_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_union_type

	return p
}

func (s *Union_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Union_typeContext) KW_UNION() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNION, 0)
}

func (s *Union_typeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Union_typeContext) KW_SWITCH() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SWITCH, 0)
}

func (s *Union_typeContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Union_typeContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Union_typeContext) Switch_type_spec() ISwitch_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitch_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitch_type_specContext)
}

func (s *Union_typeContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Union_typeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Union_typeContext) Switch_body() ISwitch_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitch_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitch_bodyContext)
}

func (s *Union_typeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Union_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Union_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Union_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnion_type(s)
	}
}

func (s *Union_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnion_type(s)
	}
}

func (p *IDLParser) Union_type() (localctx IUnion_typeContext) {
	this := p
	_ = this

	localctx = NewUnion_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, IDLParserRULE_union_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.Match(IDLParserKW_UNION)
	}
	{
		p.SetState(927)
		p.Identifier()
	}
	{
		p.SetState(928)
		p.Match(IDLParserKW_SWITCH)
	}
	{
		p.SetState(929)
		p.Match(IDLParserLEFT_BRACKET)
	}
	{
		p.SetState(930)
		p.Annapps()
	}
	{
		p.SetState(931)
		p.Switch_type_spec()
	}
	{
		p.SetState(932)
		p.Match(IDLParserRIGHT_BRACKET)
	}
	{
		p.SetState(933)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(934)
		p.Switch_body()
	}
	{
		p.SetState(935)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// ISwitch_type_specContext is an interface to support dynamic dispatch.
type ISwitch_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitch_type_specContext differentiates from other interfaces.
	IsSwitch_type_specContext()
}

type Switch_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitch_type_specContext() *Switch_type_specContext {
	var p = new(Switch_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_switch_type_spec
	return p
}

func (*Switch_type_specContext) IsSwitch_type_specContext() {}

func NewSwitch_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switch_type_specContext {
	var p = new(Switch_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_switch_type_spec

	return p
}

func (s *Switch_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Switch_type_specContext) Integer_type() IInteger_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *Switch_type_specContext) Char_type() IChar_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_typeContext)
}

func (s *Switch_type_specContext) Wide_char_type() IWide_char_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_char_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_char_typeContext)
}

func (s *Switch_type_specContext) Octet_type() IOctet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctet_typeContext)
}

func (s *Switch_type_specContext) Boolean_type() IBoolean_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_typeContext)
}

func (s *Switch_type_specContext) Enum_type() IEnum_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_typeContext)
}

func (s *Switch_type_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Switch_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switch_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switch_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSwitch_type_spec(s)
	}
}

func (s *Switch_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSwitch_type_spec(s)
	}
}

func (p *IDLParser) Switch_type_spec() (localctx ISwitch_type_specContext) {
	this := p
	_ = this

	localctx = NewSwitch_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, IDLParserRULE_switch_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(944)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_UNSIGNED, IDLParserKW_INT8, IDLParserKW_UINT8, IDLParserKW_INT16, IDLParserKW_UINT16, IDLParserKW_INT32, IDLParserKW_UINT32, IDLParserKW_INT64, IDLParserKW_UINT64:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(937)
			p.Integer_type()
		}

	case IDLParserKW_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(938)
			p.Char_type()
		}

	case IDLParserKW_WCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(939)
			p.Wide_char_type()
		}

	case IDLParserKW_OCTET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(940)
			p.Octet_type()
		}

	case IDLParserKW_BOOLEAN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(941)
			p.Boolean_type()
		}

	case IDLParserKW_ENUM:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(942)
			p.Enum_type()
		}

	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(943)
			p.Scoped_name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISwitch_bodyContext is an interface to support dynamic dispatch.
type ISwitch_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitch_bodyContext differentiates from other interfaces.
	IsSwitch_bodyContext()
}

type Switch_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitch_bodyContext() *Switch_bodyContext {
	var p = new(Switch_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_switch_body
	return p
}

func (*Switch_bodyContext) IsSwitch_bodyContext() {}

func NewSwitch_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switch_bodyContext {
	var p = new(Switch_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_switch_body

	return p
}

func (s *Switch_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Switch_bodyContext) AllCase_stmt() []ICase_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_stmtContext)(nil)).Elem())
	var tst = make([]ICase_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_stmtContext)
		}
	}

	return tst
}

func (s *Switch_bodyContext) Case_stmt(i int) ICase_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_stmtContext)
}

func (s *Switch_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switch_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switch_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSwitch_body(s)
	}
}

func (s *Switch_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSwitch_body(s)
	}
}

func (p *IDLParser) Switch_body() (localctx ISwitch_bodyContext) {
	this := p
	_ = this

	localctx = NewSwitch_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, IDLParserRULE_switch_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == IDLParserAT || _la == IDLParserKW_DEFAULT || _la == IDLParserKW_CASE {
		{
			p.SetState(946)
			p.Case_stmt()
		}

		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICase_stmtContext is an interface to support dynamic dispatch.
type ICase_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_stmtContext differentiates from other interfaces.
	IsCase_stmtContext()
}

type Case_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_stmtContext() *Case_stmtContext {
	var p = new(Case_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_case_stmt
	return p
}

func (*Case_stmtContext) IsCase_stmtContext() {}

func NewCase_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_stmtContext {
	var p = new(Case_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_case_stmt

	return p
}

func (s *Case_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_stmtContext) Element_spec() IElement_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElement_specContext)
}

func (s *Case_stmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Case_stmtContext) AllCase_label() []ICase_labelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_labelContext)(nil)).Elem())
	var tst = make([]ICase_labelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_labelContext)
		}
	}

	return tst
}

func (s *Case_stmtContext) Case_label(i int) ICase_labelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_labelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_labelContext)
}

func (s *Case_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterCase_stmt(s)
	}
}

func (s *Case_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitCase_stmt(s)
	}
}

func (p *IDLParser) Case_stmt() (localctx ICase_stmtContext) {
	this := p
	_ = this

	localctx = NewCase_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, IDLParserRULE_case_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(951)
				p.Case_label()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
	}
	{
		p.SetState(956)
		p.Element_spec()
	}
	{
		p.SetState(957)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// ICase_labelContext is an interface to support dynamic dispatch.
type ICase_labelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_labelContext differentiates from other interfaces.
	IsCase_labelContext()
}

type Case_labelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_labelContext() *Case_labelContext {
	var p = new(Case_labelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_case_label
	return p
}

func (*Case_labelContext) IsCase_labelContext() {}

func NewCase_labelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_labelContext {
	var p = new(Case_labelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_case_label

	return p
}

func (s *Case_labelContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_labelContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Case_labelContext) KW_CASE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CASE, 0)
}

func (s *Case_labelContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Case_labelContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Case_labelContext) KW_DEFAULT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_DEFAULT, 0)
}

func (s *Case_labelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_labelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_labelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterCase_label(s)
	}
}

func (s *Case_labelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitCase_label(s)
	}
}

func (p *IDLParser) Case_label() (localctx ICase_labelContext) {
	this := p
	_ = this

	localctx = NewCase_labelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, IDLParserRULE_case_label)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(959)
		p.Annapps()
	}
	p.SetState(966)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_CASE:
		{
			p.SetState(960)
			p.Match(IDLParserKW_CASE)
		}
		{
			p.SetState(961)
			p.Const_exp()
		}
		{
			p.SetState(962)
			p.Match(IDLParserCOLON)
		}

	case IDLParserKW_DEFAULT:
		{
			p.SetState(964)
			p.Match(IDLParserKW_DEFAULT)
		}
		{
			p.SetState(965)
			p.Match(IDLParserCOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IElement_specContext is an interface to support dynamic dispatch.
type IElement_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_specContext differentiates from other interfaces.
	IsElement_specContext()
}

type Element_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_specContext() *Element_specContext {
	var p = new(Element_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_element_spec
	return p
}

func (*Element_specContext) IsElement_specContext() {}

func NewElement_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_specContext {
	var p = new(Element_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_element_spec

	return p
}

func (s *Element_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_specContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Element_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Element_specContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Element_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterElement_spec(s)
	}
}

func (s *Element_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitElement_spec(s)
	}
}

func (p *IDLParser) Element_spec() (localctx IElement_specContext) {
	this := p
	_ = this

	localctx = NewElement_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, IDLParserRULE_element_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(968)
		p.Annapps()
	}
	{
		p.SetState(969)
		p.Type_spec()
	}
	{
		p.SetState(970)
		p.Declarator()
	}

	return localctx
}

// IEnum_typeContext is an interface to support dynamic dispatch.
type IEnum_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_typeContext differentiates from other interfaces.
	IsEnum_typeContext()
}

type Enum_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_typeContext() *Enum_typeContext {
	var p = new(Enum_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_enum_type
	return p
}

func (*Enum_typeContext) IsEnum_typeContext() {}

func NewEnum_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_typeContext {
	var p = new(Enum_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_enum_type

	return p
}

func (s *Enum_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_typeContext) KW_ENUM() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ENUM, 0)
}

func (s *Enum_typeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Enum_typeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Enum_typeContext) AllEnumerator() []IEnumeratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem())
	var tst = make([]IEnumeratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumeratorContext)
		}
	}

	return tst
}

func (s *Enum_typeContext) Enumerator(i int) IEnumeratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *Enum_typeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Enum_typeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Enum_typeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Enum_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEnum_type(s)
	}
}

func (s *Enum_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEnum_type(s)
	}
}

func (p *IDLParser) Enum_type() (localctx IEnum_typeContext) {
	this := p
	_ = this

	localctx = NewEnum_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, IDLParserRULE_enum_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(972)
		p.Match(IDLParserKW_ENUM)
	}
	{
		p.SetState(973)
		p.Identifier()
	}
	{
		p.SetState(974)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(975)
		p.Enumerator()
	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(976)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(977)
			p.Enumerator()
		}

		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(983)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_enumerator
	return p
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEnumerator(s)
	}
}

func (s *EnumeratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEnumerator(s)
	}
}

func (p *IDLParser) Enumerator() (localctx IEnumeratorContext) {
	this := p
	_ = this

	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, IDLParserRULE_enumerator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(985)
		p.Identifier()
	}

	return localctx
}

// ISequence_typeContext is an interface to support dynamic dispatch.
type ISequence_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_typeContext differentiates from other interfaces.
	IsSequence_typeContext()
}

type Sequence_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_typeContext() *Sequence_typeContext {
	var p = new(Sequence_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_sequence_type
	return p
}

func (*Sequence_typeContext) IsSequence_typeContext() {}

func NewSequence_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_typeContext {
	var p = new(Sequence_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_sequence_type

	return p
}

func (s *Sequence_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_typeContext) KW_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SEQUENCE, 0)
}

func (s *Sequence_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *Sequence_typeContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Sequence_typeContext) Simple_type_spec() ISimple_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_type_specContext)
}

func (s *Sequence_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *Sequence_typeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, 0)
}

func (s *Sequence_typeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Sequence_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSequence_type(s)
	}
}

func (s *Sequence_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSequence_type(s)
	}
}

func (p *IDLParser) Sequence_type() (localctx ISequence_typeContext) {
	this := p
	_ = this

	localctx = NewSequence_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, IDLParserRULE_sequence_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(987)
		p.Match(IDLParserKW_SEQUENCE)
	}
	{
		p.SetState(988)
		p.Match(IDLParserLEFT_ANG_BRACKET)
	}
	{
		p.SetState(989)
		p.Annapps()
	}
	{
		p.SetState(990)
		p.Simple_type_spec()
	}
	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOMMA {
		{
			p.SetState(991)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(992)
			p.Positive_int_const()
		}

	}
	{
		p.SetState(995)
		p.Match(IDLParserRIGHT_ANG_BRACKET)
	}

	return localctx
}

// ISet_typeContext is an interface to support dynamic dispatch.
type ISet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_typeContext differentiates from other interfaces.
	IsSet_typeContext()
}

type Set_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_typeContext() *Set_typeContext {
	var p = new(Set_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_set_type
	return p
}

func (*Set_typeContext) IsSet_typeContext() {}

func NewSet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_typeContext {
	var p = new(Set_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_set_type

	return p
}

func (s *Set_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_typeContext) KW_SET() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SET, 0)
}

func (s *Set_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *Set_typeContext) Simple_type_spec() ISimple_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_type_specContext)
}

func (s *Set_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *Set_typeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, 0)
}

func (s *Set_typeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Set_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSet_type(s)
	}
}

func (s *Set_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSet_type(s)
	}
}

func (p *IDLParser) Set_type() (localctx ISet_typeContext) {
	this := p
	_ = this

	localctx = NewSet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, IDLParserRULE_set_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Match(IDLParserKW_SET)
	}
	{
		p.SetState(998)
		p.Match(IDLParserLEFT_ANG_BRACKET)
	}
	{
		p.SetState(999)
		p.Simple_type_spec()
	}
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOMMA {
		{
			p.SetState(1000)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(1001)
			p.Positive_int_const()
		}

	}
	{
		p.SetState(1004)
		p.Match(IDLParserRIGHT_ANG_BRACKET)
	}

	return localctx
}

// IMap_typeContext is an interface to support dynamic dispatch.
type IMap_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMap_typeContext differentiates from other interfaces.
	IsMap_typeContext()
}

type Map_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMap_typeContext() *Map_typeContext {
	var p = new(Map_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_map_type
	return p
}

func (*Map_typeContext) IsMap_typeContext() {}

func NewMap_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Map_typeContext {
	var p = new(Map_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_map_type

	return p
}

func (s *Map_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Map_typeContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_MAP, 0)
}

func (s *Map_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *Map_typeContext) AllSimple_type_spec() []ISimple_type_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_type_specContext)(nil)).Elem())
	var tst = make([]ISimple_type_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_type_specContext)
		}
	}

	return tst
}

func (s *Map_typeContext) Simple_type_spec(i int) ISimple_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_type_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_type_specContext)
}

func (s *Map_typeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Map_typeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Map_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *Map_typeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Map_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Map_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Map_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterMap_type(s)
	}
}

func (s *Map_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitMap_type(s)
	}
}

func (p *IDLParser) Map_type() (localctx IMap_typeContext) {
	this := p
	_ = this

	localctx = NewMap_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, IDLParserRULE_map_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Match(IDLParserKW_MAP)
	}
	{
		p.SetState(1007)
		p.Match(IDLParserLEFT_ANG_BRACKET)
	}
	{
		p.SetState(1008)
		p.Simple_type_spec()
	}
	{
		p.SetState(1009)
		p.Match(IDLParserCOMMA)
	}
	{
		p.SetState(1010)
		p.Simple_type_spec()
	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOMMA {
		{
			p.SetState(1011)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(1012)
			p.Positive_int_const()
		}

	}
	{
		p.SetState(1015)
		p.Match(IDLParserRIGHT_ANG_BRACKET)
	}

	return localctx
}

// IString_typeContext is an interface to support dynamic dispatch.
type IString_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_typeContext differentiates from other interfaces.
	IsString_typeContext()
}

type String_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_typeContext() *String_typeContext {
	var p = new(String_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_string_type
	return p
}

func (*String_typeContext) IsString_typeContext() {}

func NewString_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_typeContext {
	var p = new(String_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_string_type

	return p
}

func (s *String_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *String_typeContext) KW_STRING() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_STRING, 0)
}

func (s *String_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *String_typeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *String_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *String_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterString_type(s)
	}
}

func (s *String_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitString_type(s)
	}
}

func (p *IDLParser) String_type() (localctx IString_typeContext) {
	this := p
	_ = this

	localctx = NewString_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, IDLParserRULE_string_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.Match(IDLParserKW_STRING)
	}
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserLEFT_ANG_BRACKET {
		{
			p.SetState(1018)
			p.Match(IDLParserLEFT_ANG_BRACKET)
		}
		{
			p.SetState(1019)
			p.Positive_int_const()
		}
		{
			p.SetState(1020)
			p.Match(IDLParserRIGHT_ANG_BRACKET)
		}

	}

	return localctx
}

// IWide_string_typeContext is an interface to support dynamic dispatch.
type IWide_string_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWide_string_typeContext differentiates from other interfaces.
	IsWide_string_typeContext()
}

type Wide_string_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWide_string_typeContext() *Wide_string_typeContext {
	var p = new(Wide_string_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_wide_string_type
	return p
}

func (*Wide_string_typeContext) IsWide_string_typeContext() {}

func NewWide_string_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wide_string_typeContext {
	var p = new(Wide_string_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_wide_string_type

	return p
}

func (s *Wide_string_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Wide_string_typeContext) KW_WSTRING() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_WSTRING, 0)
}

func (s *Wide_string_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *Wide_string_typeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Wide_string_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *Wide_string_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wide_string_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wide_string_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterWide_string_type(s)
	}
}

func (s *Wide_string_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitWide_string_type(s)
	}
}

func (p *IDLParser) Wide_string_type() (localctx IWide_string_typeContext) {
	this := p
	_ = this

	localctx = NewWide_string_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, IDLParserRULE_wide_string_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		p.Match(IDLParserKW_WSTRING)
	}
	p.SetState(1029)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserLEFT_ANG_BRACKET {
		{
			p.SetState(1025)
			p.Match(IDLParserLEFT_ANG_BRACKET)
		}
		{
			p.SetState(1026)
			p.Positive_int_const()
		}
		{
			p.SetState(1027)
			p.Match(IDLParserRIGHT_ANG_BRACKET)
		}

	}

	return localctx
}

// IArray_declaratorContext is an interface to support dynamic dispatch.
type IArray_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_declaratorContext differentiates from other interfaces.
	IsArray_declaratorContext()
}

type Array_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_declaratorContext() *Array_declaratorContext {
	var p = new(Array_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_array_declarator
	return p
}

func (*Array_declaratorContext) IsArray_declaratorContext() {}

func NewArray_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_declaratorContext {
	var p = new(Array_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_array_declarator

	return p
}

func (s *Array_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_declaratorContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Array_declaratorContext) AllFixed_array_size() []IFixed_array_sizeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFixed_array_sizeContext)(nil)).Elem())
	var tst = make([]IFixed_array_sizeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFixed_array_sizeContext)
		}
	}

	return tst
}

func (s *Array_declaratorContext) Fixed_array_size(i int) IFixed_array_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFixed_array_sizeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFixed_array_sizeContext)
}

func (s *Array_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterArray_declarator(s)
	}
}

func (s *Array_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitArray_declarator(s)
	}
}

func (p *IDLParser) Array_declarator() (localctx IArray_declaratorContext) {
	this := p
	_ = this

	localctx = NewArray_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, IDLParserRULE_array_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.Match(IDLParserID)
	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == IDLParserLEFT_SQUARE_BRACKET {
		{
			p.SetState(1032)
			p.Fixed_array_size()
		}

		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFixed_array_sizeContext is an interface to support dynamic dispatch.
type IFixed_array_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixed_array_sizeContext differentiates from other interfaces.
	IsFixed_array_sizeContext()
}

type Fixed_array_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixed_array_sizeContext() *Fixed_array_sizeContext {
	var p = new(Fixed_array_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_fixed_array_size
	return p
}

func (*Fixed_array_sizeContext) IsFixed_array_sizeContext() {}

func NewFixed_array_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fixed_array_sizeContext {
	var p = new(Fixed_array_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_fixed_array_size

	return p
}

func (s *Fixed_array_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Fixed_array_sizeContext) LEFT_SQUARE_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_SQUARE_BRACKET, 0)
}

func (s *Fixed_array_sizeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Fixed_array_sizeContext) RIGHT_SQUARE_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_SQUARE_BRACKET, 0)
}

func (s *Fixed_array_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fixed_array_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fixed_array_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFixed_array_size(s)
	}
}

func (s *Fixed_array_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFixed_array_size(s)
	}
}

func (p *IDLParser) Fixed_array_size() (localctx IFixed_array_sizeContext) {
	this := p
	_ = this

	localctx = NewFixed_array_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, IDLParserRULE_fixed_array_size)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1037)
		p.Match(IDLParserLEFT_SQUARE_BRACKET)
	}
	{
		p.SetState(1038)
		p.Positive_int_const()
	}
	{
		p.SetState(1039)
		p.Match(IDLParserRIGHT_SQUARE_BRACKET)
	}

	return localctx
}

// IAttr_declContext is an interface to support dynamic dispatch.
type IAttr_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_declContext differentiates from other interfaces.
	IsAttr_declContext()
}

type Attr_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_declContext() *Attr_declContext {
	var p = new(Attr_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_attr_decl
	return p
}

func (*Attr_declContext) IsAttr_declContext() {}

func NewAttr_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_declContext {
	var p = new(Attr_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_attr_decl

	return p
}

func (s *Attr_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_declContext) Readonly_attr_spec() IReadonly_attr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadonly_attr_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadonly_attr_specContext)
}

func (s *Attr_declContext) Attr_spec() IAttr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_specContext)
}

func (s *Attr_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAttr_decl(s)
	}
}

func (s *Attr_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAttr_decl(s)
	}
}

func (p *IDLParser) Attr_decl() (localctx IAttr_declContext) {
	this := p
	_ = this

	localctx = NewAttr_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, IDLParserRULE_attr_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1043)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_READONLY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1041)
			p.Readonly_attr_spec()
		}

	case IDLParserKW_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1042)
			p.Attr_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExcept_declContext is an interface to support dynamic dispatch.
type IExcept_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExcept_declContext differentiates from other interfaces.
	IsExcept_declContext()
}

type Except_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_declContext() *Except_declContext {
	var p = new(Except_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_except_decl
	return p
}

func (*Except_declContext) IsExcept_declContext() {}

func NewExcept_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_declContext {
	var p = new(Except_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_except_decl

	return p
}

func (s *Except_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_declContext) KW_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EXCEPTION, 0)
}

func (s *Except_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Except_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Except_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Except_declContext) AllMember() []IMemberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMemberContext)(nil)).Elem())
	var tst = make([]IMemberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMemberContext)
		}
	}

	return tst
}

func (s *Except_declContext) Member(i int) IMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMemberContext)
}

func (s *Except_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Except_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterExcept_decl(s)
	}
}

func (s *Except_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitExcept_decl(s)
	}
}

func (p *IDLParser) Except_decl() (localctx IExcept_declContext) {
	this := p
	_ = this

	localctx = NewExcept_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, IDLParserRULE_except_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.Match(IDLParserKW_EXCEPTION)
	}
	{
		p.SetState(1046)
		p.Identifier()
	}
	{
		p.SetState(1047)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserAT-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_SEQUENCE-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(IDLParserKW_WSTRING-64))|(1<<(IDLParserKW_VALUEBASE-64))|(1<<(IDLParserKW_OBJECT-64))|(1<<(IDLParserKW_UNSIGNED-64))|(1<<(IDLParserKW_FIXED-64))|(1<<(IDLParserKW_UNION-64))|(1<<(IDLParserKW_ANY-64))|(1<<(IDLParserKW_CHAR-64))|(1<<(IDLParserKW_FLOAT-64))|(1<<(IDLParserKW_BOOLEAN-64))|(1<<(IDLParserKW_DOUBLE-64)))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(IDLParserKW_SET-99))|(1<<(IDLParserKW_MAP-99))|(1<<(IDLParserKW_BITSET-99))|(1<<(IDLParserKW_BITMASK-99))|(1<<(IDLParserKW_INT8-99))|(1<<(IDLParserKW_UINT8-99))|(1<<(IDLParserKW_INT16-99))|(1<<(IDLParserKW_UINT16-99))|(1<<(IDLParserKW_INT32-99))|(1<<(IDLParserKW_UINT32-99))|(1<<(IDLParserKW_INT64-99))|(1<<(IDLParserKW_UINT64-99))|(1<<(IDLParserID-99)))) != 0) {
		{
			p.SetState(1048)
			p.Member()
		}

		p.SetState(1053)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1054)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IOp_declContext is an interface to support dynamic dispatch.
type IOp_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_declContext differentiates from other interfaces.
	IsOp_declContext()
}

type Op_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_declContext() *Op_declContext {
	var p = new(Op_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_op_decl
	return p
}

func (*Op_declContext) IsOp_declContext() {}

func NewOp_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_declContext {
	var p = new(Op_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_op_decl

	return p
}

func (s *Op_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_declContext) Op_type_spec() IOp_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOp_type_specContext)
}

func (s *Op_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Op_declContext) Parameter_decls() IParameter_declsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declsContext)
}

func (s *Op_declContext) Op_attribute() IOp_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOp_attributeContext)
}

func (s *Op_declContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Op_declContext) Context_expr() IContext_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContext_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContext_exprContext)
}

func (s *Op_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOp_decl(s)
	}
}

func (s *Op_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOp_decl(s)
	}
}

func (p *IDLParser) Op_decl() (localctx IOp_declContext) {
	this := p
	_ = this

	localctx = NewOp_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, IDLParserRULE_op_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1057)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ONEWAY {
		{
			p.SetState(1056)
			p.Op_attribute()
		}

	}
	{
		p.SetState(1059)
		p.Op_type_spec()
	}
	{
		p.SetState(1060)
		p.Identifier()
	}
	{
		p.SetState(1061)
		p.Parameter_decls()
	}
	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_RAISES {
		{
			p.SetState(1062)
			p.Raises_expr()
		}

	}
	p.SetState(1066)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_CONTEXT {
		{
			p.SetState(1065)
			p.Context_expr()
		}

	}

	return localctx
}

// IOp_attributeContext is an interface to support dynamic dispatch.
type IOp_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_attributeContext differentiates from other interfaces.
	IsOp_attributeContext()
}

type Op_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_attributeContext() *Op_attributeContext {
	var p = new(Op_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_op_attribute
	return p
}

func (*Op_attributeContext) IsOp_attributeContext() {}

func NewOp_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_attributeContext {
	var p = new(Op_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_op_attribute

	return p
}

func (s *Op_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_attributeContext) KW_ONEWAY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ONEWAY, 0)
}

func (s *Op_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOp_attribute(s)
	}
}

func (s *Op_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOp_attribute(s)
	}
}

func (p *IDLParser) Op_attribute() (localctx IOp_attributeContext) {
	this := p
	_ = this

	localctx = NewOp_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, IDLParserRULE_op_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1068)
		p.Match(IDLParserKW_ONEWAY)
	}

	return localctx
}

// IOp_type_specContext is an interface to support dynamic dispatch.
type IOp_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_type_specContext differentiates from other interfaces.
	IsOp_type_specContext()
}

type Op_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_type_specContext() *Op_type_specContext {
	var p = new(Op_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_op_type_spec
	return p
}

func (*Op_type_specContext) IsOp_type_specContext() {}

func NewOp_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_type_specContext {
	var p = new(Op_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_op_type_spec

	return p
}

func (s *Op_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_type_specContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Op_type_specContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Op_type_specContext) KW_VOID() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VOID, 0)
}

func (s *Op_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOp_type_spec(s)
	}
}

func (s *Op_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOp_type_spec(s)
	}
}

func (p *IDLParser) Op_type_spec() (localctx IOp_type_specContext) {
	this := p
	_ = this

	localctx = NewOp_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, IDLParserRULE_op_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1070)
		p.Annapps()
	}
	p.SetState(1073)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserKW_STRING, IDLParserKW_OCTET, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_WSTRING, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserKW_INT8, IDLParserKW_UINT8, IDLParserKW_INT16, IDLParserKW_UINT16, IDLParserKW_INT32, IDLParserKW_UINT32, IDLParserKW_INT64, IDLParserKW_UINT64, IDLParserID:
		{
			p.SetState(1071)
			p.Param_type_spec()
		}

	case IDLParserKW_VOID:
		{
			p.SetState(1072)
			p.Match(IDLParserKW_VOID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParameter_declsContext is an interface to support dynamic dispatch.
type IParameter_declsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declsContext differentiates from other interfaces.
	IsParameter_declsContext()
}

type Parameter_declsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declsContext() *Parameter_declsContext {
	var p = new(Parameter_declsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_parameter_decls
	return p
}

func (*Parameter_declsContext) IsParameter_declsContext() {}

func NewParameter_declsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declsContext {
	var p = new(Parameter_declsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_parameter_decls

	return p
}

func (s *Parameter_declsContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declsContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Parameter_declsContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Parameter_declsContext) AllParam_decl() []IParam_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParam_declContext)(nil)).Elem())
	var tst = make([]IParam_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParam_declContext)
		}
	}

	return tst
}

func (s *Parameter_declsContext) Param_decl(i int) IParam_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParam_declContext)
}

func (s *Parameter_declsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Parameter_declsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Parameter_declsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterParameter_decls(s)
	}
}

func (s *Parameter_declsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitParameter_decls(s)
	}
}

func (p *IDLParser) Parameter_decls() (localctx IParameter_declsContext) {
	this := p
	_ = this

	localctx = NewParameter_declsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, IDLParserRULE_parameter_decls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1075)
		p.Match(IDLParserLEFT_BRACKET)
	}
	p.SetState(1084)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(IDLParserAT-35))|(1<<(IDLParserKW_OUT-35))|(1<<(IDLParserKW_IN-35)))) != 0) || _la == IDLParserKW_INOUT {
		{
			p.SetState(1076)
			p.Param_decl()
		}
		p.SetState(1081)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMMA {
			{
				p.SetState(1077)
				p.Match(IDLParserCOMMA)
			}
			{
				p.SetState(1078)
				p.Param_decl()
			}

			p.SetState(1083)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1086)
		p.Match(IDLParserRIGHT_BRACKET)
	}

	return localctx
}

// IParam_declContext is an interface to support dynamic dispatch.
type IParam_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_declContext differentiates from other interfaces.
	IsParam_declContext()
}

type Param_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_declContext() *Param_declContext {
	var p = new(Param_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_param_decl
	return p
}

func (*Param_declContext) IsParam_declContext() {}

func NewParam_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_declContext {
	var p = new(Param_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_param_decl

	return p
}

func (s *Param_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_declContext) AllAnnapps() []IAnnappsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnappsContext)(nil)).Elem())
	var tst = make([]IAnnappsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnappsContext)
		}
	}

	return tst
}

func (s *Param_declContext) Annapps(i int) IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Param_declContext) Param_attribute() IParam_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_attributeContext)
}

func (s *Param_declContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Param_declContext) Simple_declarator() ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Param_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterParam_decl(s)
	}
}

func (s *Param_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitParam_decl(s)
	}
}

func (p *IDLParser) Param_decl() (localctx IParam_declContext) {
	this := p
	_ = this

	localctx = NewParam_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, IDLParserRULE_param_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1088)
		p.Annapps()
	}
	{
		p.SetState(1089)
		p.Param_attribute()
	}
	{
		p.SetState(1090)
		p.Annapps()
	}
	{
		p.SetState(1091)
		p.Param_type_spec()
	}
	{
		p.SetState(1092)
		p.Annapps()
	}
	{
		p.SetState(1093)
		p.Simple_declarator()
	}

	return localctx
}

// IParam_attributeContext is an interface to support dynamic dispatch.
type IParam_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_attributeContext differentiates from other interfaces.
	IsParam_attributeContext()
}

type Param_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_attributeContext() *Param_attributeContext {
	var p = new(Param_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_param_attribute
	return p
}

func (*Param_attributeContext) IsParam_attributeContext() {}

func NewParam_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_attributeContext {
	var p = new(Param_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_param_attribute

	return p
}

func (s *Param_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_attributeContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_IN, 0)
}

func (s *Param_attributeContext) KW_OUT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_OUT, 0)
}

func (s *Param_attributeContext) KW_INOUT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INOUT, 0)
}

func (s *Param_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterParam_attribute(s)
	}
}

func (s *Param_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitParam_attribute(s)
	}
}

func (p *IDLParser) Param_attribute() (localctx IParam_attributeContext) {
	this := p
	_ = this

	localctx = NewParam_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, IDLParserRULE_param_attribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1095)
		_la = p.GetTokenStream().LA(1)

		if !(_la == IDLParserKW_OUT || _la == IDLParserKW_IN || _la == IDLParserKW_INOUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRaises_exprContext is an interface to support dynamic dispatch.
type IRaises_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRaises_exprContext differentiates from other interfaces.
	IsRaises_exprContext()
}

type Raises_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaises_exprContext() *Raises_exprContext {
	var p = new(Raises_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_raises_expr
	return p
}

func (*Raises_exprContext) IsRaises_exprContext() {}

func NewRaises_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raises_exprContext {
	var p = new(Raises_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_raises_expr

	return p
}

func (s *Raises_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Raises_exprContext) KW_RAISES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_RAISES, 0)
}

func (s *Raises_exprContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Raises_exprContext) AllA_scoped_name() []IA_scoped_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem())
	var tst = make([]IA_scoped_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IA_scoped_nameContext)
		}
	}

	return tst
}

func (s *Raises_exprContext) A_scoped_name(i int) IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Raises_exprContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Raises_exprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Raises_exprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Raises_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raises_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raises_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterRaises_expr(s)
	}
}

func (s *Raises_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitRaises_expr(s)
	}
}

func (p *IDLParser) Raises_expr() (localctx IRaises_exprContext) {
	this := p
	_ = this

	localctx = NewRaises_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, IDLParserRULE_raises_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.Match(IDLParserKW_RAISES)
	}
	{
		p.SetState(1098)
		p.Match(IDLParserLEFT_BRACKET)
	}
	{
		p.SetState(1099)
		p.A_scoped_name()
	}
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(1100)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(1101)
			p.A_scoped_name()
		}

		p.SetState(1106)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1107)
		p.Match(IDLParserRIGHT_BRACKET)
	}

	return localctx
}

// IContext_exprContext is an interface to support dynamic dispatch.
type IContext_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContext_exprContext differentiates from other interfaces.
	IsContext_exprContext()
}

type Context_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContext_exprContext() *Context_exprContext {
	var p = new(Context_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_context_expr
	return p
}

func (*Context_exprContext) IsContext_exprContext() {}

func NewContext_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Context_exprContext {
	var p = new(Context_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_context_expr

	return p
}

func (s *Context_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Context_exprContext) KW_CONTEXT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CONTEXT, 0)
}

func (s *Context_exprContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Context_exprContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(IDLParserSTRING_LITERAL)
}

func (s *Context_exprContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, i)
}

func (s *Context_exprContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Context_exprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Context_exprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Context_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Context_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Context_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterContext_expr(s)
	}
}

func (s *Context_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitContext_expr(s)
	}
}

func (p *IDLParser) Context_expr() (localctx IContext_exprContext) {
	this := p
	_ = this

	localctx = NewContext_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, IDLParserRULE_context_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.Match(IDLParserKW_CONTEXT)
	}
	{
		p.SetState(1110)
		p.Match(IDLParserLEFT_BRACKET)
	}
	{
		p.SetState(1111)
		p.Match(IDLParserSTRING_LITERAL)
	}
	p.SetState(1116)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(1112)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(1113)
			p.Match(IDLParserSTRING_LITERAL)
		}

		p.SetState(1118)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1119)
		p.Match(IDLParserRIGHT_BRACKET)
	}

	return localctx
}

// IParam_type_specContext is an interface to support dynamic dispatch.
type IParam_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_type_specContext differentiates from other interfaces.
	IsParam_type_specContext()
}

type Param_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_type_specContext() *Param_type_specContext {
	var p = new(Param_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_param_type_spec
	return p
}

func (*Param_type_specContext) IsParam_type_specContext() {}

func NewParam_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_type_specContext {
	var p = new(Param_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_param_type_spec

	return p
}

func (s *Param_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_type_specContext) Base_type_spec() IBase_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_type_specContext)
}

func (s *Param_type_specContext) String_type() IString_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_typeContext)
}

func (s *Param_type_specContext) Wide_string_type() IWide_string_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_string_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_string_typeContext)
}

func (s *Param_type_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Param_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterParam_type_spec(s)
	}
}

func (s *Param_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitParam_type_spec(s)
	}
}

func (p *IDLParser) Param_type_spec() (localctx IParam_type_specContext) {
	this := p
	_ = this

	localctx = NewParam_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, IDLParserRULE_param_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1125)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_OCTET, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserKW_INT8, IDLParserKW_UINT8, IDLParserKW_INT16, IDLParserKW_UINT16, IDLParserKW_INT32, IDLParserKW_UINT32, IDLParserKW_INT64, IDLParserKW_UINT64:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1121)
			p.Base_type_spec()
		}

	case IDLParserKW_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1122)
			p.String_type()
		}

	case IDLParserKW_WSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1123)
			p.Wide_string_type()
		}

	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1124)
			p.Scoped_name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFixed_pt_typeContext is an interface to support dynamic dispatch.
type IFixed_pt_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixed_pt_typeContext differentiates from other interfaces.
	IsFixed_pt_typeContext()
}

type Fixed_pt_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixed_pt_typeContext() *Fixed_pt_typeContext {
	var p = new(Fixed_pt_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_fixed_pt_type
	return p
}

func (*Fixed_pt_typeContext) IsFixed_pt_typeContext() {}

func NewFixed_pt_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fixed_pt_typeContext {
	var p = new(Fixed_pt_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_fixed_pt_type

	return p
}

func (s *Fixed_pt_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Fixed_pt_typeContext) KW_FIXED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FIXED, 0)
}

func (s *Fixed_pt_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *Fixed_pt_typeContext) AllPositive_int_const() []IPositive_int_constContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem())
	var tst = make([]IPositive_int_constContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPositive_int_constContext)
		}
	}

	return tst
}

func (s *Fixed_pt_typeContext) Positive_int_const(i int) IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Fixed_pt_typeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, 0)
}

func (s *Fixed_pt_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *Fixed_pt_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fixed_pt_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fixed_pt_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFixed_pt_type(s)
	}
}

func (s *Fixed_pt_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFixed_pt_type(s)
	}
}

func (p *IDLParser) Fixed_pt_type() (localctx IFixed_pt_typeContext) {
	this := p
	_ = this

	localctx = NewFixed_pt_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, IDLParserRULE_fixed_pt_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1127)
		p.Match(IDLParserKW_FIXED)
	}
	{
		p.SetState(1128)
		p.Match(IDLParserLEFT_ANG_BRACKET)
	}
	{
		p.SetState(1129)
		p.Positive_int_const()
	}
	{
		p.SetState(1130)
		p.Match(IDLParserCOMMA)
	}
	{
		p.SetState(1131)
		p.Positive_int_const()
	}
	{
		p.SetState(1132)
		p.Match(IDLParserRIGHT_ANG_BRACKET)
	}

	return localctx
}

// IFixed_pt_const_typeContext is an interface to support dynamic dispatch.
type IFixed_pt_const_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixed_pt_const_typeContext differentiates from other interfaces.
	IsFixed_pt_const_typeContext()
}

type Fixed_pt_const_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixed_pt_const_typeContext() *Fixed_pt_const_typeContext {
	var p = new(Fixed_pt_const_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_fixed_pt_const_type
	return p
}

func (*Fixed_pt_const_typeContext) IsFixed_pt_const_typeContext() {}

func NewFixed_pt_const_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fixed_pt_const_typeContext {
	var p = new(Fixed_pt_const_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_fixed_pt_const_type

	return p
}

func (s *Fixed_pt_const_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Fixed_pt_const_typeContext) KW_FIXED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FIXED, 0)
}

func (s *Fixed_pt_const_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fixed_pt_const_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fixed_pt_const_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFixed_pt_const_type(s)
	}
}

func (s *Fixed_pt_const_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFixed_pt_const_type(s)
	}
}

func (p *IDLParser) Fixed_pt_const_type() (localctx IFixed_pt_const_typeContext) {
	this := p
	_ = this

	localctx = NewFixed_pt_const_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, IDLParserRULE_fixed_pt_const_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1134)
		p.Match(IDLParserKW_FIXED)
	}

	return localctx
}

// IValue_base_typeContext is an interface to support dynamic dispatch.
type IValue_base_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_base_typeContext differentiates from other interfaces.
	IsValue_base_typeContext()
}

type Value_base_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_base_typeContext() *Value_base_typeContext {
	var p = new(Value_base_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_base_type
	return p
}

func (*Value_base_typeContext) IsValue_base_typeContext() {}

func NewValue_base_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_base_typeContext {
	var p = new(Value_base_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_base_type

	return p
}

func (s *Value_base_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_base_typeContext) KW_VALUEBASE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUEBASE, 0)
}

func (s *Value_base_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_base_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_base_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_base_type(s)
	}
}

func (s *Value_base_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_base_type(s)
	}
}

func (p *IDLParser) Value_base_type() (localctx IValue_base_typeContext) {
	this := p
	_ = this

	localctx = NewValue_base_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, IDLParserRULE_value_base_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		p.Match(IDLParserKW_VALUEBASE)
	}

	return localctx
}

// IConstr_forward_declContext is an interface to support dynamic dispatch.
type IConstr_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstr_forward_declContext differentiates from other interfaces.
	IsConstr_forward_declContext()
}

type Constr_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstr_forward_declContext() *Constr_forward_declContext {
	var p = new(Constr_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_constr_forward_decl
	return p
}

func (*Constr_forward_declContext) IsConstr_forward_declContext() {}

func NewConstr_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constr_forward_declContext {
	var p = new(Constr_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_constr_forward_decl

	return p
}

func (s *Constr_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Constr_forward_declContext) KW_STRUCT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_STRUCT, 0)
}

func (s *Constr_forward_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Constr_forward_declContext) KW_UNION() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNION, 0)
}

func (s *Constr_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constr_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constr_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConstr_forward_decl(s)
	}
}

func (s *Constr_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConstr_forward_decl(s)
	}
}

func (p *IDLParser) Constr_forward_decl() (localctx IConstr_forward_declContext) {
	this := p
	_ = this

	localctx = NewConstr_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, IDLParserRULE_constr_forward_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1142)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_STRUCT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1138)
			p.Match(IDLParserKW_STRUCT)
		}
		{
			p.SetState(1139)
			p.Match(IDLParserID)
		}

	case IDLParserKW_UNION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1140)
			p.Match(IDLParserKW_UNION)
		}
		{
			p.SetState(1141)
			p.Match(IDLParserID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImport_declContext is an interface to support dynamic dispatch.
type IImport_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_declContext differentiates from other interfaces.
	IsImport_declContext()
}

type Import_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_declContext() *Import_declContext {
	var p = new(Import_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_import_decl
	return p
}

func (*Import_declContext) IsImport_declContext() {}

func NewImport_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_declContext {
	var p = new(Import_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_import_decl

	return p
}

func (s *Import_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_declContext) AllAnnapps() []IAnnappsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnappsContext)(nil)).Elem())
	var tst = make([]IAnnappsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnappsContext)
		}
	}

	return tst
}

func (s *Import_declContext) Annapps(i int) IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Import_declContext) KW_IMPORT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_IMPORT, 0)
}

func (s *Import_declContext) Imported_scope() IImported_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImported_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImported_scopeContext)
}

func (s *Import_declContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Import_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterImport_decl(s)
	}
}

func (s *Import_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitImport_decl(s)
	}
}

func (p *IDLParser) Import_decl() (localctx IImport_declContext) {
	this := p
	_ = this

	localctx = NewImport_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, IDLParserRULE_import_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1144)
		p.Annapps()
	}
	{
		p.SetState(1145)
		p.Match(IDLParserKW_IMPORT)
	}
	{
		p.SetState(1146)
		p.Annapps()
	}
	{
		p.SetState(1147)
		p.Imported_scope()
	}
	{
		p.SetState(1148)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// IImported_scopeContext is an interface to support dynamic dispatch.
type IImported_scopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImported_scopeContext differentiates from other interfaces.
	IsImported_scopeContext()
}

type Imported_scopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImported_scopeContext() *Imported_scopeContext {
	var p = new(Imported_scopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_imported_scope
	return p
}

func (*Imported_scopeContext) IsImported_scopeContext() {}

func NewImported_scopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imported_scopeContext {
	var p = new(Imported_scopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_imported_scope

	return p
}

func (s *Imported_scopeContext) GetParser() antlr.Parser { return s.parser }

func (s *Imported_scopeContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Imported_scopeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, 0)
}

func (s *Imported_scopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imported_scopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imported_scopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterImported_scope(s)
	}
}

func (s *Imported_scopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitImported_scope(s)
	}
}

func (p *IDLParser) Imported_scope() (localctx IImported_scopeContext) {
	this := p
	_ = this

	localctx = NewImported_scopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, IDLParserRULE_imported_scope)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1152)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1150)
			p.Scoped_name()
		}

	case IDLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1151)
			p.Match(IDLParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_id_declContext is an interface to support dynamic dispatch.
type IType_id_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_id_declContext differentiates from other interfaces.
	IsType_id_declContext()
}

type Type_id_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_id_declContext() *Type_id_declContext {
	var p = new(Type_id_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_id_decl
	return p
}

func (*Type_id_declContext) IsType_id_declContext() {}

func NewType_id_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_id_declContext {
	var p = new(Type_id_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_id_decl

	return p
}

func (s *Type_id_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_id_declContext) KW_TYPEID() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_TYPEID, 0)
}

func (s *Type_id_declContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Type_id_declContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, 0)
}

func (s *Type_id_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_id_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_id_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_id_decl(s)
	}
}

func (s *Type_id_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_id_decl(s)
	}
}

func (p *IDLParser) Type_id_decl() (localctx IType_id_declContext) {
	this := p
	_ = this

	localctx = NewType_id_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, IDLParserRULE_type_id_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1154)
		p.Match(IDLParserKW_TYPEID)
	}
	{
		p.SetState(1155)
		p.A_scoped_name()
	}
	{
		p.SetState(1156)
		p.Match(IDLParserSTRING_LITERAL)
	}

	return localctx
}

// IType_prefix_declContext is an interface to support dynamic dispatch.
type IType_prefix_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_prefix_declContext differentiates from other interfaces.
	IsType_prefix_declContext()
}

type Type_prefix_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_prefix_declContext() *Type_prefix_declContext {
	var p = new(Type_prefix_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_prefix_decl
	return p
}

func (*Type_prefix_declContext) IsType_prefix_declContext() {}

func NewType_prefix_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_prefix_declContext {
	var p = new(Type_prefix_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_prefix_decl

	return p
}

func (s *Type_prefix_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_prefix_declContext) KW_TYPEPREFIX() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_TYPEPREFIX, 0)
}

func (s *Type_prefix_declContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Type_prefix_declContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, 0)
}

func (s *Type_prefix_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_prefix_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_prefix_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_prefix_decl(s)
	}
}

func (s *Type_prefix_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_prefix_decl(s)
	}
}

func (p *IDLParser) Type_prefix_decl() (localctx IType_prefix_declContext) {
	this := p
	_ = this

	localctx = NewType_prefix_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, IDLParserRULE_type_prefix_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1158)
		p.Match(IDLParserKW_TYPEPREFIX)
	}
	{
		p.SetState(1159)
		p.A_scoped_name()
	}
	{
		p.SetState(1160)
		p.Match(IDLParserSTRING_LITERAL)
	}

	return localctx
}

// IReadonly_attr_specContext is an interface to support dynamic dispatch.
type IReadonly_attr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadonly_attr_specContext differentiates from other interfaces.
	IsReadonly_attr_specContext()
}

type Readonly_attr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadonly_attr_specContext() *Readonly_attr_specContext {
	var p = new(Readonly_attr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_readonly_attr_spec
	return p
}

func (*Readonly_attr_specContext) IsReadonly_attr_specContext() {}

func NewReadonly_attr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Readonly_attr_specContext {
	var p = new(Readonly_attr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_readonly_attr_spec

	return p
}

func (s *Readonly_attr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Readonly_attr_specContext) KW_READONLY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_READONLY, 0)
}

func (s *Readonly_attr_specContext) KW_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ATTRIBUTE, 0)
}

func (s *Readonly_attr_specContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Readonly_attr_specContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Readonly_attr_specContext) Readonly_attr_declarator() IReadonly_attr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadonly_attr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadonly_attr_declaratorContext)
}

func (s *Readonly_attr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Readonly_attr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Readonly_attr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterReadonly_attr_spec(s)
	}
}

func (s *Readonly_attr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitReadonly_attr_spec(s)
	}
}

func (p *IDLParser) Readonly_attr_spec() (localctx IReadonly_attr_specContext) {
	this := p
	_ = this

	localctx = NewReadonly_attr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, IDLParserRULE_readonly_attr_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.Match(IDLParserKW_READONLY)
	}
	{
		p.SetState(1163)
		p.Match(IDLParserKW_ATTRIBUTE)
	}
	{
		p.SetState(1164)
		p.Annapps()
	}
	{
		p.SetState(1165)
		p.Param_type_spec()
	}
	{
		p.SetState(1166)
		p.Readonly_attr_declarator()
	}

	return localctx
}

// IReadonly_attr_declaratorContext is an interface to support dynamic dispatch.
type IReadonly_attr_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadonly_attr_declaratorContext differentiates from other interfaces.
	IsReadonly_attr_declaratorContext()
}

type Readonly_attr_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadonly_attr_declaratorContext() *Readonly_attr_declaratorContext {
	var p = new(Readonly_attr_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_readonly_attr_declarator
	return p
}

func (*Readonly_attr_declaratorContext) IsReadonly_attr_declaratorContext() {}

func NewReadonly_attr_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Readonly_attr_declaratorContext {
	var p = new(Readonly_attr_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_readonly_attr_declarator

	return p
}

func (s *Readonly_attr_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Readonly_attr_declaratorContext) AllAnnapps() []IAnnappsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnappsContext)(nil)).Elem())
	var tst = make([]IAnnappsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnappsContext)
		}
	}

	return tst
}

func (s *Readonly_attr_declaratorContext) Annapps(i int) IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Readonly_attr_declaratorContext) AllSimple_declarator() []ISimple_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem())
	var tst = make([]ISimple_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_declaratorContext)
		}
	}

	return tst
}

func (s *Readonly_attr_declaratorContext) Simple_declarator(i int) ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Readonly_attr_declaratorContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Readonly_attr_declaratorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Readonly_attr_declaratorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Readonly_attr_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Readonly_attr_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Readonly_attr_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterReadonly_attr_declarator(s)
	}
}

func (s *Readonly_attr_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitReadonly_attr_declarator(s)
	}
}

func (p *IDLParser) Readonly_attr_declarator() (localctx IReadonly_attr_declaratorContext) {
	this := p
	_ = this

	localctx = NewReadonly_attr_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, IDLParserRULE_readonly_attr_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1168)
		p.Annapps()
	}
	{
		p.SetState(1169)
		p.Simple_declarator()
	}
	p.SetState(1180)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_RAISES:
		{
			p.SetState(1170)
			p.Raises_expr()
		}

	case IDLParserSEMICOLON, IDLParserCOMMA:
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMMA {
			{
				p.SetState(1171)
				p.Match(IDLParserCOMMA)
			}
			{
				p.SetState(1172)
				p.Annapps()
			}
			{
				p.SetState(1173)
				p.Simple_declarator()
			}

			p.SetState(1179)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttr_specContext is an interface to support dynamic dispatch.
type IAttr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_specContext differentiates from other interfaces.
	IsAttr_specContext()
}

type Attr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_specContext() *Attr_specContext {
	var p = new(Attr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_attr_spec
	return p
}

func (*Attr_specContext) IsAttr_specContext() {}

func NewAttr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_specContext {
	var p = new(Attr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_attr_spec

	return p
}

func (s *Attr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_specContext) KW_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ATTRIBUTE, 0)
}

func (s *Attr_specContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Attr_specContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Attr_specContext) Attr_declarator() IAttr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_declaratorContext)
}

func (s *Attr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAttr_spec(s)
	}
}

func (s *Attr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAttr_spec(s)
	}
}

func (p *IDLParser) Attr_spec() (localctx IAttr_specContext) {
	this := p
	_ = this

	localctx = NewAttr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, IDLParserRULE_attr_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1182)
		p.Match(IDLParserKW_ATTRIBUTE)
	}
	{
		p.SetState(1183)
		p.Annapps()
	}
	{
		p.SetState(1184)
		p.Param_type_spec()
	}
	{
		p.SetState(1185)
		p.Attr_declarator()
	}

	return localctx
}

// IAttr_declaratorContext is an interface to support dynamic dispatch.
type IAttr_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_declaratorContext differentiates from other interfaces.
	IsAttr_declaratorContext()
}

type Attr_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_declaratorContext() *Attr_declaratorContext {
	var p = new(Attr_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_attr_declarator
	return p
}

func (*Attr_declaratorContext) IsAttr_declaratorContext() {}

func NewAttr_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_declaratorContext {
	var p = new(Attr_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_attr_declarator

	return p
}

func (s *Attr_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_declaratorContext) AllAnnapps() []IAnnappsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnappsContext)(nil)).Elem())
	var tst = make([]IAnnappsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnappsContext)
		}
	}

	return tst
}

func (s *Attr_declaratorContext) Annapps(i int) IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Attr_declaratorContext) AllSimple_declarator() []ISimple_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem())
	var tst = make([]ISimple_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_declaratorContext)
		}
	}

	return tst
}

func (s *Attr_declaratorContext) Simple_declarator(i int) ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Attr_declaratorContext) Attr_raises_expr() IAttr_raises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_raises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_raises_exprContext)
}

func (s *Attr_declaratorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Attr_declaratorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Attr_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAttr_declarator(s)
	}
}

func (s *Attr_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAttr_declarator(s)
	}
}

func (p *IDLParser) Attr_declarator() (localctx IAttr_declaratorContext) {
	this := p
	_ = this

	localctx = NewAttr_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, IDLParserRULE_attr_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.Annapps()
	}
	{
		p.SetState(1188)
		p.Simple_declarator()
	}
	p.SetState(1199)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_SETRAISES, IDLParserKW_GETRAISES:
		{
			p.SetState(1189)
			p.Attr_raises_expr()
		}

	case IDLParserSEMICOLON, IDLParserCOMMA:
		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMMA {
			{
				p.SetState(1190)
				p.Match(IDLParserCOMMA)
			}
			{
				p.SetState(1191)
				p.Annapps()
			}
			{
				p.SetState(1192)
				p.Simple_declarator()
			}

			p.SetState(1198)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttr_raises_exprContext is an interface to support dynamic dispatch.
type IAttr_raises_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_raises_exprContext differentiates from other interfaces.
	IsAttr_raises_exprContext()
}

type Attr_raises_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_raises_exprContext() *Attr_raises_exprContext {
	var p = new(Attr_raises_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_attr_raises_expr
	return p
}

func (*Attr_raises_exprContext) IsAttr_raises_exprContext() {}

func NewAttr_raises_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_raises_exprContext {
	var p = new(Attr_raises_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_attr_raises_expr

	return p
}

func (s *Attr_raises_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_raises_exprContext) Get_excep_expr() IGet_excep_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_excep_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_excep_exprContext)
}

func (s *Attr_raises_exprContext) Set_excep_expr() ISet_excep_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_excep_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_excep_exprContext)
}

func (s *Attr_raises_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_raises_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_raises_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAttr_raises_expr(s)
	}
}

func (s *Attr_raises_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAttr_raises_expr(s)
	}
}

func (p *IDLParser) Attr_raises_expr() (localctx IAttr_raises_exprContext) {
	this := p
	_ = this

	localctx = NewAttr_raises_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, IDLParserRULE_attr_raises_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1206)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_GETRAISES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1201)
			p.Get_excep_expr()
		}
		p.SetState(1203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == IDLParserKW_SETRAISES {
			{
				p.SetState(1202)
				p.Set_excep_expr()
			}

		}

	case IDLParserKW_SETRAISES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1205)
			p.Set_excep_expr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGet_excep_exprContext is an interface to support dynamic dispatch.
type IGet_excep_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_excep_exprContext differentiates from other interfaces.
	IsGet_excep_exprContext()
}

type Get_excep_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_excep_exprContext() *Get_excep_exprContext {
	var p = new(Get_excep_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_get_excep_expr
	return p
}

func (*Get_excep_exprContext) IsGet_excep_exprContext() {}

func NewGet_excep_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_excep_exprContext {
	var p = new(Get_excep_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_get_excep_expr

	return p
}

func (s *Get_excep_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_excep_exprContext) KW_GETRAISES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_GETRAISES, 0)
}

func (s *Get_excep_exprContext) Exception_list() IException_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_listContext)
}

func (s *Get_excep_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_excep_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_excep_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterGet_excep_expr(s)
	}
}

func (s *Get_excep_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitGet_excep_expr(s)
	}
}

func (p *IDLParser) Get_excep_expr() (localctx IGet_excep_exprContext) {
	this := p
	_ = this

	localctx = NewGet_excep_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, IDLParserRULE_get_excep_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		p.Match(IDLParserKW_GETRAISES)
	}
	{
		p.SetState(1209)
		p.Exception_list()
	}

	return localctx
}

// ISet_excep_exprContext is an interface to support dynamic dispatch.
type ISet_excep_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_excep_exprContext differentiates from other interfaces.
	IsSet_excep_exprContext()
}

type Set_excep_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_excep_exprContext() *Set_excep_exprContext {
	var p = new(Set_excep_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_set_excep_expr
	return p
}

func (*Set_excep_exprContext) IsSet_excep_exprContext() {}

func NewSet_excep_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_excep_exprContext {
	var p = new(Set_excep_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_set_excep_expr

	return p
}

func (s *Set_excep_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_excep_exprContext) KW_SETRAISES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SETRAISES, 0)
}

func (s *Set_excep_exprContext) Exception_list() IException_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_listContext)
}

func (s *Set_excep_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_excep_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_excep_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSet_excep_expr(s)
	}
}

func (s *Set_excep_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSet_excep_expr(s)
	}
}

func (p *IDLParser) Set_excep_expr() (localctx ISet_excep_exprContext) {
	this := p
	_ = this

	localctx = NewSet_excep_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, IDLParserRULE_set_excep_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1211)
		p.Match(IDLParserKW_SETRAISES)
	}
	{
		p.SetState(1212)
		p.Exception_list()
	}

	return localctx
}

// IException_listContext is an interface to support dynamic dispatch.
type IException_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_listContext differentiates from other interfaces.
	IsException_listContext()
}

type Exception_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_listContext() *Exception_listContext {
	var p = new(Exception_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_exception_list
	return p
}

func (*Exception_listContext) IsException_listContext() {}

func NewException_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_listContext {
	var p = new(Exception_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_exception_list

	return p
}

func (s *Exception_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_listContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Exception_listContext) AllA_scoped_name() []IA_scoped_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem())
	var tst = make([]IA_scoped_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IA_scoped_nameContext)
		}
	}

	return tst
}

func (s *Exception_listContext) A_scoped_name(i int) IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Exception_listContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Exception_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Exception_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Exception_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterException_list(s)
	}
}

func (s *Exception_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitException_list(s)
	}
}

func (p *IDLParser) Exception_list() (localctx IException_listContext) {
	this := p
	_ = this

	localctx = NewException_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, IDLParserRULE_exception_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1214)
		p.Match(IDLParserLEFT_BRACKET)
	}
	{
		p.SetState(1215)
		p.A_scoped_name()
	}
	p.SetState(1220)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(1216)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(1217)
			p.A_scoped_name()
		}

		p.SetState(1222)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1223)
		p.Match(IDLParserRIGHT_BRACKET)
	}

	return localctx
}

// IComponentContext is an interface to support dynamic dispatch.
type IComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentContext differentiates from other interfaces.
	IsComponentContext()
}

type ComponentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentContext() *ComponentContext {
	var p = new(ComponentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component
	return p
}

func (*ComponentContext) IsComponentContext() {}

func NewComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentContext {
	var p = new(ComponentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component

	return p
}

func (s *ComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentContext) Component_decl() IComponent_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_declContext)
}

func (s *ComponentContext) Component_forward_decl() IComponent_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_forward_declContext)
}

func (s *ComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent(s)
	}
}

func (s *ComponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent(s)
	}
}

func (p *IDLParser) Component() (localctx IComponentContext) {
	this := p
	_ = this

	localctx = NewComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, IDLParserRULE_component)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1225)
			p.Component_decl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1226)
			p.Component_forward_decl()
		}

	}

	return localctx
}

// IComponent_forward_declContext is an interface to support dynamic dispatch.
type IComponent_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_forward_declContext differentiates from other interfaces.
	IsComponent_forward_declContext()
}

type Component_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_forward_declContext() *Component_forward_declContext {
	var p = new(Component_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_forward_decl
	return p
}

func (*Component_forward_declContext) IsComponent_forward_declContext() {}

func NewComponent_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_forward_declContext {
	var p = new(Component_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_forward_decl

	return p
}

func (s *Component_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_forward_declContext) KW_COMPONENT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_COMPONENT, 0)
}

func (s *Component_forward_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Component_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_forward_decl(s)
	}
}

func (s *Component_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_forward_decl(s)
	}
}

func (p *IDLParser) Component_forward_decl() (localctx IComponent_forward_declContext) {
	this := p
	_ = this

	localctx = NewComponent_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, IDLParserRULE_component_forward_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1229)
		p.Match(IDLParserKW_COMPONENT)
	}
	{
		p.SetState(1230)
		p.Match(IDLParserID)
	}

	return localctx
}

// IComponent_declContext is an interface to support dynamic dispatch.
type IComponent_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_declContext differentiates from other interfaces.
	IsComponent_declContext()
}

type Component_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_declContext() *Component_declContext {
	var p = new(Component_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_decl
	return p
}

func (*Component_declContext) IsComponent_declContext() {}

func NewComponent_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_declContext {
	var p = new(Component_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_decl

	return p
}

func (s *Component_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_declContext) Component_header() IComponent_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_headerContext)
}

func (s *Component_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Component_declContext) Component_body() IComponent_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_bodyContext)
}

func (s *Component_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Component_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_decl(s)
	}
}

func (s *Component_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_decl(s)
	}
}

func (p *IDLParser) Component_decl() (localctx IComponent_declContext) {
	this := p
	_ = this

	localctx = NewComponent_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, IDLParserRULE_component_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1232)
		p.Component_header()
	}
	{
		p.SetState(1233)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(1234)
		p.Component_body()
	}
	{
		p.SetState(1235)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IComponent_headerContext is an interface to support dynamic dispatch.
type IComponent_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_headerContext differentiates from other interfaces.
	IsComponent_headerContext()
}

type Component_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_headerContext() *Component_headerContext {
	var p = new(Component_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_header
	return p
}

func (*Component_headerContext) IsComponent_headerContext() {}

func NewComponent_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_headerContext {
	var p = new(Component_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_header

	return p
}

func (s *Component_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_headerContext) KW_COMPONENT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_COMPONENT, 0)
}

func (s *Component_headerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Component_headerContext) Component_inheritance_spec() IComponent_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_inheritance_specContext)
}

func (s *Component_headerContext) Supported_interface_spec() ISupported_interface_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupported_interface_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupported_interface_specContext)
}

func (s *Component_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_header(s)
	}
}

func (s *Component_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_header(s)
	}
}

func (p *IDLParser) Component_header() (localctx IComponent_headerContext) {
	this := p
	_ = this

	localctx = NewComponent_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, IDLParserRULE_component_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.Match(IDLParserKW_COMPONENT)
	}
	{
		p.SetState(1238)
		p.Identifier()
	}
	p.SetState(1240)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(1239)
			p.Component_inheritance_spec()
		}

	}
	p.SetState(1243)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_SUPPORTS {
		{
			p.SetState(1242)
			p.Supported_interface_spec()
		}

	}

	return localctx
}

// ISupported_interface_specContext is an interface to support dynamic dispatch.
type ISupported_interface_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSupported_interface_specContext differentiates from other interfaces.
	IsSupported_interface_specContext()
}

type Supported_interface_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupported_interface_specContext() *Supported_interface_specContext {
	var p = new(Supported_interface_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_supported_interface_spec
	return p
}

func (*Supported_interface_specContext) IsSupported_interface_specContext() {}

func NewSupported_interface_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Supported_interface_specContext {
	var p = new(Supported_interface_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_supported_interface_spec

	return p
}

func (s *Supported_interface_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Supported_interface_specContext) KW_SUPPORTS() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SUPPORTS, 0)
}

func (s *Supported_interface_specContext) AllA_scoped_name() []IA_scoped_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem())
	var tst = make([]IA_scoped_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IA_scoped_nameContext)
		}
	}

	return tst
}

func (s *Supported_interface_specContext) A_scoped_name(i int) IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Supported_interface_specContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Supported_interface_specContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Supported_interface_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Supported_interface_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Supported_interface_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSupported_interface_spec(s)
	}
}

func (s *Supported_interface_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSupported_interface_spec(s)
	}
}

func (p *IDLParser) Supported_interface_spec() (localctx ISupported_interface_specContext) {
	this := p
	_ = this

	localctx = NewSupported_interface_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, IDLParserRULE_supported_interface_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1245)
		p.Match(IDLParserKW_SUPPORTS)
	}
	{
		p.SetState(1246)
		p.A_scoped_name()
	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMMA {
		{
			p.SetState(1247)
			p.Match(IDLParserCOMMA)
		}
		{
			p.SetState(1248)
			p.A_scoped_name()
		}

		p.SetState(1253)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComponent_inheritance_specContext is an interface to support dynamic dispatch.
type IComponent_inheritance_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_inheritance_specContext differentiates from other interfaces.
	IsComponent_inheritance_specContext()
}

type Component_inheritance_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_inheritance_specContext() *Component_inheritance_specContext {
	var p = new(Component_inheritance_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_inheritance_spec
	return p
}

func (*Component_inheritance_specContext) IsComponent_inheritance_specContext() {}

func NewComponent_inheritance_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_inheritance_specContext {
	var p = new(Component_inheritance_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_inheritance_spec

	return p
}

func (s *Component_inheritance_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_inheritance_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Component_inheritance_specContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Component_inheritance_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_inheritance_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_inheritance_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_inheritance_spec(s)
	}
}

func (s *Component_inheritance_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_inheritance_spec(s)
	}
}

func (p *IDLParser) Component_inheritance_spec() (localctx IComponent_inheritance_specContext) {
	this := p
	_ = this

	localctx = NewComponent_inheritance_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, IDLParserRULE_component_inheritance_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1254)
		p.Match(IDLParserCOLON)
	}
	{
		p.SetState(1255)
		p.A_scoped_name()
	}

	return localctx
}

// IComponent_bodyContext is an interface to support dynamic dispatch.
type IComponent_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_bodyContext differentiates from other interfaces.
	IsComponent_bodyContext()
}

type Component_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_bodyContext() *Component_bodyContext {
	var p = new(Component_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_body
	return p
}

func (*Component_bodyContext) IsComponent_bodyContext() {}

func NewComponent_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_bodyContext {
	var p = new(Component_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_body

	return p
}

func (s *Component_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_bodyContext) AllComponent_export() []IComponent_exportContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponent_exportContext)(nil)).Elem())
	var tst = make([]IComponent_exportContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponent_exportContext)
		}
	}

	return tst
}

func (s *Component_bodyContext) Component_export(i int) IComponent_exportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_exportContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponent_exportContext)
}

func (s *Component_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_body(s)
	}
}

func (s *Component_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_body(s)
	}
}

func (p *IDLParser) Component_body() (localctx IComponent_bodyContext) {
	this := p
	_ = this

	localctx = NewComponent_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, IDLParserRULE_component_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1260)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(IDLParserAT-35))|(1<<(IDLParserKW_EMITS-35))|(1<<(IDLParserKW_PUBLISHES-35))|(1<<(IDLParserKW_USES-35))|(1<<(IDLParserKW_READONLY-35)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(IDLParserKW_PROVIDES-89))|(1<<(IDLParserKW_CONSUMES-89))|(1<<(IDLParserKW_ATTRIBUTE-89)))) != 0) {
		{
			p.SetState(1257)
			p.Component_export()
		}

		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComponent_exportContext is an interface to support dynamic dispatch.
type IComponent_exportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_exportContext differentiates from other interfaces.
	IsComponent_exportContext()
}

type Component_exportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_exportContext() *Component_exportContext {
	var p = new(Component_exportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_export
	return p
}

func (*Component_exportContext) IsComponent_exportContext() {}

func NewComponent_exportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_exportContext {
	var p = new(Component_exportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_export

	return p
}

func (s *Component_exportContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_exportContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Component_exportContext) Provides_decl() IProvides_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProvides_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProvides_declContext)
}

func (s *Component_exportContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Component_exportContext) Uses_decl() IUses_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUses_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUses_declContext)
}

func (s *Component_exportContext) Emits_decl() IEmits_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmits_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmits_declContext)
}

func (s *Component_exportContext) Publishes_decl() IPublishes_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPublishes_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPublishes_declContext)
}

func (s *Component_exportContext) Consumes_decl() IConsumes_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConsumes_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConsumes_declContext)
}

func (s *Component_exportContext) Attr_decl() IAttr_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_declContext)
}

func (s *Component_exportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_exportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_exportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_export(s)
	}
}

func (s *Component_exportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_export(s)
	}
}

func (p *IDLParser) Component_export() (localctx IComponent_exportContext) {
	this := p
	_ = this

	localctx = NewComponent_exportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, IDLParserRULE_component_export)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1263)
		p.Annapps()
	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_PROVIDES:
		{
			p.SetState(1264)
			p.Provides_decl()
		}
		{
			p.SetState(1265)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_USES:
		{
			p.SetState(1267)
			p.Uses_decl()
		}
		{
			p.SetState(1268)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_EMITS:
		{
			p.SetState(1270)
			p.Emits_decl()
		}
		{
			p.SetState(1271)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_PUBLISHES:
		{
			p.SetState(1273)
			p.Publishes_decl()
		}
		{
			p.SetState(1274)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_CONSUMES:
		{
			p.SetState(1276)
			p.Consumes_decl()
		}
		{
			p.SetState(1277)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_READONLY, IDLParserKW_ATTRIBUTE:
		{
			p.SetState(1279)
			p.Attr_decl()
		}
		{
			p.SetState(1280)
			p.Match(IDLParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProvides_declContext is an interface to support dynamic dispatch.
type IProvides_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProvides_declContext differentiates from other interfaces.
	IsProvides_declContext()
}

type Provides_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProvides_declContext() *Provides_declContext {
	var p = new(Provides_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_provides_decl
	return p
}

func (*Provides_declContext) IsProvides_declContext() {}

func NewProvides_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Provides_declContext {
	var p = new(Provides_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_provides_decl

	return p
}

func (s *Provides_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Provides_declContext) KW_PROVIDES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PROVIDES, 0)
}

func (s *Provides_declContext) Interface_type() IInterface_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_typeContext)
}

func (s *Provides_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Provides_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Provides_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Provides_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterProvides_decl(s)
	}
}

func (s *Provides_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitProvides_decl(s)
	}
}

func (p *IDLParser) Provides_decl() (localctx IProvides_declContext) {
	this := p
	_ = this

	localctx = NewProvides_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, IDLParserRULE_provides_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1284)
		p.Match(IDLParserKW_PROVIDES)
	}
	{
		p.SetState(1285)
		p.Interface_type()
	}
	{
		p.SetState(1286)
		p.Match(IDLParserID)
	}

	return localctx
}

// IInterface_typeContext is an interface to support dynamic dispatch.
type IInterface_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_typeContext differentiates from other interfaces.
	IsInterface_typeContext()
}

type Interface_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_typeContext() *Interface_typeContext {
	var p = new(Interface_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_type
	return p
}

func (*Interface_typeContext) IsInterface_typeContext() {}

func NewInterface_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_typeContext {
	var p = new(Interface_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_type

	return p
}

func (s *Interface_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_typeContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Interface_typeContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Interface_typeContext) KW_OBJECT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_OBJECT, 0)
}

func (s *Interface_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_type(s)
	}
}

func (s *Interface_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_type(s)
	}
}

func (p *IDLParser) Interface_type() (localctx IInterface_typeContext) {
	this := p
	_ = this

	localctx = NewInterface_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, IDLParserRULE_interface_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.Annapps()
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserID:
		{
			p.SetState(1289)
			p.Scoped_name()
		}

	case IDLParserKW_OBJECT:
		{
			p.SetState(1290)
			p.Match(IDLParserKW_OBJECT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUses_declContext is an interface to support dynamic dispatch.
type IUses_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUses_declContext differentiates from other interfaces.
	IsUses_declContext()
}

type Uses_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUses_declContext() *Uses_declContext {
	var p = new(Uses_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_uses_decl
	return p
}

func (*Uses_declContext) IsUses_declContext() {}

func NewUses_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Uses_declContext {
	var p = new(Uses_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_uses_decl

	return p
}

func (s *Uses_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Uses_declContext) KW_USES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_USES, 0)
}

func (s *Uses_declContext) Interface_type() IInterface_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_typeContext)
}

func (s *Uses_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Uses_declContext) KW_MULTIPLE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_MULTIPLE, 0)
}

func (s *Uses_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Uses_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Uses_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUses_decl(s)
	}
}

func (s *Uses_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUses_decl(s)
	}
}

func (p *IDLParser) Uses_decl() (localctx IUses_declContext) {
	this := p
	_ = this

	localctx = NewUses_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, IDLParserRULE_uses_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1293)
		p.Match(IDLParserKW_USES)
	}
	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_MULTIPLE {
		{
			p.SetState(1294)
			p.Match(IDLParserKW_MULTIPLE)
		}

	}
	{
		p.SetState(1297)
		p.Interface_type()
	}
	{
		p.SetState(1298)
		p.Match(IDLParserID)
	}

	return localctx
}

// IEmits_declContext is an interface to support dynamic dispatch.
type IEmits_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmits_declContext differentiates from other interfaces.
	IsEmits_declContext()
}

type Emits_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmits_declContext() *Emits_declContext {
	var p = new(Emits_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_emits_decl
	return p
}

func (*Emits_declContext) IsEmits_declContext() {}

func NewEmits_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Emits_declContext {
	var p = new(Emits_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_emits_decl

	return p
}

func (s *Emits_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Emits_declContext) KW_EMITS() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EMITS, 0)
}

func (s *Emits_declContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Emits_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Emits_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Emits_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Emits_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEmits_decl(s)
	}
}

func (s *Emits_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEmits_decl(s)
	}
}

func (p *IDLParser) Emits_decl() (localctx IEmits_declContext) {
	this := p
	_ = this

	localctx = NewEmits_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, IDLParserRULE_emits_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1300)
		p.Match(IDLParserKW_EMITS)
	}
	{
		p.SetState(1301)
		p.A_scoped_name()
	}
	{
		p.SetState(1302)
		p.Match(IDLParserID)
	}

	return localctx
}

// IPublishes_declContext is an interface to support dynamic dispatch.
type IPublishes_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPublishes_declContext differentiates from other interfaces.
	IsPublishes_declContext()
}

type Publishes_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPublishes_declContext() *Publishes_declContext {
	var p = new(Publishes_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_publishes_decl
	return p
}

func (*Publishes_declContext) IsPublishes_declContext() {}

func NewPublishes_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Publishes_declContext {
	var p = new(Publishes_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_publishes_decl

	return p
}

func (s *Publishes_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Publishes_declContext) KW_PUBLISHES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PUBLISHES, 0)
}

func (s *Publishes_declContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Publishes_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Publishes_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Publishes_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Publishes_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterPublishes_decl(s)
	}
}

func (s *Publishes_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitPublishes_decl(s)
	}
}

func (p *IDLParser) Publishes_decl() (localctx IPublishes_declContext) {
	this := p
	_ = this

	localctx = NewPublishes_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, IDLParserRULE_publishes_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1304)
		p.Match(IDLParserKW_PUBLISHES)
	}
	{
		p.SetState(1305)
		p.A_scoped_name()
	}
	{
		p.SetState(1306)
		p.Match(IDLParserID)
	}

	return localctx
}

// IConsumes_declContext is an interface to support dynamic dispatch.
type IConsumes_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConsumes_declContext differentiates from other interfaces.
	IsConsumes_declContext()
}

type Consumes_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConsumes_declContext() *Consumes_declContext {
	var p = new(Consumes_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_consumes_decl
	return p
}

func (*Consumes_declContext) IsConsumes_declContext() {}

func NewConsumes_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Consumes_declContext {
	var p = new(Consumes_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_consumes_decl

	return p
}

func (s *Consumes_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Consumes_declContext) KW_CONSUMES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CONSUMES, 0)
}

func (s *Consumes_declContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Consumes_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Consumes_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Consumes_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Consumes_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConsumes_decl(s)
	}
}

func (s *Consumes_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConsumes_decl(s)
	}
}

func (p *IDLParser) Consumes_decl() (localctx IConsumes_declContext) {
	this := p
	_ = this

	localctx = NewConsumes_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, IDLParserRULE_consumes_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1308)
		p.Match(IDLParserKW_CONSUMES)
	}
	{
		p.SetState(1309)
		p.A_scoped_name()
	}
	{
		p.SetState(1310)
		p.Match(IDLParserID)
	}

	return localctx
}

// IHome_declContext is an interface to support dynamic dispatch.
type IHome_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_declContext differentiates from other interfaces.
	IsHome_declContext()
}

type Home_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_declContext() *Home_declContext {
	var p = new(Home_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_decl
	return p
}

func (*Home_declContext) IsHome_declContext() {}

func NewHome_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_declContext {
	var p = new(Home_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_decl

	return p
}

func (s *Home_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_declContext) Home_header() IHome_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHome_headerContext)
}

func (s *Home_declContext) Home_body() IHome_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHome_bodyContext)
}

func (s *Home_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_decl(s)
	}
}

func (s *Home_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_decl(s)
	}
}

func (p *IDLParser) Home_decl() (localctx IHome_declContext) {
	this := p
	_ = this

	localctx = NewHome_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, IDLParserRULE_home_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1312)
		p.Home_header()
	}
	{
		p.SetState(1313)
		p.Home_body()
	}

	return localctx
}

// IHome_headerContext is an interface to support dynamic dispatch.
type IHome_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_headerContext differentiates from other interfaces.
	IsHome_headerContext()
}

type Home_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_headerContext() *Home_headerContext {
	var p = new(Home_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_header
	return p
}

func (*Home_headerContext) IsHome_headerContext() {}

func NewHome_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_headerContext {
	var p = new(Home_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_header

	return p
}

func (s *Home_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_headerContext) KW_HOME() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_HOME, 0)
}

func (s *Home_headerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Home_headerContext) KW_MANAGES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_MANAGES, 0)
}

func (s *Home_headerContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Home_headerContext) Home_inheritance_spec() IHome_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHome_inheritance_specContext)
}

func (s *Home_headerContext) Supported_interface_spec() ISupported_interface_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupported_interface_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupported_interface_specContext)
}

func (s *Home_headerContext) Primary_key_spec() IPrimary_key_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_key_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_key_specContext)
}

func (s *Home_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_header(s)
	}
}

func (s *Home_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_header(s)
	}
}

func (p *IDLParser) Home_header() (localctx IHome_headerContext) {
	this := p
	_ = this

	localctx = NewHome_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, IDLParserRULE_home_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.Match(IDLParserKW_HOME)
	}
	{
		p.SetState(1316)
		p.Identifier()
	}
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(1317)
			p.Home_inheritance_spec()
		}

	}
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_SUPPORTS {
		{
			p.SetState(1320)
			p.Supported_interface_spec()
		}

	}
	{
		p.SetState(1323)
		p.Match(IDLParserKW_MANAGES)
	}
	{
		p.SetState(1324)
		p.A_scoped_name()
	}
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_PRIMARYKEY {
		{
			p.SetState(1325)
			p.Primary_key_spec()
		}

	}

	return localctx
}

// IHome_inheritance_specContext is an interface to support dynamic dispatch.
type IHome_inheritance_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_inheritance_specContext differentiates from other interfaces.
	IsHome_inheritance_specContext()
}

type Home_inheritance_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_inheritance_specContext() *Home_inheritance_specContext {
	var p = new(Home_inheritance_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_inheritance_spec
	return p
}

func (*Home_inheritance_specContext) IsHome_inheritance_specContext() {}

func NewHome_inheritance_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_inheritance_specContext {
	var p = new(Home_inheritance_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_inheritance_spec

	return p
}

func (s *Home_inheritance_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_inheritance_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Home_inheritance_specContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Home_inheritance_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_inheritance_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_inheritance_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_inheritance_spec(s)
	}
}

func (s *Home_inheritance_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_inheritance_spec(s)
	}
}

func (p *IDLParser) Home_inheritance_spec() (localctx IHome_inheritance_specContext) {
	this := p
	_ = this

	localctx = NewHome_inheritance_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, IDLParserRULE_home_inheritance_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1328)
		p.Match(IDLParserCOLON)
	}
	{
		p.SetState(1329)
		p.A_scoped_name()
	}

	return localctx
}

// IPrimary_key_specContext is an interface to support dynamic dispatch.
type IPrimary_key_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_key_specContext differentiates from other interfaces.
	IsPrimary_key_specContext()
}

type Primary_key_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_key_specContext() *Primary_key_specContext {
	var p = new(Primary_key_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_primary_key_spec
	return p
}

func (*Primary_key_specContext) IsPrimary_key_specContext() {}

func NewPrimary_key_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_key_specContext {
	var p = new(Primary_key_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_primary_key_spec

	return p
}

func (s *Primary_key_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_key_specContext) KW_PRIMARYKEY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PRIMARYKEY, 0)
}

func (s *Primary_key_specContext) A_scoped_name() IA_scoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IA_scoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IA_scoped_nameContext)
}

func (s *Primary_key_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_key_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_key_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterPrimary_key_spec(s)
	}
}

func (s *Primary_key_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitPrimary_key_spec(s)
	}
}

func (p *IDLParser) Primary_key_spec() (localctx IPrimary_key_specContext) {
	this := p
	_ = this

	localctx = NewPrimary_key_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, IDLParserRULE_primary_key_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1331)
		p.Match(IDLParserKW_PRIMARYKEY)
	}
	{
		p.SetState(1332)
		p.A_scoped_name()
	}

	return localctx
}

// IHome_bodyContext is an interface to support dynamic dispatch.
type IHome_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_bodyContext differentiates from other interfaces.
	IsHome_bodyContext()
}

type Home_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_bodyContext() *Home_bodyContext {
	var p = new(Home_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_body
	return p
}

func (*Home_bodyContext) IsHome_bodyContext() {}

func NewHome_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_bodyContext {
	var p = new(Home_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_body

	return p
}

func (s *Home_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_bodyContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Home_bodyContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Home_bodyContext) AllHome_export() []IHome_exportContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHome_exportContext)(nil)).Elem())
	var tst = make([]IHome_exportContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHome_exportContext)
		}
	}

	return tst
}

func (s *Home_bodyContext) Home_export(i int) IHome_exportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_exportContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHome_exportContext)
}

func (s *Home_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_body(s)
	}
}

func (s *Home_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_body(s)
	}
}

func (p *IDLParser) Home_body() (localctx IHome_bodyContext) {
	this := p
	_ = this

	localctx = NewHome_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, IDLParserRULE_home_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1334)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(1338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserAT-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_FINDER-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(IDLParserKW_WSTRING-64))|(1<<(IDLParserKW_FACTORY-64))|(1<<(IDLParserKW_EXCEPTION-64))|(1<<(IDLParserKW_CONST-64))|(1<<(IDLParserKW_VALUEBASE-64))|(1<<(IDLParserKW_OBJECT-64))|(1<<(IDLParserKW_UNSIGNED-64))|(1<<(IDLParserKW_UNION-64))|(1<<(IDLParserKW_ONEWAY-64))|(1<<(IDLParserKW_ANY-64))|(1<<(IDLParserKW_CHAR-64))|(1<<(IDLParserKW_FLOAT-64))|(1<<(IDLParserKW_BOOLEAN-64))|(1<<(IDLParserKW_DOUBLE-64))|(1<<(IDLParserKW_TYPEPREFIX-64))|(1<<(IDLParserKW_TYPEID-64))|(1<<(IDLParserKW_ATTRIBUTE-64)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(IDLParserKW_BITSET-102))|(1<<(IDLParserKW_BITMASK-102))|(1<<(IDLParserKW_INT8-102))|(1<<(IDLParserKW_UINT8-102))|(1<<(IDLParserKW_INT16-102))|(1<<(IDLParserKW_UINT16-102))|(1<<(IDLParserKW_INT32-102))|(1<<(IDLParserKW_UINT32-102))|(1<<(IDLParserKW_INT64-102))|(1<<(IDLParserKW_UINT64-102))|(1<<(IDLParserID-102)))) != 0) {
		{
			p.SetState(1335)
			p.Home_export()
		}

		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1341)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IHome_exportContext is an interface to support dynamic dispatch.
type IHome_exportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_exportContext differentiates from other interfaces.
	IsHome_exportContext()
}

type Home_exportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_exportContext() *Home_exportContext {
	var p = new(Home_exportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_export
	return p
}

func (*Home_exportContext) IsHome_exportContext() {}

func NewHome_exportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_exportContext {
	var p = new(Home_exportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_export

	return p
}

func (s *Home_exportContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_exportContext) Export_() IExport_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExport_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExport_Context)
}

func (s *Home_exportContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *Home_exportContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Home_exportContext) Factory_decl() IFactory_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactory_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactory_declContext)
}

func (s *Home_exportContext) Finder_decl() IFinder_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinder_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinder_declContext)
}

func (s *Home_exportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_exportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_exportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_export(s)
	}
}

func (s *Home_exportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_export(s)
	}
}

func (p *IDLParser) Home_export() (localctx IHome_exportContext) {
	this := p
	_ = this

	localctx = NewHome_exportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, IDLParserRULE_home_export)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1343)
			p.Export_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1344)
			p.Annapps()
		}
		p.SetState(1347)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case IDLParserKW_FACTORY:
			{
				p.SetState(1345)
				p.Factory_decl()
			}

		case IDLParserKW_FINDER:
			{
				p.SetState(1346)
				p.Finder_decl()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1349)
			p.Match(IDLParserSEMICOLON)
		}

	}

	return localctx
}

// IFactory_declContext is an interface to support dynamic dispatch.
type IFactory_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactory_declContext differentiates from other interfaces.
	IsFactory_declContext()
}

type Factory_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactory_declContext() *Factory_declContext {
	var p = new(Factory_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_factory_decl
	return p
}

func (*Factory_declContext) IsFactory_declContext() {}

func NewFactory_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Factory_declContext {
	var p = new(Factory_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_factory_decl

	return p
}

func (s *Factory_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Factory_declContext) KW_FACTORY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FACTORY, 0)
}

func (s *Factory_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Factory_declContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Factory_declContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Factory_declContext) Init_param_decls() IInit_param_declsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_declsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_param_declsContext)
}

func (s *Factory_declContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Factory_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Factory_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Factory_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFactory_decl(s)
	}
}

func (s *Factory_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFactory_decl(s)
	}
}

func (p *IDLParser) Factory_decl() (localctx IFactory_declContext) {
	this := p
	_ = this

	localctx = NewFactory_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, IDLParserRULE_factory_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1353)
		p.Match(IDLParserKW_FACTORY)
	}
	{
		p.SetState(1354)
		p.Identifier()
	}
	{
		p.SetState(1355)
		p.Match(IDLParserLEFT_BRACKET)
	}
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserAT || _la == IDLParserKW_IN {
		{
			p.SetState(1356)
			p.Init_param_decls()
		}

	}
	{
		p.SetState(1359)
		p.Match(IDLParserRIGHT_BRACKET)
	}
	p.SetState(1361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_RAISES {
		{
			p.SetState(1360)
			p.Raises_expr()
		}

	}

	return localctx
}

// IFinder_declContext is an interface to support dynamic dispatch.
type IFinder_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinder_declContext differentiates from other interfaces.
	IsFinder_declContext()
}

type Finder_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinder_declContext() *Finder_declContext {
	var p = new(Finder_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_finder_decl
	return p
}

func (*Finder_declContext) IsFinder_declContext() {}

func NewFinder_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finder_declContext {
	var p = new(Finder_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_finder_decl

	return p
}

func (s *Finder_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Finder_declContext) KW_FINDER() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FINDER, 0)
}

func (s *Finder_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Finder_declContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Finder_declContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Finder_declContext) Init_param_decls() IInit_param_declsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_declsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_param_declsContext)
}

func (s *Finder_declContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Finder_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finder_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Finder_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFinder_decl(s)
	}
}

func (s *Finder_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFinder_decl(s)
	}
}

func (p *IDLParser) Finder_decl() (localctx IFinder_declContext) {
	this := p
	_ = this

	localctx = NewFinder_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, IDLParserRULE_finder_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1363)
		p.Match(IDLParserKW_FINDER)
	}
	{
		p.SetState(1364)
		p.Identifier()
	}
	{
		p.SetState(1365)
		p.Match(IDLParserLEFT_BRACKET)
	}
	p.SetState(1367)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserAT || _la == IDLParserKW_IN {
		{
			p.SetState(1366)
			p.Init_param_decls()
		}

	}
	{
		p.SetState(1369)
		p.Match(IDLParserRIGHT_BRACKET)
	}
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_RAISES {
		{
			p.SetState(1370)
			p.Raises_expr()
		}

	}

	return localctx
}

// IEventContext is an interface to support dynamic dispatch.
type IEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventContext differentiates from other interfaces.
	IsEventContext()
}

type EventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventContext() *EventContext {
	var p = new(EventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event
	return p
}

func (*EventContext) IsEventContext() {}

func NewEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventContext {
	var p = new(EventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event

	return p
}

func (s *EventContext) GetParser() antlr.Parser { return s.parser }

func (s *EventContext) Event_decl() IEvent_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declContext)
}

func (s *EventContext) Event_abs_decl() IEvent_abs_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_abs_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_abs_declContext)
}

func (s *EventContext) Event_forward_decl() IEvent_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_forward_declContext)
}

func (s *EventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent(s)
	}
}

func (s *EventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent(s)
	}
}

func (p *IDLParser) Event() (localctx IEventContext) {
	this := p
	_ = this

	localctx = NewEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, IDLParserRULE_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1373)
			p.Event_decl()
		}

	case 2:
		{
			p.SetState(1374)
			p.Event_abs_decl()
		}

	case 3:
		{
			p.SetState(1375)
			p.Event_forward_decl()
		}

	}

	return localctx
}

// IEvent_forward_declContext is an interface to support dynamic dispatch.
type IEvent_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_forward_declContext differentiates from other interfaces.
	IsEvent_forward_declContext()
}

type Event_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_forward_declContext() *Event_forward_declContext {
	var p = new(Event_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event_forward_decl
	return p
}

func (*Event_forward_declContext) IsEvent_forward_declContext() {}

func NewEvent_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_forward_declContext {
	var p = new(Event_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event_forward_decl

	return p
}

func (s *Event_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_forward_declContext) KW_EVENTTYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EVENTTYPE, 0)
}

func (s *Event_forward_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Event_forward_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Event_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent_forward_decl(s)
	}
}

func (s *Event_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent_forward_decl(s)
	}
}

func (p *IDLParser) Event_forward_decl() (localctx IEvent_forward_declContext) {
	this := p
	_ = this

	localctx = NewEvent_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, IDLParserRULE_event_forward_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ABSTRACT {
		{
			p.SetState(1378)
			p.Match(IDLParserKW_ABSTRACT)
		}

	}
	{
		p.SetState(1381)
		p.Match(IDLParserKW_EVENTTYPE)
	}
	{
		p.SetState(1382)
		p.Match(IDLParserID)
	}

	return localctx
}

// IEvent_abs_declContext is an interface to support dynamic dispatch.
type IEvent_abs_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_abs_declContext differentiates from other interfaces.
	IsEvent_abs_declContext()
}

type Event_abs_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_abs_declContext() *Event_abs_declContext {
	var p = new(Event_abs_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event_abs_decl
	return p
}

func (*Event_abs_declContext) IsEvent_abs_declContext() {}

func NewEvent_abs_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_abs_declContext {
	var p = new(Event_abs_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event_abs_decl

	return p
}

func (s *Event_abs_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_abs_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Event_abs_declContext) KW_EVENTTYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EVENTTYPE, 0)
}

func (s *Event_abs_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Event_abs_declContext) Value_inheritance_spec() IValue_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_inheritance_specContext)
}

func (s *Event_abs_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Event_abs_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Event_abs_declContext) AllExport_() []IExport_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExport_Context)(nil)).Elem())
	var tst = make([]IExport_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExport_Context)
		}
	}

	return tst
}

func (s *Event_abs_declContext) Export_(i int) IExport_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExport_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExport_Context)
}

func (s *Event_abs_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_abs_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_abs_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent_abs_decl(s)
	}
}

func (s *Event_abs_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent_abs_decl(s)
	}
}

func (p *IDLParser) Event_abs_decl() (localctx IEvent_abs_declContext) {
	this := p
	_ = this

	localctx = NewEvent_abs_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, IDLParserRULE_event_abs_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1384)
		p.Match(IDLParserKW_ABSTRACT)
	}
	{
		p.SetState(1385)
		p.Match(IDLParserKW_EVENTTYPE)
	}
	{
		p.SetState(1386)
		p.Identifier()
	}
	{
		p.SetState(1387)
		p.Value_inheritance_spec()
	}
	{
		p.SetState(1388)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(1392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserAT-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(IDLParserKW_WSTRING-64))|(1<<(IDLParserKW_EXCEPTION-64))|(1<<(IDLParserKW_CONST-64))|(1<<(IDLParserKW_VALUEBASE-64))|(1<<(IDLParserKW_OBJECT-64))|(1<<(IDLParserKW_UNSIGNED-64))|(1<<(IDLParserKW_UNION-64))|(1<<(IDLParserKW_ONEWAY-64))|(1<<(IDLParserKW_ANY-64))|(1<<(IDLParserKW_CHAR-64))|(1<<(IDLParserKW_FLOAT-64))|(1<<(IDLParserKW_BOOLEAN-64))|(1<<(IDLParserKW_DOUBLE-64))|(1<<(IDLParserKW_TYPEPREFIX-64))|(1<<(IDLParserKW_TYPEID-64))|(1<<(IDLParserKW_ATTRIBUTE-64)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(IDLParserKW_BITSET-102))|(1<<(IDLParserKW_BITMASK-102))|(1<<(IDLParserKW_INT8-102))|(1<<(IDLParserKW_UINT8-102))|(1<<(IDLParserKW_INT16-102))|(1<<(IDLParserKW_UINT16-102))|(1<<(IDLParserKW_INT32-102))|(1<<(IDLParserKW_UINT32-102))|(1<<(IDLParserKW_INT64-102))|(1<<(IDLParserKW_UINT64-102))|(1<<(IDLParserID-102)))) != 0) {
		{
			p.SetState(1389)
			p.Export_()
		}

		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1395)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IEvent_declContext is an interface to support dynamic dispatch.
type IEvent_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_declContext differentiates from other interfaces.
	IsEvent_declContext()
}

type Event_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_declContext() *Event_declContext {
	var p = new(Event_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event_decl
	return p
}

func (*Event_declContext) IsEvent_declContext() {}

func NewEvent_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_declContext {
	var p = new(Event_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event_decl

	return p
}

func (s *Event_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_declContext) Event_header() IEvent_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_headerContext)
}

func (s *Event_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Event_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Event_declContext) AllValue_element() []IValue_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValue_elementContext)(nil)).Elem())
	var tst = make([]IValue_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValue_elementContext)
		}
	}

	return tst
}

func (s *Event_declContext) Value_element(i int) IValue_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValue_elementContext)
}

func (s *Event_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent_decl(s)
	}
}

func (s *Event_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent_decl(s)
	}
}

func (p *IDLParser) Event_decl() (localctx IEvent_declContext) {
	this := p
	_ = this

	localctx = NewEvent_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, IDLParserRULE_event_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1397)
		p.Event_header()
	}
	{
		p.SetState(1398)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserAT-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_PRIVATE-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_PUBLIC-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(IDLParserKW_WSTRING-64))|(1<<(IDLParserKW_FACTORY-64))|(1<<(IDLParserKW_EXCEPTION-64))|(1<<(IDLParserKW_CONST-64))|(1<<(IDLParserKW_VALUEBASE-64))|(1<<(IDLParserKW_OBJECT-64))|(1<<(IDLParserKW_UNSIGNED-64))|(1<<(IDLParserKW_UNION-64))|(1<<(IDLParserKW_ONEWAY-64))|(1<<(IDLParserKW_ANY-64))|(1<<(IDLParserKW_CHAR-64))|(1<<(IDLParserKW_FLOAT-64))|(1<<(IDLParserKW_BOOLEAN-64))|(1<<(IDLParserKW_DOUBLE-64))|(1<<(IDLParserKW_TYPEPREFIX-64))|(1<<(IDLParserKW_TYPEID-64))|(1<<(IDLParserKW_ATTRIBUTE-64)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(IDLParserKW_BITSET-102))|(1<<(IDLParserKW_BITMASK-102))|(1<<(IDLParserKW_INT8-102))|(1<<(IDLParserKW_UINT8-102))|(1<<(IDLParserKW_INT16-102))|(1<<(IDLParserKW_UINT16-102))|(1<<(IDLParserKW_INT32-102))|(1<<(IDLParserKW_UINT32-102))|(1<<(IDLParserKW_INT64-102))|(1<<(IDLParserKW_UINT64-102))|(1<<(IDLParserID-102)))) != 0) {
		{
			p.SetState(1399)
			p.Value_element()
		}

		p.SetState(1404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1405)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IEvent_headerContext is an interface to support dynamic dispatch.
type IEvent_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_headerContext differentiates from other interfaces.
	IsEvent_headerContext()
}

type Event_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_headerContext() *Event_headerContext {
	var p = new(Event_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event_header
	return p
}

func (*Event_headerContext) IsEvent_headerContext() {}

func NewEvent_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_headerContext {
	var p = new(Event_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event_header

	return p
}

func (s *Event_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_headerContext) KW_EVENTTYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EVENTTYPE, 0)
}

func (s *Event_headerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Event_headerContext) Value_inheritance_spec() IValue_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_inheritance_specContext)
}

func (s *Event_headerContext) KW_CUSTOM() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CUSTOM, 0)
}

func (s *Event_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent_header(s)
	}
}

func (s *Event_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent_header(s)
	}
}

func (p *IDLParser) Event_header() (localctx IEvent_headerContext) {
	this := p
	_ = this

	localctx = NewEvent_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, IDLParserRULE_event_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_CUSTOM {
		{
			p.SetState(1407)
			p.Match(IDLParserKW_CUSTOM)
		}

	}
	{
		p.SetState(1410)
		p.Match(IDLParserKW_EVENTTYPE)
	}
	{
		p.SetState(1411)
		p.Identifier()
	}
	{
		p.SetState(1412)
		p.Value_inheritance_spec()
	}

	return localctx
}

// IAnnappsContext is an interface to support dynamic dispatch.
type IAnnappsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnappsContext differentiates from other interfaces.
	IsAnnappsContext()
}

type AnnappsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnappsContext() *AnnappsContext {
	var p = new(AnnappsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annapps
	return p
}

func (*AnnappsContext) IsAnnappsContext() {}

func NewAnnappsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnappsContext {
	var p = new(AnnappsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annapps

	return p
}

func (s *AnnappsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnappsContext) AllAnnotation_appl() []IAnnotation_applContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotation_applContext)(nil)).Elem())
	var tst = make([]IAnnotation_applContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotation_applContext)
		}
	}

	return tst
}

func (s *AnnappsContext) Annotation_appl(i int) IAnnotation_applContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_applContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_applContext)
}

func (s *AnnappsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnappsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnappsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnapps(s)
	}
}

func (s *AnnappsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnapps(s)
	}
}

func (p *IDLParser) Annapps() (localctx IAnnappsContext) {
	this := p
	_ = this

	localctx = NewAnnappsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, IDLParserRULE_annapps)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1417)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1414)
				p.Annotation_appl()
			}

		}
		p.SetState(1419)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())
	}

	return localctx
}

// IAnnotation_applContext is an interface to support dynamic dispatch.
type IAnnotation_applContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_applContext differentiates from other interfaces.
	IsAnnotation_applContext()
}

type Annotation_applContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_applContext() *Annotation_applContext {
	var p = new(Annotation_applContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_appl
	return p
}

func (*Annotation_applContext) IsAnnotation_applContext() {}

func NewAnnotation_applContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_applContext {
	var p = new(Annotation_applContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_appl

	return p
}

func (s *Annotation_applContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_applContext) AT() antlr.TerminalNode {
	return s.GetToken(IDLParserAT, 0)
}

func (s *Annotation_applContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Annotation_applContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Annotation_applContext) Annotation_appl_params() IAnnotation_appl_paramsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_appl_paramsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_appl_paramsContext)
}

func (s *Annotation_applContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Annotation_applContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_applContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_applContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_appl(s)
	}
}

func (s *Annotation_applContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_appl(s)
	}
}

func (p *IDLParser) Annotation_appl() (localctx IAnnotation_applContext) {
	this := p
	_ = this

	localctx = NewAnnotation_applContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, IDLParserRULE_annotation_appl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		p.Match(IDLParserAT)
	}
	{
		p.SetState(1421)
		p.Scoped_name()
	}
	p.SetState(1426)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserLEFT_BRACKET {
		{
			p.SetState(1422)
			p.Match(IDLParserLEFT_BRACKET)
		}
		{
			p.SetState(1423)
			p.Annotation_appl_params()
		}
		{
			p.SetState(1424)
			p.Match(IDLParserRIGHT_BRACKET)
		}

	}

	return localctx
}

// IAnnotation_appl_paramsContext is an interface to support dynamic dispatch.
type IAnnotation_appl_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_appl_paramsContext differentiates from other interfaces.
	IsAnnotation_appl_paramsContext()
}

type Annotation_appl_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_appl_paramsContext() *Annotation_appl_paramsContext {
	var p = new(Annotation_appl_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_appl_params
	return p
}

func (*Annotation_appl_paramsContext) IsAnnotation_appl_paramsContext() {}

func NewAnnotation_appl_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_appl_paramsContext {
	var p = new(Annotation_appl_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_appl_params

	return p
}

func (s *Annotation_appl_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_appl_paramsContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Annotation_appl_paramsContext) AllAnnotation_appl_param() []IAnnotation_appl_paramContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotation_appl_paramContext)(nil)).Elem())
	var tst = make([]IAnnotation_appl_paramContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotation_appl_paramContext)
		}
	}

	return tst
}

func (s *Annotation_appl_paramsContext) Annotation_appl_param(i int) IAnnotation_appl_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_appl_paramContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_appl_paramContext)
}

func (s *Annotation_appl_paramsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMMA)
}

func (s *Annotation_appl_paramsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMMA, i)
}

func (s *Annotation_appl_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_appl_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_appl_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_appl_params(s)
	}
}

func (s *Annotation_appl_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_appl_params(s)
	}
}

func (p *IDLParser) Annotation_appl_params() (localctx IAnnotation_appl_paramsContext) {
	this := p
	_ = this

	localctx = NewAnnotation_appl_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, IDLParserRULE_annotation_appl_params)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1428)
			p.Const_exp()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1429)
			p.Annotation_appl_param()
		}
		p.SetState(1434)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMMA {
			{
				p.SetState(1430)
				p.Match(IDLParserCOMMA)
			}
			{
				p.SetState(1431)
				p.Annotation_appl_param()
			}

			p.SetState(1436)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IAnnotation_appl_paramContext is an interface to support dynamic dispatch.
type IAnnotation_appl_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_appl_paramContext differentiates from other interfaces.
	IsAnnotation_appl_paramContext()
}

type Annotation_appl_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_appl_paramContext() *Annotation_appl_paramContext {
	var p = new(Annotation_appl_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_annotation_appl_param
	return p
}

func (*Annotation_appl_paramContext) IsAnnotation_appl_paramContext() {}

func NewAnnotation_appl_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_appl_paramContext {
	var p = new(Annotation_appl_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_annotation_appl_param

	return p
}

func (s *Annotation_appl_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_appl_paramContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Annotation_appl_paramContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(IDLParserEQUAL, 0)
}

func (s *Annotation_appl_paramContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Annotation_appl_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_appl_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_appl_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnnotation_appl_param(s)
	}
}

func (s *Annotation_appl_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnnotation_appl_param(s)
	}
}

func (p *IDLParser) Annotation_appl_param() (localctx IAnnotation_appl_paramContext) {
	this := p
	_ = this

	localctx = NewAnnotation_appl_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, IDLParserRULE_annotation_appl_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1439)
		p.Match(IDLParserID)
	}
	{
		p.SetState(1440)
		p.Match(IDLParserEQUAL)
	}
	{
		p.SetState(1441)
		p.Const_exp()
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Annapps() IAnnappsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnappsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnappsContext)
}

func (s *IdentifierContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *IDLParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, IDLParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1443)
		p.Annapps()
	}
	{
		p.SetState(1444)
		p.Match(IDLParserID)
	}

	return localctx
}
